#line 1 ".\\moc_bbb_GLWidget.cpp"










#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\bbb_GLWidget.h"





#line 1 "C:\\qt-3.3.8\\include\\qgl.h"









































#line 1 "c:\\qt-3.3.8\\include\\qwidget.h"









































#line 1 "c:\\qt-3.3.8\\include\\qwindowdefs.h"










































#line 1 "c:\\qt-3.3.8\\include\\qobjectdefs.h"









































#line 1 "c:\\qt-3.3.8\\include\\qglobal.h"



















































































#line 85 "c:\\qt-3.3.8\\include\\qglobal.h"

#line 87 "c:\\qt-3.3.8\\include\\qglobal.h"

#line 89 "c:\\qt-3.3.8\\include\\qglobal.h"

#line 91 "c:\\qt-3.3.8\\include\\qglobal.h"

#line 93 "c:\\qt-3.3.8\\include\\qglobal.h"

#line 95 "c:\\qt-3.3.8\\include\\qglobal.h"





#line 101 "c:\\qt-3.3.8\\include\\qglobal.h"


#line 104 "c:\\qt-3.3.8\\include\\qglobal.h"






















































#line 159 "c:\\qt-3.3.8\\include\\qglobal.h"



#line 163 "c:\\qt-3.3.8\\include\\qglobal.h"



#line 167 "c:\\qt-3.3.8\\include\\qglobal.h"





#line 173 "c:\\qt-3.3.8\\include\\qglobal.h"
















#line 190 "c:\\qt-3.3.8\\include\\qglobal.h"











































#line 234 "c:\\qt-3.3.8\\include\\qglobal.h"





#line 240 "c:\\qt-3.3.8\\include\\qglobal.h"




#line 245 "c:\\qt-3.3.8\\include\\qglobal.h"









#line 255 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 256 "c:\\qt-3.3.8\\include\\qglobal.h"






#line 263 "c:\\qt-3.3.8\\include\\qglobal.h"

#line 265 "c:\\qt-3.3.8\\include\\qglobal.h"























































































































































































































































































#line 545 "c:\\qt-3.3.8\\include\\qglobal.h"



#line 549 "c:\\qt-3.3.8\\include\\qglobal.h"
















#line 566 "c:\\qt-3.3.8\\include\\qglobal.h"


#line 569 "c:\\qt-3.3.8\\include\\qglobal.h"

#line 571 "c:\\qt-3.3.8\\include\\qglobal.h"



#line 575 "c:\\qt-3.3.8\\include\\qglobal.h"














#line 590 "c:\\qt-3.3.8\\include\\qglobal.h"


#line 593 "c:\\qt-3.3.8\\include\\qglobal.h"



#line 597 "c:\\qt-3.3.8\\include\\qglobal.h"



#line 601 "c:\\qt-3.3.8\\include\\qglobal.h"

























#line 627 "c:\\qt-3.3.8\\include\\qglobal.h"

typedef unsigned char   uchar;
typedef unsigned short  ushort;
typedef unsigned	uint;
typedef unsigned long   ulong;
typedef char	       *pchar;
typedef uchar	       *puchar;
typedef const char     *pcchar;







const bool FALSE = 0;
const bool TRUE = !0;
#line 645 "c:\\qt-3.3.8\\include\\qglobal.h"





#line 651 "c:\\qt-3.3.8\\include\\qglobal.h"







#line 659 "c:\\qt-3.3.8\\include\\qglobal.h"









#line 669 "c:\\qt-3.3.8\\include\\qglobal.h"












#line 682 "c:\\qt-3.3.8\\include\\qglobal.h"










inline int qRound( double d )
{
    return d >= 0.0 ? int(d + 0.5) : int( d - ((int)d-1) + 0.5 ) + ((int)d-1);
}








typedef signed char		INT8;		
typedef unsigned char		UINT8;		
typedef short			INT16;		
typedef unsigned short		UINT16;		
typedef int			INT32;		
typedef unsigned int		UINT32;		
#line 711 "c:\\qt-3.3.8\\include\\qglobal.h"

typedef signed char		Q_INT8;		
typedef unsigned char		Q_UINT8;	
typedef short			Q_INT16;	
typedef unsigned short		Q_UINT16;	
typedef int			Q_INT32;	
typedef unsigned int		Q_UINT32;	



#line 722 "c:\\qt-3.3.8\\include\\qglobal.h"
typedef long			Q_LONG;		
typedef unsigned long		Q_ULONG;	
#line 725 "c:\\qt-3.3.8\\include\\qglobal.h"



typedef __int64			Q_INT64;	
typedef unsigned __int64	Q_UINT64;	





#line 736 "c:\\qt-3.3.8\\include\\qglobal.h"
typedef Q_INT64			Q_LLONG;	
typedef Q_UINT64		Q_ULLONG;	



#line 742 "c:\\qt-3.3.8\\include\\qglobal.h"


#line 745 "c:\\qt-3.3.8\\include\\qglobal.h"
    typedef Q_ULONG QtOffset;
#line 747 "c:\\qt-3.3.8\\include\\qglobal.h"






class QDataStream;














#line 769 "c:\\qt-3.3.8\\include\\qglobal.h"

#line 771 "c:\\qt-3.3.8\\include\\qglobal.h"

#line 773 "c:\\qt-3.3.8\\include\\qglobal.h"

#line 775 "c:\\qt-3.3.8\\include\\qglobal.h"

#line 777 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 1 "c:\\qt-3.3.8\\include\\qconfig.h"

















#line 19 "c:\\qt-3.3.8\\include\\qconfig.h"



#line 23 "c:\\qt-3.3.8\\include\\qconfig.h"



#line 27 "c:\\qt-3.3.8\\include\\qconfig.h"



#line 778 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 779 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 780 "c:\\qt-3.3.8\\include\\qglobal.h"







#line 1 "c:\\qt-3.3.8\\include\\qmodules.h"

















#line 788 "c:\\qt-3.3.8\\include\\qglobal.h"


























#line 815 "c:\\qt-3.3.8\\include\\qglobal.h"













#line 829 "c:\\qt-3.3.8\\include\\qglobal.h"







#line 837 "c:\\qt-3.3.8\\include\\qglobal.h"



#line 841 "c:\\qt-3.3.8\\include\\qglobal.h"


#line 1 "c:\\qt-3.3.8\\include\\qfeatures.h"












































































































































































#line 174 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 179 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 184 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 189 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 194 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 199 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 204 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 209 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 214 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 219 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 224 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 229 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 234 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 239 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 244 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 249 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 254 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 259 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 264 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 269 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 274 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 279 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 284 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 289 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 294 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 299 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 304 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 309 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 314 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 319 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 324 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 329 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 334 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 339 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 344 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 349 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 354 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 359 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 364 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 369 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 374 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 379 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 384 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 389 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 394 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 399 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 404 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 409 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 414 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 419 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 424 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 429 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 434 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 439 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 444 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 449 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 454 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 459 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 464 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 469 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 474 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 479 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 484 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 489 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 494 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 499 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 504 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 509 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 514 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 519 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 524 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 529 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 534 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 539 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 544 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 549 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 554 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 559 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 564 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 569 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 574 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 579 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 584 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 589 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 594 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 599 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 604 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 609 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 614 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 619 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 624 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 629 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 634 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 639 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 644 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 649 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 654 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 659 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 664 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 669 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 674 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 679 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 684 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 689 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 694 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 699 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 704 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 709 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 714 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 719 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 724 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 729 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 734 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 739 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 744 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 749 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 754 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 759 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 764 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 769 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 774 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 779 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 784 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 789 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 794 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 799 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 804 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 809 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 814 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 819 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 824 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 829 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 834 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 839 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 844 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 849 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 854 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 859 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 864 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 869 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 874 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 879 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 884 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 889 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 894 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 899 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 904 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 909 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 914 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 919 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 924 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 929 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 934 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 939 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 944 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 949 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 954 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 959 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 964 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 969 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 974 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 979 "c:\\qt-3.3.8\\include\\qfeatures.h"




#line 984 "c:\\qt-3.3.8\\include\\qfeatures.h"

#line 844 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 845 "c:\\qt-3.3.8\\include\\qglobal.h"











#line 857 "c:\\qt-3.3.8\\include\\qglobal.h"







#line 865 "c:\\qt-3.3.8\\include\\qglobal.h"







#line 873 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 874 "c:\\qt-3.3.8\\include\\qglobal.h"

#line 876 "c:\\qt-3.3.8\\include\\qglobal.h"














#line 891 "c:\\qt-3.3.8\\include\\qglobal.h"











extern __declspec(dllimport) bool qt_winunicode;
#line 904 "c:\\qt-3.3.8\\include\\qglobal.h"






__declspec(dllimport) const char *qVersion();
__declspec(dllimport) bool qSysInfo( int *wordSize, bool *bigEndian );
__declspec(dllimport) bool qSharedBuild();


#line 916 "c:\\qt-3.3.8\\include\\qglobal.h"
__declspec(dllimport) int qWinVersion();






#line 924 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 925 "c:\\qt-3.3.8\\include\\qglobal.h"
















#line 942 "c:\\qt-3.3.8\\include\\qglobal.h"















#line 958 "c:\\qt-3.3.8\\include\\qglobal.h"










#line 969 "c:\\qt-3.3.8\\include\\qglobal.h"


__declspec(dllimport) void qDebug( const char *, ... )	


#line 975 "c:\\qt-3.3.8\\include\\qglobal.h"
;

__declspec(dllimport) void qWarning( const char *, ... )	


#line 981 "c:\\qt-3.3.8\\include\\qglobal.h"
;

__declspec(dllimport) void qFatal( const char *, ... )	


#line 987 "c:\\qt-3.3.8\\include\\qglobal.h"
;

__declspec(dllimport) void qSystemWarning( const char *, int code = -1 );



__declspec(dllimport) void debug( const char *, ... )	


#line 997 "c:\\qt-3.3.8\\include\\qglobal.h"
;

__declspec(dllimport) void warning( const char *, ... )	


#line 1003 "c:\\qt-3.3.8\\include\\qglobal.h"
;

__declspec(dllimport) void fatal( const char *, ... )	


#line 1009 "c:\\qt-3.3.8\\include\\qglobal.h"
;

#line 1012 "c:\\qt-3.3.8\\include\\qglobal.h"






#line 1019 "c:\\qt-3.3.8\\include\\qglobal.h"

#line 1021 "c:\\qt-3.3.8\\include\\qglobal.h"


#line 1024 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 1025 "c:\\qt-3.3.8\\include\\qglobal.h"





#line 1031 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 1032 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 1033 "c:\\qt-3.3.8\\include\\qglobal.h"


__declspec(dllimport) bool qt_check_pointer( bool c, const char *, int );





#line 1042 "c:\\qt-3.3.8\\include\\qglobal.h"




#line 1047 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 1048 "c:\\qt-3.3.8\\include\\qglobal.h"

enum QtMsgType { QtDebugMsg, QtWarningMsg, QtFatalMsg };

typedef void (*QtMsgHandler)(QtMsgType, const char *);
__declspec(dllimport) QtMsgHandler qInstallMsgHandler( QtMsgHandler );


typedef QtMsgHandler msg_handler;
#line 1057 "c:\\qt-3.3.8\\include\\qglobal.h"

__declspec(dllimport) void qSuppressObsoleteWarnings( bool = TRUE );

__declspec(dllimport) void qObsolete( const char *obj, const char *oldfunc,
		   const char *newfunc );
__declspec(dllimport) void qObsolete( const char *obj, const char *oldfunc );
__declspec(dllimport) void qObsolete( const char *message );






__declspec(dllimport) const char *qInstallPath();
__declspec(dllimport) const char *qInstallPathDocs();
__declspec(dllimport) const char *qInstallPathHeaders();
__declspec(dllimport) const char *qInstallPathLibs();
__declspec(dllimport) const char *qInstallPathBins();
__declspec(dllimport) const char *qInstallPathPlugins();
__declspec(dllimport) const char *qInstallPathData();
__declspec(dllimport) const char *qInstallPathTranslations();
__declspec(dllimport) const char *qInstallPathSysconf();

#line 1081 "c:\\qt-3.3.8\\include\\qglobal.h"

















#line 1099 "c:\\qt-3.3.8\\include\\qglobal.h"

#line 1101 "c:\\qt-3.3.8\\include\\qglobal.h"









#line 1111 "c:\\qt-3.3.8\\include\\qglobal.h"


#pragma warning(disable: 4244) 
#pragma warning(disable: 4275) 
#pragma warning(disable: 4514) 
#pragma warning(disable: 4800) 
#pragma warning(disable: 4097) 
#pragma warning(disable: 4706) 
#pragma warning(disable: 4786) 
#pragma warning(disable: 4660) 
#pragma warning(disable: 4355) 
#pragma warning(disable: 4231) 
#pragma warning(disable: 4710) 








#line 1133 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 1134 "c:\\qt-3.3.8\\include\\qglobal.h"


#line 43 "c:\\qt-3.3.8\\include\\qobjectdefs.h"
#line 44 "c:\\qt-3.3.8\\include\\qobjectdefs.h"












#line 57 "c:\\qt-3.3.8\\include\\qobjectdefs.h"



#line 61 "c:\\qt-3.3.8\\include\\qobjectdefs.h"







#line 69 "c:\\qt-3.3.8\\include\\qobjectdefs.h"



struct QUObject;



















#line 93 "c:\\qt-3.3.8\\include\\qobjectdefs.h"


























#line 120 "c:\\qt-3.3.8\\include\\qobjectdefs.h"
















#line 137 "c:\\qt-3.3.8\\include\\qobjectdefs.h"



#line 141 "c:\\qt-3.3.8\\include\\qobjectdefs.h"





#line 147 "c:\\qt-3.3.8\\include\\qobjectdefs.h"





class QObject;
class QMetaObject;
class QSignal;
class QConnection;
class QEvent;
struct QMetaData;
class QConnectionList;
class QConnectionListIt;
class QSignalVec;
class QObjectList;
class QObjectListIt;
class QMemberDict;

__declspec(dllimport) void *qt_find_obj_child( QObject *, const char *, const char * );



__declspec(dllimport) void *qt_inheritedBy( QMetaObject *super, const QObject *cls );

template <typename T>
inline T qt_cast(const QObject *object)
{ return (T)qt_inheritedBy( ((T)0)->staticMetaObject(), object ); }
#line 175 "c:\\qt-3.3.8\\include\\qobjectdefs.h"
#line 44 "c:\\qt-3.3.8\\include\\qwindowdefs.h"
#line 1 "c:\\qt-3.3.8\\include\\qstring.h"









































#line 1 "c:\\qt-3.3.8\\include\\qcstring.h"










































#line 1 "c:\\qt-3.3.8\\include\\qmemarray.h"









































#line 1 "c:\\qt-3.3.8\\include\\qgarray.h"









































#line 1 "c:\\qt-3.3.8\\include\\qshared.h"









































#line 1 "c:\\qt-3.3.8\\include\\qglobal.h"





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1111 "c:\\qt-3.3.8\\include\\qglobal.h"


#pragma warning(disable: 4244) 
#pragma warning(disable: 4275) 
#pragma warning(disable: 4514) 
#pragma warning(disable: 4800) 
#pragma warning(disable: 4097) 
#pragma warning(disable: 4706) 
#pragma warning(disable: 4786) 
#pragma warning(disable: 4660) 
#pragma warning(disable: 4355) 
#pragma warning(disable: 4231) 
#pragma warning(disable: 4710) 








#line 1133 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 1134 "c:\\qt-3.3.8\\include\\qglobal.h"


#line 43 "c:\\qt-3.3.8\\include\\qshared.h"
#line 44 "c:\\qt-3.3.8\\include\\qshared.h"


struct __declspec(dllimport) QShared
{
    QShared() : count( 1 ) { }
    void ref()		{ count++; }
    bool deref()	{ return !--count; }
    uint count;
};


#line 56 "c:\\qt-3.3.8\\include\\qshared.h"
#line 43 "c:\\qt-3.3.8\\include\\qgarray.h"
#line 44 "c:\\qt-3.3.8\\include\\qgarray.h"


class __declspec(dllimport) QGArray					
{
friend class QBuffer;
public:
    
    
    struct array_data : public QShared {	
	array_data():data(0),len(0)



	    {}
	char *data;				
	uint  len;



    };
    QGArray();
    enum Optimization { MemOptim, SpeedOptim };
protected:
    QGArray( int, int );			
    QGArray( int size );			
    QGArray( const QGArray &a );		
    virtual ~QGArray();

    QGArray    &operator=( const QGArray &a ) { return assign( a ); }

    virtual void detach()	{ duplicate(*this); }

    
    char       *data()	 const	{ return shd->data; }
    uint	nrefs()	 const	{ return shd->count; }
    uint	size()	 const	{ return shd->len; }
    bool	isEqual( const QGArray &a ) const;

    bool	resize( uint newsize, Optimization optim );
    bool	resize( uint newsize );

    bool	fill( const char *d, int len, uint sz );

    QGArray    &assign( const QGArray &a );
    QGArray    &assign( const char *d, uint len );
    QGArray    &duplicate( const QGArray &a );
    QGArray    &duplicate( const char *d, uint len );
    void	store( const char *d, uint len );

    array_data *sharedBlock()	const		{ return shd; }
    void	setSharedBlock( array_data *p ) { shd=(array_data*)p; }

    QGArray    &setRawData( const char *d, uint len );
    void	resetRawData( const char *d, uint len );

    int		find( const char *d, uint index, uint sz ) const;
    int		contains( const char *d, uint sz ) const;

    void	sort( uint sz );
    int		bsearch( const char *d, uint sz ) const;

    char       *at( uint index ) const;

    bool	setExpand( uint index, const char *d, uint sz );

protected:
    virtual array_data *newData();
    virtual void deleteData( array_data *p );

private:
    static void msg_index( uint );
    array_data *shd;
};


inline char *QGArray::at( uint index ) const
{

    if ( index >= size() ) {
	msg_index( index );
	index = 0;
    }
#line 127 "c:\\qt-3.3.8\\include\\qgarray.h"
    return &shd->data[index];
}


#line 132 "c:\\qt-3.3.8\\include\\qgarray.h"
#line 43 "c:\\qt-3.3.8\\include\\qmemarray.h"
#line 44 "c:\\qt-3.3.8\\include\\qmemarray.h"


template<class type>
class QMemArray : public QGArray
{
public:
    typedef type* Iterator;
    typedef const type* ConstIterator;
    typedef type ValueType;

protected:
    QMemArray( int, int ) : QGArray( 0, 0 ) {}

public:
    QMemArray() {}
    QMemArray( int size ) : QGArray(size*sizeof(type)) {} 
    QMemArray( const QMemArray<type> &a ) : QGArray(a) {}
   ~QMemArray() {}
    QMemArray<type> &operator=(const QMemArray<type> &a)
				{ return (QMemArray<type>&)QGArray::assign(a); }
    type *data()    const	{ return (type *)QGArray::data(); }
    uint  nrefs()   const	{ return QGArray::nrefs(); }
    uint  size()    const	{ return QGArray::size()/sizeof(type); }
    uint  count()   const	{ return size(); }
    bool  isEmpty() const	{ return QGArray::size() == 0; }
    bool  isNull()  const	{ return QGArray::data() == 0; }
    bool  resize( uint size )	{ return QGArray::resize(size*sizeof(type)); }
    bool  resize( uint size, Optimization optim ) { return QGArray::resize(size*sizeof(type), optim); }
    bool  truncate( uint pos )	{ return QGArray::resize(pos*sizeof(type)); }
    bool  fill( const type &d, int size = -1 )
	{ return QGArray::fill((char*)&d,size,sizeof(type) ); }
    void  detach()		{ QGArray::detach(); }
    QMemArray<type>   copy() const
	{ QMemArray<type> tmp; return tmp.duplicate(*this); }
    QMemArray<type>& assign( const QMemArray<type>& a )
	{ return (QMemArray<type>&)QGArray::assign(a); }
    QMemArray<type>& assign( const type *a, uint n )
	{ return (QMemArray<type>&)QGArray::assign((char*)a,n*sizeof(type)); }
    QMemArray<type>& duplicate( const QMemArray<type>& a )
	{ return (QMemArray<type>&)QGArray::duplicate(a); }
    QMemArray<type>& duplicate( const type *a, uint n )
	{ return (QMemArray<type>&)QGArray::duplicate((char*)a,n*sizeof(type)); }
    QMemArray<type>& setRawData( const type *a, uint n )
	{ return (QMemArray<type>&)QGArray::setRawData((char*)a,
						     n*sizeof(type)); }
    void resetRawData( const type *a, uint n )
	{ QGArray::resetRawData((char*)a,n*sizeof(type)); }
    int	 find( const type &d, uint i=0 ) const
	{ return QGArray::find((char*)&d,i,sizeof(type)); }
    int	 contains( const type &d ) const
	{ return QGArray::contains((char*)&d,sizeof(type)); }
    void sort() { QGArray::sort(sizeof(type)); }
    int  bsearch( const type &d ) const
	{ return QGArray::bsearch((const char*)&d,sizeof(type)); }
    
    type& operator[]( int i ) const
	{ return (type &)(*(type *)QGArray::at(i*sizeof(type))); }
    type& at( uint i ) const
	{ return (type &)(*(type *)QGArray::at(i*sizeof(type))); }
	 operator const type*() const { return (const type *)QGArray::data(); }
    bool operator==( const QMemArray<type> &a ) const { return isEqual(a); }
    bool operator!=( const QMemArray<type> &a ) const { return !isEqual(a); }
    Iterator begin() { return data(); }
    Iterator end() { return data() + size(); }
    ConstIterator begin() const { return data(); }
    ConstIterator end() const { return data() + size(); }
};



#line 115 "c:\\qt-3.3.8\\include\\qmemarray.h"


#line 1 "c:\\qt-3.3.8\\include\\qwinexport.h"










































#line 44 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 49 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 54 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 59 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 65 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 70 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 75 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 81 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 87 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 94 "c:\\qt-3.3.8\\include\\qwinexport.h"



extern template class __declspec(dllimport) QMemArray<int>;
extern template class __declspec(dllimport) QMemArray<bool>;
extern template class __declspec(dllimport) QMemArray<char>;
#line 101 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 106 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 112 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 118 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 124 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 130 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 136 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 141 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 146 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 151 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 156 "c:\\qt-3.3.8\\include\\qwinexport.h"







#line 164 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 170 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 176 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 182 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 187 "c:\\qt-3.3.8\\include\\qwinexport.h"








#line 196 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 202 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 207 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 211 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 218 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 222 "c:\\qt-3.3.8\\include\\qwinexport.h"
#line 118 "c:\\qt-3.3.8\\include\\qmemarray.h"
#line 119 "c:\\qt-3.3.8\\include\\qmemarray.h"
#line 44 "c:\\qt-3.3.8\\include\\qcstring.h"
#line 45 "c:\\qt-3.3.8\\include\\qcstring.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"















#pragma once
#line 18 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"




#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 





#line 22 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 23 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














#line 38 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"



#line 42 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"




















    

#line 65 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 67 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\sal.h"

























































































































































































































#pragma once






#line 226 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\sal.h"
extern "C" {




#line 232 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\sal.h"



























































































































































































































#line 452 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 486 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\sal.h"



































































































































































































































    
    
#line 716 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\sal.h"






#line 723 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\sal.h"
#line 724 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\sal.h"


}
#line 728 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\sal.h"



#line 69 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"









#line 79 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"








#line 88 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"






#line 95 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"





#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtassem.h"












#pragma once



#line 18 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtassem.h"




#line 23 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtassem.h"

#line 25 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtassem.h"
#line 26 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtassem.h"



#line 30 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtassem.h"

#line 101 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"




#pragma comment(linker,"/manifestdependency:\"type='win32' "            \
        "name='" "Microsoft.VC80" ".DebugCRT' "         \
        "version='" "8.0.50727.762" "' "                          \
        "processorArchitecture='x86' "                                  \
        "publicKeyToken='" "1fc8b3b9a1e18e3b" "'\"")






#line 117 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 119 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"





































#line 157 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 159 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"





#pragma pack(push,8)
#line 166 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"













#pragma once
#line 16 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"






#line 23 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"









#pragma pack(push,8)
#line 34 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"


extern "C" {
#line 38 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"







#line 46 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"
#line 47 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"





typedef __w64 unsigned int   uintptr_t;
#line 54 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"

#line 56 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"





typedef char *  va_list;
#line 63 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"

#line 65 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"





#line 71 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"











#line 83 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"


#line 86 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"













#line 100 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"












































#line 145 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"


}
#line 149 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"


#pragma pack(pop)
#line 153 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"

#line 155 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vadefs.h"
#line 168 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"


extern "C" {
#line 172 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"





#line 178 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"




#line 183 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"








#line 192 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"






#line 199 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 201 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 202 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"








#line 211 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 212 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"










#line 223 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"


#line 226 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 227 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"





#line 233 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"









#line 243 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 245 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"







#line 253 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 254 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"




#line 259 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 261 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 262 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"




#line 267 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 269 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 270 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"


 

#line 275 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
  
 #line 277 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 278 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"










#line 289 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 290 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"






#line 297 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 298 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

















#line 316 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"




#line 321 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"






#line 328 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"





#line 334 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"






#line 341 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 342 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"





#line 348 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"






#line 355 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 356 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"






#line 363 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 364 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"




#line 369 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"


#line 372 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 374 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 375 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 376 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"





#line 382 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"










#line 393 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 395 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 396 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 397 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"










#line 408 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"






#line 415 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 416 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"







#line 424 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 426 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 427 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"



 
  
 



#line 437 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 438 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"


 
  
  
 



#line 448 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 449 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"


 
  
   
  

#line 457 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
 



#line 462 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 463 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"





#line 469 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"




#line 474 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 476 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 477 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"





typedef __w64 unsigned int   size_t;
#line 484 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 486 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"



typedef size_t rsize_t;

#line 492 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 493 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"





typedef __w64 int            intptr_t;
#line 500 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 502 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














typedef __w64 int            ptrdiff_t;
#line 518 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 520 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"


typedef unsigned short wchar_t;

#line 525 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"


typedef unsigned short wint_t;
typedef unsigned short wctype_t;

#line 531 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"


















#line 550 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 551 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"





__declspec(deprecated("This name was supported during some Whidbey pre-releases. Instead, use the standard name errno_t.")) typedef int errcode;


#line 560 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

typedef int errno_t;
#line 563 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"


typedef __w64 long __time32_t;   

#line 568 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"



typedef __int64 __time64_t;     
#line 573 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 575 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"





typedef __time64_t time_t;      
#line 582 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 584 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"







#line 592 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 593 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"




#line 598 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 600 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 601 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"




#line 606 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 608 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 609 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"






#line 616 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 617 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"




#line 622 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"



#line 626 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"











#line 638 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"




#line 643 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"




#line 648 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 650 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 651 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"







#line 659 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"


































































































































































#line 822 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 823 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1889 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"















































































































































#line 2033 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"
#line 2034 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;
typedef struct threadmbcinfostruct * pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct
{
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
} _locale_tstruct, *_locale_t;


typedef struct tagLC_ID {
        unsigned short wLanguage;
        unsigned short wCountry;
        unsigned short wCodePage;
} LC_ID, *LPLC_ID;

#line 2055 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"


typedef struct threadlocaleinfostruct {
        int refcount;
        unsigned int lc_codepage;
        unsigned int lc_collate_cp;
        unsigned long lc_handle[6]; 
        LC_ID lc_id[6];
        struct {
            char *locale;
            wchar_t *wlocale;
            int *refcount;
            int *wrefcount;
        } lc_category[6];
        int lc_clike;
        int mb_cur_max;
        int * lconv_intl_refcount;
        int * lconv_num_refcount;
        int * lconv_mon_refcount;
        struct lconv * lconv;
        int * ctype1_refcount;
        unsigned short * ctype1;
        const unsigned short * pctype;
        const unsigned char * pclmap;
        const unsigned char * pcumap;
        struct __lc_time_data * lc_time_curr;
} threadlocinfo;

#line 2084 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"


}
#line 2088 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"



#line 2092 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 2094 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"



#line 2098 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 2100 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"



#line 2104 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 2106 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"






#line 2113 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"



#line 2117 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"


#pragma pack(pop)
#line 2121 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 2123 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"

#line 23 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"


extern "C" {
#line 27 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"




#line 32 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"







#line 40 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
#line 41 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"







__declspec(dllimport) void *  __cdecl _memccpy(        void * _Dst,      const void * _Src,      int _Val,      size_t _MaxCount);
__declspec(dllimport)  const void *  __cdecl memchr(          const void * _Buf ,      int _Val,      size_t _MaxCount);
__declspec(dllimport)  int     __cdecl _memicmp(         const void * _Buf1,          const void * _Buf2,      size_t _Size);
__declspec(dllimport)  int     __cdecl _memicmp_l(         const void * _Buf1,          const void * _Buf2,      size_t _Size,        _locale_t _Locale);
         int     __cdecl memcmp(         const void * _Buf1,          const void * _Buf2,      size_t _Size);
         void *  __cdecl memcpy(         void * _Dst,          const void * _Src,      size_t _Size);

__declspec(dllimport) errno_t  __cdecl memcpy_s(         void * _Dst,      rsize_t _DstSize,          const void * _Src,      rsize_t _MaxCount);
#line 57 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
        void *  __cdecl memset(         void * _Dst,      int _Val,      size_t _Size);



__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_memccpy" ". See online help for details.")) __declspec(dllimport) void * __cdecl memccpy(       void * _Dst,          const void * _Src,      int _Val,      size_t _Size);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_memicmp" ". See online help for details.")) __declspec(dllimport)  int __cdecl memicmp(         const void * _Buf1,          const void * _Buf2,      size_t _Size);
#line 64 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"

#line 66 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"

__declspec(dllimport)  errno_t __cdecl _strset_s(           char * _Dst,      size_t _DstSize,      int _Value);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(           char (&_Dest)[_Size],      int _Value) { return _strset_s(_Dest, _Size, _Value); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  char * __cdecl _strset( char *_Dest,  int _Value);

__declspec(dllimport)  errno_t __cdecl strcpy_s(       char * _Dst,      rsize_t _DstSize,        const char * _Src);
#line 73 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(       char (&_Dest)[_Size],        const char * _Source) { return strcpy_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  char * __cdecl strcpy( char *_Dest,  const char * _Source);

__declspec(dllimport)  errno_t __cdecl strcat_s(           char * _Dst,      rsize_t _DstSize,        const char * _Src);
#line 78 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(           char (&_Dest)[_Size],        const char * _Source) { return strcat_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  char * __cdecl strcat( char *_Dest,  const char * _Source);
         int     __cdecl strcmp(       const char * _Str1,        const char * _Str2);
         size_t  __cdecl strlen(       const char * _Str);
__declspec(dllimport)  size_t  __cdecl strnlen(       const char * _Str,      size_t _MaxCount);

static __inline  size_t  __cdecl strnlen_s(        const char * _Str,      size_t _MaxCount)
{
    return strnlen(_Str, _MaxCount);
}
#line 89 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"

__declspec(dllimport)  errno_t __cdecl memmove_s(         void * _Dst,      rsize_t _DstSize,          const void * _Src,      rsize_t _MaxCount);
#line 92 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"



#line 96 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
__declspec(dllimport)  void *  __cdecl memmove(         void * _Dst,          const void * _Src,      size_t _Size);
#line 98 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"




#line 103 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"

__declspec(dllimport)  char *  __cdecl _strdup(         const char * _Src);



#line 109 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"

__declspec(dllimport)  const char *  __cdecl strchr(       const char * _Str,      int _Val);
__declspec(dllimport)  int     __cdecl _stricmp(        const char * _Str1,         const char * _Str2);
__declspec(dllimport)  int     __cdecl _strcmpi(        const char * _Str1,         const char * _Str2);
__declspec(dllimport)  int     __cdecl _stricmp_l(        const char * _Str1,         const char * _Str2,        _locale_t _Locale);
__declspec(dllimport)  int     __cdecl strcoll(        const char * _Str1,         const  char * _Str2);
__declspec(dllimport)  int     __cdecl _strcoll_l(        const char * _Str1,         const char * _Str2,        _locale_t _Locale);
__declspec(dllimport)  int     __cdecl _stricoll(        const char * _Str1,         const char * _Str2);
__declspec(dllimport)  int     __cdecl _stricoll_l(        const char * _Str1,         const char * _Str2,        _locale_t _Locale);
__declspec(dllimport)  int     __cdecl _strncoll  (       const char * _Str1,        const char * _Str2,      size_t _MaxCount);
__declspec(dllimport)  int     __cdecl _strncoll_l(       const char * _Str1,        const char * _Str2,      size_t _MaxCount,        _locale_t _Locale);
__declspec(dllimport)  int     __cdecl _strnicoll (       const char * _Str1,        const char * _Str2,      size_t _MaxCount);
__declspec(dllimport)  int     __cdecl _strnicoll_l(       const char * _Str1,        const char * _Str2,      size_t _MaxCount,        _locale_t _Locale);
__declspec(dllimport)  size_t  __cdecl strcspn(        const char * _Str,         const char * _Control);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  char *  __cdecl _strerror(         const char * _ErrMsg);
__declspec(dllimport)  errno_t __cdecl _strerror_s(       char * _Buf,      size_t _SizeInBytes,          const char * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(     char (&_Buffer)[_Size],          const char * _ErrorMessage) { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  char *  __cdecl strerror(     int);

__declspec(dllimport)  errno_t __cdecl strerror_s(       char * _Buf,      size_t _SizeInBytes,      int _ErrNum);
#line 130 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(     char (&_Buffer)[_Size],      int _ErrorMessage) { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
__declspec(dllimport)  errno_t __cdecl _strlwr_s(           char * _Str,      size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(           char (&_String)[_Size]) { return _strlwr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strlwr( char *_String);
__declspec(dllimport)  errno_t __cdecl _strlwr_s_l(           char * _Str,      size_t _Size,        _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(           char (&_String)[_Size],        _locale_t _Locale) { return _strlwr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strlwr_l(         char *_String,        _locale_t _Locale);

__declspec(dllimport)  errno_t __cdecl strncat_s(           char * _Dst,      rsize_t _DstSize,        const char * _Src,      rsize_t _MaxCount);
#line 140 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(           char (&_Dest)[_Size],        const char * _Source,      size_t _Count) { return strncat_s(_Dest, _Size, _Source, _Count); } }
#pragma warning(push)
#pragma warning(disable:6059)

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl strncat(           char *_Dest,        const char * _Source,      size_t _Count);
#pragma warning(pop)


#line 149 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
__declspec(dllimport)  int     __cdecl strncmp(       const char * _Str1,        const char * _Str2,      size_t _MaxCount);
#line 151 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
__declspec(dllimport)  int     __cdecl _strnicmp(       const char * _Str1,        const char * _Str2,      size_t _MaxCount);
__declspec(dllimport)  int     __cdecl _strnicmp_l(       const char * _Str1,        const char * _Str2,      size_t _MaxCount,        _locale_t _Locale);

__declspec(dllimport)  errno_t __cdecl strncpy_s(       char * _Dst,      rsize_t _DstSize,          const char * _Src,      rsize_t _MaxCount);
#line 156 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(     char (&_Dest)[_Size],        const char * _Source,      size_t _Count) { return strncpy_s(_Dest, _Size, _Source, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl strncpy(     char *_Dest,        const char * _Source,      size_t _Count);
__declspec(dllimport)  errno_t __cdecl _strnset_s(           char * _Str,      size_t _Size,      int _Val,      size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(           char (&_Dest)[_Size],      int _Val,      size_t _Count) { return _strnset_s(_Dest, _Size, _Val, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strnset(           char *_Dest,      int _Val,      size_t _Count);
__declspec(dllimport)  const char *  __cdecl strpbrk(       const char * _Str,        const char * _Control);
__declspec(dllimport)  const char *  __cdecl strrchr(       const char * _Str,      int _Ch);
__declspec(dllimport) char *  __cdecl _strrev(         char * _Str);
__declspec(dllimport)  size_t  __cdecl strspn(       const char * _Str,        const char * _Control);
__declspec(dllimport)  const char *  __cdecl strstr(       const char * _Str,        const char * _SubStr);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  char *  __cdecl strtok(           char * _Str,        const char * _Delim);

__declspec(dllimport)  char *  __cdecl strtok_s(           char * _Str,        const char * _Delim,                        char ** _Context);
#line 170 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
__declspec(dllimport)  errno_t __cdecl _strupr_s(           char * _Str,      size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(           char (&_String)[_Size]) { return _strupr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strupr( char *_String);
__declspec(dllimport)  errno_t __cdecl _strupr_s_l(           char * _Str,      size_t _Size, _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(           char (&_String)[_Size], _locale_t _Locale) { return _strupr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strupr_l(         char *_String,        _locale_t _Locale);
__declspec(dllimport)  size_t  __cdecl strxfrm (         char * _Dst,        const char * _Src,      size_t _MaxCount);
__declspec(dllimport)  size_t  __cdecl _strxfrm_l(         char * _Dst,        const char * _Src,      size_t _MaxCount,        _locale_t _Locale);


extern "C++" {


inline  char * __cdecl strchr(       char * _Str,      int _Ch)
	{ return (char*)strchr((const char*)_Str, _Ch); }
inline  char * __cdecl strpbrk(       char * _Str,        const char * _Control)
	{ return (char*)strpbrk((const char*)_Str, _Control); }
inline  char * __cdecl strrchr(       char * _Str,      int _Ch)
	{ return (char*)strrchr((const char*)_Str, _Ch); }
inline  char * __cdecl strstr(       char * _Str,        const char * _SubStr)
	{ return (char*)strstr((const char*)_Str, _SubStr); }
#line 192 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"


inline  void * __cdecl memchr(         void * _Pv,      int _C,      size_t _N)
	{ return (void*)memchr((const void*)_Pv, _C, _N); }
#line 197 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
}
#line 199 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"






#line 206 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"

__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strdup" ". See online help for details.")) __declspec(dllimport)  char * __cdecl strdup(         const char * _Src);



#line 212 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"


__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strcmpi" ". See online help for details.")) __declspec(dllimport)  int __cdecl strcmpi(       const char * _Str1,        const char * _Str2);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_stricmp" ". See online help for details.")) __declspec(dllimport)  int __cdecl stricmp(       const char * _Str1,        const char * _Str2);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strlwr" ". See online help for details.")) __declspec(dllimport) char * __cdecl strlwr(         char * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strnicmp" ". See online help for details.")) __declspec(dllimport)  int __cdecl strnicmp(       const char * _Str1,        const char * _Str,      size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strnset" ". See online help for details.")) __declspec(dllimport) char * __cdecl strnset(           char * _Str,      int _Val,      size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strrev" ". See online help for details.")) __declspec(dllimport) char * __cdecl strrev(         char * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strset" ". See online help for details."))         char * __cdecl strset(         char * _Str,      int _Val);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strupr" ". See online help for details.")) __declspec(dllimport) char * __cdecl strupr(         char * _Str);

#line 224 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"









#line 234 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"

__declspec(dllimport)  wchar_t * __cdecl _wcsdup(       const wchar_t * _Str);



#line 240 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"


__declspec(dllimport)  errno_t __cdecl wcscat_s(           wchar_t * _Dst,      rsize_t _DstSize, const wchar_t * _Src);
#line 244 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(           wchar_t (&_Dest)[_Size],        const wchar_t * _Source) { return wcscat_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcscat( wchar_t *_Dest,  const wchar_t * _Source);
__declspec(dllimport)  const wchar_t * __cdecl wcschr(       const wchar_t * _Str, wchar_t _Ch);
__declspec(dllimport)  int __cdecl wcscmp(       const wchar_t * _Str1,        const wchar_t * _Str2);

__declspec(dllimport)  errno_t __cdecl wcscpy_s(       wchar_t * _Dst,      rsize_t _DstSize,        const wchar_t * _Src);
#line 251 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(     wchar_t (&_Dest)[_Size],        const wchar_t * _Source) { return wcscpy_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcscpy( wchar_t *_Dest,  const wchar_t * _Source);
__declspec(dllimport)  size_t __cdecl wcscspn(       const wchar_t * _Str,        const wchar_t * _Control);
__declspec(dllimport)  size_t __cdecl wcslen(       const wchar_t * _Str);
__declspec(dllimport)  size_t __cdecl wcsnlen(       const wchar_t * _Src,      size_t _MaxCount);

static __inline  size_t __cdecl wcsnlen_s(       const wchar_t * _Src,      size_t _MaxCount)
{
    return wcsnlen(_Src, _MaxCount);
}
#line 262 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"

__declspec(dllimport)  errno_t __cdecl wcsncat_s(           wchar_t * _Dst,      rsize_t _DstSize,        const wchar_t * _Src,      rsize_t _MaxCount);
#line 265 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(           wchar_t (&_Dest)[_Size],        const wchar_t * _Source,      size_t _Count) { return wcsncat_s(_Dest, _Size, _Source, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsncat(     wchar_t *_Dest,        const wchar_t * _Source,      size_t _Count);
__declspec(dllimport)  int __cdecl wcsncmp(       const wchar_t * _Str1,        const wchar_t * _Str2,      size_t _MaxCount);

__declspec(dllimport)  errno_t __cdecl wcsncpy_s(       wchar_t * _Dst,      rsize_t _DstSize,        const wchar_t * _Src,      rsize_t _MaxCount);
#line 271 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(     wchar_t (&_Dest)[_Size],        const wchar_t * _Source,      size_t _Count) { return wcsncpy_s(_Dest, _Size, _Source, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsncpy(     wchar_t *_Dest,        const wchar_t * _Source,      size_t _Count);
__declspec(dllimport)  const wchar_t * __cdecl wcspbrk(       const wchar_t * _Str,        const wchar_t * _Control);
__declspec(dllimport)  const wchar_t * __cdecl wcsrchr(       const wchar_t * _Str,      wchar_t _Ch);
__declspec(dllimport)  size_t __cdecl wcsspn(       const wchar_t * _Str,        const wchar_t * _Control);
__declspec(dllimport)  const wchar_t * __cdecl wcsstr(       const wchar_t * _Str,        const wchar_t * _SubStr);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  wchar_t * __cdecl wcstok(           wchar_t * _Str,        const wchar_t * _Delim);
__declspec(dllimport)  wchar_t * __cdecl wcstok_s(           wchar_t * _Str,        const wchar_t * _Delim,                        wchar_t ** _Context);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  wchar_t * __cdecl _wcserror(     int _ErrNum);
__declspec(dllimport)  errno_t __cdecl _wcserror_s(         wchar_t * _Buf,      size_t _SizeInWords,      int _ErrNum);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(     wchar_t (&_Buffer)[_Size],      int _Error) { return _wcserror_s(_Buffer, _Size, _Error); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  wchar_t * __cdecl __wcserror(         const wchar_t * _Str);
__declspec(dllimport)  errno_t __cdecl __wcserror_s(         wchar_t * _Buffer,      size_t _SizeInWords,        const wchar_t * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(     wchar_t (&_Buffer)[_Size],        const wchar_t * _ErrorMessage) { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }

__declspec(dllimport)  int __cdecl _wcsicmp(       const wchar_t * _Str1,        const wchar_t * _Str2);
__declspec(dllimport)  int __cdecl _wcsicmp_l(       const wchar_t * _Str1,        const wchar_t * _Str2,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl _wcsnicmp(       const wchar_t * _Str1,        const wchar_t * _Str2,      size_t _MaxCount);
__declspec(dllimport)  int __cdecl _wcsnicmp_l(       const wchar_t * _Str1,        const wchar_t * _Str2,      size_t _MaxCount,        _locale_t _Locale);
__declspec(dllimport)  errno_t __cdecl _wcsnset_s(           wchar_t * _Dst,      size_t _DstSizeInWords, wchar_t _Val,      size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(           wchar_t (&_Dst)[_Size], wchar_t _Val,      size_t _MaxCount) { return _wcsnset_s(_Dst, _Size, _Val, _MaxCount); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsnset(           wchar_t *_Str, wchar_t _Val,      size_t _MaxCount);
__declspec(dllimport) wchar_t * __cdecl _wcsrev(         wchar_t * _Str);
__declspec(dllimport)  errno_t __cdecl _wcsset_s(           wchar_t * _Str,      size_t _SizeInWords, wchar_t _Val);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(           wchar_t (&_Str)[_Size], wchar_t _Val) { return _wcsset_s(_Str, _Size, _Val); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsset(         wchar_t *_Str, wchar_t _Val);

__declspec(dllimport)  errno_t __cdecl _wcslwr_s(           wchar_t * _Str,      size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(           wchar_t (&_String)[_Size]) { return _wcslwr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcslwr( wchar_t *_String);
__declspec(dllimport)  errno_t __cdecl _wcslwr_s_l(           wchar_t * _Str,      size_t _SizeInWords,        _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(           wchar_t (&_String)[_Size],        _locale_t _Locale) { return _wcslwr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcslwr_l(         wchar_t *_String,        _locale_t _Locale);
__declspec(dllimport)  errno_t __cdecl _wcsupr_s(           wchar_t * _Str,      size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(           wchar_t (&_String)[_Size]) { return _wcsupr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsupr( wchar_t *_String);
__declspec(dllimport)  errno_t __cdecl _wcsupr_s_l(           wchar_t * _Str,      size_t _Size,        _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(           wchar_t (&_String)[_Size],        _locale_t _Locale) { return _wcsupr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsupr_l(         wchar_t *_String,        _locale_t _Locale);
__declspec(dllimport)  size_t __cdecl wcsxfrm(         wchar_t * _Dst,        const wchar_t * _Src,      size_t _MaxCount);
__declspec(dllimport)  size_t __cdecl _wcsxfrm_l(         wchar_t * _Dst,        const wchar_t *_Src,      size_t _MaxCount,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl wcscoll(       const wchar_t * _Str1,        const wchar_t * _Str2);
__declspec(dllimport)  int __cdecl _wcscoll_l(       const wchar_t * _Str1,        const wchar_t * _Str2,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl _wcsicoll(       const wchar_t * _Str1,        const wchar_t * _Str2);
__declspec(dllimport)  int __cdecl _wcsicoll_l(       const wchar_t * _Str1,        const wchar_t *_Str2,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl _wcsncoll(       const wchar_t * _Str1,        const wchar_t * _Str2,      size_t _MaxCount);
__declspec(dllimport)  int __cdecl _wcsncoll_l(       const wchar_t * _Str1,        const wchar_t * _Str2,      size_t _MaxCount,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl _wcsnicoll(       const wchar_t * _Str1,        const wchar_t * _Str2,      size_t _MaxCount);
__declspec(dllimport)  int __cdecl _wcsnicoll_l(       const wchar_t * _Str1,        const wchar_t * _Str2,      size_t _MaxCount,        _locale_t _Locale);




extern "C++" {
inline  wchar_t * __cdecl wcschr(       wchar_t *_Str, wchar_t _Ch)
        {return ((wchar_t *)wcschr((const wchar_t *)_Str, _Ch)); }
inline  wchar_t * __cdecl wcspbrk(       wchar_t *_Str,        const wchar_t *_Control)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_Str, _Control)); }
inline  wchar_t * __cdecl wcsrchr(       wchar_t *_Str,      wchar_t _Ch)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_Str, _Ch)); }
inline  wchar_t * __cdecl wcsstr(       wchar_t *_Str,        const wchar_t *_SubStr)
        {return ((wchar_t *)wcsstr((const wchar_t *)_Str, _SubStr)); }
}
#line 335 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
#line 336 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"






#line 343 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"

__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsdup" ". See online help for details.")) __declspec(dllimport)  wchar_t * __cdecl wcsdup(       const wchar_t * _Str);



#line 349 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"





__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsicmp" ". See online help for details.")) __declspec(dllimport)  int __cdecl wcsicmp(       const wchar_t * _Str1,        const wchar_t * _Str2);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsnicmp" ". See online help for details.")) __declspec(dllimport)  int __cdecl wcsnicmp(       const wchar_t * _Str1,        const wchar_t * _Str2,      size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsnset" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsnset(           wchar_t * _Str,        wchar_t _Val,      size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsrev" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsrev(         wchar_t * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsset" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsset(         wchar_t * _Str, wchar_t _Val);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcslwr" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcslwr(         wchar_t * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsupr" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsupr(         wchar_t * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsicoll" ". See online help for details.")) __declspec(dllimport)  int __cdecl wcsicoll(       const wchar_t * _Str1,        const wchar_t * _Str2);

#line 364 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"


#line 367 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"



}
#line 372 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"

#line 374 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string.h"
#line 47 "c:\\qt-3.3.8\\include\\qcstring.h"






__declspec(dllimport) void *qmemmove( void *dst, const void *src, uint len );

__declspec(dllimport) char *qstrdup( const char * );

__declspec(dllimport) inline uint qstrlen( const char *str )
{ return str ? (uint)strlen(str) : 0u; }

__declspec(dllimport) inline char *qstrcpy( char *dst, const char *src )
{ return src ? strcpy(dst, src) : 0; }

__declspec(dllimport) char *qstrncpy( char *dst, const char *src, uint len );

__declspec(dllimport) inline int qstrcmp( const char *str1, const char *str2 )
{
    return ( str1 && str2 ) ? strcmp( str1, str2 )
			    : ( str1 ? 1 : ( str2 ? -1 : 0 ) );
}

__declspec(dllimport) inline int qstrncmp( const char *str1, const char *str2, uint len )
{
    return ( str1 && str2 ) ? strncmp( str1, str2, len )
			    : ( str1 ? 1 : ( str2 ? -1 : 0 ) );
}

__declspec(dllimport) int qstricmp( const char *, const char * );

__declspec(dllimport) int qstrnicmp( const char *, const char *, uint len );


__declspec(dllimport) inline uint cstrlen( const char *str )
{ return (uint)strlen(str); }

__declspec(dllimport) inline char *cstrcpy( char *dst, const char *src )
{ return strcpy(dst,src); }

__declspec(dllimport) inline int cstrcmp( const char *str1, const char *str2 )
{ return strcmp(str1,str2); }

__declspec(dllimport) inline int cstrncmp( const char *str1, const char *str2, uint len )
{ return strncmp(str1,str2,len); }
#line 94 "c:\\qt-3.3.8\\include\\qcstring.h"




__declspec(dllimport) Q_UINT16 qChecksum( const char *s, uint len );
















#line 116 "c:\\qt-3.3.8\\include\\qcstring.h"
typedef QMemArray<char> QByteArray;
#line 118 "c:\\qt-3.3.8\\include\\qcstring.h"


__declspec(dllimport) QByteArray qCompress( const uchar* data, int nbytes );
__declspec(dllimport) QByteArray qUncompress( const uchar* data, int nbytes );
__declspec(dllimport) inline QByteArray qCompress( const QByteArray& data)
{ return qCompress( (const uchar*)data.data(), data.size() ); }
__declspec(dllimport) inline QByteArray qUncompress( const QByteArray& data )
{ return qUncompress( (const uchar*)data.data(), data.size() ); }
#line 127 "c:\\qt-3.3.8\\include\\qcstring.h"





__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QByteArray & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QByteArray & );
#line 135 "c:\\qt-3.3.8\\include\\qcstring.h"





class QRegExp;

class __declspec(dllimport) QCString : public QByteArray	
{
public:
    QCString() {}				
    QCString( int size );			
    QCString( const QCString &s ) : QByteArray( s ) {}
    QCString( const char *str );		
    QCString( const char *str, uint maxlen );	
    ~QCString();

    QCString    &operator=( const QCString &s );
    QCString    &operator=( const char *str );	

    bool	isNull()	const;
    bool	isEmpty()	const;
    uint	length()	const;
    bool	resize( uint newlen );
    bool	truncate( uint pos );
    bool	fill( char c, int len = -1 );

    QCString	copy()	const;

    QCString    &sprintf( const char *format, ... );

    int		find( char c, int index=0, bool cs=TRUE ) const;
    int		find( const char *str, int index=0, bool cs=TRUE ) const;

    int		find( const QRegExp &, int index=0 ) const;
#line 171 "c:\\qt-3.3.8\\include\\qcstring.h"
    int		findRev( char c, int index=-1, bool cs=TRUE) const;
    int		findRev( const char *str, int index=-1, bool cs=TRUE) const;

    int		findRev( const QRegExp &, int index=-1 ) const;
#line 176 "c:\\qt-3.3.8\\include\\qcstring.h"
    int		contains( char c, bool cs=TRUE ) const;
    int		contains( const char *str, bool cs=TRUE ) const;

    int		contains( const QRegExp & ) const;
#line 181 "c:\\qt-3.3.8\\include\\qcstring.h"
    QCString	left( uint len )  const;
    QCString	right( uint len ) const;
    QCString	mid( uint index, uint len=0xffffffff) const;

    QCString	leftJustify( uint width, char fill=' ', bool trunc=FALSE)const;
    QCString	rightJustify( uint width, char fill=' ',bool trunc=FALSE)const;

    QCString	lower() const;
    QCString	upper() const;

    QCString	stripWhiteSpace()	const;
    QCString	simplifyWhiteSpace()	const;

    QCString    &insert( uint index, const char * );
    QCString    &insert( uint index, char );
    QCString    &append( const char * );
    QCString    &prepend( const char * );
    QCString    &remove( uint index, uint len );
    QCString    &replace( uint index, uint len, const char * );

    QCString    &replace( const QRegExp &, const char * );
#line 203 "c:\\qt-3.3.8\\include\\qcstring.h"
    QCString    &replace( char c, const char *after );
    QCString    &replace( const char *, const char * );
    QCString    &replace( char, char );

    short	toShort( bool *ok=0 )	const;
    ushort	toUShort( bool *ok=0 )	const;
    int		toInt( bool *ok=0 )	const;
    uint	toUInt( bool *ok=0 )	const;
    long	toLong( bool *ok=0 )	const;
    ulong	toULong( bool *ok=0 )	const;
    float	toFloat( bool *ok=0 )	const;
    double	toDouble( bool *ok=0 )	const;

    QCString    &setStr( const char *s );
    QCString    &setNum( short );
    QCString    &setNum( ushort );
    QCString    &setNum( int );
    QCString    &setNum( uint );
    QCString    &setNum( long );
    QCString    &setNum( ulong );
    QCString    &setNum( float, char f='g', int prec=6 );
    QCString    &setNum( double, char f='g', int prec=6 );

    bool	setExpand( uint index, char c );

		operator const char *() const;
    QCString    &operator+=( const char *str );
    QCString    &operator+=( char c );
private:
    int	find( const char *str, int index, bool cs, uint l ) const;
};






__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QCString & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QCString & );
#line 243 "c:\\qt-3.3.8\\include\\qcstring.h"





inline QCString &QCString::operator=( const QCString &s )
{ return (QCString&)assign( s ); }

inline QCString &QCString::operator=( const char *str )
{ return (QCString&)duplicate( str, qstrlen(str)+1 ); }

inline bool QCString::isNull() const
{ return data() == 0; }

inline bool QCString::isEmpty() const
{ return data() == 0 || *data() == '\0'; }

inline uint QCString::length() const
{ return qstrlen( data() ); }

inline bool QCString::truncate( uint pos )
{ return resize(pos+1); }

inline QCString QCString::copy() const
{ return QCString( data() ); }

inline QCString &QCString::prepend( const char *s )
{ return insert(0,s); }

inline QCString &QCString::append( const char *s )
{ return operator+=(s); }

inline QCString &QCString::setNum( short n )
{ return setNum((long)n); }

inline QCString &QCString::setNum( ushort n )
{ return setNum((ulong)n); }

inline QCString &QCString::setNum( int n )
{ return setNum((long)n); }

inline QCString &QCString::setNum( uint n )
{ return setNum((ulong)n); }

inline QCString &QCString::setNum( float n, char f, int prec )
{ return setNum((double)n,f,prec); }

inline QCString::operator const char *() const
{ return (const char *)data(); }






__declspec(dllimport) inline bool operator==( const QCString &s1, const QCString &s2 )
{ return qstrcmp( s1.data(), s2.data() ) == 0; }

__declspec(dllimport) inline bool operator==( const QCString &s1, const char *s2 )
{ return qstrcmp( s1.data(), s2 ) == 0; }

__declspec(dllimport) inline bool operator==( const char *s1, const QCString &s2 )
{ return qstrcmp( s1, s2.data() ) == 0; }

__declspec(dllimport) inline bool operator!=( const QCString &s1, const QCString &s2 )
{ return qstrcmp( s1.data(), s2.data() ) != 0; }

__declspec(dllimport) inline bool operator!=( const QCString &s1, const char *s2 )
{ return qstrcmp( s1.data(), s2 ) != 0; }

__declspec(dllimport) inline bool operator!=( const char *s1, const QCString &s2 )
{ return qstrcmp( s1, s2.data() ) != 0; }

__declspec(dllimport) inline bool operator<( const QCString &s1, const QCString& s2 )
{ return qstrcmp( s1.data(), s2.data() ) < 0; }

__declspec(dllimport) inline bool operator<( const QCString &s1, const char *s2 )
{ return qstrcmp( s1.data(), s2 ) < 0; }

__declspec(dllimport) inline bool operator<( const char *s1, const QCString &s2 )
{ return qstrcmp( s1, s2.data() ) < 0; }

__declspec(dllimport) inline bool operator<=( const QCString &s1, const QCString &s2 )
{ return qstrcmp( s1.data(), s2.data() ) <= 0; }

__declspec(dllimport) inline bool operator<=( const QCString &s1, const char *s2 )
{ return qstrcmp( s1.data(), s2 ) <= 0; }

__declspec(dllimport) inline bool operator<=( const char *s1, const QCString &s2 )
{ return qstrcmp( s1, s2.data() ) <= 0; }

__declspec(dllimport) inline bool operator>( const QCString &s1, const QCString &s2 )
{ return qstrcmp( s1.data(), s2.data() ) > 0; }

__declspec(dllimport) inline bool operator>( const QCString &s1, const char *s2 )
{ return qstrcmp( s1.data(), s2 ) > 0; }

__declspec(dllimport) inline bool operator>( const char *s1, const QCString &s2 )
{ return qstrcmp( s1, s2.data() ) > 0; }

__declspec(dllimport) inline bool operator>=( const QCString &s1, const QCString& s2 )
{ return qstrcmp( s1.data(), s2.data() ) >= 0; }

__declspec(dllimport) inline bool operator>=( const QCString &s1, const char *s2 )
{ return qstrcmp( s1.data(), s2 ) >= 0; }

__declspec(dllimport) inline bool operator>=( const char *s1, const QCString &s2 )
{ return qstrcmp( s1, s2.data() ) >= 0; }

__declspec(dllimport) inline const QCString operator+( const QCString &s1,
					  const QCString &s2 )
{
    QCString tmp( s1.data() );
    tmp += s2;
    return tmp;
}

__declspec(dllimport) inline const QCString operator+( const QCString &s1, const char *s2 )
{
    QCString tmp( s1.data() );
    tmp += s2;
    return tmp;
}

__declspec(dllimport) inline const QCString operator+( const char *s1, const QCString &s2 )
{
    QCString tmp( s1 );
    tmp += s2;
    return tmp;
}

__declspec(dllimport) inline const QCString operator+( const QCString &s1, char c2 )
{
    QCString tmp( s1.data() );
    tmp += c2;
    return tmp;
}

__declspec(dllimport) inline const QCString operator+( char c1, const QCString &s2 )
{
    QCString tmp;
    tmp += c1;
    tmp += s2;
    return tmp;
}
#line 1 "c:\\qt-3.3.8\\include\\qwinexport.h"










































#line 44 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 49 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 54 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 59 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 65 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 70 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 75 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 81 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 87 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 94 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 101 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 106 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 112 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 118 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 124 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 130 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 136 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 141 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 146 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 151 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 156 "c:\\qt-3.3.8\\include\\qwinexport.h"







#line 164 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 170 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 176 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 182 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 187 "c:\\qt-3.3.8\\include\\qwinexport.h"








#line 196 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 202 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 207 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 211 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 218 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 222 "c:\\qt-3.3.8\\include\\qwinexport.h"
#line 389 "c:\\qt-3.3.8\\include\\qcstring.h"
#line 390 "c:\\qt-3.3.8\\include\\qcstring.h"
#line 43 "c:\\qt-3.3.8\\include\\qstring.h"
#line 44 "c:\\qt-3.3.8\\include\\qstring.h"


#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\limits.h"















#pragma once
#line 18 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\limits.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 20 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\limits.h"
















#line 37 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\limits.h"



















#line 57 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\limits.h"





#line 63 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\limits.h"





#line 69 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\limits.h"








#line 78 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\limits.h"








#line 87 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\limits.h"






#line 94 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\limits.h"
#line 95 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\limits.h"







#line 103 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\limits.h"
#line 104 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\limits.h"
































#line 137 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\limits.h"
#line 47 "c:\\qt-3.3.8\\include\\qstring.h"
#line 48 "c:\\qt-3.3.8\\include\\qstring.h"







#line 56 "c:\\qt-3.3.8\\include\\qstring.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string"

#pragma once



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream"

#pragma once



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream"

#pragma once



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ios"

#pragma once



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"

#pragma once



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\climits"

#pragma once


#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

#pragma once



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 7 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"


#pragma pack(push,8)
#line 11 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"









































#line 53 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

#line 55 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"
#line 56 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

		


		




		

 
  

 

#line 73 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

 
  
 #line 77 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

 
  
 #line 81 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"


 
#line 85 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"


 
#line 89 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"




	
		
	

#line 98 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"







#line 106 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"













#line 120 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"




#line 125 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"




#line 130 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

#line 132 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"
#line 133 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"



#line 137 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"











#line 149 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"








#line 158 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"






 



#line 169 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

 





#line 177 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

 




#line 184 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

 
 

 #line 189 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

 









 










 









 

 









 









 




 





 
 

 
















#line 275 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"











 

 

 

 










 










 










 










 









#line 347 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"











#line 359 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\use_ansi.h"













#pragma once












#pragma comment(lib,"msvcprtd")


#line 31 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\use_ansi.h"








#line 40 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\use_ansi.h"






#line 47 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\use_ansi.h"










#pragma comment(linker,"/manifestdependency:\"type='win32' "            \
        "name='" "Microsoft.VC80" ".DebugCRT' "         \
        "version='" "8.0.50727.762" "' "                           \
        "processorArchitecture='x86' "                                  \
        "publicKeyToken='" "1fc8b3b9a1e18e3b" "'\"")






#line 69 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\use_ansi.h"

#line 71 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\use_ansi.h"





































#line 109 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\use_ansi.h"







#line 117 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\use_ansi.h"

#line 119 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\use_ansi.h"

#line 121 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\use_ansi.h"

#line 123 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\use_ansi.h"
#line 361 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"


 
#line 365 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"


 











 
  

#line 383 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"
   
  #line 385 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"
 #line 386 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"






 











 

   


#line 410 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"
    
   #line 412 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

 #line 414 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"


 
  

#line 420 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"
   
  #line 422 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"
 #line 423 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"


 
  

#line 429 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"
   
  #line 431 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"
 #line 432 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"


 
  

#line 438 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"
   
  #line 440 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"
 #line 441 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

 
  
 #line 445 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

 
   


     
   #line 452 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"
 #line 453 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"


    
#line 457 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"


  



		

 
  
  
  




  
  
  

  







   
   
   
  #line 489 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

  
  
  
  

 












#line 509 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

 

 
namespace std {
typedef bool _Bool;
}
 #line 517 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

		





		






typedef __int64 _Longlong;
typedef unsigned __int64 _ULonglong;

		


 
  
 #line 540 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"





		
		






 
namespace std {
		


#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) _Lockit
	{	
public:
  

    













#line 580 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"
    explicit __thiscall _Lockit();	
	explicit __thiscall _Lockit(int);	
	__thiscall ~_Lockit();	
    #line 584 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

    static  void __cdecl _Lockit_ctor(int);
    static  void __cdecl _Lockit_dtor(int);

private:
    static  void __cdecl _Lockit_ctor(_Lockit *);
    static  void __cdecl _Lockit_ctor(_Lockit *, int);
    static  void __cdecl _Lockit_dtor(_Lockit *);

	 _Lockit(const _Lockit&);				
	_Lockit&  operator=(const _Lockit&);	

	int _Locktype;

  












#line 612 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

	};



























































































#line 706 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

class __declspec(dllimport) _Mutex
	{	
public:

  
    
    
















#line 731 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"
    __thiscall _Mutex();
	__thiscall ~_Mutex();
	void __thiscall _Lock();
	void __thiscall _Unlock();
    #line 736 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

private:
    static  void __cdecl _Mutex_ctor(_Mutex *);
    static  void __cdecl _Mutex_dtor(_Mutex *);
    static  void __cdecl _Mutex_Lock(_Mutex *);
    static  void __cdecl _Mutex_Unlock(_Mutex *);

	 _Mutex(const _Mutex&);				
	_Mutex&  operator=(const _Mutex&);	
	void *_Mtx;

  







#line 756 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

	};

class __declspec(dllimport) _Init_locks
	{	
public:

 
    
    








#line 775 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"
    __thiscall _Init_locks();
	__thiscall ~_Init_locks();
    #line 778 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

private:
    static  void __cdecl _Init_locks_ctor(_Init_locks *);
    static  void __cdecl _Init_locks_dtor(_Init_locks *);

 







#line 792 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

	};
#pragma warning(pop)
}
 #line 797 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"





		

__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void));

typedef int _Mbstatet;





  
  


#pragma pack(pop)
#line 818 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"

#line 820 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\yvals.h"






#line 6 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\climits"

 #pragma warning(disable: 4514)


#line 11 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\climits"





#line 7 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstdio"

#pragma once










 #line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"















#pragma once
#line 18 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"




#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 23 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"





#pragma pack(push,8)
#line 30 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"


extern "C" {
#line 34 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"

























struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;

#line 72 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"










#line 83 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"













#line 97 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"




















#line 118 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"













__declspec(dllimport) FILE * __cdecl __iob_func(void);
#line 133 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"










#line 144 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"



typedef __int64 fpos_t;




#line 153 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
#line 154 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"


#line 157 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"






#line 164 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
























__declspec(dllimport)  int __cdecl _filbuf(     FILE * _File );
__declspec(dllimport)  int __cdecl _flsbuf(     int _Ch,      FILE * _File);




__declspec(dllimport)  FILE * __cdecl _fsopen(       const char * _Filename,        const char * _Mode,      int _ShFlag);
#line 196 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"

__declspec(dllimport) void __cdecl clearerr(     FILE * _File);
__declspec(dllimport)  errno_t __cdecl clearerr_s(     FILE * _File );
__declspec(dllimport)  int __cdecl fclose(     FILE * _File);
__declspec(dllimport)  int __cdecl _fcloseall(void);




__declspec(dllimport)  FILE * __cdecl _fdopen(     int _FileHandle,        const char * _Mode);
#line 207 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"

__declspec(dllimport)  int __cdecl feof(     FILE * _File);
__declspec(dllimport)  int __cdecl ferror(     FILE * _File);
__declspec(dllimport)  int __cdecl fflush(       FILE * _File);
__declspec(dllimport)  int __cdecl fgetc(     FILE * _File);
__declspec(dllimport)  int __cdecl _fgetchar(void);
__declspec(dllimport)  int __cdecl fgetpos(     FILE * _File ,      fpos_t * _Pos);
__declspec(dllimport)  char * __cdecl fgets(       char * _Buf,      int _MaxCount,      FILE * _File);




__declspec(dllimport)  int __cdecl _fileno(     FILE * _File);
#line 221 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"




#line 226 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"

__declspec(dllimport)  char * __cdecl _tempnam(         const char * _DirName,          const char * _FilePrefix);



#line 232 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"

__declspec(dllimport)  int __cdecl _flushall(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  FILE * __cdecl fopen(       const char * _Filename,        const char * _Mode);

__declspec(dllimport)  errno_t __cdecl fopen_s(                  FILE ** _File,        const char * _Filename,        const char * _Mode);
#line 238 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
__declspec(dllimport)  int __cdecl fprintf(     FILE * _File,         const char * _Format, ...);
__declspec(dllimport)  int __cdecl fprintf_s(     FILE * _File,         const char * _Format, ...);
__declspec(dllimport)  int __cdecl fputc(     int _Ch,      FILE * _File);
__declspec(dllimport)  int __cdecl _fputchar(     int _Ch);
__declspec(dllimport)  int __cdecl fputs(       const char * _Str,      FILE * _File);
__declspec(dllimport)  size_t __cdecl fread(     void * _DstBuf,      size_t _ElementSize,      size_t _Count,      FILE * _File);
__declspec(dllimport)  size_t __cdecl fread_s(     void * _DstBuf,      size_t _DstSize,      size_t _ElementSize,      size_t _Count,      FILE * _File);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  FILE * __cdecl freopen(       const char * _Filename,        const char * _Mode,      FILE * _File);

__declspec(dllimport)  errno_t __cdecl freopen_s(                  FILE ** _File,        const char * _Filename,        const char * _Mode,      FILE * _OldFile);
#line 249 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl fscanf(     FILE * _File,         const char * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _fscanf_l(     FILE * _File,         const char * _Format,        _locale_t _Locale, ...);

__declspec(dllimport)  int __cdecl fscanf_s(     FILE * _File,         const char * _Format, ...);
#line 254 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
__declspec(dllimport)  int __cdecl _fscanf_s_l(     FILE * _File,         const char * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl fsetpos(     FILE * _File,      const fpos_t * _Pos);
__declspec(dllimport)  int __cdecl fseek(     FILE * _File,      long _Offset,      int _Origin);
__declspec(dllimport)  long __cdecl ftell(     FILE * _File);

__declspec(dllimport)  int __cdecl _fseeki64(     FILE * _File,      __int64 _Offset,      int _Origin);
__declspec(dllimport)  __int64 __cdecl _ftelli64(     FILE * _File);

__declspec(dllimport)  size_t __cdecl fwrite(       const void * _Str,      size_t _Size,      size_t _Count,      FILE * _File);
__declspec(dllimport)  int __cdecl getc(     FILE * _File);
__declspec(dllimport)  int __cdecl getchar(void);
__declspec(dllimport)  int __cdecl _getmaxstdio(void);

__declspec(dllimport) char * __cdecl gets_s(       char * _Buf,      rsize_t _Size);
#line 269 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline char * __cdecl gets_s(     char (&_Buffer)[_Size]) { return gets_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "gets_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl gets( char *_Buffer);
 int __cdecl _getw(     FILE * _File);


__declspec(dllimport) void __cdecl perror(         const char * _ErrMsg);
#line 276 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
__declspec(dllimport)  int __cdecl _pclose(     FILE * _File);
__declspec(dllimport)  FILE * __cdecl _popen(       const char * _Command,        const char * _Mode);
__declspec(dllimport)  int __cdecl printf(        const char * _Format, ...);
__declspec(dllimport)  int __cdecl printf_s(        const char * _Format, ...);
__declspec(dllimport)  int __cdecl putc(     int _Ch,      FILE * _File);
__declspec(dllimport)  int __cdecl putchar(     int _Ch);
__declspec(dllimport)  int __cdecl puts(       const char * _Str);
__declspec(dllimport)  int __cdecl _putw(     int _Word,      FILE * _File);


__declspec(dllimport)  int __cdecl remove(       const char * _Filename);
__declspec(dllimport)  int __cdecl rename(       const char * _OldFilename,        const char * _NewFilename);
__declspec(dllimport)  int __cdecl _unlink(       const char * _Filename);

__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_unlink" ". See online help for details.")) __declspec(dllimport)  int __cdecl unlink(       const char * _Filename);
#line 292 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
#line 293 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
__declspec(dllimport) void __cdecl rewind(     FILE * _File);
__declspec(dllimport)  int __cdecl _rmtmp(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl scanf(        const char * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _scanf_l(        const char * _Format,        _locale_t _Locale, ...);

__declspec(dllimport)  int __cdecl scanf_s(        const char * _Format, ...);
#line 300 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
__declspec(dllimport)  int __cdecl _scanf_s_l(        const char * _Format,        _locale_t _Locale, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl setbuf(     FILE * _File,              char * _Buffer);
__declspec(dllimport)  int __cdecl _setmaxstdio(     int _Max);
__declspec(dllimport)  unsigned int __cdecl _set_output_format(     unsigned int _Format);
__declspec(dllimport)  unsigned int __cdecl _get_output_format(void);
__declspec(dllimport)  int __cdecl setvbuf(     FILE * _File,          char * _Buf,      int _Mode,      size_t _Size);
__declspec(dllimport)  int __cdecl _snprintf_s(       char * _DstBuf,      size_t _DstSize,      size_t _MaxCount,         const char * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snprintf_s(     char (&_Dest)[_Size],      size_t _Size,         const char * _Format, ...) { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return _vsnprintf_s(_Dest, _Size, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
__declspec(dllimport)  int __cdecl sprintf_s(       char * _DstBuf,      size_t _DstSize,         const char * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl sprintf_s(     char (&_Dest)[_Size],         const char * _Format, ...) { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return vsprintf_s(_Dest, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
__declspec(dllimport)  int __cdecl _scprintf(        const char * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl sscanf(       const char * _Src,         const char * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _sscanf_l(       const char * _Src,         const char * _Format,        _locale_t _Locale, ...);

__declspec(dllimport)  int __cdecl sscanf_s(       const char * _Src,         const char * _Format, ...);
#line 316 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
__declspec(dllimport)  int __cdecl _sscanf_s_l(       const char * _Src,         const char * _Format,        _locale_t _Locale, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _snscanf(         const char * _Src,      size_t _MaxCount,         const char * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _snscanf_l(         const char * _Src,      size_t _MaxCount,         const char * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _snscanf_s(         const char * _Src,      size_t _MaxCount,         const char * _Format, ...);
__declspec(dllimport)  int __cdecl _snscanf_s_l(         const char * _Src,      size_t _MaxCount,         const char * _Format,        _locale_t _Locale, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  FILE * __cdecl tmpfile(void);

__declspec(dllimport)  errno_t __cdecl tmpfile_s(                FILE ** _File);
__declspec(dllimport)  errno_t __cdecl tmpnam_s(       char * _Buf,      rsize_t _Size);
#line 326 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl tmpnam_s(       char (&_Buf)[_Size]) { return tmpnam_s(_Buf, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl tmpnam( char *_Buffer);
__declspec(dllimport)  int __cdecl ungetc(     int _Ch,      FILE * _File);
__declspec(dllimport)  int __cdecl vfprintf(     FILE * _File,         const char * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl vfprintf_s(     FILE * _File,         const char * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl vprintf(        const char * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl vprintf_s(        const char * _Format, va_list _ArgList);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl vsnprintf(     char * _DstBuf,      size_t _MaxCount,         const char * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl vsnprintf_s(       char * _DstBuf,      size_t _DstSize,      size_t _MaxCount,         const char * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vsnprintf_s(       char * _DstBuf,      size_t _DstSize,      size_t _MaxCount,         const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnprintf_s(     char (&_Dest)[_Size],      size_t _Size,         const char * _Format, va_list _Args) { return _vsnprintf_s(_Dest, _Size, _Size, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snprintf(     char *_Dest,      size_t _Count,         const char * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnprintf(     char *_Dest,      size_t _Count,         const char * _Format, va_list _Args);
#pragma warning(pop)
__declspec(dllimport) int __cdecl vsprintf_s(       char * _DstBuf,      size_t _Size,         const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vsprintf_s(     char (&_Dest)[_Size],         const char * _Format, va_list _Args) { return vsprintf_s(_Dest, _Size, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl sprintf( char *_Dest,  const char * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl vsprintf( char *_Dest,  const char * _Format, va_list _Args);
#pragma warning(pop)
__declspec(dllimport)  int __cdecl _vscprintf(        const char * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl _snprintf_c(     char * _DstBuf,      size_t _MaxCount,         const char * _Format, ...);
__declspec(dllimport)  int __cdecl _vsnprintf_c(     char *_DstBuf,      size_t _MaxCount,         const char * _Format, va_list _ArgList);

__declspec(dllimport)  int __cdecl _fprintf_p(     FILE * _File,         const char * _Format, ...);
__declspec(dllimport)  int __cdecl _printf_p(        const char * _Format, ...);
__declspec(dllimport)  int __cdecl _sprintf_p(       char * _Dst,      size_t _MaxCount,         const char * _Format, ...);
__declspec(dllimport)  int __cdecl _vfprintf_p(     FILE * _File,         const char * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vprintf_p(        const char * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vsprintf_p(       char * _Dst,      size_t _MaxCount,         const char * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl _scprintf_p(        const char * _Format, ...);
__declspec(dllimport)  int __cdecl _vscprintf_p(        const char * _Format, va_list _ArgList);
__declspec(dllimport) int __cdecl _set_printf_count_output(     int _Value);
__declspec(dllimport) int __cdecl _get_printf_count_output();

__declspec(dllimport)  int __cdecl _printf_l(        const char * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _printf_p_l(        const char * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _printf_s_l(        const char * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _vprintf_l(        const char * _Format,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vprintf_p_l(        const char * _Format,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vprintf_s_l(        const char * _Format,        _locale_t _Locale, va_list _ArgList);

__declspec(dllimport)  int __cdecl _fprintf_l(     FILE * _File,         const char * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _fprintf_p_l(     FILE * _File,         const char * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _fprintf_s_l(     FILE * _File,         const char * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _vfprintf_l(     FILE * _File,        const char * _Format,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vfprintf_p_l(     FILE * _File,        const char * _Format,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vfprintf_s_l(     FILE * _File,        const char * _Format,        _locale_t _Locale, va_list _ArgList);

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _sprintf_l(     char * _DstBuf,         const char * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _sprintf_p_l(       char * _DstBuf,      size_t _MaxCount,         const char * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _sprintf_s_l(       char * _DstBuf,      size_t _DstSize,         const char * _Format,        _locale_t _Locale, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _vsprintf_l(     char * _DstBuf,        const char * _Format,        _locale_t, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vsprintf_p_l(       char * _DstBuf,      size_t _MaxCount,         const char* _Format,        _locale_t _Locale,  va_list _ArgList);
__declspec(dllimport)  int __cdecl _vsprintf_s_l(       char * _DstBuf,      size_t _DstSize,         const char * _Format,        _locale_t _Locale, va_list _ArgList);

__declspec(dllimport)  int __cdecl _scprintf_l(        const char * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _scprintf_p_l(        const char * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _vscprintf_l(        const char * _Format,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vscprintf_p_l(        const char * _Format,        _locale_t _Locale, va_list _ArgList);

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _snprintf_l(     char * _DstBuf,      size_t _MaxCount,         const char * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _snprintf_c_l(     char * _DstBuf,      size_t _MaxCount,         const char * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _snprintf_s_l(       char * _DstBuf,      size_t _DstSize,      size_t _MaxCount,         const char * _Format,        _locale_t _Locale, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _vsnprintf_l(     char * _DstBuf,      size_t _MaxCount,         const char * _Format,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vsnprintf_c_l(     char * _DstBuf,      size_t _MaxCount, const char *,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vsnprintf_s_l(       char * _DstBuf,      size_t _DstSize,      size_t _MaxCount,         const char* _Format,       _locale_t _Locale, va_list _ArgList);







#line 402 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"




__declspec(dllimport)  FILE * __cdecl _wfsopen(       const wchar_t * _Filename,        const wchar_t * _Mode,      int _ShFlag);
#line 408 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"

__declspec(dllimport)  wint_t __cdecl fgetwc(     FILE * _File);
__declspec(dllimport)  wint_t __cdecl _fgetwchar(void);
__declspec(dllimport)  wint_t __cdecl fputwc(     wchar_t _Ch,      FILE * _File);
__declspec(dllimport)  wint_t __cdecl _fputwchar(     wchar_t _Ch);
__declspec(dllimport)  wint_t __cdecl getwc(     FILE * _File);
__declspec(dllimport)  wint_t __cdecl getwchar(void);
__declspec(dllimport)  wint_t __cdecl putwc(     wchar_t _Ch,      FILE * _File);
__declspec(dllimport)  wint_t __cdecl putwchar(     wchar_t _Ch);
__declspec(dllimport)  wint_t __cdecl ungetwc(     wint_t _Ch,      FILE * _File);

__declspec(dllimport)  wchar_t * __cdecl fgetws(       wchar_t * _Dst,      int _SizeInWords,      FILE * _File);
__declspec(dllimport)  int __cdecl fputws(       const wchar_t * _Str,      FILE * _File);
__declspec(dllimport)  wchar_t * __cdecl _getws_s(       wchar_t * _Str,      size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline wchar_t * __cdecl _getws_s(     wchar_t (&_String)[_Size]) { return _getws_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_getws_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _getws( wchar_t *_String);
__declspec(dllimport)  int __cdecl _putws(       const wchar_t * _Str);

__declspec(dllimport)  int __cdecl fwprintf(     FILE * _File,         const wchar_t * _Format, ...);
__declspec(dllimport)  int __cdecl fwprintf_s(     FILE * _File,         const wchar_t * _Format, ...);
__declspec(dllimport)  int __cdecl wprintf(        const wchar_t * _Format, ...);
__declspec(dllimport)  int __cdecl wprintf_s(        const wchar_t * _Format, ...);
__declspec(dllimport)  int __cdecl _scwprintf(        const wchar_t * _Format, ...);
__declspec(dllimport)  int __cdecl vfwprintf(     FILE * _File,         const wchar_t * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl vfwprintf_s(     FILE * _File,         const wchar_t * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl vwprintf(        const wchar_t * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl vwprintf_s(        const wchar_t * _Format, va_list _ArgList);

__declspec(dllimport) int __cdecl swprintf_s(       wchar_t * _Dst,      size_t _SizeInWords,         const wchar_t * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl swprintf_s(     wchar_t (&_Dest)[_Size],         const wchar_t * _Format, ...) { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return vswprintf_s(_Dest, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
__declspec(dllimport) int __cdecl vswprintf_s(       wchar_t * _Dst,      size_t _SizeInWords,         const wchar_t * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vswprintf_s(     wchar_t (&_Dest)[_Size],         const wchar_t * _Format, va_list _Args) { return vswprintf_s(_Dest, _Size, _Format, _Args); } }

__declspec(dllimport)  int __cdecl _swprintf_c(       wchar_t * _DstBuf,      size_t _SizeInWords,         const wchar_t * _Format, ...);
__declspec(dllimport)  int __cdecl _vswprintf_c(       wchar_t * _DstBuf,      size_t _SizeInWords,         const wchar_t * _Format, va_list _ArgList);

__declspec(dllimport)  int __cdecl _snwprintf_s(       wchar_t * _DstBuf,      size_t _DstSizeInWords,      size_t _MaxCount,         const wchar_t * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snwprintf_s(     wchar_t (&_Dest)[_Size],      size_t _Count,         const wchar_t * _Format, ...) { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _ArgList); } __pragma(warning(pop)); }
__declspec(dllimport)  int __cdecl _vsnwprintf_s(       wchar_t * _DstBuf,      size_t _DstSizeInWords,      size_t _MaxCount,         const wchar_t * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnwprintf_s(     wchar_t (&_Dest)[_Size],      size_t _Count,         const wchar_t * _Format, va_list _Args) { return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwprintf(     wchar_t *_Dest,      size_t _Count,         const wchar_t * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnwprintf(     wchar_t *_Dest,      size_t _Count,         const wchar_t * _Format, va_list _Args);
#pragma warning(pop)

__declspec(dllimport)  int __cdecl _fwprintf_p(     FILE * _File,         const wchar_t * _Format, ...);
__declspec(dllimport)  int __cdecl _wprintf_p(        const wchar_t * _Format, ...);
__declspec(dllimport)  int __cdecl _vfwprintf_p(     FILE * _File,         const wchar_t * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vwprintf_p(        const wchar_t * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl _swprintf_p(       wchar_t * _DstBuf,      size_t _MaxCount,         const wchar_t * _Format, ...);
__declspec(dllimport)  int __cdecl _vswprintf_p(       wchar_t * _DstBuf,      size_t _MaxCount,         const wchar_t * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl _scwprintf_p(        const wchar_t * _Format, ...);
__declspec(dllimport)  int __cdecl _vscwprintf_p(        const wchar_t * _Format, va_list _ArgList);

__declspec(dllimport)  int __cdecl _wprintf_l(        const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _wprintf_p_l(        const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _wprintf_s_l(        const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _vwprintf_l(        const wchar_t * _Format,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vwprintf_p_l(        const wchar_t * _Format,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vwprintf_s_l(        const wchar_t * _Format,        _locale_t _Locale, va_list _ArgList);

__declspec(dllimport)  int __cdecl _fwprintf_l(     FILE * _File,         const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _fwprintf_p_l(     FILE * _File,         const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _fwprintf_s_l(     FILE * _File,         const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _vfwprintf_l(     FILE * _File,         const wchar_t * _Format,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vfwprintf_p_l(     FILE * _File,         const wchar_t * _Format,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vfwprintf_s_l(     FILE * _File,         const wchar_t * _Format,        _locale_t _Locale, va_list _ArgList);

__declspec(dllimport)  int __cdecl _swprintf_c_l(       wchar_t * _DstBuf,      size_t _MaxCount,         const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _swprintf_p_l(       wchar_t * _DstBuf,      size_t _MaxCount,         const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _swprintf_s_l(       wchar_t * _DstBuf,      size_t _DstSize,         const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _vswprintf_c_l(       wchar_t * _DstBuf,      size_t _MaxCount,         const wchar_t * _Format,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vswprintf_p_l(       wchar_t * _DstBuf,      size_t _MaxCount,         const wchar_t * _Format,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vswprintf_s_l(       wchar_t * _DstBuf,      size_t _DstSize,         const wchar_t * _Format,        _locale_t _Locale, va_list _ArgList);

__declspec(dllimport)  int __cdecl _scwprintf_l(        const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _scwprintf_p_l(        const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _vscwprintf_p_l(        const wchar_t * _Format,        _locale_t _Locale, va_list _ArgList);

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _snwprintf_l(     wchar_t * _DstBuf,      size_t _MaxCount,         const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _snwprintf_s_l(       wchar_t * _DstBuf,      size_t _DstSize,      size_t _MaxCount,         const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _vsnwprintf_l(     wchar_t * _DstBuf,      size_t _MaxCount,         const wchar_t * _Format,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vsnwprintf_s_l(       wchar_t * _DstBuf,      size_t _DstSize,      size_t _MaxCount,         const wchar_t * _Format,        _locale_t _Locale, va_list _ArgList);










#line 502 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"


#pragma warning(push)
#pragma warning(disable:4141 4996 4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _swprintf(     wchar_t *_Dest,         const wchar_t * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _vswprintf(     wchar_t *_Dest,         const wchar_t * _Format, va_list _Args);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __swprintf_l(     wchar_t *_Dest,         const wchar_t * _Format, _locale_t _Plocinfo, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __vswprintf_l(     wchar_t *_Dest,         const wchar_t * _Format, _locale_t _Plocinfo, va_list _Args);
#pragma warning(pop)


#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\swprintf.inl"












#pragma once







#line 22 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\swprintf.inl"










#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\swprintf.inl"

#pragma warning( push )
#pragma warning( disable : 4793 4412 )
static __inline int swprintf(wchar_t * _String, size_t _Count, const wchar_t * _Format, ...)
{
    va_list _Arglist;
    int _Ret;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    _Ret = _vswprintf_c_l(_String, _Count, _Format, 0, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
static __inline int __cdecl vswprintf(wchar_t * _String, size_t _Count, const wchar_t * _Format, va_list _Ap)
{
    return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap);
}
#pragma warning( pop )


#line 57 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\swprintf.inl"

#pragma warning( push )
#pragma warning( disable : 4793 4412 )
static __inline int _swprintf_l(wchar_t * _String, size_t _Count, const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
    va_list _Arglist;
    int _Ret;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Plocinfo) ) + ( (sizeof(_Plocinfo) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    _Ret = _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
static __inline int __cdecl _vswprintf_l(wchar_t * _String, size_t _Count, const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
    return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap);
}
#pragma warning( pop )


#pragma warning( push )
#pragma warning( disable : 4996 )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int swprintf(     wchar_t * _String,         const wchar_t * _Format, ...)
{
    va_list _Arglist;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    int _Ret = _vswprintf(_String, _Format, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int __cdecl vswprintf(     wchar_t * _String,         const wchar_t * _Format, va_list _Ap)
{
    return _vswprintf(_String, _Format, _Ap);
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int _swprintf_l(     wchar_t * _String,         const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
    va_list _Arglist;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Plocinfo) ) + ( (sizeof(_Plocinfo) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    int _Ret = __vswprintf_l(_String, _Format, _Plocinfo, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int __cdecl _vswprintf_l(     wchar_t * _String,         const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
    return __vswprintf_l(_String, _Format, _Plocinfo, _Ap);
}
#pragma warning( pop )

#pragma warning( pop )

#line 126 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\swprintf.inl"

#line 128 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\swprintf.inl"
#line 129 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\swprintf.inl"

#line 512 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
#line 513 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"













#line 527 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"

__declspec(dllimport)  wchar_t * __cdecl _wtempnam(         const wchar_t * _Directory,          const wchar_t * _FilePrefix);



#line 533 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"

__declspec(dllimport)  int __cdecl _vscwprintf(        const wchar_t * _Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vscwprintf_l(        const wchar_t * _Format,        _locale_t _Locale, va_list _ArgList);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl fwscanf(     FILE * _File,         const wchar_t * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _fwscanf_l(     FILE * _File,         const wchar_t * _Format,        _locale_t _Locale, ...);

__declspec(dllimport)  int __cdecl fwscanf_s(     FILE * _File,         const wchar_t * _Format, ...);
#line 541 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
__declspec(dllimport)  int __cdecl _fwscanf_s_l(     FILE * _File,         const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl swscanf(       const wchar_t * _Src,         const wchar_t * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _swscanf_l(       const wchar_t * _Src,         const wchar_t * _Format,        _locale_t _Locale, ...);

__declspec(dllimport)  int __cdecl swscanf_s(       const wchar_t *_Src,         const wchar_t * _Format, ...);
#line 547 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
__declspec(dllimport)  int __cdecl _swscanf_s_l(       const wchar_t * _Src,         const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _snwscanf(         const wchar_t * _Src,      size_t _MaxCount,         const wchar_t * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _snwscanf_l(         const wchar_t * _Src,      size_t _MaxCount,         const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _snwscanf_s(         const wchar_t * _Src,      size_t _MaxCount,         const wchar_t * _Format, ...);
__declspec(dllimport)  int __cdecl _snwscanf_s_l(         const wchar_t * _Src,      size_t _MaxCount,         const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl wscanf(        const wchar_t * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _wscanf_l(        const wchar_t * _Format,        _locale_t _Locale, ...);

__declspec(dllimport)  int __cdecl wscanf_s(        const wchar_t * _Format, ...);
#line 557 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
__declspec(dllimport)  int __cdecl _wscanf_s_l(        const wchar_t * _Format,        _locale_t _Locale, ...);

__declspec(dllimport)  FILE * __cdecl _wfdopen(     int _FileHandle ,        const wchar_t * _Mode);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  FILE * __cdecl _wfopen(       const wchar_t * _Filename,        const wchar_t * _Mode);
__declspec(dllimport)  errno_t __cdecl _wfopen_s(                  FILE ** _File,        const wchar_t * _Filename,        const wchar_t * _Mode);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  FILE * __cdecl _wfreopen(       const wchar_t * _Filename,        const wchar_t * _Mode,      FILE * _OldFile);
__declspec(dllimport)  errno_t __cdecl _wfreopen_s(                  FILE ** _File,        const wchar_t * _Filename,        const wchar_t * _Mode,      FILE * _OldFile);



__declspec(dllimport) void __cdecl _wperror(         const wchar_t * _ErrMsg);
#line 569 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
__declspec(dllimport)  FILE * __cdecl _wpopen(       const wchar_t *_Command,        const wchar_t * _Mode);
__declspec(dllimport)  int __cdecl _wremove(       const wchar_t * _Filename);
__declspec(dllimport)  errno_t __cdecl _wtmpnam_s(       wchar_t * _DstBuf,      size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(       wchar_t (&_Buffer)[_Size]) { return _wtmpnam_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wtmpnam( wchar_t *_Buffer);

__declspec(dllimport)  wint_t __cdecl _fgetwc_nolock(     FILE * _File);
__declspec(dllimport)  wint_t __cdecl _fputwc_nolock(     wchar_t _Ch,      FILE * _File);
__declspec(dllimport)  wint_t __cdecl _ungetwc_nolock(     wint_t _Ch,      FILE * _File);






#line 585 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"
inline wint_t __cdecl getwchar()
        {return (fgetwc((&__iob_func()[0]))); }   
inline wint_t __cdecl putwchar(wchar_t _C)
        {return (fputwc(_C, (&__iob_func()[1]))); }       
#line 590 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"










#line 601 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"


#line 604 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"


#line 607 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"















#line 623 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"












__declspec(dllimport) void __cdecl _lock_file(     FILE * _File);
__declspec(dllimport) void __cdecl _unlock_file(     FILE * _File);



#line 641 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"


__declspec(dllimport)  int __cdecl _fclose_nolock(     FILE * _File);
__declspec(dllimport)  int __cdecl _fflush_nolock(       FILE * _File);
__declspec(dllimport)  size_t __cdecl _fread_nolock(     void * _DstBuf,      size_t _ElementSize,      size_t _Count,      FILE * _File);
__declspec(dllimport)  size_t __cdecl _fread_nolock_s(     void * _DstBuf,      size_t _DstSize,      size_t _ElementSize,      size_t _Count,      FILE * _File);
__declspec(dllimport)  int __cdecl _fseek_nolock(     FILE * _File,      long _Offset,      int _Origin);
__declspec(dllimport)  long __cdecl _ftell_nolock(     FILE * _File);
__declspec(dllimport)  int __cdecl _fseeki64_nolock(     FILE * _File,      __int64 _Offset,      int _Origin);
__declspec(dllimport)  __int64 __cdecl _ftelli64_nolock(     FILE * _File);
__declspec(dllimport)  size_t __cdecl _fwrite_nolock(       const void * _DstBuf,      size_t _Size,      size_t _Count,      FILE * _File);
__declspec(dllimport)  int __cdecl _ungetc_nolock(     int _Ch,      FILE * _File);












#line 666 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"











#line 678 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"

__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_tempnam" ". See online help for details.")) __declspec(dllimport) char * __cdecl tempnam(         const char * _Directory,          const char * _FilePrefix);



#line 684 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"

__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport)  int __cdecl fcloseall(void);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fdopen" ". See online help for details.")) __declspec(dllimport)  FILE * __cdecl fdopen(     int _FileHandle,         const char * _Format);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fgetchar" ". See online help for details.")) __declspec(dllimport)  int __cdecl fgetchar(void);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fileno" ". See online help for details.")) __declspec(dllimport)  int __cdecl fileno(     FILE * _File);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_flushall" ". See online help for details.")) __declspec(dllimport)  int __cdecl flushall(void);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fputchar" ". See online help for details.")) __declspec(dllimport)  int __cdecl fputchar(     int _Ch);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_getw" ". See online help for details.")) __declspec(dllimport)  int __cdecl getw(     FILE * _File);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_putw" ". See online help for details.")) __declspec(dllimport)  int __cdecl putw(     int _Ch,      FILE * _File);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_rmtmp" ". See online help for details.")) __declspec(dllimport)  int __cdecl rmtmp(void);

#line 696 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"


}
#line 700 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"


#pragma pack(pop)
#line 704 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"

#line 706 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdio.h"

#line 14 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstdio"
#line 15 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstdio"

 

 
 
 


 
namespace std {
using ::size_t; using ::fpos_t; using ::FILE;
using ::clearerr; using ::fclose; using ::feof;
using ::ferror; using ::fflush; using ::fgetc;
using ::fgetpos; using ::fgets; using ::fopen;
using ::fprintf; using ::fputc; using ::fputs;
using ::fread; using ::freopen; using ::fscanf;
using ::fseek; using ::fsetpos; using ::ftell;
using ::fwrite; using ::getc; using ::getchar;
using ::gets; using ::perror;
using ::putc; using ::putchar;
using ::printf; using ::puts; using ::remove;
using ::rename; using ::rewind; using ::scanf;
using ::setbuf; using ::setvbuf; using ::sprintf;
using ::sscanf; using ::tmpfile; using ::tmpnam;
using ::ungetc; using ::vfprintf; using ::vprintf;
using ::vsprintf;
}
 #line 43 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstdio"
#line 44 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstdio"









#line 54 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstdio"





#line 8 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstdlib"

#pragma once










 #line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
















#pragma once
#line 19 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"




#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 24 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"







#pragma pack(push,8)
#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"


extern "C" {
#line 37 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"



















typedef int (__cdecl * _onexit_t)(void);



#line 61 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"



#line 65 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"




#line 70 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"


#line 73 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"






typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;


#line 91 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"










#pragma pack(4)
typedef struct {
    unsigned char ld[10];
} _LDOUBLE;
#pragma pack()













#line 120 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

typedef struct {
        double x;
} _CRT_DOUBLE;

typedef struct {
    float f;
} _CRT_FLOAT;





typedef struct {
        


        long double x;
} _LONGDOUBLE;



#pragma pack(4)
typedef struct {
    unsigned char ld12[12];
} _LDBL12;
#pragma pack()


#line 150 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"














#line 165 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

__declspec(dllimport) extern int __mb_cur_max;



#line 171 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
__declspec(dllimport) int __cdecl ___mb_cur_max_func(void);
__declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t);
#line 174 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"





































typedef void (__cdecl *_purecall_handler)(void); 


__declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler(       _purecall_handler _Handler);
__declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler();
#line 217 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"


extern "C++"
{




#line 226 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"







#line 234 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
}
#line 236 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"



typedef void (__cdecl *_invalid_parameter_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); 


__declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(       _invalid_parameter_handler _Handler);
__declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);
#line 245 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"


extern "C++"
{




#line 254 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"






#line 261 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
}
#line 263 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"




__declspec(dllimport) extern int * __cdecl _errno(void);


errno_t __cdecl _set_errno(     int _Value);
errno_t __cdecl _get_errno(     int * _Value);
#line 273 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

__declspec(dllimport) unsigned long * __cdecl __doserrno(void);


errno_t __cdecl _set_doserrno(     unsigned long _Value);
errno_t __cdecl _get_doserrno(     unsigned long * _Value);


__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char ** __cdecl __sys_errlist(void);


__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int * __cdecl __sys_nerr(void);




__declspec(dllimport) int *          __cdecl __p___argc(void);
__declspec(dllimport) char ***       __cdecl __p___argv(void);
__declspec(dllimport) wchar_t ***    __cdecl __p___wargv(void);
__declspec(dllimport) char ***       __cdecl __p__environ(void);
__declspec(dllimport) wchar_t ***    __cdecl __p__wenviron(void);
__declspec(dllimport) char **        __cdecl __p__pgmptr(void);
__declspec(dllimport) wchar_t **     __cdecl __p__wpgmptr(void);


#line 299 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"


__declspec(dllimport) extern int __argc;          
__declspec(dllimport) extern char ** __argv;      
__declspec(dllimport) extern wchar_t ** __wargv;  







#line 312 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"





__declspec(dllimport) extern char ** _environ;    
__declspec(dllimport) extern wchar_t ** _wenviron;    
#line 320 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern char * _pgmptr;      
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern wchar_t * _wpgmptr;  














#line 338 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

errno_t __cdecl _get_pgmptr(       char ** _Value);
errno_t __cdecl _get_wpgmptr(       wchar_t ** _Value);



__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern int _fmode;          



#line 349 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

__declspec(dllimport) errno_t __cdecl _set_fmode(     int _Mode);
__declspec(dllimport) errno_t __cdecl _get_fmode(     int * _PMode);



#pragma warning(push)
#pragma warning(disable:4141)


__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_osplatform" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "GetVersionEx" " instead. See online help for details."))	__declspec(dllimport) extern unsigned int _osplatform;
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_osver" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "GetVersionEx" " instead. See online help for details."))			__declspec(dllimport) extern unsigned int _osver;
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_winver" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "GetVersionEx" " instead. See online help for details."))		__declspec(dllimport) extern unsigned int _winver;
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_winmajor" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "GetVersionEx" " instead. See online help for details."))		__declspec(dllimport) extern unsigned int _winmajor;
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_winminor" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "GetVersionEx" " instead. See online help for details."))		__declspec(dllimport) extern unsigned int _winminor;














#line 379 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

#pragma warning(pop)

__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "GetVersionEx" " instead. See online help for details.")) errno_t __cdecl _get_osplatform(     unsigned int * _Value);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "GetVersionEx" " instead. See online help for details.")) errno_t __cdecl _get_osver(     unsigned int * _Value);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "GetVersionEx" " instead. See online help for details.")) errno_t __cdecl _get_winver(     unsigned int * _Value);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "GetVersionEx" " instead. See online help for details.")) errno_t __cdecl _get_winmajor(     unsigned int * _Value);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "GetVersionEx" " instead. See online help for details.")) errno_t __cdecl _get_winminor(     unsigned int * _Value);





#line 393 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
extern "C++"
{
template <typename _CountofType, size_t _SizeOfArray>
char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

}
#line 400 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
#line 401 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"





__declspec(dllimport) __declspec(noreturn) void __cdecl exit(     int _Code);
__declspec(dllimport) __declspec(noreturn) void __cdecl _exit(     int _Code);
__declspec(dllimport) void __cdecl abort(void);
#line 410 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(     unsigned int _Flags,      unsigned int _Mask);



        int     __cdecl abs(     int _X);
        long    __cdecl labs(     long _X);
#line 418 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"


        __int64    __cdecl _abs64(__int64);
#line 422 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"










#line 433 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"












#line 446 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
        int    __cdecl atexit(void (__cdecl *)(void));
#line 448 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"


__declspec(dllimport)  double  __cdecl atof(       const char *_String);
__declspec(dllimport)  double  __cdecl _atof_l(       const char *_String,        _locale_t _Locale);
#line 453 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
__declspec(dllimport)   int    __cdecl atoi(       const char *_Str);
__declspec(dllimport)  int    __cdecl _atoi_l(       const char *_Str,        _locale_t _Locale);
__declspec(dllimport)  long   __cdecl atol(       const char *_Str);
__declspec(dllimport)  long   __cdecl _atol_l(       const char *_Str,        _locale_t _Locale);



__declspec(dllimport)  void * __cdecl bsearch_s(     const void * _Key,        const void * _Base, 
             rsize_t _NumOfElements,      rsize_t _SizeOfElements,
             int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
#line 464 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
__declspec(dllimport)  void * __cdecl bsearch(     const void * _Key,        const void * _Base, 
             size_t _NumOfElements,      size_t _SizeOfElements,
             int (__cdecl * _PtFuncCompare)(const void *, const void *));


__declspec(dllimport) void __cdecl qsort_s(       void * _Base, 
             rsize_t _NumOfElements,      rsize_t _SizeOfElements,
             int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void *_Context);
#line 473 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
__declspec(dllimport) void __cdecl qsort(       void * _Base, 
	     size_t _NumOfElements,      size_t _SizeOfElements, 
             int (__cdecl * _PtFuncCompare)(const void *, const void *));
#line 477 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
         unsigned short __cdecl _byteswap_ushort(     unsigned short _Short);
         unsigned long  __cdecl _byteswap_ulong (     unsigned long _Long);

         unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64 _Int64);
#line 482 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
__declspec(dllimport)  div_t  __cdecl div(     int _Numerator,      int _Denominator);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  char * __cdecl getenv(       const char * _VarName);

__declspec(dllimport)  errno_t __cdecl getenv_s(     size_t * _ReturnSize,        char * _DstBuf,      rsize_t _DstSize,        const char * _VarName);
#line 487 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(     size_t * _ReturnSize,      char (&_Dest)[_Size],        const char * _VarName) { return getenv_s(_ReturnSize, _Dest, _Size, _VarName); } }



#line 492 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

__declspec(dllimport)  errno_t __cdecl _dupenv_s(                     char **_PBuffer,        size_t * _PBufferSizeInBytes,        const char * _VarName);



#line 498 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

__declspec(dllimport)  errno_t __cdecl _itoa_s(     int _Value,        char * _DstBuf,      size_t _Size,      int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itoa_s(     int _Value,      char (&_Dest)[_Size],      int _Radix) { return _itoa_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _itoa( int _Value,  char *_Dest,  int _Radix);

__declspec(dllimport)  errno_t __cdecl _i64toa_s(     __int64 _Val,        char * _DstBuf,      size_t _Size,      int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _i64toa(     __int64 _Val,      char * _DstBuf,      int _Radix);
__declspec(dllimport)  errno_t __cdecl _ui64toa_s(     unsigned __int64 _Val,        char * _DstBuf,      size_t _Size,      int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _ui64toa(     unsigned __int64 _Val,      char * _DstBuf,      int _Radix);
__declspec(dllimport)  __int64 __cdecl _atoi64(       const char * _String);
__declspec(dllimport)  __int64 __cdecl _atoi64_l(       const char * _String,        _locale_t _Locale);
__declspec(dllimport)  __int64 __cdecl _strtoi64(       const char * _String,                    char ** _EndPtr,      int _Radix);
__declspec(dllimport)  __int64 __cdecl _strtoi64_l(       const char * _String,                    char ** _EndPtr,      int _Radix,        _locale_t _Locale);
__declspec(dllimport)  unsigned __int64 __cdecl _strtoui64(       const char * _String,                    char ** _EndPtr,      int _Radix);
__declspec(dllimport)  unsigned __int64 __cdecl _strtoui64_l(       const char * _String,                    char ** _EndPtr,      int  _Radix,        _locale_t _Locale);
#line 514 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
__declspec(dllimport)  ldiv_t __cdecl ldiv(     long _Numerator,      long _Denominator);

extern "C++"
{
    inline ldiv_t  div(     long _A1,      long _A2)
    {
        return ldiv(_A1, _A2);
    }
}
#line 524 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
__declspec(dllimport)  errno_t __cdecl _ltoa_s(     long _Val,        char * _DstBuf,      size_t _Size,      int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(     long _Value,      char (&_Dest)[_Size],      int _Radix) { return _ltoa_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _ltoa( long _Value,  char *_Dest,  int _Radix);
__declspec(dllimport)  int    __cdecl mblen(           const char * _Ch,      size_t _MaxCount);
__declspec(dllimport)  int    __cdecl _mblen_l(           const char * _Ch,      size_t _MaxCount,        _locale_t _Locale);
__declspec(dllimport)  size_t __cdecl _mbstrlen(       const char * _Str);
__declspec(dllimport)  size_t __cdecl _mbstrlen_l(       const char *_Str,        _locale_t _Locale);
__declspec(dllimport)  size_t __cdecl _mbstrnlen(       const char *_Str,      size_t _MaxCount);
__declspec(dllimport)  size_t __cdecl _mbstrnlen_l(       const char *_Str,      size_t _MaxCount,        _locale_t _Locale);
__declspec(dllimport) int    __cdecl mbtowc(     wchar_t * _DstCh,            const char * _SrcCh,      size_t _SrcSizeInBytes);
__declspec(dllimport) int    __cdecl _mbtowc_l(     wchar_t * _DstCh,            const char * _SrcCh,      size_t _SrcSizeInBytes,        _locale_t _Locale);
__declspec(dllimport)  errno_t __cdecl mbstowcs_s(       size_t * _PtNumOfCharConverted,          wchar_t * _DstBuf,      size_t _SizeInWords,          const char * _SrcBuf,      size_t _MaxCount );
extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(       size_t * _PtNumOfCharConverted,        wchar_t (&_Dest)[_Size],        const char * _Source,      size_t _MaxCount) { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest,  const char * _Source,  size_t _MaxCount);

__declspec(dllimport)  errno_t __cdecl _mbstowcs_s_l(       size_t * _PtNumOfCharConverted,          wchar_t * _DstBuf,      size_t _SizeInWords,          const char * _SrcBuf,      size_t _MaxCount,        _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(       size_t * _PtNumOfCharConverted,      wchar_t (&_Dest)[_Size],        const char * _Source,      size_t _MaxCount,        _locale_t _Locale) { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l(       wchar_t *_Dest,        const char * _Source,      size_t _MaxCount,        _locale_t _Locale);

__declspec(dllimport)  int    __cdecl rand(void);


#line 547 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

__declspec(dllimport)  int    __cdecl _set_error_mode(     int _Mode);

__declspec(dllimport) void   __cdecl srand(     unsigned int _Seed);
__declspec(dllimport)  double __cdecl strtod(       const char * _Str,                    char ** _EndPtr);
__declspec(dllimport)  double __cdecl _strtod_l(       const char * _Str,                    char ** _EndPtr,        _locale_t _Locale);
__declspec(dllimport)  long   __cdecl strtol(       const char * _Str,                    char ** _EndPtr,      int _Radix );
__declspec(dllimport)  long   __cdecl _strtol_l(       const char *_Str,                    char **_EndPtr,      int _Radix,        _locale_t _Locale);
__declspec(dllimport)  unsigned long __cdecl strtoul(       const char * _Str,                    char ** _EndPtr,      int _Radix);
__declspec(dllimport)  unsigned long __cdecl _strtoul_l(const char * _Str,                    char **_EndPtr,      int _Radix,        _locale_t _Locale);


__declspec(dllimport) int __cdecl system(         const char * _Command);
#line 561 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
__declspec(dllimport)  errno_t __cdecl _ultoa_s(     unsigned long _Val,        char * _DstBuf,      size_t _Size,      int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(     unsigned long _Value,      char (&_Dest)[_Size],      int _Radix) { return _ultoa_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _ultoa( unsigned long _Value,  char *_Dest,  int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int    __cdecl wctomb(         char * _MbCh,        wchar_t _WCh);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int    __cdecl _wctomb_l(       char * _MbCh,      wchar_t _WCh,        _locale_t _Locale);

__declspec(dllimport)  errno_t __cdecl wctomb_s(       int * _SizeConverted,          char * _MbCh,      rsize_t _SizeInBytes,      wchar_t _WCh);
#line 569 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
__declspec(dllimport)  errno_t __cdecl _wctomb_s_l(       int * _SizeConverted,          char * _MbCh,      size_t _SizeInBytes,      wchar_t _WCh,        _locale_t _Locale);
__declspec(dllimport)  errno_t __cdecl wcstombs_s(       size_t * _PtNumOfCharConverted,          char * _Dst,      size_t _DstSizeInBytes,        const wchar_t * _Src,      size_t _MaxCountInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(       size_t * _PtNumOfCharConverted,        char (&_Dest)[_Size],        const wchar_t * _Source,      size_t _MaxCount) { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest,  const wchar_t * _Source,  size_t _MaxCount);
__declspec(dllimport)  errno_t __cdecl _wcstombs_s_l(       size_t * _PtNumOfCharConverted,          char * _Dst,      size_t _DstSizeInBytes,        const wchar_t * _Src,      size_t _MaxCountInBytes,        _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(       size_t * _PtNumOfCharConverted,        char (&_Dest)[_Size],        const wchar_t * _Source,      size_t _MaxCount,        _locale_t _Locale) { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l(       char *_Dest,        const wchar_t * _Source,      size_t _MaxCount,        _locale_t _Locale);






















#line 599 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"


































#line 634 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
__declspec(dllimport)   __declspec(noalias) __declspec(restrict)         void * __cdecl calloc(     size_t _NumOfElements,      size_t _SizeOfElements);
__declspec(dllimport)                     __declspec(noalias)                                                                             void   __cdecl free(       void * _Memory);
__declspec(dllimport)   __declspec(noalias) __declspec(restrict)                                   void * __cdecl malloc(     size_t _Size);
__declspec(dllimport)                     __declspec(noalias) __declspec(restrict)                                void * __cdecl realloc(       void * _Memory,      size_t _NewSize);
__declspec(dllimport)                     __declspec(noalias) __declspec(restrict)                            void * __cdecl _recalloc(       void * _Memory,      size_t _Count,      size_t _Size);
__declspec(dllimport)                     __declspec(noalias)                                                                             void   __cdecl _aligned_free(       void * _Memory);
__declspec(dllimport)                     __declspec(noalias) __declspec(restrict)                                   void * __cdecl _aligned_malloc(     size_t _Size,      size_t _Alignment);
__declspec(dllimport)                     __declspec(noalias) __declspec(restrict)                                   void * __cdecl _aligned_offset_malloc(     size_t _Size,      size_t _Alignment,      size_t _Offset);
__declspec(dllimport)                     __declspec(noalias) __declspec(restrict)                                   void * __cdecl _aligned_realloc(       void * _Memory,      size_t _Size,      size_t _Alignment);
__declspec(dllimport)                     __declspec(noalias) __declspec(restrict)                            void * __cdecl _aligned_recalloc(       void * _Memory,      size_t _Count,      size_t _Size,      size_t _Alignment);
__declspec(dllimport)                     __declspec(noalias) __declspec(restrict)                                   void * __cdecl _aligned_offset_realloc(       void * _Memory,      size_t _Size,      size_t _Alignment,      size_t _Offset);
__declspec(dllimport)                     __declspec(noalias) __declspec(restrict)                            void * __cdecl _aligned_offset_recalloc(       void * _Memory,      size_t _Count,      size_t _Size,      size_t _Alignment,      size_t _Offset);
__declspec(dllimport)                                                                                                size_t __cdecl _aligned_msize(     void * _Memory,      size_t _Alignment,      size_t _Offset);


















#line 666 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

#line 668 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"





__declspec(dllimport)  errno_t __cdecl _itow_s (     int _Val,        wchar_t * _DstBuf,      size_t _SizeInWords,      int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(     int _Value,      wchar_t (&_Dest)[_Size],      int _Radix) { return _itow_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _itow( int _Value,  wchar_t *_Dest,  int _Radix);
__declspec(dllimport)  errno_t __cdecl _ltow_s (     long _Val,        wchar_t * _DstBuf,      size_t _SizeInWords,      int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(     long _Value,      wchar_t (&_Dest)[_Size],      int _Radix) { return _ltow_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _ltow( long _Value,  wchar_t *_Dest,  int _Radix);
__declspec(dllimport)  errno_t __cdecl _ultow_s (     unsigned long _Val,        wchar_t * _DstBuf,      size_t _SizeInWords,      int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(     unsigned long _Value,      wchar_t (&_Dest)[_Size],      int _Radix) { return _ultow_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _ultow( unsigned long _Value,  wchar_t *_Dest,  int _Radix);
__declspec(dllimport)  double __cdecl wcstod(       const wchar_t * _Str,                    wchar_t ** _EndPtr);
__declspec(dllimport)  double __cdecl _wcstod_l(       const wchar_t *_Str,                    wchar_t ** _EndPtr,        _locale_t _Locale);
__declspec(dllimport)  long   __cdecl wcstol(       const wchar_t *_Str,                    wchar_t ** _EndPtr, int _Radix);
__declspec(dllimport)  long   __cdecl _wcstol_l(       const wchar_t *_Str,                    wchar_t **_EndPtr, int _Radix,        _locale_t _Locale);
__declspec(dllimport)  unsigned long __cdecl wcstoul(       const wchar_t *_Str,                    wchar_t ** _EndPtr, int _Radix);
__declspec(dllimport)  unsigned long __cdecl _wcstoul_l(       const wchar_t *_Str,                    wchar_t **_EndPtr, int _Radix,        _locale_t _Locale);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  wchar_t * __cdecl _wgetenv(       const wchar_t * _VarName);
__declspec(dllimport)  errno_t __cdecl _wgetenv_s(     size_t * _ReturnSize,        wchar_t * _DstBuf,      size_t _DstSizeInWords,        const wchar_t * _VarName);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wgetenv_s(     size_t * _ReturnSize,      wchar_t (&_Dest)[_Size],        const wchar_t * _VarName) { return _wgetenv_s(_ReturnSize, _Dest, _Size, _VarName); } }




#line 696 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

__declspec(dllimport)  errno_t __cdecl _wdupenv_s(                     wchar_t **_Buffer,        size_t *_BufferSizeInWords,        const wchar_t *_VarName);



#line 702 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"



__declspec(dllimport) int __cdecl _wsystem(         const wchar_t * _Command);
#line 707 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
__declspec(dllimport)  double __cdecl _wtof(       const wchar_t *_Str);
__declspec(dllimport)  double __cdecl _wtof_l(       const wchar_t *_Str,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl _wtoi(       const wchar_t *_Str);
__declspec(dllimport)  int __cdecl _wtoi_l(       const wchar_t *_Str,        _locale_t _Locale);
__declspec(dllimport)  long __cdecl _wtol(       const wchar_t *_Str);
__declspec(dllimport)  long __cdecl _wtol_l(       const wchar_t *_Str,        _locale_t _Locale);


__declspec(dllimport)  errno_t __cdecl _i64tow_s(     __int64 _Val,        wchar_t * _DstBuf,      size_t _SizeInWords,      int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i65tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) wchar_t * __cdecl _i64tow(     __int64 _Val,      wchar_t * _DstBuf,      int _Radix);
__declspec(dllimport)  errno_t __cdecl _ui64tow_s(     unsigned __int64 _Val,        wchar_t * _DstBuf,      size_t _SizeInWords,      int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) wchar_t * __cdecl _ui64tow(     unsigned __int64 _Val,      wchar_t * _DstBuf,      int _Radix);
__declspec(dllimport)  __int64   __cdecl _wtoi64(       const wchar_t *_Str);
__declspec(dllimport)  __int64   __cdecl _wtoi64_l(       const wchar_t *_Str,        _locale_t _Locale);
__declspec(dllimport)  __int64   __cdecl _wcstoi64(       const wchar_t * _Str,                    wchar_t ** _EndPtr,      int _Radix);
__declspec(dllimport)  __int64   __cdecl _wcstoi64_l(       const wchar_t * _Str,                    wchar_t ** _EndPtr,      int _Radix,        _locale_t _Locale);
__declspec(dllimport)  unsigned __int64  __cdecl _wcstoui64(       const wchar_t * _Str,                    wchar_t ** _EndPtr,      int _Radix);
__declspec(dllimport)  unsigned __int64  __cdecl _wcstoui64_l(       const wchar_t *_Str ,                    wchar_t ** _EndPtr,      int _Radix,        _locale_t _Locale);
#line 726 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"


#line 729 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"














#line 744 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

__declspec(dllimport)  char * __cdecl _fullpath(         char * _FullPath,        const char * _Path,      size_t _SizeInBytes);





#line 752 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

__declspec(dllimport)  errno_t __cdecl _ecvt_s(       char * _DstBuf,      size_t _Size,      double _Val,      int _NumOfDights,      int * _PtDec,      int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(     char (&_Dest)[_Size],      double _Value,      int _NumOfDigits,      int * _PtDec,      int * _PtSign) { return _ecvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  char * __cdecl _ecvt(     double _Val,      int _NumOfDigits,      int * _PtDec,      int * _PtSign);
__declspec(dllimport)  errno_t __cdecl _fcvt_s(       char * _DstBuf,      size_t _Size,      double _Val,      int _NumOfDec,      int * _PtDec,      int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _fcvt_s(     char (&_Dest)[_Size],      double _Value,      int _NumOfDigits,      int * _PtDec,      int * _PtSign) { return _fcvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  char * __cdecl _fcvt(     double _Val,      int _NumOfDec,      int * _PtDec,      int * _PtSign);
__declspec(dllimport) errno_t __cdecl _gcvt_s(       char * _DstBuf,      size_t _Size,      double _Val,      int _NumOfDigits);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _gcvt_s(     char (&_Dest)[_Size],      double _Value,      int _NumOfDigits) { return _gcvt_s(_Dest, _Size, _Value, _NumOfDigits); } }
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _gcvt(     double _Val,      int _NumOfDigits,      char * _DstBuf);

__declspec(dllimport)  int __cdecl _atodbl(     _CRT_DOUBLE * _Result,        char * _Str);
__declspec(dllimport)  int __cdecl _atoldbl(     _LDOUBLE * _Result,        char * _Str);
__declspec(dllimport)  int __cdecl _atoflt(     _CRT_FLOAT * _Result,        char * _Str);
__declspec(dllimport)  int __cdecl _atodbl_l(     _CRT_DOUBLE * _Result,        char * _Str,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl _atoldbl_l(     _LDOUBLE * _Result,        char * _Str,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl _atoflt_l(     _CRT_FLOAT * _Result,        char * _Str,        _locale_t _Locale);
         unsigned long __cdecl _lrotl(     unsigned long _Val,      int _Shift);
         unsigned long __cdecl _lrotr(     unsigned long _Val,      int _Shift);
__declspec(dllimport)  errno_t   __cdecl _makepath_s(       char * _PathResult,        size_t _Size,          const char * _Drive,          const char * _Dir,          const char * _Filename,
                 const char * _Ext);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(     char (&_Path)[_Size],          const char * _Drive,          const char * _Dir,          const char * _Filename,          const char * _Ext) { return _makepath_s(_Path, _Size, _Drive, _Dir, _Filename, _Ext); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _makepath( char *_Path,  const char * _Drive,  const char * _Dir,  const char * _Filename,  const char * _Ext);












#line 788 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"












#line 801 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
        _onexit_t __cdecl _onexit(       _onexit_t _Func);
#line 803 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
        




__declspec(dllimport)  int    __cdecl _putenv(       const char * _EnvString);
__declspec(dllimport)  errno_t __cdecl _putenv_s(       const char * _Name,        const char * _Value);
         unsigned int __cdecl _rotl(     unsigned int _Val,      int _Shift);

         unsigned __int64 __cdecl _rotl64(     unsigned __int64 _Val,      int _Shift);
#line 814 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
         unsigned int __cdecl _rotr(     unsigned int _Val,      int _Shift);

         unsigned __int64 __cdecl _rotr64(     unsigned __int64 _Val,      int _Shift);
#line 818 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
__declspec(dllimport) errno_t __cdecl _searchenv_s(       const char * _Filename,        const char * _EnvVar,        char * _ResultPath,      size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(       const char * _Filename,        const char * _EnvVar,      char (&_ResultPath)[_Size]) { return _searchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _searchenv( const char * _Filename,  const char * _EnvVar,  char *_ResultPath);

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void   __cdecl _splitpath(       const char * _FullPath,        char * _Drive,        char * _Dir,        char * _Filename,        char * _Ext);
__declspec(dllimport)  errno_t  __cdecl _splitpath_s(       const char * _FullPath, 
		         char * _Drive,      size_t _DriveSize, 
		         char * _Dir,      size_t _DirSize, 
		         char * _Filename,      size_t _FilenameSize, 
		         char * _Ext,      size_t _ExtSize);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(     const char *_Dest,        char (&_Drive)[_DriveSize],        char (&_Dir)[_DirSize],        char (&_Name)[_NameSize],        char (&_Ext)[_ExtSize]) { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }

__declspec(dllimport) void   __cdecl _swab(           char * _Buf1,            char * _Buf2, int _SizeInBytes);








#line 840 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

__declspec(dllimport)  wchar_t * __cdecl _wfullpath(         wchar_t * _FullPath,        const wchar_t * _Path,      size_t _SizeInWords);



#line 846 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

__declspec(dllimport)  errno_t __cdecl _wmakepath_s(       wchar_t * _PathResult,        size_t _SizeInWords,          const wchar_t * _Drive,          const wchar_t * _Dir,          const wchar_t * _Filename,
                 const wchar_t * _Ext);        
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(     wchar_t (&_ResultPath)[_Size],          const wchar_t * _Drive,          const wchar_t * _Dir,          const wchar_t * _Filename,          const wchar_t * _Ext) { return _wmakepath_s(_ResultPath, _Size, _Drive, _Dir, _Filename, _Ext); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath( wchar_t *_ResultPath,  const wchar_t * _Drive,  const wchar_t * _Dir,  const wchar_t * _Filename,  const wchar_t * _Ext);




__declspec(dllimport)  int    __cdecl _wputenv(       const wchar_t * _EnvString);
__declspec(dllimport)  errno_t __cdecl _wputenv_s(       const wchar_t * _Name,        const wchar_t * _Value);
__declspec(dllimport) errno_t __cdecl _wsearchenv_s(       const wchar_t * _Filename,        const wchar_t * _EnvVar,        wchar_t * _ResultPath,      size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(       const wchar_t * _Filename,        const wchar_t * _EnvVar,      wchar_t (&_ResultPath)[_Size]) { return _wsearchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv( const wchar_t * _Filename,  const wchar_t * _EnvVar,  wchar_t *_ResultPath);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void   __cdecl _wsplitpath(       const wchar_t * _FullPath,        wchar_t * _Drive,        wchar_t * _Dir,        wchar_t * _Filename,        wchar_t * _Ext);
__declspec(dllimport) errno_t __cdecl _wsplitpath_s(       const wchar_t * _FullPath, 
		         wchar_t * _Drive,      size_t _DriveSizeInWords, 
		         wchar_t * _Dir,      size_t _DirSizeInWords, 
		         wchar_t * _Filename,      size_t _FilenameSizeInWords, 
		         wchar_t * _Ext,      size_t _ExtSizeInWords);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(     const wchar_t *_Path,        wchar_t (&_Drive)[_DriveSize],        wchar_t (&_Dir)[_DirSize],        wchar_t (&_Name)[_NameSize],        wchar_t (&_Ext)[_ExtSize]) { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }


#line 870 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"


__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "SetErrorMode" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _seterrormode(     int _Mode);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Beep" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _beep(     unsigned _Frequency,      unsigned _Duration);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Sleep" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _sleep(     unsigned long _Duration);

#line 877 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"
















#pragma warning(push)
#pragma warning(disable: 4141)  
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))		__declspec(dllimport)  char * __cdecl ecvt(     double _Val,      int _NumOfDigits,      int * _PtDec,      int * _PtSign);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))		__declspec(dllimport)  char * __cdecl fcvt(     double _Val,      int _NumOfDec,      int * _PtDec,      int * _PtSign);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))		__declspec(dllimport) char * __cdecl gcvt(     double _Val,      int _NumOfDigits,      char * _DstBuf);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))		__declspec(dllimport) char * __cdecl itoa(     int _Val,      char * _DstBuf,      int _Radix);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))		__declspec(dllimport) char * __cdecl ltoa(     long _Val,      char * _DstBuf,      int _Radix);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_putenv" ". See online help for details.")) 									__declspec(dllimport)  int    __cdecl putenv(       const char * _EnvString);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_swab" ". See online help for details."))										__declspec(dllimport) void   __cdecl swab(           char * _Buf1,           char * _Buf2,      int _SizeInBytes);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))	__declspec(dllimport) char * __cdecl ultoa(     unsigned long _Val,      char * _Dstbuf,      int _Radix);
#pragma warning(pop)
_onexit_t __cdecl onexit(       _onexit_t _Func);

#line 907 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

#line 909 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"


}

#line 914 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"


#pragma pack(pop)
#line 918 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

#line 920 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdlib.h"

#line 14 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstdlib"


 
namespace std {
using ::size_t; using ::div_t; using ::ldiv_t;

using ::abort; using ::abs; using ::atexit;
using ::atof; using ::atoi; using ::atol;
using ::bsearch; using ::calloc; using ::div;
using ::exit; using ::free; using ::getenv;
using ::labs; using ::ldiv; using ::malloc;
using ::mblen; using ::mbstowcs; using ::mbtowc;
using ::qsort; using ::rand; using ::realloc;
using ::srand; using ::strtod; using ::strtol;
using ::strtoul; using ::system;
using ::wcstombs; using ::wctomb;
}
 #line 32 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstdlib"
#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstdlib"

#line 35 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstdlib"
#line 36 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstdlib"





#line 9 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\streambuf"

#pragma once



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xiosbase"

#pragma once



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"

#pragma once




#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstring"

#pragma once










 

 
  
namespace std {
using ::size_t; using ::memchr; using ::memcmp;
using ::memcpy; using ::memmove; using ::memset;
using ::strcat; using ::strchr; using ::strcmp;
using ::strcoll; using ::strcpy; using ::strcspn;
using ::strerror; using ::strlen; using ::strncat;
using ::strncmp; using ::strncpy; using ::strpbrk;
using ::strrchr; using ::strspn; using ::strstr;
using ::strtok; using ::strxfrm;
}
  #line 28 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstring"
 #line 29 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstring"

#line 31 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstring"
#line 32 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstring"





#line 8 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"

#pragma once



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"

#pragma once













#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstddef"

#pragma once







#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstddef"

#pragma once










 #line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stddef.h"















#pragma once
#line 18 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stddef.h"




#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 23 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stddef.h"


extern "C" {
#line 27 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stddef.h"




























#line 56 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stddef.h"









#line 66 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stddef.h"


__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);
#line 72 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stddef.h"



}
#line 77 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stddef.h"

#line 79 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stddef.h"
#line 14 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstddef"


 
namespace std {
using ::ptrdiff_t; using ::size_t;
}
 #line 21 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstddef"
#line 22 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstddef"

#line 24 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstddef"
#line 25 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cstddef"





#line 11 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstddef"


#pragma pack(push,8)
#pragma warning(push,3)
#line 16 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstddef"

namespace std {

		

 
 
 
 
 

 
 

 
 

 
 

 













#line 51 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstddef"

 

		
 

 

		




 
 

 
 



#line 73 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstddef"
  
 #line 75 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstddef"

 
  
  
  
 #line 81 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstddef"

		
enum _Uninitialized
	{	
	_Noinit};
}


#pragma warning(pop)
#pragma pack(pop)
#line 92 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstddef"

#line 94 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstddef"
#line 95 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstddef"





#line 17 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"


#pragma pack(push,8)
#pragma warning(push,3)
#line 22 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"

namespace std {

  


  



  



 }

 

 #line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\eh.h"













#pragma once
#line 16 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\eh.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 18 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\eh.h"








#pragma pack(push,8)
#line 28 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\eh.h"







typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *unexpected_handler)();





#line 45 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\eh.h"








struct _EXCEPTION_POINTERS;

typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);
#line 57 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\eh.h"

__declspec(dllimport) __declspec(noreturn) void __cdecl terminate(void);
__declspec(dllimport) void __cdecl unexpected(void);

__declspec(dllimport) int __cdecl _is_exception_typeof(     const type_info &_Type,      struct _EXCEPTION_POINTERS * _ExceptionPtr);



__declspec(dllimport) terminate_function __cdecl set_terminate(       terminate_function _NewPtFunc);
extern "C" __declspec(dllimport) terminate_function __cdecl _get_terminate(void);
__declspec(dllimport) unexpected_function __cdecl set_unexpected(       unexpected_function _NewPtFunc);
extern "C" __declspec(dllimport) unexpected_function __cdecl _get_unexpected(void);
#line 70 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\eh.h"



__declspec(dllimport) _se_translator_function __cdecl _set_se_translator(       _se_translator_function _NewPtFunc);
#line 75 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\eh.h"
__declspec(dllimport) bool __cdecl __uncaught_exception();















#pragma pack(pop)
#line 93 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\eh.h"
#line 94 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\eh.h"
#line 95 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\eh.h"
#line 41 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"
 #line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"















#pragma once
#line 18 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"




#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 23 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"






#pragma pack(push,8)
#line 31 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"


extern "C" {
#line 35 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"







#line 43 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"





#line 49 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"













typedef struct _heapinfo {
        int * _pentry;
        size_t _size;
        int _useflag;
        } _HEAPINFO;

#line 69 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"




extern __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_amblksiz" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) unsigned int _amblksiz;



#line 78 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"



































#line 114 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"

































#line 148 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"

__declspec(dllimport) int     __cdecl _resetstkoflw (void);



__declspec(dllimport) unsigned long __cdecl _set_malloc_crt_max_wait(     unsigned long _NewValue);








#line 163 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"

__declspec(dllimport)      void *  __cdecl _expand(     void * _Memory,      size_t _NewSize);
__declspec(dllimport)  size_t  __cdecl _msize(     void * _Memory);




#line 171 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"

   void *          __cdecl _alloca(     size_t _Size);
__declspec(dllimport)  size_t  __cdecl _get_sbh_threshold(void);
__declspec(dllimport) int     __cdecl _set_sbh_threshold(     size_t _NewValue);
__declspec(dllimport) errno_t __cdecl _set_amblksiz(     size_t _Value);
__declspec(dllimport) errno_t __cdecl _get_amblksiz(     size_t * _Value);
__declspec(dllimport)  int     __cdecl _heapadd(     void * _Memory,      size_t _Size);
__declspec(dllimport)  int     __cdecl _heapchk(void);
__declspec(dllimport)  int     __cdecl _heapmin(void);
__declspec(dllimport) int     __cdecl _heapset(     unsigned int _Fill);
__declspec(dllimport)  int     __cdecl _heapwalk(     _HEAPINFO * _EntryInfo);
__declspec(dllimport) size_t  __cdecl _heapused(size_t * _Used, size_t * _Commit);

__declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);











#line 197 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"

typedef char __static_assert_t[ (sizeof(unsigned int) <= 8) ];


__inline void *_MarkAllocaS(        void *_Ptr, unsigned int _Marker)
{
    if (_Ptr)
    {
        *((unsigned int*)_Ptr) = _Marker;
        _Ptr = (char*)_Ptr + 8;
    }
    return _Ptr;
}
#line 211 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"







#line 219 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"







#line 227 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"








__declspec(noalias) __inline void __cdecl _freea(       void * _Memory)
{
    unsigned int _Marker;
    if (_Memory)
    {
        _Memory = (char*)_Memory - 8;
        _Marker = *(unsigned int *)_Memory;
        if (_Marker == 0xDDDD)
        {
            free(_Memory);
        }





#line 252 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"
    }
}
#line 255 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"
#line 256 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"




#line 261 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"

#line 263 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"






















}
#line 287 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"


#pragma pack(pop)
#line 291 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"

#line 293 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\malloc.h"
#line 42 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"

 

#line 46 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"

 


































typedef const char *__exString;
extern "C" size_t __cdecl strlen(const char *);

extern "C" __declspec(dllimport) errno_t __cdecl strcpy_s(       char * _Dst,      size_t _DstSize,        const char * _Src);




#line 91 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"

 namespace std {

class __declspec(dllimport) exception
	{	
public:


































































































     exception();
     exception(const char *const&);
     exception(const char *const&, int);
     exception(const exception&);
    exception&  operator=(const exception&);
    virtual  ~exception();
    virtual const char *  what() const;
#line 203 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"
private:
	const char *_m_what;
	int _m_doFree;
	};

using ::set_terminate; using ::terminate_handler; using ::terminate; using ::set_unexpected; using ::unexpected_handler; using ::unexpected;

typedef void (__cdecl *_Prhand)(const exception&);




#line 216 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"
__declspec(dllimport) bool __cdecl uncaught_exception();
#line 218 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"

}

 












































































































#line 331 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"


namespace std {


#line 337 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"

		
class bad_exception : public exception
	{	
public:
	 bad_exception(const char *_Message = "bad exception")
		throw ()
		: exception(_Message)
		{	
		}

	virtual  ~bad_exception() throw ()
		{	
		}

 





#line 359 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"

	};


static const char * _bad_alloc_Message = "bad allocation";

		
class bad_alloc : public exception
	{	
public:
	 bad_alloc(const char *_Message) throw ()
		: exception(_Message)
		{	
		}

	 bad_alloc() throw ()
		: exception(_bad_alloc_Message, 1)
		{	
		}

	virtual  ~bad_alloc() throw ()
		{	
		}

 





#line 390 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"

	};


}









#line 405 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"


#pragma warning(pop)
#pragma pack(pop)





#line 415 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"

#line 417 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"
#line 418 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\exception"





#line 7 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

#pragma once



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xmemory"

#pragma once





#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\new"

#pragma once






#pragma pack(push,8)
#pragma warning(push,3)

  
#line 14 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\new"

  








#line 25 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\new"


namespace std {

		
 




typedef void (__cdecl * new_handler) ();
#line 37 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\new"
 #line 38 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\new"

 
struct nothrow_t
	{	
	};

extern const nothrow_t nothrow;	
 #line 46 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\new"

		
__declspec(dllimport) new_handler __cdecl set_new_handler(new_handler)
	throw ();	
}

		
void __cdecl operator delete(void *) throw ();
  void *__cdecl operator new(size_t _Size) throw (...);

 
  
inline void *__cdecl operator new(size_t, void *_Where) throw ()
	{	
	return (_Where);
	}

inline void __cdecl operator delete(void *, void *) throw ()
	{	
	}
 #line 67 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\new"

 
  
inline void *__cdecl operator new[](size_t, void *_Where) throw ()
	{	
	return (_Where);
	}

inline void __cdecl operator delete[](void *, void *) throw ()
	{	
	}
 #line 79 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\new"

void __cdecl operator delete[](void *) throw ();	

  void *__cdecl operator new[](size_t _Size)
	throw (...);	

 
  
    void *__cdecl operator new(size_t _Size, const std::nothrow_t&)
	throw ();

    void *__cdecl operator new[](size_t _Size, const std::nothrow_t&)
	throw ();	

void __cdecl operator delete(void *, const std::nothrow_t&)
	throw ();	

void __cdecl operator delete[](void *, const std::nothrow_t&)
	throw ();	
 #line 99 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\new"



 
using std::new_handler;
 #line 105 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\new"


  

#pragma warning(pop)
#pragma pack(pop)
#line 112 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\new"

#line 114 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\new"
#line 115 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\new"





#line 9 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xmemory"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

#pragma once




#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\utility"

#pragma once



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iosfwd"

#pragma once





#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cwchar"

#pragma once














 #line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


















#pragma once
#line 21 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"





#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 27 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


#pragma pack(push,8)
#line 31 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


extern "C" {
#line 35 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"





















































typedef unsigned long _fsize_t; 

#line 91 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"



struct _wfinddata32_t {
        unsigned    attrib;
        __time32_t  time_create;    
        __time32_t  time_access;    
        __time32_t  time_write;
        _fsize_t    size;
        wchar_t     name[260];
};



struct _wfinddata32i64_t {
        unsigned    attrib;
        __time32_t  time_create;    
        __time32_t  time_access;    
        __time32_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

struct _wfinddata64i32_t {
        unsigned    attrib;
        __time64_t  time_create;    
        __time64_t  time_access;    
        __time64_t  time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

struct _wfinddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    
        __time64_t  time_access;    
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#line 133 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"



















#line 153 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


#line 156 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"






























#line 187 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

#line 189 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"
#line 190 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

__declspec(dllimport) const unsigned short * __cdecl __pctype_func(void);

__declspec(dllimport) extern const unsigned short *_pctype;


#line 197 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"
#line 198 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"
#line 199 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"





__declspec(dllimport) extern const unsigned short _wctype[];
#line 206 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

__declspec(dllimport) const wctype_t * __cdecl __pwctype_func(void);

__declspec(dllimport) extern const wctype_t *_pwctype;


#line 213 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"
#line 214 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"
#line 215 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"







                                
















__declspec(dllimport)  int __cdecl iswalpha(     wint_t _C);
__declspec(dllimport)  int __cdecl _iswalpha_l(     wint_t _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl iswupper(     wint_t _C);
__declspec(dllimport)  int __cdecl _iswupper_l(     wint_t _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl iswlower(     wint_t _C);
__declspec(dllimport)  int __cdecl _iswlower_l(     wint_t _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl iswdigit(     wint_t _C);
__declspec(dllimport)  int __cdecl _iswdigit_l(     wint_t _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl iswxdigit(     wint_t _C);
__declspec(dllimport)  int __cdecl _iswxdigit_l(     wint_t _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl iswspace(     wint_t _C);
__declspec(dllimport)  int __cdecl _iswspace_l(     wint_t _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl iswpunct(     wint_t _C);
__declspec(dllimport)  int __cdecl _iswpunct_l(     wint_t _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl iswalnum(     wint_t _C);
__declspec(dllimport)  int __cdecl _iswalnum_l(     wint_t _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl iswprint(     wint_t _C);
__declspec(dllimport)  int __cdecl _iswprint_l(     wint_t _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl iswgraph(     wint_t _C);
__declspec(dllimport)  int __cdecl _iswgraph_l(     wint_t _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl iswcntrl(     wint_t _C);
__declspec(dllimport)  int __cdecl _iswcntrl_l(     wint_t _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl iswascii(     wint_t _C);
__declspec(dllimport)  int __cdecl isleadbyte(     int _C);
__declspec(dllimport)  int __cdecl _isleadbyte_l(     int _C,        _locale_t _Locale);

__declspec(dllimport)  wint_t __cdecl towupper(     wint_t _C);
__declspec(dllimport)  wint_t __cdecl _towupper_l(     wint_t _C,        _locale_t _Locale);
__declspec(dllimport)  wint_t __cdecl towlower(     wint_t _C);
__declspec(dllimport)  wint_t __cdecl _towlower_l(     wint_t _C,        _locale_t _Locale); 
__declspec(dllimport)  int __cdecl iswctype(     wint_t _C,      wctype_t _Type);
__declspec(dllimport)  int __cdecl _iswctype_l(     wint_t _C,      wctype_t _Type,        _locale_t _Locale);

__declspec(dllimport)  int __cdecl __iswcsymf(     wint_t _C);
__declspec(dllimport)  int __cdecl _iswcsymf_l(     wint_t _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl __iswcsym(     wint_t _C);
__declspec(dllimport)  int __cdecl _iswcsym_l(     wint_t _C,        _locale_t _Locale);

__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "iswctype" " instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(     wint_t _C,      wctype_t _Type);


#line 281 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"












#line 294 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

__declspec(dllimport)         wchar_t * __cdecl _wgetcwd(       wchar_t * _DstBuf,      int _SizeInWords);
__declspec(dllimport)         wchar_t * __cdecl _wgetdcwd(     int _Drive,        wchar_t * _DstBuf,      int _SizeInWords);
        wchar_t * __cdecl _wgetdcwd_nolock(     int _Drive,        wchar_t * _DstBuf,      int _SizeInWords);





#line 304 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

__declspec(dllimport)  int __cdecl _wchdir(       const wchar_t * _Path);
__declspec(dllimport)  int __cdecl _wmkdir(       const wchar_t * _Path);
__declspec(dllimport)  int __cdecl _wrmdir(       const wchar_t * _Path);


#line 311 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"



__declspec(dllimport)  int __cdecl _waccess(       const wchar_t * _Filename,      int _AccessMode);
__declspec(dllimport)  errno_t __cdecl _waccess_s(       const wchar_t * _Filename,      int _AccessMode);
__declspec(dllimport)  int __cdecl _wchmod(       const wchar_t * _Filename,      int _Mode);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _wcreat(       const wchar_t * _Filename,      int _PermissionMode);
__declspec(dllimport)  intptr_t __cdecl _wfindfirst32(       const wchar_t * _Filename,      struct _wfinddata32_t * _FindData);
__declspec(dllimport)  int __cdecl _wfindnext32(     intptr_t _FindHandle,      struct _wfinddata32_t * _FindData);
__declspec(dllimport)  int __cdecl _wunlink(       const wchar_t * _Filename);
__declspec(dllimport)  int __cdecl _wrename(       const wchar_t * _NewFilename,        const wchar_t * _OldFilename);
__declspec(dllimport) errno_t __cdecl _wmktemp_s(           wchar_t * _TemplateName,      size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(       wchar_t (&_TemplateName)[_Size]) { return _wmktemp_s(_TemplateName, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wmktemp( wchar_t *_TemplateName);


__declspec(dllimport)  intptr_t __cdecl _wfindfirst32i64(       const wchar_t * _Filename,      struct _wfinddata32i64_t * _FindData);
__declspec(dllimport)  intptr_t __cdecl _wfindfirst64i32(       const wchar_t * _Filename,      struct _wfinddata64i32_t * _FindData);
__declspec(dllimport)  intptr_t __cdecl _wfindfirst64(       const wchar_t * _Filename,      struct _wfinddata64_t * _FindData);
__declspec(dllimport)  int __cdecl _wfindnext32i64(     intptr_t _FindHandle,      struct _wfinddata32i64_t * _FindData);
__declspec(dllimport)  int __cdecl _wfindnext64i32(     intptr_t _FindHandle,      struct _wfinddata64i32_t * _FindData);
__declspec(dllimport)  int __cdecl _wfindnext64(     intptr_t _FindHandle,      struct _wfinddata64_t * _FindData);
#line 334 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

__declspec(dllimport)  errno_t __cdecl _wsopen_s(     int * _FileHandle,        const wchar_t * _Filename,      int _OpenFlag,      int _ShareFlag,      int _PermissionFlag);






#line 343 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


extern "C++" __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wopen(       const wchar_t * _Filename,      int _OpenFlag,      int _PermissionMode = 0);
extern "C++" __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wsopen(       const wchar_t * _Filename,      int _OpenFlag,      int _ShareFlag, int _PermissionMode = 0);

#line 349 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


#line 352 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"





__declspec(dllimport)  wchar_t * __cdecl _wsetlocale(     int _Category,          const wchar_t * _Locale);


#line 361 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"





__declspec(dllimport) intptr_t __cdecl _wexecl(       const wchar_t * _Filename,        const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexecle(       const wchar_t * _Filename,        const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexeclp(       const wchar_t * _Filename,        const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexeclpe(       const wchar_t * _Filename,        const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexecv(       const wchar_t * _Filename,        const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wexecve(       const wchar_t * _Filename,        const wchar_t * const * _ArgList,
                 const wchar_t * const * _Env);
__declspec(dllimport) intptr_t __cdecl _wexecvp(       const wchar_t * _Filename,        const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wexecvpe(       const wchar_t * _Filename,        const wchar_t * const * _ArgList, 
                 const wchar_t * const * _Env);
__declspec(dllimport) intptr_t __cdecl _wspawnl(     int _Mode,        const wchar_t * _Filename,        const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnle(     int _Mode,        const wchar_t * _Filename,        const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnlp(     int _Mode,        const wchar_t * _Filename,        const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnlpe(     int _Mode,        const wchar_t * _Filename,        const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnv(     int _Mode,        const wchar_t * _Filename,        const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wspawnve(     int _Mode,        const wchar_t * _Filename,        const wchar_t * const * _ArgList,
                 const wchar_t * const * _Env);
__declspec(dllimport) intptr_t __cdecl _wspawnvp(     int _Mode,        const wchar_t * _Filename,        const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wspawnvpe(     int _Mode,        const wchar_t * _Filename,        const wchar_t * const * _ArgList,
                 const wchar_t * const * _Env);






#line 393 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


































#line 428 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


























#line 455 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

#line 457 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"







typedef unsigned short _ino_t;      


typedef unsigned short ino_t;
#line 469 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

#line 471 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


typedef unsigned int _dev_t;        


typedef unsigned int dev_t;
#line 478 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

#line 480 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


typedef long _off_t;                


typedef long off_t;
#line 487 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

#line 489 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"



struct _stat32 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
        };



struct stat {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#line 523 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"



struct _stat32i64 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        __int64    st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
        };

struct _stat64i32 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

struct _stat64 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        __int64    st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

#line 569 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"























#line 593 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"



#line 597 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"





__declspec(dllimport) int __cdecl _wstat32(       const wchar_t * _Name,      struct _stat32 * _Stat);


__declspec(dllimport) int __cdecl _wstat32i64(       const wchar_t * _Name,      struct _stat32i64 * _Stat);
__declspec(dllimport) int __cdecl _wstat64i32(       const wchar_t * _Name,      struct _stat64i32 * _Stat);
__declspec(dllimport) int __cdecl _wstat64(       const wchar_t * _Name,      struct _stat64 * _Stat);
#line 609 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


#line 612 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

#line 614 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"










__declspec(dllimport)  errno_t __cdecl _cgetws_s(       wchar_t * _Buffer, size_t _SizeInWords,      size_t * _SizeRead);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _cgetws_s(       wchar_t (&_Buffer)[_Size], size_t * _Size) { return _cgetws_s(_Buffer, _Size, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_cgetws_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _cgetws(         wchar_t *_Buffer);
__declspec(dllimport)  wint_t __cdecl _getwch(void);
__declspec(dllimport)  wint_t __cdecl _getwche(void);
__declspec(dllimport)  wint_t __cdecl _putwch(wchar_t _WCh);
__declspec(dllimport)  wint_t __cdecl _ungetwch(wint_t _WCh);
__declspec(dllimport)  int __cdecl _cputws(       const wchar_t * _String);
__declspec(dllimport)  int __cdecl _cwprintf(        const wchar_t * _Format, ...);
__declspec(dllimport)  int __cdecl _cwprintf_s(        const wchar_t * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _cwscanf(        const wchar_t * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport)  int __cdecl _cwscanf_l(        const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _cwscanf_s(        const wchar_t * _Format, ...);
__declspec(dllimport)  int __cdecl _cwscanf_s_l(        const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport)  int __cdecl _vcwprintf(        const wchar_t *_Format, va_list _ArgList);
__declspec(dllimport)  int __cdecl _vcwprintf_s(        const wchar_t *_Format, va_list _ArgList);

__declspec(dllimport)  int __cdecl _cwprintf_p(        const wchar_t * _Format, ...);
__declspec(dllimport)  int __cdecl _vcwprintf_p(        const wchar_t*  _Format, va_list _ArgList);

__declspec(dllimport) int __cdecl _cwprintf_l(       const  wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _cwprintf_s_l(        const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vcwprintf_l(        const wchar_t *_Format,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vcwprintf_s_l(        const wchar_t * _Format,        _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _cwprintf_p_l(        const wchar_t * _Format,        _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vcwprintf_p_l(        const wchar_t * _Format,        _locale_t _Locale, va_list _ArgList);

 wint_t __cdecl _putwch_nolock(wchar_t _WCh);
 wint_t __cdecl _getwch_nolock(void);
 wint_t __cdecl _getwche_nolock(void);
 wint_t __cdecl _ungetwch_nolock(wint_t _WCh);






#line 662 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


#line 665 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"




















































































































































































































































































































#line 974 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

















































































































































struct tm {
        int tm_sec;     
        int tm_min;     
        int tm_hour;    
        int tm_mday;    
        int tm_mon;     
        int tm_year;    
        int tm_wday;    
        int tm_yday;    
        int tm_isdst;   
        };

#line 1132 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"




 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wasctime(     const struct tm * _Tm);
__declspec(dllimport) errno_t __cdecl _wasctime_s(       wchar_t *_Buf,      size_t _SizeInWords,      const struct tm * _Tm);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wasctime_s(       wchar_t (&_Buffer)[_Size],      const struct tm * _Time) { return _wasctime_s(_Buffer, _Size, _Time); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wctime32(     const __time32_t *_Time);
__declspec(dllimport) errno_t __cdecl _wctime32_s(       wchar_t* _Buf,      size_t _SizeInWords,      const __time32_t * _Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(       wchar_t (&_Buffer)[_Size],      const __time32_t * _Time) { return _wctime32_s(_Buffer, _Size, _Time); } }

__declspec(dllimport) size_t __cdecl wcsftime(       wchar_t * _Buf,      size_t _SizeInWords,         const wchar_t * _Format,       const struct tm * _Tm);
__declspec(dllimport) size_t __cdecl _wcsftime_l(       wchar_t * _Buf,      size_t _SizeInWords,         const wchar_t *_Format,      const struct tm *_Tm,        _locale_t _Locale);

__declspec(dllimport) errno_t __cdecl _wstrdate_s(       wchar_t * _Buf,      size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(       wchar_t (&_Buffer)[_Size]) { return _wstrdate_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wstrdate( wchar_t *_Buffer);

__declspec(dllimport) errno_t __cdecl _wstrtime_s(       wchar_t * _Buf,      size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(       wchar_t (&_Buffer)[_Size]) { return _wstrtime_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wstrtime( wchar_t *_Buffer);


__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wctime64(     const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _wctime64_s(       wchar_t* _Buf,      size_t _SizeInWords,      const __time64_t *_Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(       wchar_t (&_Buffer)[_Size],      const __time64_t * _Time) { return _wctime64_s(_Buffer, _Size, _Time); } }
#line 1161 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wtime.inl"













#pragma once
#line 16 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wtime.inl"







#line 24 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wtime.inl"





#pragma warning(push)
#pragma warning(disable:4996)















static __inline wchar_t * __cdecl _wctime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _wctime64(_Time);
#pragma warning( pop )
}

static __inline errno_t __cdecl _wctime_s(wchar_t *_Buffer, size_t _SizeInWords, const time_t * _Time)
{
    return _wctime64_s(_Buffer, _SizeInWords, _Time);
}
#line 59 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wtime.inl"

#pragma warning(pop)

#line 63 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wtime.inl"
#line 64 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wtime.inl"
#line 1164 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"
#line 1165 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


#line 1168 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


typedef int mbstate_t;
typedef wchar_t _Wint_t;

__declspec(dllimport) wint_t __cdecl btowc(int);
__declspec(dllimport) size_t __cdecl mbrlen(           const char * _Ch,      size_t _SizeInBytes,
                                     mbstate_t * _State);
__declspec(dllimport) size_t __cdecl mbrtowc(       wchar_t * _DstCh,            const char * _SrcCh,
                                    size_t _SizeInBytes,        mbstate_t * _State);
__declspec(dllimport) errno_t __cdecl mbsrtowcs_s(       size_t* _Retval,          wchar_t * _Dst,      size_t _SizeInWords,                  const char ** _PSrc,      size_t _N,        mbstate_t * _State);
extern "C++" { template <size_t _Size> inline errno_t __cdecl mbsrtowcs_s(       size_t * _Retval,        wchar_t (&_Dest)[_Size],                  const char ** _PSource,      size_t _Count,        mbstate_t * _State) { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl mbsrtowcs( wchar_t *_Dest,  const char ** _PSrc,  size_t _Count,  mbstate_t * _State);

__declspec(dllimport) errno_t __cdecl wcrtomb_s(       size_t * _Retval,          char * _Dst,
             size_t _SizeInBytes,        wchar_t _Ch,        mbstate_t * _State);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcrtomb_s(       size_t * _Retval,          char (&_Dest)[_Size],        wchar_t _Source,        mbstate_t * _State) { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb( char *_Dest,  wchar_t _Source,  mbstate_t * _State);
__declspec(dllimport) errno_t __cdecl wcsrtombs_s(       size_t * _Retval,          char * _Dst,
             size_t _SizeInBytes,                const wchar_t ** _Src,      size_t _Size,        mbstate_t * _State);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsrtombs_s(       size_t * _Retval,          char (&_Dest)[_Size],                const wchar_t ** _PSrc,      size_t _Count,        mbstate_t * _State) { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs( char *_Dest,  const wchar_t ** _PSource,  size_t _Count,  mbstate_t * _State);
__declspec(dllimport) int __cdecl wctob(     wint_t _WCh);






#line 1198 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"
__declspec(dllimport)  void *  __cdecl memmove(         void * _Dst,          const void * _Src,      size_t _MaxCount);
#line 1200 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"
 void *  __cdecl memcpy(         void * _Dst,          const void * _Src,      size_t _MaxCount);

__declspec(dllimport) errno_t __cdecl memcpy_s(         void * _Dst,      rsize_t _DstSize,          const void * _Src,      rsize_t _MaxCount);
__declspec(dllimport) errno_t __cdecl memmove_s(         void * _Dst,      rsize_t _DstSize,          const void * _Src,      rsize_t _MaxCount);
#line 1205 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"
__inline int __cdecl fwide(       FILE * _F, int _M)
        {(void)_F; return (_M); }
__inline int __cdecl mbsinit(       const mbstate_t *_P)
        {return (_P == 0 || *_P == 0); }
__inline const wchar_t * __cdecl wmemchr(       const wchar_t *_S,        wchar_t _C,      size_t _N)
        {for (; 0 < _N; ++_S, --_N)
                if (*_S == _C)
                        return (const wchar_t *)(_S);
        return (0); }
__inline int __cdecl wmemcmp(       const wchar_t *_S1,        const wchar_t *_S2,      size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }

__inline  wchar_t * __cdecl wmemcpy(       wchar_t *_S1,          const wchar_t *_S2,      size_t _N)
        {
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
            return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning( pop )
        }


__inline errno_t __cdecl wmemcpy_s(         wchar_t *_S1,      rsize_t _N1,          const wchar_t *_S2, rsize_t _N)
        {
#pragma warning( push )
#pragma warning( disable : 6386 )
            return memcpy_s(_S1, _N1*sizeof(wchar_t), _S2, _N*sizeof(wchar_t));
        }
#pragma warning( pop )
#line 1237 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

__inline  wchar_t * __cdecl wmemmove(         wchar_t *_S1,          const wchar_t *_S2,      size_t _N)
        {
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
#pragma warning( disable : 6387)
			
            return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning( pop )
        }


__inline errno_t __cdecl wmemmove_s(         wchar_t *_S1,      rsize_t _N1,          const wchar_t *_S2,      rsize_t _N)
        {
#pragma warning( push )
#pragma warning( disable : 6386 )
            return memmove_s(_S1, _N1*sizeof(wchar_t), _S2, _N*sizeof(wchar_t));
#pragma warning( pop )
        }
#line 1257 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

__inline wchar_t * __cdecl wmemset(       wchar_t *_S,        wchar_t _C,      size_t _N)
        {
            wchar_t *_Su = _S;
            for (; 0 < _N; ++_Su, --_N)
            {
                *_Su = _C;
            }
            return (_S);
        }


extern "C++" {
inline wchar_t * __cdecl wmemchr(       wchar_t *_S,      wchar_t _C,      size_t _N)
        { return (wchar_t *)wmemchr((const wchar_t *)_S, _C, _N); }
}
#line 1274 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"
#line 1275 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


}       
#line 1279 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"


#pragma pack(pop)
#line 1283 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

#line 1285 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\wchar.h"

#line 18 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cwchar"





typedef mbstate_t _Mbstatet;

 
namespace std {
using ::mbstate_t; using ::size_t; using ::tm; using ::wint_t;

using ::btowc; using ::fgetwc; using ::fgetws; using ::fputwc;
using ::fputws; using ::fwide; using ::fwprintf;
using ::fwscanf; using ::getwc; using ::getwchar;
using ::mbrlen; using ::mbrtowc; using ::mbsrtowcs;
using ::mbsinit; using ::putwc; using ::putwchar;
using ::swprintf; using ::swscanf; using ::ungetwc;
using ::vfwprintf; using ::vswprintf; using ::vwprintf;
using ::wcrtomb; using ::wprintf; using ::wscanf;
using ::wcsrtombs; using ::wcstol; using ::wcscat;
using ::wcschr; using ::wcscmp; using ::wcscoll;
using ::wcscpy; using ::wcscspn; using ::wcslen;
using ::wcsncat; using ::wcsncmp; using ::wcsncpy;
using ::wcspbrk; using ::wcsrchr; using ::wcsspn;
using ::wcstod; using ::wcstoul; using ::wcsstr;
using ::wcstok; using ::wcsxfrm; using ::wctob;
using ::wmemchr; using ::wmemcmp; using ::wmemcpy;
using ::wmemmove; using ::wmemset; using ::wcsftime;
}
 #line 48 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cwchar"
#line 49 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cwchar"

#line 51 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cwchar"
#line 52 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\cwchar"





#line 9 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iosfwd"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"













#pragma once
#line 16 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 18 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"





#pragma pack(push,8)
#line 25 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"












extern "C" {
#line 39 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"

 





typedef void *_HFILE; 


















typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);
typedef int (__cdecl * _CRT_REPORT_HOOKW)(int, wchar_t *, int *);



#line 71 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"




#line 76 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"




 





 










typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);


#line 101 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"


#line 104 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"

 





































 














typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);


#line 162 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"


#line 165 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"

struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        size_t lCounts[5];
        size_t lSizes[5];
        size_t lHighWaterCount;
        size_t lTotalCount;
} _CrtMemState;


 


























































































































































 
























 






__declspec(dllimport) extern long _crtAssertBusy;
#line 366 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"


__declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(
    void
    );
#line 372 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"






__declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
           _CRT_REPORT_HOOK _PFnNewHook
        );

__declspec(dllimport) int __cdecl _CrtSetReportHook2(
             int _Mode,
               _CRT_REPORT_HOOK _PFnNewHook
        );

__declspec(dllimport) int __cdecl _CrtSetReportHookW2(
             int _Mode,
               _CRT_REPORT_HOOKW _PFnNewHook
        );


















#line 410 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"



























#line 438 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"


__declspec(dllimport) int __cdecl _CrtSetReportMode(
             int _ReportType,
               int _ReportMode 
        );

__declspec(dllimport) _HFILE __cdecl _CrtSetReportFile(
             int _ReportType,
               _HFILE _ReportFile 
        );

__declspec(dllimport) int __cdecl _CrtDbgReport(
             int _ReportType,
                 const char * _Filename,
             int _Linenumber,
                 const char * _ModuleName,
                 const char * _Format,
        ...);

__declspec(dllimport) size_t __cdecl _CrtSetDebugFillThreshold(
             size_t _NewDebugFillThreshold
        );



#line 465 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"
__declspec(dllimport) int __cdecl _CrtDbgReportW(
             int _ReportType,
                 const wchar_t * _Filename,
             int _LineNumber,
                 const wchar_t * _ModuleName,
                 const wchar_t * _Format,
        ...);










#line 483 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"



#line 487 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"







#line 495 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"



















#line 515 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"























































































#line 603 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"

 





















































__declspec(dllimport) extern long _crtBreakAlloc;      
#line 660 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"

__declspec(dllimport) long __cdecl _CrtSetBreakAlloc(
             long _BreakAlloc 
        );





__declspec(dllimport)      void * __cdecl _malloc_dbg(
             size_t _Size,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)      void * __cdecl _calloc_dbg(
             size_t _NumOfElements,
             size_t _SizeOfElements,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)      void * __cdecl _realloc_dbg(
               void * _Memory,
             size_t _NewSize,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)      void * __cdecl _recalloc_dbg
(
               void * _Memory,
             size_t _NumOfElements,
             size_t _SizeOfElements,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
);

__declspec(dllimport)      void * __cdecl _expand_dbg(
               void * _Memory,
             size_t _NewSize,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport) void __cdecl _free_dbg(
               void * _Memory,
             int _BlockType
        );

__declspec(dllimport) size_t __cdecl _msize_dbg (
             void * _Memory,
             int _BlockType
        );

__declspec(dllimport) size_t __cdecl _aligned_msize_dbg (
             void * _Memory,
             size_t _Alignment,
             size_t _Offset
        );

__declspec(dllimport)      void * __cdecl _aligned_malloc_dbg(
             size_t _Size,
             size_t _Alignment,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)      void * __cdecl _aligned_realloc_dbg(
               void * _Memory,
             size_t _Size,
             size_t _Alignment,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)      void * __cdecl _aligned_recalloc_dbg
(
               void * _Memory,
             size_t _NumOfElements,
             size_t _SizeOfElements,
             size_t _Alignment,
                 const char * _Filename,
             int _LineNumber
);

__declspec(dllimport)      void * __cdecl _aligned_offset_malloc_dbg(
             size_t _Size,
             size_t _Alignment,
             size_t _Offset,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)      void * __cdecl _aligned_offset_realloc_dbg(
               void * _Memory,
             size_t _Size,
             size_t _Alignment,
             size_t _Offset,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)      void * __cdecl _aligned_offset_recalloc_dbg
(
               void * _Memory,
             size_t _NumOfElements,
             size_t _SizeOfElements,
             size_t _Alignment,
             size_t _Offset,
                 const char * _Filename,
             int _LineNumber
);

__declspec(dllimport) void __cdecl _aligned_free_dbg(
               void * _Memory
        );

__declspec(dllimport)         char * __cdecl _strdup_dbg(
                 const char * _Str,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)         wchar_t * __cdecl _wcsdup_dbg(
                 const wchar_t * _Str,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)         char * __cdecl _tempnam_dbg(
                 const char * _DirName,
                 const char * _FilePrefix,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)         wchar_t * __cdecl _wtempnam_dbg(
                 const wchar_t * _DirName,
                 const wchar_t * _FilePrefix,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)         char * __cdecl _fullpath_dbg(
                 char * _FullPath, 
               const char * _Path, 
             size_t _SizeInBytes,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)         wchar_t * __cdecl _wfullpath_dbg(
                 wchar_t * _FullPath, 
               const wchar_t * _Path, 
             size_t _SizeInWords,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)         char * __cdecl _getcwd_dbg(
                 char * _DstBuf,
             int _SizeInBytes,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)         wchar_t * __cdecl _wgetcwd_dbg(
                 wchar_t * _DstBuf,
             int _SizeInWords,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)         char * __cdecl _getdcwd_dbg(
             int _Drive,
                 char * _DstBuf,
             int _SizeInBytes,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)         wchar_t * __cdecl _wgetdcwd_dbg(
             int _Drive,
                 wchar_t * _DstBuf,
             int _SizeInWords,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

        char * __cdecl _getdcwd_lk_dbg(
             int _Drive,
                 char * _DstBuf,
             int _SizeInBytes,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

        wchar_t * __cdecl _wgetdcwd_lk_dbg(
             int _Drive,
                 wchar_t * _DstBuf,
             int _SizeInWords,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)  errno_t __cdecl _dupenv_s_dbg(
                             char ** _PBuffer,
               size_t * _PBufferSizeInBytes,
               const char * _VarName,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );

__declspec(dllimport)  errno_t __cdecl _wdupenv_s_dbg(
                             wchar_t ** _PBuffer,
               size_t * _PBufferSizeInWords,
               const wchar_t * _VarName,
             int _BlockType,
                 const char * _Filename,
             int _LineNumber
        );









#line 910 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"

 





__declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook
(
    void
);
#line 922 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"






__declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook
(
           _CRT_ALLOC_HOOK _PfnNewHook
);








#line 941 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"


















#line 960 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"


 











__declspec(dllimport) extern int _crtDbgFlag;
#line 976 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"

__declspec(dllimport) int __cdecl _CrtCheckMemory(
        void
        );

__declspec(dllimport) int __cdecl _CrtSetDbgFlag(
             int _NewFlag
        );

__declspec(dllimport) void __cdecl _CrtDoForAllClientObjects(
             void (__cdecl *_PFn)(void *, void *),
        void * _Context
        );









#line 999 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"

__declspec(dllimport)  int __cdecl _CrtIsValidPointer(
               const void * _Ptr,
             unsigned int _Bytes,
             int _ReadWrite
        );

__declspec(dllimport)  int __cdecl _CrtIsValidHeapPointer(
               const void * _HeapPtr
        );

__declspec(dllimport) int __cdecl _CrtIsMemoryBlock(
               const void * _Memory,
             unsigned int _Bytes,
               long * _RequestNumber,
               char ** _Filename,
               int * _LineNumber
        );

__declspec(dllimport)  int __cdecl _CrtReportBlockType(
               const void * _Memory
        );


 






__declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient
(
    void
);
#line 1035 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"






__declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient
(
           _CRT_DUMP_CLIENT _PFnNewDump
);









#line 1055 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"















#line 1071 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"

__declspec(dllimport)  void __cdecl _CrtMemCheckpoint(
             _CrtMemState * _State
        );

__declspec(dllimport)  int __cdecl _CrtMemDifference(
             _CrtMemState * _State,
             const _CrtMemState * _OldState,
             const _CrtMemState * _NewState
        );

__declspec(dllimport) void __cdecl _CrtMemDumpAllObjectsSince(
               const _CrtMemState * _State
        );

__declspec(dllimport) void __cdecl _CrtMemDumpStatistics(
             const _CrtMemState * _State
        );

__declspec(dllimport) int __cdecl _CrtDumpMemoryLeaks(
        void
        );

__declspec(dllimport) int __cdecl _CrtSetCheckCount(
             int _CheckCount
        );

__declspec(dllimport) int __cdecl _CrtGetCheckCount(
        void
        );

#line 1103 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"


}



extern "C++" {










































 






 
  void * __cdecl operator new[](size_t _Size);

  void * __cdecl operator new(
        size_t _Size,
        int,
        const char *,
        int
        );

  void * __cdecl operator new[](
        size_t _Size,
        int,
        const char *,
        int
        );


void __cdecl operator delete[](void *);

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }

inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#line 1185 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"



















#line 1205 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"

#line 1207 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"

}

#line 1211 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"

#line 1213 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"


#pragma pack(pop)
#line 1217 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"

#line 1219 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdbg.h"

#line 11 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iosfwd"


#pragma pack(push,8)
#pragma warning(push,3)
#line 16 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iosfwd"

namespace std {

		

 




typedef long streamoff;
typedef int streamsize;
 #line 29 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iosfwd"





extern __declspec(dllimport)  fpos_t _Fpz;
extern __declspec(dllimport)  const streamoff _BADOFF;
#line 37 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iosfwd"

		
template<class _Statetype>
	class fpos
	{	
	typedef fpos<_Statetype> _Myt;

public:
	 fpos(streamoff _Off = 0)
		: _Myoff(_Off), _Fpos(0), _Mystate(_Stz)
		{	
		}

	 fpos(_Statetype _State, fpos_t _Fileposition)
		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
		{	
		}

	_Statetype  state() const
		{	
		return (_Mystate);
		}

	void  state(_Statetype _State)
		{	
		_Mystate = _State;
		}

	fpos_t  seekpos() const
		{	
		return (_Fpos);
		}

	 operator streamoff() const
		{	
		return (_Myoff + ((long)(_Fpos)));
		}

	streamoff  operator-(const _Myt& _Right) const
		{	
		return ((streamoff)*this - (streamoff)_Right);
		}

	_Myt&  operator+=(streamoff _Off)
		{	
		_Myoff += _Off;
		return (*this);
		}

	_Myt&  operator-=(streamoff _Off)
		{	
		_Myoff -= _Off;
		return (*this);
		}

	_Myt  operator+(streamoff _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt  operator-(streamoff _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	bool  operator==(const _Myt& _Right) const
		{	
		return ((streamoff)*this == (streamoff)_Right);
		}

	bool  operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

private:
	 static const _Statetype _Stz;	
	streamoff _Myoff;	
	fpos_t _Fpos;	
	_Statetype _Mystate;	
	};

	
template<class _Statetype>
	 const _Statetype fpos<_Statetype>::_Stz = _Statetype();

 

 
 

typedef fpos<_Mbstatet> streampos;
typedef streampos wstreampos;

		
struct _Unsecure_char_traits_tag
	{
	};
struct _Secure_char_traits_tag
	{
	};

		
		
		
		
		
struct _Char_traits_base
	{
	typedef _Unsecure_char_traits_tag _Secure_char_traits;
	};

		
		
		
template<class _Elem>
	struct char_traits:
		public _Char_traits_base
	{	
	typedef _Elem char_type;
	typedef long int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right)
		{	
		_Left = _Right;
		}

	static bool __cdecl eq(const _Elem& _Left, const _Elem& _Right)
		{	
		return (_Left == _Right);
		}

	static bool __cdecl lt(const _Elem& _Left, const _Elem& _Right)
		{	
		return (_Left < _Right);
		}

	static int __cdecl compare(const _Elem *_First1,
		const _Elem *_First2, size_t _Count)
		{	


		for (; 0 < _Count; --_Count, ++_First1, ++_First2)
			if (!eq(*_First1, *_First2))
				return (lt(*_First1, *_First2) ? -1 : +1);
		return (0);
		}

	static size_t __cdecl length(const _Elem *_First)
		{	

		size_t _Count;
		for (_Count = 0; !eq(*_First, _Elem()); ++_First)
			++_Count;
		return (_Count);
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	static _Elem *__cdecl copy(_Elem *_First1,
		const _Elem *_First2, size_t _Count)
		{	
		
		return _Copy_s(_First1, _Count, _First2, _Count);
		}

	static _Elem *__cdecl _Copy_s(_Elem *_First1, size_t _Dest_size,
		const _Elem *_First2, size_t _Count)
		{	


		{ if (!(_Dest_size >= _Count)) { (void) ((!!((("_Dest_size >= _Count", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iosfwd", 212, 0, L"(\"_Dest_size >= _Count\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"_Dest_size >= _Count", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iosfwd", 212, 0); return (0); } };
		_Elem *_Next = _First1;
		for (; 0 < _Count; --_Count, ++_Next, ++_First2)
			assign(*_Next, *_First2);
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First,
		size_t _Count, const _Elem& _Ch)
		{	

		for (; 0 < _Count; --_Count, ++_First)
			if (eq(*_First, _Ch))
				return (_First);
		return (0);
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	static _Elem *__cdecl move(_Elem *_First1,
		const _Elem *_First2, size_t _Count)
		{	
		
		return _Move_s(_First1, _Count, _First2, _Count);
		}

	static _Elem *__cdecl _Move_s(_Elem *_First1, size_t _Dest_size,
		const _Elem *_First2, size_t _Count)
		{	


		{ if (!(_Dest_size >= _Count)) { (void) ((!!((("_Dest_size >= _Count", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iosfwd", 242, 0, L"(\"_Dest_size >= _Count\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"_Dest_size >= _Count", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iosfwd", 242, 0); return (0); } };
		_Elem *_Next = _First1;
		if (_First2 < _Next && _Next < _First2 + _Count)
			for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
				assign(*--_Next, *--_First2);
		else
			for (; 0 < _Count; --_Count, ++_Next, ++_First2)
				assign(*_Next, *_First2);
		return (_First1);
		}

	static _Elem *__cdecl assign(_Elem *_First,
		size_t _Count, _Elem _Ch)
		{	

		_Elem *_Next = _First;
		for (; 0 < _Count; --_Count, ++_Next)
			assign(*_Next, _Ch);
		return (_First);
		}

	static _Elem __cdecl to_char_type(const int_type& _Meta)
		{	
		return ((_Elem)_Meta);
		}

	static int_type __cdecl to_int_type(const _Elem& _Ch)
		{	
		return ((int_type)_Ch);
		}

	static bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right)
		{	
		return (_Left == _Right);
		}

	static int_type __cdecl eof()
		{	
		return ((int_type)(-1));
		}

	static int_type __cdecl not_eof(const int_type& _Meta)
		{	
		return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());
		}
	};

		
template<> struct __declspec(dllimport) char_traits<wchar_t>:
	public _Char_traits_base
	{	
	typedef wchar_t _Elem;
	typedef _Elem char_type;	
	typedef wint_t int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right)
		{	
		_Left = _Right;
		}

	static bool __cdecl eq(const _Elem& _Left, const _Elem& _Right)
		{	
		return (_Left == _Right);
		}

	static bool __cdecl lt(const _Elem& _Left, const _Elem& _Right)
		{	
		return (_Left < _Right);
		}

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	


		return (::wmemcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	

		return (::wcslen(_First));
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		
		return _Copy_s(_First1, _Count, _First2, _Count);
		}

	static _Elem *__cdecl _Copy_s(_Elem *_First1, size_t _Size_in_words, const _Elem *_First2,
		size_t _Count)
		{	


		::wmemcpy_s((_First1), (_Size_in_words), (_First2), (_Count));
		return _First1;
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	

		return ((const _Elem *)::wmemchr(_First, _Ch, _Count));
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		
		return _Move_s(_First1, _Count, _First2, _Count);
		}

	static _Elem *__cdecl _Move_s(_Elem *_First1, size_t _Size_in_words, const _Elem *_First2,
		size_t _Count)
		{	


		::wmemmove_s((_First1), (_Size_in_words), (_First2), (_Count));
		return (_Elem *)_First1;
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem _Ch)
		{	

		return ((_Elem *)::wmemset(_First, _Ch, _Count));
		}

	static _Elem __cdecl to_char_type(const int_type& _Meta)
		{	
		return (_Meta);
		}

	static int_type __cdecl to_int_type(const _Elem& _Ch)
		{	
		return (_Ch);
		}

	static bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right)
		{	
		return (_Left == _Right);
		}

	static int_type __cdecl eof()
		{	
		return ((wint_t)(0xFFFF));
		}

	static int_type __cdecl not_eof(const int_type& _Meta)
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}
	};


		
template<> struct __declspec(dllimport) char_traits<char>:
	public _Char_traits_base
	{	
	typedef char _Elem;
	typedef _Elem char_type;
	typedef int int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right)
		{	
		_Left = _Right;
		}

	static bool __cdecl eq(const _Elem& _Left, const _Elem& _Right)
		{	
		return (_Left == _Right);
		}

	static bool __cdecl lt(const _Elem& _Left, const _Elem& _Right)
		{	
		return (_Left < _Right);
		}

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	


		return (::memcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	

		return (::strlen(_First));
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		
		return _Copy_s(_First1, _Count, _First2, _Count);
		}

	static _Elem *__cdecl _Copy_s(_Elem *_First1, size_t _Size_in_bytes, const _Elem *_First2,
		size_t _Count)
		{	


		::memcpy_s((_First1), (_Size_in_bytes), (_First2), (_Count));
		return _First1;
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	

		return ((const _Elem *)::memchr(_First, _Ch, _Count));
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		
		return _Move_s(_First1, _Count, _First2, _Count);
		}

	static _Elem *__cdecl _Move_s(_Elem *_First1, size_t _Size_in_bytes, const _Elem *_First2,
		size_t _Count)
		{	


		::memmove_s((_First1), (_Size_in_bytes), (_First2), (_Count));
		return _First1;
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem _Ch)
		{	

		return ((_Elem *)::memset(_First, _Ch, _Count));
		}

	static _Elem __cdecl to_char_type(const int_type& _Meta)
		{	
		return ((_Elem)_Meta);
		}

	static int_type __cdecl to_int_type(const _Elem& _Ch)
		{	
		return ((unsigned char)_Ch);
		}

	static bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right)
		{	
		return (_Left == _Right);
		}

	static int_type __cdecl eof()
		{	
		return ((-1));
		}

	static int_type __cdecl not_eof(const int_type& _Meta)
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}
	};

		
	template <class _Traits>
	class _Inherits_from_char_traits_base
	{
		typedef char _True;
		class _False { char _Dummy[2]; };
		static _True _Inherits(_Char_traits_base);
		static _False _Inherits(...);
		static _Traits _Make_traits();

	public:
		enum { _Exists = sizeof(_Inherits(_Make_traits())) == sizeof(_True) };
	};

	template <class _Traits, bool _Inherits_from_char_traits_base>
	class _Char_traits_category_helper
	{
	public:
		typedef _Unsecure_char_traits_tag _Secure_char_traits;
	};

	
	
	template <class _Elem>
	class _Char_traits_category_helper< char_traits<_Elem> , true>
	{
	public:
		typedef _Secure_char_traits_tag _Secure_char_traits;
	};

	template <class _Traits>
	class _Char_traits_category_helper<_Traits, true>
	{
	public:
		typedef typename _Traits::_Secure_char_traits _Secure_char_traits;
	};

	template <class _Traits>
	class _Char_traits_category
	{
	public:
		typedef typename _Char_traits_category_helper<_Traits, _Inherits_from_char_traits_base<_Traits>::_Exists>::_Secure_char_traits _Secure_char_traits;
	};

	
	
	template<class _Traits> 
	inline
	typename _Char_traits_category<_Traits>::_Secure_char_traits _Char_traits_cat()
	{
		typename _Char_traits_category<_Traits>::_Secure_char_traits _Secure;
		return (_Secure);
	}

	namespace _Traits_helper
	{

		
	template<class _Traits>
	inline
	typename _Traits::char_type *copy_s(typename _Traits::char_type *_First1, size_t _Size,
		const typename _Traits::char_type *_First2, size_t _Count)
	{
		return copy_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());
	}

	template<class _Traits>
	inline
	typename _Traits::char_type *copy_s(typename _Traits::char_type *_First1, size_t _Size,
		const typename _Traits::char_type *_First2, size_t _Count, _Secure_char_traits_tag)
	{
		return _Traits::_Copy_s(_First1, _Size, _First2, _Count);
	}

	
	template<class _Traits>
	inline
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	typename _Traits::char_type *copy_s(typename _Traits::char_type *_First1, size_t _Size,
		const typename _Traits::char_type *_First2, size_t _Count, _Unsecure_char_traits_tag)
	{
		return _Traits::copy(_First1, _First2, _Count);
	}

		
	template<class _Traits>
	inline
	typename _Traits::char_type *move_s(typename _Traits::char_type *_First1, size_t _Size,
		const typename _Traits::char_type *_First2, size_t _Count)
	{
		return move_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());
	}

	template<class _Traits>
	inline
	typename _Traits::char_type *move_s(typename _Traits::char_type *_First1, size_t _Size,
		const typename _Traits::char_type *_First2, size_t _Count, _Secure_char_traits_tag)
	{
		return _Traits::_Move_s(_First1, _Size, _First2, _Count);
	}

	
	template<class _Traits>
	inline
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	typename _Traits::char_type *move_s(typename _Traits::char_type *_First1, size_t _Size,
		const typename _Traits::char_type *_First2, size_t _Count, _Unsecure_char_traits_tag)
	{
		return _Traits::move(_First1, _First2, _Count);
	}

	} 

		
template<class _Ty>
	class allocator;
class ios_base;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ios;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class istreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class ostreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_streambuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_istream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ostream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_iostream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringbuf;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_istringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_ostringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_filebuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ifstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ofstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_fstream;

 
template<class _Elem,
	class _InIt >
    class num_get;
template<class _Elem,
	class _OutIt >
    class num_put;
template<class _Elem>
    class collate;
 #line 696 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iosfwd"

		
typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
	allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
	allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
	allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
	allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;

		
typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
	wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;



 
typedef num_get<char, istreambuf_iterator<char, char_traits<char> > >
	numget;
typedef num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >
	wnumget;
typedef num_put<char, ostreambuf_iterator<char, char_traits<char> > >
	numput;
typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >
	wnumput;
typedef collate<char> ncollate;
typedef collate<wchar_t> wcollate;
 #line 750 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iosfwd"

}


#pragma warning(pop)
#pragma pack(pop)
#line 757 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iosfwd"

#line 759 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iosfwd"
#line 760 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iosfwd"





#line 7 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\utility"


#pragma pack(push,8)
#pragma warning(push,3)
#line 12 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\utility"

namespace std {
		
template<class _Ty> inline
	void swap(_Ty& _Left, _Ty& _Right)
	{	
	_Ty _Tmp = _Left;
	_Left = _Right, _Right = _Tmp;
	}

		
template<class _Ty1,
	class _Ty2> struct pair
	{	
	typedef pair<_Ty1, _Ty2> _Myt;
	typedef _Ty1 first_type;
	typedef _Ty2 second_type;

	pair()
		: first(_Ty1()), second(_Ty2())
		{	
		}

	pair(const _Ty1& _Val1, const _Ty2& _Val2)
		: first(_Val1), second(_Val2)
		{	
		}

	template<class _Other1,
		class _Other2>
		pair(const pair<_Other1, _Other2>& _Right)
		: first(_Right.first), second(_Right.second)
		{	
		}

	void swap(_Myt& _Right)
		{	
		std::swap(first, _Right.first);
		std::swap(second, _Right.second);
		}

	_Ty1 first;	
	_Ty2 second;	
	};

		
template<class _Ty1,
	class _Ty2> inline
	bool operator==(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Left.first == _Right.first && _Left.second == _Right.second);
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator!=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator<(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Left.first < _Right.first ||
		!(_Right.first < _Left.first) && _Left.second < _Right.second);
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator>(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator<=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator>=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Ty1,
	class _Ty2> inline
	pair<_Ty1, _Ty2> make_pair(_Ty1 _Val1, _Ty2 _Val2)
	{	
	return (pair<_Ty1, _Ty2>(_Val1, _Val2));
	}

template<class _Ty1,
	class _Ty2> inline
	void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)
	{	
	_Left.swap(_Right);
	}

		
	namespace rel_ops
		{	
template<class _Ty> inline
	bool  operator!=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty> inline
	bool operator>(const _Ty& _Left, const _Ty& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty> inline
	bool operator<=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty> inline
	bool operator>=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Left < _Right));
	}
		}
}


#pragma warning(pop)
#pragma pack(pop)
#line 154 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\utility"

#line 156 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\utility"
#line 157 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\utility"






















#line 8 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"



#pragma pack(push,8)
#pragma warning(push,3)
#line 14 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

namespace std {

		
struct _Unchecked_iterator_tag
	{
	};
struct _Range_checked_iterator_tag
	{
	};

		
struct _Unchanged_checked_iterator_base_type_tag
	{
	};

struct _Different_checked_iterator_base_type_tag
	{
	};

		
struct _Undefined_inner_type_tag
	{
	};

		
struct _Undefined_move_tag
	{
	};

struct _Swap_move_tag
	{
	};

		


		


 




__declspec(noreturn) __declspec(deprecated) __declspec(dllimport) void __cdecl _Debug_message(const char *, const char *);






__declspec(dllimport) void __cdecl _Debug_message(const wchar_t *, const wchar_t *, unsigned int line);


#line 70 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		





#line 78 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		
class _Iterator_base;

class __declspec(dllimport) _Container_base
	{	
public:
	friend class _Iterator_base;

	typedef _Undefined_move_tag _Move_category;

	 _Container_base()
		: _Myfirstiter(0)
		{	
		}

	 _Container_base(const _Container_base&)
		: _Myfirstiter(0)
		{	
		}

	_Container_base&  operator=(const _Container_base&)
		{	
		return (*this);
		}

	 ~_Container_base()
		{	
		_Orphan_all();
		}

	void  _Orphan_all() const;	
	void  _Swap_all(_Container_base&) const;	

	_Iterator_base *_Myfirstiter;
	};

		
class _Iterator_base
	{	
public:
	typedef _Unchecked_iterator_tag _Checked_iterator_category;
	typedef _Unchanged_checked_iterator_base_type_tag _Checked_iterator_base_type;
	typedef _Undefined_inner_type_tag _Inner_type;

	friend class _Container_base;

	 _Iterator_base()
		: _Mycont(0), _Mynextiter(0)
		{	
		}

	 _Iterator_base(const _Iterator_base& _Right)
		: _Mycont(0), _Mynextiter(0)
		{	
		*this = _Right;
		}

	_Iterator_base&  operator=(const _Iterator_base& _Right)
		{	
		if (_Mycont != _Right._Mycont)
			{	
			_Lockit _Lock(3);
			_Orphan_me();
			_Adopt(_Right._Mycont);
			}
		return (*this);
		}

	 ~_Iterator_base()
		{	
		_Lockit _Lock(3);
		_Orphan_me();
		}

	void  _Adopt(const _Container_base *_Parent)
		{	
		if (_Mycont != _Parent)
			{	
			_Lockit _Lock(3);
			_Orphan_me();
			if (_Parent != 0 && _Parent->_Myfirstiter != ((_Iterator_base *)-3))
				{	
				_Mynextiter = _Parent->_Myfirstiter;
				((_Container_base *)_Parent)->_Myfirstiter = this;
				}
			_Mycont = _Parent;
			}
		}

	void  _Orphan_me()
		{	
		if (_Mycont != 0 && _Mycont->_Myfirstiter != ((_Iterator_base *)-3))
			{	
			_Iterator_base **_Pnext =
				(_Iterator_base **)&_Mycont->_Myfirstiter;
			while (*_Pnext != 0 && *_Pnext != this)
				_Pnext = &(*_Pnext)->_Mynextiter;

			if (*_Pnext == 0)
				_Debug_message(L"ITERATOR LIST CORRUPTED!", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 178);
			*_Pnext = _Mynextiter;
			_Mycont = 0;
			}
		}

	const _Container_base *_Mycont;
	_Iterator_base *_Mynextiter;
	};

typedef _Iterator_base _Iterator_base_secure;

inline void  _Container_base::_Orphan_all() const
	{	
	_Lockit _Lock(3);
	if (_Myfirstiter != ((_Iterator_base *)-3))
		{
		for (_Iterator_base **_Pnext = (_Iterator_base **)&_Myfirstiter;
			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
			(*_Pnext)->_Mycont = 0;
		*(_Iterator_base **)&_Myfirstiter = 0;
		}
	}

inline void  _Container_base::_Swap_all(_Container_base& _Right) const
	{	
	_Lockit _Lock(3);
	_Iterator_base *_Pnext;
	_Iterator_base *_Temp = (_Iterator_base *)_Myfirstiter;
	*(_Iterator_base **)&_Myfirstiter = (_Iterator_base *)_Right._Myfirstiter;
	*(_Iterator_base **)&_Right._Myfirstiter = _Temp;

	if (_Myfirstiter != ((_Iterator_base *)-3))
		{
		for (_Pnext = (_Iterator_base *)_Myfirstiter;
			_Pnext != 0; _Pnext = _Pnext->_Mynextiter)
			_Pnext->_Mycont = this;
		}
	if (_Right._Myfirstiter != ((_Iterator_base *)-3))
		{
		for (_Pnext = (_Iterator_base *)_Right._Myfirstiter;
			_Pnext != 0; _Pnext = _Pnext->_Mynextiter)
			_Pnext->_Mycont = &_Right;
		}
	}

		
template<class _Iter> inline
	const _Container_base *__cdecl _Debug_get_cont(const _Iter&)
	{	
	return (0);
	}

inline const _Container_base *__cdecl _Debug_get_cont(const _Iterator_base& _Where)
	{	
	return (_Where._Mycont);
	}

		
 

template<class _Ty1, class _Ty2> inline
	bool __cdecl _Debug_lt(const _Ty1& _Left, const _Ty2& _Right,
		const wchar_t *_Where, unsigned int _Line)
	{	
	if (!(_Left < _Right))
		return (false);
	else if (_Right < _Left)
		_Debug_message(L"invalid operator<", _Where, _Line);
	return (true);
	}

template<class _Ty1, class _Ty2> inline
	bool __cdecl _Debug_lt(const _Ty1& _Left, _Ty2& _Right,
		const wchar_t *_Where, unsigned int _Line)
	{	
	if (!(_Left < _Right))
		return (false);
	else if (_Right < _Left)
		_Debug_message(L"invalid operator<", _Where, _Line);
	return (true);
	}

template<class _Ty1, class _Ty2> inline
	bool __cdecl _Debug_lt(_Ty1& _Left, const _Ty2& _Right,
		const wchar_t *_Where, unsigned int _Line)
	{	
	if (!(_Left < _Right))
		return (false);
	else if (_Right < _Left)
		_Debug_message(L"invalid operator<", _Where, _Line);
	return (true);
	}

template<class _Ty1, class _Ty2> inline
	bool __cdecl _Debug_lt(_Ty1& _Left, _Ty2& _Right,
		const wchar_t *_Where, unsigned int _Line)
	{	
	if (!(_Left < _Right))
		return (false);
	else if (_Right < _Left)
		_Debug_message(L"invalid operator<", _Where, _Line);
	return (true);
	}

		
 

template<class _Pr, class _Ty1, class _Ty2> inline
	bool __cdecl _Debug_lt_pred(_Pr _Pred, const _Ty1& _Left, const _Ty2& _Right,
		const wchar_t *_Where, unsigned int _Line)
	{	
	if (!_Pred(_Left, _Right))
		return (false);
	else if (_Pred(_Right, _Left))
		_Debug_message(L"invalid operator<", _Where, _Line);
	return (true);
	}

template<class _Pr, class _Ty1, class _Ty2> inline
	bool __cdecl _Debug_lt_pred(_Pr _Pred, const _Ty1& _Left, _Ty2& _Right,
		const wchar_t *_Where, unsigned int _Line)
	{	
	if (!_Pred(_Left, _Right))
		return (false);
	else if (_Pred(_Right, _Left))
		_Debug_message(L"invalid operator<", _Where, _Line);
	return (true);
	}

template<class _Pr, class _Ty1, class _Ty2> inline
	bool __cdecl _Debug_lt_pred(_Pr _Pred, _Ty1& _Left, const _Ty2& _Right,
		const wchar_t *_Where, unsigned int _Line)
	{	
	if (!_Pred(_Left, _Right))
		return (false);
	else if (_Pred(_Right, _Left))
		_Debug_message(L"invalid operator<", _Where, _Line);
	return (true);
	}

template<class _Pr, class _Ty1, class _Ty2> inline
	bool __cdecl _Debug_lt_pred(_Pr _Pred, _Ty1& _Left, _Ty2& _Right,
		const wchar_t *_Where, unsigned int _Line)
	{	
	if (!_Pred(_Left, _Right))
		return (false);
	else if (_Pred(_Right, _Left))
		_Debug_message(L"invalid operator<", _Where, _Line);
	return (true);
	}

 





































































































































#line 465 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"



		
struct input_iterator_tag
	{	
	};

struct output_iterator_tag
	{	
	};

struct forward_iterator_tag
	: public input_iterator_tag
	{	
	};

struct bidirectional_iterator_tag
	: public forward_iterator_tag
	{	
	};

struct random_access_iterator_tag
	: public bidirectional_iterator_tag
	{	
	};

struct _Int_iterator_tag
	{	
	};

struct _Float_iterator_tag
	{	
	};

		
struct _Nonscalar_ptr_iterator_tag
	{	
	};
struct _Scalar_ptr_iterator_tag
	{	
	};

		
template<class _Category,
	class _Ty,
	class _Diff = ptrdiff_t,
	class _Pointer = _Ty *,
	class _Reference = _Ty&>
		struct iterator
			: public _Iterator_base

	{	
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;
	typedef _Diff distance_type;	
	typedef _Pointer pointer;
	typedef _Reference reference;
	};

template<class _Category,
	class _Ty,
	class _Diff = ptrdiff_t,
	class _Pointer = _Ty *,
	class _Reference = _Ty&,
	class _Base_class = _Iterator_base>
		struct _Iterator_with_base
			: public _Base_class

	{	
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;
	typedef _Diff distance_type;	
	typedef _Pointer pointer;
	typedef _Reference reference;
	};

template<class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference>
	struct _Bidit
		: public _Iterator_base

	{	
	typedef bidirectional_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;
	typedef _Diff distance_type;	
	typedef _Pointer pointer;
	typedef _Reference reference;
	};

template<class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference>
	struct _Ranit
		: public _Iterator_base

	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;
	typedef _Diff distance_type;	
	typedef _Pointer pointer;
	typedef _Reference reference;
	};

template<class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Base_class>
	struct _Ranit_base
		: public _Base_class

	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;
	typedef _Diff distance_type;	
	typedef _Pointer pointer;
	typedef _Reference reference;
	};

struct _Outit
	: public iterator<output_iterator_tag, void, void,
		void, void>
	{	
	};

template <class _Base_class>
struct _Outit_with_base
	: public _Iterator_with_base<output_iterator_tag, void, void,
		void, void, _Base_class>
	{	
	};

		
template<class _Iter>
	struct iterator_traits
	{	
	typedef typename _Iter::iterator_category iterator_category;
	typedef typename _Iter::value_type value_type;
	typedef typename _Iter::difference_type difference_type;
	typedef difference_type distance_type;	
	typedef typename _Iter::pointer pointer;
	typedef typename _Iter::reference reference;
	};

template<class _Ty>
	struct iterator_traits<_Ty *>
	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;
	typedef ptrdiff_t distance_type;	
	typedef _Ty *pointer;
	typedef _Ty& reference;
	};

template<class _Ty>
	struct iterator_traits<const _Ty *>
	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;
	typedef ptrdiff_t distance_type;	
	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	};

template<> struct iterator_traits<_Bool>
	{	
	typedef _Int_iterator_tag iterator_category;
	typedef _Bool value_type;
	typedef _Bool difference_type;
	typedef _Bool distance_type;
	typedef _Bool * pointer;
	typedef _Bool& reference;
	};

template<> struct iterator_traits<char>
	{	
	typedef _Int_iterator_tag iterator_category;
	typedef char value_type;
	typedef char difference_type;
	typedef char distance_type;
	typedef char * pointer;
	typedef char& reference;
	};

template<> struct iterator_traits<signed char>
	{	
	typedef _Int_iterator_tag iterator_category;
	typedef signed char value_type;
	typedef signed char difference_type;
	typedef signed char distance_type;
	typedef signed char * pointer;
	typedef signed char& reference;
	};

template<> struct iterator_traits<unsigned char>
	{	
	typedef _Int_iterator_tag iterator_category;
	typedef unsigned char value_type;
	typedef unsigned char difference_type;
	typedef unsigned char distance_type;
	typedef unsigned char * pointer;
	typedef unsigned char& reference;
	};

 











template<> struct iterator_traits<short>
	{	
	typedef _Int_iterator_tag iterator_category;
	typedef short value_type;
	typedef short difference_type;
	typedef short distance_type;
	typedef short * pointer;
	typedef short& reference;
	};

template<> struct iterator_traits<unsigned short>
	{	
	typedef _Int_iterator_tag iterator_category;
	typedef unsigned short value_type;
	typedef unsigned short difference_type;
	typedef unsigned short distance_type;
	typedef unsigned short * pointer;
	typedef unsigned short& reference;
	};

template<> struct iterator_traits<int>
	{	
	typedef _Int_iterator_tag iterator_category;
	typedef int value_type;
	typedef int difference_type;
	typedef int distance_type;	
	typedef int * pointer;
	typedef int& reference;
	};

template<> struct iterator_traits<unsigned int>
	{	
	typedef _Int_iterator_tag iterator_category;
	typedef unsigned int value_type;
	typedef unsigned int difference_type;
	typedef unsigned int distance_type;	
	typedef unsigned int * pointer;
	typedef unsigned int& reference;
	};

template<> struct iterator_traits<long>
	{	
	typedef _Int_iterator_tag iterator_category;
	typedef long value_type;
	typedef long difference_type;
	typedef long distance_type;	
	typedef long * pointer;
	typedef long& reference;
	};

template<> struct iterator_traits<unsigned long>
	{	
	typedef _Int_iterator_tag iterator_category;
	typedef unsigned long value_type;
	typedef unsigned long difference_type;
	typedef unsigned long distance_type;	
	typedef unsigned long * pointer;
	typedef unsigned long& reference;
	};

template<> struct iterator_traits<double>
	{
	typedef _Float_iterator_tag iterator_category;
	typedef double value_type;
	typedef double difference_type;
	typedef double distance_type;	
	typedef double * pointer;
	typedef double& reference;
	};

template<> struct iterator_traits<float>
	{
	typedef _Float_iterator_tag iterator_category;
	typedef float value_type;
	typedef float difference_type;
	typedef float distance_type;	
	typedef float * pointer;
	typedef float& reference;
	};

 
template<> struct iterator_traits<__int64>
	{	
	typedef _Int_iterator_tag iterator_category;
	typedef __int64 value_type;
	typedef __int64 difference_type;
	typedef __int64 distance_type;	
	typedef __int64 * pointer;
	typedef __int64& reference;
	};

template<> struct iterator_traits<unsigned __int64>
	{	
	typedef _Int_iterator_tag iterator_category;
	typedef unsigned __int64 value_type;
	typedef unsigned __int64 difference_type;
	typedef unsigned __int64 distance_type;	
	typedef unsigned __int64 * pointer;
	typedef unsigned __int64& reference;
	};
 #line 793 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		
template<class _Iter> inline
	typename iterator_traits<_Iter>::iterator_category
		__cdecl _Iter_cat(const _Iter&)
	{	
	typename iterator_traits<_Iter>::iterator_category _Cat;
	return (_Cat);
	}

		
		
		
template<class _Cat1, class _Cat2>
	class _Iter_random_helper
	{
	public:
		typedef forward_iterator_tag _Iter_random_cat;
	};

template<>
	class _Iter_random_helper<random_access_iterator_tag, random_access_iterator_tag>
	{
	public:
		typedef random_access_iterator_tag _Iter_random_cat;
	};

template<class _Cat1, class _Cat2, class _Cat3>
	class _Iter_random_helper3
	{
	public:
		typedef forward_iterator_tag _Iter_random_cat;
	};

template<>
	class _Iter_random_helper3<random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag>
	{
	public:
		typedef random_access_iterator_tag _Iter_random_cat;
	};

template<class _Iter1, class _Iter2> inline
	typename _Iter_random_helper<
		typename iterator_traits<_Iter1>::iterator_category,
		typename iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat
		__cdecl _Iter_random(const _Iter1&, const _Iter2&)
	{	
	typename _Iter_random_helper<
		iterator_traits<_Iter1>::iterator_category, 
		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
	return (_Cat);
	}

template<class _Iter1, class _Iter2, class _Iter3> inline
	typename _Iter_random_helper3<
		typename iterator_traits<_Iter1>::iterator_category,
		typename iterator_traits<_Iter2>::iterator_category,
		typename iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat
		__cdecl _Iter_random(const _Iter1&, const _Iter2&, const _Iter3&)
	{	
	typename _Iter_random_helper3<
		iterator_traits<_Iter1>::iterator_category, 
		iterator_traits<_Iter2>::iterator_category,
		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
	return (_Cat);
	}

		
		
	template <bool _Cond, class _Ty1, class _Ty2>
	class _If
	{
	public:
		typedef _Ty2 _Result;
	};

	template <class _Ty1, class _Ty2>
	class _If<true, _Ty1, _Ty2>
	{
	public:
		typedef _Ty1 _Result;
	};

		
	template <bool _Secure_validation>
	class _Secure_validation_helper
	{
	public:
		typedef _Unchecked_iterator_tag _Checked_iterator_category;
	};

	template <>
	class _Secure_validation_helper<true>
	{
	public:
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
	};


		
	template <class _Iter, bool _Inherits_from_iterator_base>
	class _Checked_iterator_category_helper
	{
	public:
		typedef _Unchecked_iterator_tag _Checked_cat;
	};

	template <class _Iter>
	class _Checked_iterator_category_helper<_Iter, true>
	{
	public:
		typedef typename _Iter::_Checked_iterator_category _Checked_cat;
	};

	template <class _Iter>
	class _Checked_iterator_category
	{
	public:
		typedef typename _Checked_iterator_category_helper<_Iter, __is_base_of(_Iterator_base, _Iter)>::_Checked_cat _Checked_cat;
	};

	template<class _Iter> 
	inline
	typename _Checked_iterator_category<_Iter>::_Checked_cat _Checked_cat(const _Iter&)
	{
		typename _Checked_iterator_category<_Iter>::_Checked_cat _Cat;
		return (_Cat);
	}

		
	template <class _Iter, bool _Inherits_from_iterator_base>
	class _Checked_iterator_base_helper2
	{
	public:
		typedef _Unchanged_checked_iterator_base_type_tag _Checked_iterator_base_type;
	};

	template <class _Iter>
	class _Checked_iterator_base_helper2<_Iter, true>
	{
	public:
		typedef typename _Iter::_Checked_iterator_base_type _Checked_iterator_base_type;
	};

	template <class _Iter, class _Base_type>
	class _Checked_iterator_base_helper1
	{
	public:
		typedef _Different_checked_iterator_base_type_tag _Base_type_tag;
		typedef _Base_type _Checked_iterator_base_type;
	};

	template <class _Iter>
	class _Checked_iterator_base_helper1<_Iter, _Unchanged_checked_iterator_base_type_tag>
	{
	public:
		typedef _Unchanged_checked_iterator_base_type_tag _Base_type_tag;
		typedef _Iter _Checked_iterator_base_type;
	};

	template <class _Iter>
	class _Checked_iterator_base_helper
	{
	public:
		typedef _Checked_iterator_base_helper2<_Iter, __is_base_of(_Iterator_base, _Iter)> _Base_helper2;
		typedef _Checked_iterator_base_helper1<_Iter, typename  _Base_helper2::_Checked_iterator_base_type > _Base_helper1;

		typedef typename _Base_helper1::_Base_type_tag _Checked_iterator_base_type_tag;
		typedef typename _Base_helper1::_Checked_iterator_base_type _Checked_iterator_base_type;
	};

	template<class _Iter, class _Base_tag>
	inline
	typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type
		__cdecl _Checked_base(const _Iter &_It, _Base_tag)
	{
		return _It._Checked_iterator_base();
	}

	template<class _Iter>
	inline
	typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type
		__cdecl _Checked_base(const _Iter &_It, _Unchanged_checked_iterator_base_type_tag)
	{
		return _It;
	}

	template<class _Iter, class _Base_tag>
	inline
	typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type
		__cdecl _Checked_base(_Iter &_It, _Base_tag)
	{
		return _It._Checked_iterator_base();
	}

	template<class _Iter>
	inline
	typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type
		__cdecl _Checked_base(_Iter &_It, _Unchanged_checked_iterator_base_type_tag)
	{
		return _It;
	}

	template<class _Iter>
	inline
	typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type
		__cdecl _Checked_base(const _Iter &_It)
	{
		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
		return _Checked_base(_It, _Base_tag);
	}

	template<class _Iter>
	inline
	typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type
		__cdecl _Checked_base(_Iter &_It)
	{
		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
		return _Checked_base(_It, _Base_tag);
	}

		

	template<class _DstIter, class _BaseIter>
	inline
	void __cdecl _Checked_assign_from_base(_DstIter &_Dest, const _BaseIter &_Src)
	{
		_Dest._Checked_iterator_assign_from_base(_Src);
	}

	template<class _Iter>
	inline
	void __cdecl _Checked_assign_from_base(_Iter &_Dest, const _Iter &_Src)
	{
		_Dest = _Src;
	}

		
 
 
 #line 1034 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

	
	template <class _Value>
	class _Move_operation_category
	{
	public:
		typedef _Undefined_move_tag _Move_cat;
	};

	template<class _Iter>
	inline
		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Move_cat(const _Iter&)
	{
		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
		return (_Cat);
	}

		
template<class _T1, class _T2, class _Checked_Cat1, class _Checked_Cat2>
struct _Ptr_cat_with_checked_cat_helper
	{
	typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
	};

template<class _T1,	class _T2>
struct _Ptr_cat_helper
	{
	typedef typename _Ptr_cat_with_checked_cat_helper<_T1, _T2, 
		typename _Checked_iterator_category<_T1>::_Checked_cat,
		typename _Checked_iterator_category<_T2>::_Checked_cat>::_Ptr_cat _Ptr_cat;
	};

template<class _T1,	class _T2, class _Checked_Cat1>
struct _Ptr_cat_with_checked_cat_helper<_T1, _T2, _Checked_Cat1, _Range_checked_iterator_tag>
	{
	typedef typename _Ptr_cat_helper<_T1, typename _T2::_Inner_type>::_Ptr_cat _Ptr_cat;
	};

template<class _T1,	class _T2, class _Checked_Cat2>
struct _Ptr_cat_with_checked_cat_helper<_T1, _T2, _Range_checked_iterator_tag, _Checked_Cat2>
	{
	typedef typename _Ptr_cat_helper<typename _T1::_Inner_type, _T2>::_Ptr_cat _Ptr_cat;
	};

template<class _T1,	class _T2>
struct _Ptr_cat_with_checked_cat_helper<_T1, _T2, _Range_checked_iterator_tag, _Range_checked_iterator_tag>
	{
	typedef typename _Ptr_cat_helper<typename _T1::_Inner_type, typename _T2::_Inner_type>::_Ptr_cat _Ptr_cat;
	};

template<class _T1>
struct _Ptr_cat_helper<_T1, _Undefined_inner_type_tag>
	{
	typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
	};

template<class _T2>
struct _Ptr_cat_helper<_Undefined_inner_type_tag, _T2>
	{
	typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<_Undefined_inner_type_tag, _Undefined_inner_type_tag>
	{
	typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
	};

		
template<>
struct _Ptr_cat_helper<_Bool *, _Bool *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<const _Bool *, _Bool *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<char *, char *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<const char *, char *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<signed char *, signed char *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<const signed char *, signed char *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<unsigned char *, unsigned char *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<const unsigned char *, unsigned char *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

 














template<>
struct _Ptr_cat_helper<short *, short *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<const short *, short *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<unsigned short *, unsigned short *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<const unsigned short *, unsigned short *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<int *, int *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<const int *, int *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<unsigned int *, unsigned int *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<const unsigned int *, unsigned int *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<long *, long *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<const long *, long *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<unsigned long *, unsigned long *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<const unsigned long *, unsigned long *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<float *, float *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<const float *, float *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<double *, double *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<const double *, double *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<long double *, long double *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<const long double *, long double *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

 

template<>
struct _Ptr_cat_helper<__int64 *, __int64 *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<const __int64 *, __int64 *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<unsigned __int64 *, unsigned __int64 *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<>
struct _Ptr_cat_helper<const unsigned __int64 *, unsigned __int64 *>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

 #line 1301 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

template<class _Ty>
struct _Ptr_cat_helper<_Ty **, _Ty **>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<class _Ty>
struct _Ptr_cat_helper<_Ty **, const _Ty **>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<class _Ty>
struct _Ptr_cat_helper<_Ty *const *, _Ty **>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};

template<class _Ty>
struct _Ptr_cat_helper<_Ty *const *, const _Ty **>
	{	
	typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};


template<class _T1, class _T2> inline 
typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat __cdecl _Ptr_cat(_T1&, _T2&)
	{
	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
	return (_Cat);
	}


 
#line 1337 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"


 
#line 1341 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

 
		
 

 

 

 

 

 

 

 


		
template<class _InIt> inline
	void __cdecl _Debug_pointer(_InIt&, const wchar_t *, unsigned int)
	{	
	}

 
template<class _Ty> inline
	void __cdecl _Debug_pointer(const _Ty *_First, const wchar_t *_File, unsigned int _Line)
	{	
	if (_First == 0)
		_Debug_message(L"invalid null pointer", _File, _Line);
	}

template<class _Ty> inline
	void __cdecl _Debug_pointer(_Ty *_First, const wchar_t *_File, unsigned int _Line)
	{	
	if (_First == 0)
		_Debug_message(L"invalid null pointer", _File, _Line);
	}
 #line 1382 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		
template<class _InIt> inline
	void __cdecl _Debug_range2(_InIt, _InIt, const wchar_t *, unsigned int ,
		input_iterator_tag)
	{	
	}

template<class _RanIt> inline
	void __cdecl _Debug_range2(_RanIt _First, _RanIt _Last, const wchar_t *_File, unsigned int _Line,
		random_access_iterator_tag)
	{	
	if (_First != _Last)
		{	
		_Debug_pointer(_First, _File, _Line);
		_Debug_pointer(_Last, _File, _Line);
		if (_Last < _First)
			_Debug_message(L"invalid iterator range", _File, _Line);
		}
	}

template<class _InIt> inline
	void __cdecl _Debug_range(_InIt _First, _InIt _Last, const wchar_t *_File, unsigned int _Line)
	{	
	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));
	}

		
template<class _InIt> inline
	void __cdecl _Debug_order2(_InIt _First, _InIt _Last,
		const wchar_t *_File, unsigned int _Line, input_iterator_tag)
	{	
	}

template<class _FwdIt> inline
	void __cdecl _Debug_order2(_FwdIt _First, _FwdIt _Last,
		const wchar_t *_File, unsigned int _Line, forward_iterator_tag)
	{	
	if (_First != _Last)
		for (_FwdIt _Next = _First; ++_Next != _Last; ++_First)
			if (_Debug_lt(*_Next, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 1422))
				_Debug_message(L"sequence not ordered", _File, _Line);
	}

template<class _InIt> inline
	void __cdecl _Debug_order(_InIt _First, _InIt _Last,
		const wchar_t *_File, unsigned int _Line)
	{	
	_Debug_range(_First, _Last, _File, _Line);
	_Debug_order2(_First, _Last, _File, _Line, _Iter_cat(_First));
	}

		
template<class _InIt,
	class _Pr> inline
	void __cdecl _Debug_order2(_InIt _First, _InIt _Last, _Pr _Pred,
		const wchar_t *_File, unsigned int _Line, input_iterator_tag)
	{	
	}

template<class _FwdIt,
	class _Pr> inline
	void __cdecl _Debug_order2(_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		const wchar_t *_File, unsigned int _Line, forward_iterator_tag)
	{	
	if (_First != _Last)
		for (_FwdIt _Next = _First; ++_Next != _Last; ++_First)
			if (_Debug_lt_pred(_Pred, *_Next, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 1449))
				_Debug_message(L"sequence not ordered", _File, _Line);
	}

template<class _InIt,
	class _Pr> inline
	void __cdecl _Debug_order(_InIt _First, _InIt _Last, _Pr _Pred,
		const wchar_t *_File, unsigned int _Line)
	{	
	_Debug_range(_First, _Last, _File, _Line);
	_Debug_pointer(_Pred, _File, _Line);
	_Debug_order2(_First, _Last, _Pred, _File, _Line, _Iter_cat(_First));
	}

		
template<class _InIt> inline
	void __cdecl _Debug_order_single2(_InIt _First, _InIt _Last, bool _IsFirstIteration,
		const wchar_t *_File, unsigned int _Line, input_iterator_tag)
	{	
	}

template<class _FwdIt> inline
	void __cdecl _Debug_order_single2(_FwdIt _First, _FwdIt _Last, bool ,
		const wchar_t *_File, unsigned int _Line, forward_iterator_tag)
	{	
	if (_First != _Last)
		{
		_FwdIt _Next = _First;
		if (++_Next != _Last)
			if (_Debug_lt(*_Next, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 1478))
				_Debug_message(L"sequence not ordered", _File, _Line);
		}
	}

template<class _InIt> inline
	void __cdecl _Debug_order_single(_InIt _First, _InIt _Last, bool _IsFirstIteration,
		const wchar_t *_File, unsigned int _Line)
	{	
	_Debug_order_single2(_First, _Last, _IsFirstIteration, _File, _Line, _Iter_cat(_First));
	}

		
template<class _InIt,
	class _Pr> inline
	void __cdecl _Debug_order_single2(_InIt _First, _InIt _Last, _Pr _Pred, bool _IsFirstIteration,
		const wchar_t *_File, unsigned int _Line, input_iterator_tag)
	{	
	}

template<class _FwdIt,
	class _Pr> inline
	void __cdecl _Debug_order_single2(_FwdIt _First, _FwdIt _Last, _Pr _Pred, bool _IsFirstIteration,
		const wchar_t *_File, unsigned int _Line, forward_iterator_tag)
	{	
	if (_First != _Last)
		{
		_FwdIt _Next = _First;
		if (++_Next != _Last)
			if (_Debug_lt_pred(_Pred, *_Next, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 1507))
				_Debug_message(L"sequence not ordered", _File, _Line);
		}
	}

template<class _InIt,
	class _Pr> inline
	void __cdecl _Debug_order_single(_InIt _First, _InIt _Last, _Pr _Pred, bool _IsFirstIteration,
		const wchar_t *_File, unsigned int _Line)
	{	
	_Debug_order_single2(_First, _Last, _Pred, _IsFirstIteration, _File, _Line, _Iter_cat(_First));
	}

 









#line 1531 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

 

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


  
  
  
  
  
  
  
  

 






#line 1569 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		

template<class _Iter> inline
	typename iterator_traits<_Iter>::value_type *__cdecl _Val_type(_Iter)
	{	
	return (0);
	}

		
template<class _InIt,
	class _Diff> inline
	void __cdecl advance(_InIt& _Where, _Diff _Off)
	{	
	_Advance(_Where, _Off, _Iter_cat(_Where));
	}

template<class _InIt,
	class _Diff> inline
	void __cdecl _Advance(_InIt& _Where, _Diff _Off, input_iterator_tag)
	{	

 


 #line 1595 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _FI,
	class _Diff> inline
	void __cdecl _Advance(_FI& _Where, _Diff _Off, forward_iterator_tag)
	{	

 


 #line 1609 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

	for (; 0 < _Off; --_Off)
		++_Where;
	}

#pragma warning(push)
#pragma warning(disable: 6295)
template<class _BI,
	class _Diff> inline
	void __cdecl _Advance(_BI& _Where, _Diff _Off, bidirectional_iterator_tag)
	{	
	for (; 0 < _Off; --_Off)
		++_Where;
	for (; _Off < 0; ++_Off)
		--_Where;
	}
#pragma warning(pop)

template<class _RI,
	class _Diff> inline
	void __cdecl _Advance(_RI& _Where, _Diff _Off, random_access_iterator_tag)
	{	
	_Where += _Off;
	}

		

template<class _Iter> inline
	typename iterator_traits<_Iter>::difference_type
		* __cdecl _Dist_type(_Iter)
	{	
	return (0);
	}

		
template<class _InIt,
	class _Diff> inline
		void __cdecl _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,
			input_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _FwdIt,
	class _Diff> inline
		void __cdecl _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,
			forward_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _BidIt,
	class _Diff> inline
		void __cdecl _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,
			bidirectional_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _RanIt,
	class _Diff> inline
		void __cdecl _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,
			random_access_iterator_tag)
	{	

 
	if (_First != _Last)
		{	
		_Debug_pointer(_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility",1680);
		_Debug_pointer(_Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility",1681);
		}
 #line 1684 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

	_Off += _Last - _First;
	}

template<class _InIt> inline
	typename iterator_traits<_InIt>::difference_type
		__cdecl distance(_InIt _First, _InIt _Last)
	{	
	typename iterator_traits<_InIt>::difference_type _Off = 0;
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	return (_Off);
	}


template<class _InIt,
	class _Diff> inline
		void __cdecl _Distance(_InIt _First, _InIt _Last, _Diff& _Off)
	{	
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	}

		
template<class _RanIt>
	class reverse_iterator
		: public _Iterator_base_secure
	{	
public:
	typedef reverse_iterator<_RanIt> _Myt;
	typedef typename iterator_traits<_RanIt>::iterator_category iterator_category;
	typedef typename iterator_traits<_RanIt>::value_type value_type;
	typedef typename iterator_traits<_RanIt>::difference_type difference_type;
	typedef typename iterator_traits<_RanIt>::difference_type distance_type;	
	typedef typename iterator_traits<_RanIt>::pointer pointer;
	typedef typename iterator_traits<_RanIt>::reference reference;
	typedef _RanIt iterator_type;

	 reverse_iterator()
		{	
		}

	explicit  reverse_iterator(_RanIt _Right)
		: current(_Right)
		{	
		}

	template<class _Other>
		 reverse_iterator(const reverse_iterator<_Other>& _Right)
		: current(_Right.base())
		{	
		}

	_RanIt  base() const
		{	
		return (current);
		}


	typedef typename ::std:: _Checked_iterator_category<_RanIt>::_Checked_cat _Checked_iterator_category;
	typedef reverse_iterator<typename _Checked_iterator_base_helper<_RanIt>::_Checked_iterator_base_type> _Checked_iterator_base_type;
 
	_Checked_iterator_base_type _Checked_iterator_base() const
	{
		typename _Checked_iterator_base_type _Base(::std:: _Checked_base(current));
		return _Base;
	}

	void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
	{
		::std:: _Checked_assign_from_base(current, _Base.base());
	}
#line 1755 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

	reference  operator*() const
		{	
		_RanIt _Tmp = current;
		return (*--_Tmp);
		}

	pointer  operator->() const
		{	
		return (&**this);
		}

	_Myt&  operator++()
		{	
		--current;
		return (*this);
		}

	_Myt  operator++(int)
		{	
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt&  operator--()
		{	
		++current;
		return (*this);
		}

	_Myt  operator--(int)
		{	
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	template<class _Other>
		bool  _Equal(const reverse_iterator<_Other>& _Right) const
		{	
		return (current == _Right.base());
		}



	_Myt&  operator+=(difference_type _Off)
		{	
		current -= _Off;
		return (*this);
		}

	_Myt  operator+(difference_type _Off) const
		{	
		return (_Myt(current - _Off));
		}

	_Myt&  operator-=(difference_type _Off)
		{	
		current += _Off;
		return (*this);
		}

	_Myt  operator-(difference_type _Off) const
		{	
		return (_Myt(current + _Off));
		}

	reference  operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	template<class _Other>
		bool  _Less(const reverse_iterator<_Other>& _Right) const
		{	
		return (_Right.base() < current);
		}

	template<class _Other>
		difference_type  _Minus(const reverse_iterator<_Other>& _Right) const
		{	
		return (_Right.base() - current);
		}

protected:
	_RanIt current;	
	};

		
template<class _RanIt,
	class _Diff> inline
	reverse_iterator<_RanIt> __cdecl operator+(_Diff _Off,
		const reverse_iterator<_RanIt>& _Right)
	{	
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2> inline
	typename reverse_iterator<_RanIt1>::difference_type
		__cdecl operator-(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Minus(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool __cdecl operator==(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Equal(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool __cdecl operator!=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool __cdecl operator<(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Less(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool __cdecl operator>(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool __cdecl operator<=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool __cdecl operator>=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left < _Right));
	}

		
template<class _BidIt,
	class _Ty,
	class _Reference = _Ty&,
	class _Pointer = _Ty *,
	class _Diff = ptrdiff_t>
	class reverse_bidirectional_iterator
		: public iterator<bidirectional_iterator_tag, _Ty, _Diff,
			_Pointer, _Reference>
	{	
public:
	typedef reverse_bidirectional_iterator<_BidIt, _Ty, _Reference,
		_Pointer, _Diff> _Myt;
	typedef _BidIt iterator_type;

	 reverse_bidirectional_iterator()
		{	
		}

	explicit  reverse_bidirectional_iterator(_BidIt _Right)
		: current(_Right)
		{	
		}

	_BidIt  base() const
		{	
		return (current);
		}

	_Reference  operator*() const
		{	
		_BidIt _Tmp = current;
		return (*--_Tmp);
		}

	_Pointer  operator->() const
		{       
		_Reference _Tmp = **this;
		return (&_Tmp);
		}

	_Myt&  operator++()
		{	
		--current;
		return (*this);
		}

	_Myt  operator++(int)
		{	
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt&  operator--()
		{	
		++current;
		return (*this);
		}

	_Myt  operator--(int)
		{	
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	bool  operator==(const _Myt& _Right) const
		{	
		return (current == _Right.current);
		}

	bool  operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

protected:
	_BidIt current;	
	};

		
template<class _BidIt,
	class _BidIt2 = _BidIt>
	class _Revbidit
		: public iterator<
			typename iterator_traits<_BidIt>::iterator_category,
			typename iterator_traits<_BidIt>::value_type,
			typename iterator_traits<_BidIt>::difference_type,
			typename iterator_traits<_BidIt>::pointer,
			typename iterator_traits<_BidIt>::reference>
	{	
public:
	typedef _Revbidit<_BidIt, _BidIt2> _Myt;
	typedef typename iterator_traits<_BidIt>::difference_type _Diff;
	typedef typename iterator_traits<_BidIt>::pointer _Pointer;
	typedef typename iterator_traits<_BidIt>::reference _Reference;
	typedef _BidIt iterator_type;

	 _Revbidit()
		{	
		}

	explicit  _Revbidit(_BidIt _Right)
		: current(_Right)
		{	
		}

	 _Revbidit(const _Revbidit<_BidIt2>& _Other)
		: current (_Other.base())
		{	
		}

	_BidIt  base() const
		{	
		return (current);
		}

	_Reference  operator*() const
		{	
		_BidIt _Tmp = current;
		return (*--_Tmp);
		}

	_Pointer  operator->() const
		{	
		_Reference _Tmp = **this;
		return (&_Tmp);
		}

	_Myt&  operator++()
		{	
		--current;
		return (*this);
		}

	_Myt  operator++(int)
		{	
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt&  operator--()
		{	
		++current;
		return (*this);
		}

	_Myt  operator--(int)
		{	
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	bool  operator==(const _Myt& _Right) const
		{	
		return (current == _Right.current);
		}

	bool  operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

protected:
	_BidIt current;
	};

		
template<class _Elem,
	class _Traits>
	class istreambuf_iterator
		: public _Iterator_with_base<input_iterator_tag,
			_Elem, typename _Traits::off_type, _Elem *, _Elem&, _Iterator_base_secure>
	{	
	typedef istreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_istream<_Elem, _Traits> istream_type;
	typedef typename traits_type::int_type int_type;

	 istreambuf_iterator(streambuf_type *_Sb = 0) throw ()
		: _Strbuf(_Sb), _Got(_Sb == 0)
		{	
		}

	 istreambuf_iterator(istream_type& _Istr) throw ()
		: _Strbuf(_Istr.rdbuf()), _Got(_Istr.rdbuf() == 0)
		{	
		}

	_Elem  operator*() const
		{	
		if (!_Got)
			((_Myt *)this)->_Peek();

 
		if (_Strbuf == 0)
			_Debug_message(L"istreambuf_iterator is not dereferencable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2112);
 #line 2114 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		return (_Val);
		}

	_Myt&  operator++()
		{	

 
		if (_Strbuf == 0)
			_Debug_message(L"istreambuf_iterator is not incrementable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2123);
 #line 2125 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		_Inc();
		return (*this);
		}

	_Myt  operator++(int)
		{	
		if (!_Got)
			_Peek();
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	bool  equal(const _Myt& _Right) const
		{	
		if (!_Got)
			((_Myt *)this)->_Peek();
		if (!_Right._Got)
			((_Myt *)&_Right)->_Peek();
		return (_Strbuf == 0 && _Right._Strbuf == 0
			|| _Strbuf != 0 && _Right._Strbuf != 0);
		}

private:
	void  _Inc()
		{	
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Strbuf->sbumpc()))
			_Strbuf = 0, _Got = true;
		else
			_Got = false;
		}

	_Elem  _Peek()
		{	
		int_type _Meta;
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Meta = _Strbuf->sgetc()))
			_Strbuf = 0;
		else
			_Val = traits_type::to_char_type(_Meta);
		_Got = true;
		return (_Val);
		}

	streambuf_type *_Strbuf;	
	bool _Got;	
	_Elem _Val;	
	};

		
template<class _Elem,
	class _Traits> inline
	bool __cdecl operator==(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	
	return (_Left.equal(_Right));
	}

template<class _Elem,
	class _Traits> inline
	bool __cdecl operator!=(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	
	return (!(_Left == _Right));
	}

		
template<class _Elem,
	class _Traits>
	class ostreambuf_iterator
		: public _Outit_with_base<_Iterator_base_secure>
	{	
	typedef ostreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_ostream<_Elem, _Traits> ostream_type;

	typedef _Range_checked_iterator_tag _Checked_iterator_category;

	 ostreambuf_iterator(streambuf_type *_Sb) throw ()
		: _Failed(false), _Strbuf(_Sb)
		{	
		}

	 ostreambuf_iterator(ostream_type& _Ostr) throw ()
		: _Failed(false), _Strbuf(_Ostr.rdbuf())
		{	
		}

	_Myt&  operator=(_Elem _Right)
		{	
		if (_Strbuf == 0
			|| traits_type::eq_int_type(_Traits::eof(),
				_Strbuf->sputc(_Right)))
			_Failed = true;
		return (*this);
		}

	_Myt&  operator*()
		{	
		return (*this);
		}

	_Myt&  operator++()
		{	
		return (*this);
		}

	_Myt&  operator++(int)
		{	
		return (*this);
		}

	bool  failed() const throw ()
		{	
		return (_Failed);
		}

private:
	bool _Failed;	
	streambuf_type *_Strbuf;	
	};



		
template<class _InIt, class _OutIt, class _InOutItCat>
inline
	_OutIt __cdecl _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
		_InOutItCat, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2264);
	for (; _First != _Last; ++_Dest, ++_First)
		*_Dest = *_First;
	return (_Dest);
	}


template<class _InIt, class _OutIt>
inline
	_OutIt __cdecl _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
		random_access_iterator_tag, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{	
	
	_OutIt _Result = _Dest + (_Last - _First);
	_Copy_opt(_First, _Last, ::std:: _Checked_base(_Dest), 
		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());
	return _Result;
	}
#line 2283 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

template<class _InIt, class _OutIt, class _InOutItCat>
inline
	_OutIt __cdecl _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
		_InOutItCat, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{	

 
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2291);
	if (_First != _Last)
		_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility",2293);
 #line 2295 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

	ptrdiff_t _Off = _Last - _First;	
	
	_OutIt _Result = _Dest + _Off;
	if (_Off > 0)
		::memmove_s((&*_Dest), (_Off * sizeof (*_First)), (&*_First), (_Off * sizeof (*_First)));
	return _Result;
	}

template <bool _Cond, class _Result_type>
struct _Enable_if;

template <class _Result_type>
struct _Enable_if<true, _Result_type>
{
	typedef _Result_type _Result;
};

template <class _Checked_iter_cat>
struct _Is_checked_iterator_helper
{
	enum { _Result = false };
};

template <>
struct _Is_checked_iterator_helper<_Range_checked_iterator_tag>
{
	enum { _Result = true };
};

template <class _Iter>
struct _Is_checked_iterator
{
	enum { _Result = 
		_Is_checked_iterator_helper<typename _Checked_iterator_category<_Iter>::_Checked_cat>::_Result };
};





















template<class _InIt, class _OutIt>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
	return (_Copy_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, 
		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag()));
	}

template<class _InIt, class _OutElem, size_t _Size>
inline
_OutElem* __cdecl copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size])
	{	
	return copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), ::stdext:: make_checked_array_iterator(_Dest, _Size)).base();
	}

template<class _InIt, class _OutIt>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
	return (_Copy_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, 
		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag()));
	}











#line 2387 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		
template<class _InIt, class _OutIt, class _InOutItCat, class _MoveCatTy>
inline
	_OutIt __cdecl _Move_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
		_InOutItCat _First_dest_cat, _MoveCatTy, _Range_checked_iterator_tag)
	{	
	return _Copy_opt(_First, _Last, _Dest,
		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());
	}

template<class _InIt, class _OutIt, class _InOutItCat>
inline
	_OutIt __cdecl _Move_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
		_InOutItCat, _Swap_move_tag, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2403);
	for (; _First != _Last; ++_Dest, ++_First)
		::std:: swap(*_Dest, *_First);
	return (_Dest);
	}


template<class _InIt, class _OutIt, class _InOutItCat>
inline
	_OutIt __cdecl _Move_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
		random_access_iterator_tag, _Swap_move_tag _Move_cat, _Range_checked_iterator_tag)
	{	
	
	_OutIt _Result = _Dest + (_Last - _First);
	_Move_opt(_First, _Last, ::std:: _Checked_base(_Dest),
		forward_iterator_tag(), _Move_cat, _Range_checked_iterator_tag());
	return _Result;
	}
#line 2422 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"



template<class _InIt, class _OutIt>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl _Move(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
	return _Move_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		_Iter_random(_First, _Dest), _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt, class _OutElem, size_t _Size>
inline
_OutElem* __cdecl _Move(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size])
	{	
	return _Move(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last),
		::stdext:: make_checked_array_iterator(_Dest, _Size)).base();
	}

template<class _InIt, class _OutIt>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl _Move(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
	return _Move_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		_Iter_random(_First, _Dest), _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
	}











#line 2461 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		
template<class _BidIt1, class _BidIt2, class _InOutItCat>
inline
	_BidIt2 __cdecl _Copy_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest,
		_InOutItCat, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2468);
	while (_First != _Last)
		*--_Dest = *--_Last;
	return (_Dest);
	}


template<class _InIt, class _OutIt>
inline
	_OutIt __cdecl _Copy_backward_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
		random_access_iterator_tag, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{	
	
	_OutIt _Result = _Dest - (_Last - _First);
	_Copy_backward_opt(_First, _Last, ::std:: _Checked_base(_Dest),
		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());
	return _Result;
	}
#line 2487 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

template<class _InIt, class _OutIt, class _InOutItCat>
inline
	_OutIt __cdecl _Copy_backward_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
		_InOutItCat, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{	

 
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2495);
	if (_First != _Last)
		_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility",2497);
 #line 2499 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

	ptrdiff_t _Off = _Last - _First;	
	


	_OutIt _Result = _Dest - _Off;
	if (_Off > 0)
		::memmove_s((&*_Result), (_Off * sizeof (*_First)), (&*_First), (_Off * sizeof (*_First)));
	return _Result;
	}



template<class _BidIt1,
	class _BidIt2> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	
	return _Copy_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt1,
	class _BidIt2> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	
	return _Copy_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}











#line 2540 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		
template<class _BidIt1, class _BidIt2, class _InOutItCat, class _MoveCatTy>
inline
	_BidIt2 __cdecl _Move_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest,
		_InOutItCat _First_dest_cat, _MoveCatTy, _Range_checked_iterator_tag)
	{	
	return _Copy_backward_opt(_First, _Last, _Dest,
		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());
	}

template<class _BidIt1, class _BidIt2, class _InOutItCat>
inline
	_BidIt2 __cdecl _Move_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest,
		_InOutItCat, _Swap_move_tag, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2556);
	while (_First != _Last)
		::std:: swap(*--_Dest, *--_Last);
	return (_Dest);
	}


template<class _BidIt1, class _BidIt2>
inline
	_BidIt2 __cdecl _Move_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest,
		random_access_iterator_tag, _Swap_move_tag _Move_cat, _Range_checked_iterator_tag)
	{	
	
	_BidIt2 _Result = _Dest - (_Last - _First);
	_Move_backward_opt(_First, _Last, ::std:: _Checked_base(_Dest),
		forward_iterator_tag(), _Move_cat, _Range_checked_iterator_tag());
	return _Result;
	}
#line 2575 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"



template<class _BidIt1, class _BidIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl _Move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	
	return _Move_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		_Iter_random(_First, _Dest), _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt1, class _BidIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl _Move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	
	return _Move_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		_Iter_random(_First, _Dest), _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
	}











#line 2606 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		
template<class _InIt1, class _InIt2, class _InItCats>
inline
	pair<_InIt1, _InIt2>
		__cdecl _Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
			_InItCats, _Range_checked_iterator_tag)
	{	

 
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2616);
	if (_First1 != _Last1)
		_Debug_pointer(_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility",2618);
 #line 2620 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

	for (; _First1 != _Last1 && *_First1 == *_First2; )
		++_First1, ++_First2;
	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}


template<class _InIt1, class _InIt2>
inline
	pair<_InIt1, _InIt2>
		__cdecl _Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
			random_access_iterator_tag, _Range_checked_iterator_tag)
	{	
	
	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);
	pair<_InIt1, typename ::std:: _Checked_iterator_base_helper<_InIt2>::_Checked_iterator_base_type> _Result =
		_Mismatch(_First1, _Last1, ::std:: _Checked_base(_First2),
			forward_iterator_tag(), _Range_checked_iterator_tag());
	::std:: _Checked_assign_from_base(_First2, _Result.second);
	return (pair<_InIt1, _InIt2>(_Result.first, _First2));
	}
#line 2642 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"



template<class _InIt1, class _InIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
		__cdecl mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	
	pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
		_Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
			_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	::std:: _Checked_assign_from_base(_First1, _Result.first);
	return (pair<_InIt1, _InIt2>(_First1, _Result.second));
	}

template<class _InIt1, class _InElem2, size_t _Size>
inline
pair<_InIt1, _InElem2*>
		__cdecl mismatch(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size])
	{	
	pair<_InIt1, ::stdext:: checked_array_iterator<_InElem2*> > _Result =
		mismatch(_First1, _Last1, ::stdext:: make_checked_array_iterator(_First2, _Size));
	return (pair<_InIt1, _InElem2*>(_Result.first, _Result.second.base()));
	}

template<class _InIt1, class _InIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
		__cdecl mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	
	pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
		_Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
			_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	::std:: _Checked_assign_from_base(_First1, _Result.first);
	return (pair<_InIt1, _InIt2>(_First1, _Result.second));
	}












#line 2692 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		
template<class _InIt1, class _InIt2, class _Pr, class _InItCats>
inline
	pair<_InIt1, _InIt2>
		__cdecl _Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred,
			_InItCats, _Range_checked_iterator_tag)
	{	

 
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2702);
	if (_First1 != _Last1)
		_Debug_pointer(_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility",2704);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility",2705);
 #line 2707 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

	for (; _First1 != _Last1 && _Pred(*_First1, *_First2); )
		++_First1, ++_First2;
	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}


template<class _InIt1, class _InIt2, class _Pr>
inline
	pair<_InIt1, _InIt2>
		__cdecl _Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred,
			random_access_iterator_tag, _Range_checked_iterator_tag)
	{	
	
	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);
	pair<_InIt1, typename ::std:: _Checked_iterator_base_helper<_InIt2>::_Checked_iterator_base_type> _Result =
		_Mismatch(_First1, _Last1, ::std:: _Checked_base(_First2), _Pred,
			forward_iterator_tag(), _Range_checked_iterator_tag());
	::std:: _Checked_assign_from_base(_First2, _Result.second);
	return (pair<_InIt1, _InIt2>(_Result.first, _First2));
	}
#line 2729 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"



template<class _InIt1, class _InIt2, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
		__cdecl mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{	
	pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
		_Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
			_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	::std:: _Checked_assign_from_base(_First1, _Result.first);
	return (pair<_InIt1, _InIt2>(_First1, _Result.second));
	}

template<class _InIt1, class _InElem2, class _Pr, size_t _Size>
inline
pair<_InIt1, _InElem2*>
		__cdecl mismatch(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size], _Pr _Pred)
	{	
	pair<_InIt1, ::stdext:: checked_array_iterator<_InElem2*> > _Result =
		mismatch(_First1, _Last1, ::stdext:: make_checked_array_iterator(_First2, _Size), _Pred);
	return (pair<_InIt1, _InElem2*>(_Result.first, _Result.second.base()));
	}

template<class _InIt1, class _InIt2, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
		__cdecl mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{	
	pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
		_Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
			_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	::std:: _Checked_assign_from_base(_First1, _Result.first);
	return (pair<_InIt1, _InIt2>(_First1, _Result.second));
	}












#line 2779 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		
template<class _InIt1, class _InIt2, class _InItCats>
inline
	bool __cdecl _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
		_InItCats, _Range_checked_iterator_tag)
	{	
	return (_Mismatch(_First1, _Last1, _First2,
		forward_iterator_tag(), _Range_checked_iterator_tag()).first == _Last1);
	}

inline bool __cdecl _Equal(const char *_First1,
	const char *_Last1, const char *_First2,
	random_access_iterator_tag, _Range_checked_iterator_tag)
	{	
 
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2795);
	if (_First1 != _Last1)
		_Debug_pointer(_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility",2797);
 #line 2799 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

	return (::memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool __cdecl _Equal(const signed char *_First1,
	const signed char *_Last1, const signed char *_First2,
	random_access_iterator_tag, _Range_checked_iterator_tag)
	{	
 
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2808);
	if (_First1 != _Last1)
		_Debug_pointer(_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility",2810);
 #line 2812 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

	return (::memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool __cdecl _Equal(const unsigned char *_First1,
	const unsigned char *_Last1, const unsigned char *_First2,
	random_access_iterator_tag, _Range_checked_iterator_tag)
	{	
 
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2821);
	if (_First1 != _Last1)
		_Debug_pointer(_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility",2823);
 #line 2825 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

	return (::memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}


template<class _InIt1, class _InIt2>
inline
	bool __cdecl _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
		random_access_iterator_tag, _Range_checked_iterator_tag)
	{
	
	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);
	return _Equal(_First1, _Last1, ::std:: _Checked_base(_First2),
		forward_iterator_tag(), _Range_checked_iterator_tag());
	}
#line 2841 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"



template<class _InIt1, class _InIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	
	return _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
		_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InElem2, size_t _Size>
inline
bool __cdecl equal(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size])
	{	
	return equal(_First1, _Last1,
		::stdext:: make_checked_array_iterator(_First2, _Size));
	}

template<class _InIt1, class _InIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	
	return _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
		_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	}











#line 2880 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		
template<class _InIt1, class _InIt2, class _Pr, class _InItCats>
inline
	bool __cdecl _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred,
		_InItCats, _Range_checked_iterator_tag)
	{	
	return (_Mismatch(_First1, _Last1, _First2, _Pred,
		forward_iterator_tag(), _Range_checked_iterator_tag()).first == _Last1);
	}


template<class _InIt1, class _InIt2, class _Pr>
inline
	bool __cdecl _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred,
		random_access_iterator_tag, _Range_checked_iterator_tag)
	{
	
	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);
	return _Equal(_First1, _Last1, ::std:: _Checked_base(_First2), _Pred,
		forward_iterator_tag(), _Range_checked_iterator_tag());
	}
#line 2903 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"



template<class _InIt1, class _InIt2, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{	
	return _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
		_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InElem2, class _Pr, size_t _Size>
inline
bool __cdecl equal(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size], _Pr _Pred)
	{	
	return equal(_First1, _Last1,
		::stdext:: make_checked_array_iterator(_First2, _Size), _Pred);
	}

template<class _InIt1, class _InIt2, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{	
	return _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
		_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	}











#line 2942 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		
template<class _FwdIt, class _Ty> inline
	void __cdecl _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2947);
	for (; _First != _Last; ++_First)
		*_First = _Val;
	}

inline void __cdecl _Fill(       char *_First, 
	       char *_Last, int _Val)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2955);
	::memset(_First, _Val, _Last - _First);
	}

inline void __cdecl _Fill(       signed char *_First, 
	       signed char *_Last, int _Val)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2962);
	::memset(_First, _Val, _Last - _First);
	}

inline void __cdecl _Fill(
	       unsigned char *_First,
	       unsigned char *_Last, int _Val)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 2970);
	::memset(_First, _Val, _Last - _First);
	}

template<class _FwdIt, class _Ty> inline
	void __cdecl fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_Fill(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val);
	}

		
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	void __cdecl _Fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val,
		_Range_checked_iterator_tag)
	{	
	for (; 0 < _Count; --_Count, ++_First)
		*_First = _Val;
	}

inline void __cdecl _Fill_n(         char *_First, 
		size_t _Count, int _Val, _Range_checked_iterator_tag)
	{	

 
	if (0 < _Count)
		_Debug_pointer(_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility",2997);
 #line 2999 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

	::memset(_First, _Val, _Count);
	}

inline void __cdecl _Fill_n(         signed char *_First, 
		size_t _Count, int _Val, _Range_checked_iterator_tag)
	{	

 
	if (0 < _Count)
		_Debug_pointer(_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility",3009);
 #line 3011 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

	::memset(_First, _Val, _Count);
	}

inline void __cdecl _Fill_n(         unsigned char *_First, 
		size_t _Count, int _Val, _Range_checked_iterator_tag)
	{	

 
	if (0 < _Count)
		_Debug_pointer(_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility",3021);
 #line 3023 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

	::memset(_First, _Val, _Count);
	}

template<class _OutIt, class _Diff, class _Ty, class _OutCat>
inline
	void __cdecl _Fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val,
		_OutCat, _Range_checked_iterator_tag)
	{
		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());
	}


template<class _OutIt, class _Diff, class _Ty>
inline
	void __cdecl _Fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val,
		random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		
		_OutIt _Last = _First + _Count; (_Last);
		_Fill_n(::std:: _Checked_base(_First), _Count, _Val,
			_Range_checked_iterator_tag());
	}
#line 3047 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"



template<class _OutIt,
	class _Diff,
	class _Ty>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result __cdecl fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val)
	{	
		_Fill_n(_First, _Count, _Val, _Iter_cat(_First), ::std:: _Range_checked_iterator_tag());
	}

template<class _OutElem,
	class _Diff,
	class _Ty, size_t _Size>
inline
void __cdecl fill_n(_OutElem (&_First)[_Size], _Diff _Count, const _Ty& _Val)
	{	
		fill_n(::stdext:: make_checked_array_iterator(_First, _Size), _Count, _Val);
	}

template<class _OutIt,
	class _Diff,
	class _Ty>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result __cdecl fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val)
	{	
		_Fill_n(_First, _Count, _Val, _Iter_cat(_First), ::std:: _Range_checked_iterator_tag());
	}











#line 3089 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		
template<class _InIt1, class _InIt2> inline
	bool __cdecl _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3095);
	_Debug_range(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3096);
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (_Debug_lt(*_First1, *_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3098))
			return (true);
		else if (*_First2 < *_First1)
			return (false);
	return (_First1 == _Last1 && _First2 != _Last2);
	}

template<class _InIt1, class _InIt2> inline
	bool __cdecl lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	return _Lexicographical_compare(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2));
	}

inline bool __cdecl lexicographical_compare(
	const unsigned char *_First1, const unsigned char *_Last1,
	const unsigned char *_First2, const unsigned char *_Last2)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3117);
	_Debug_range(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3118);
	ptrdiff_t _Num1 = _Last1 - _First1;
	ptrdiff_t _Num2 = _Last2 - _First2;
	int _Ans = ::memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
	return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);
	}

 











#line 3138 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool __cdecl _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3146);
	_Debug_range(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3147);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility",3148);
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3150))
			return (true);
		else if (_Pred(*_First2, *_First1))
			return (false);
	return (_First1 == _Last1 && _First2 != _Last2);
	}

template<class _InIt1, class _InIt2, class _Pr> inline
	bool __cdecl lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	return _Lexicographical_compare(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Pred);
	}

 
  
  
 #line 3169 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

 
  
  
  
  
 


#line 3179 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

		
template<class _Ty> inline
	const _Ty& (__cdecl max)(const _Ty& _Left, const _Ty& _Right)
	{	
	return (_Debug_lt(_Left, _Right, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3184) ? _Right : _Left);
	}

		
template<class _Ty,
	class _Pr> inline
	const _Ty& (__cdecl max)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{	
	return (_Debug_lt_pred(_Pred, _Left, _Right, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3192) ? _Right : _Left);
	}

		
template<class _Ty> inline
	const _Ty& (__cdecl min)(const _Ty& _Left, const _Ty& _Right)
	{	
	return (_Debug_lt(_Right, _Left, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3199) ? _Right : _Left);
	}

		
template<class _Ty,
	class _Pr> inline
	const _Ty& (__cdecl min)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{	
	return (_Debug_lt_pred(_Pred, _Right, _Left, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3207) ? _Right : _Left);
	}

  
  

}

namespace stdext {


template <class _Iterator>
	class checked_array_iterator
		: public ::std:: iterator<
			typename ::std:: iterator_traits<_Iterator>::iterator_category, 
			typename ::std:: iterator_traits<_Iterator>::value_type, 
			typename ::std:: iterator_traits<_Iterator>::difference_type, 
			typename ::std:: iterator_traits<_Iterator>::pointer, 
			typename ::std:: iterator_traits<_Iterator>::reference>
	{
public:
	typedef checked_array_iterator<_Iterator> _Myt;
	typedef typename ::std:: iterator_traits<_Iterator>::difference_type difference_type;
	typedef typename ::std:: iterator_traits<_Iterator>::pointer pointer;
	typedef typename ::std:: iterator_traits<_Iterator>::reference reference;

	typedef ::std:: _Range_checked_iterator_tag _Checked_iterator_category;
	typedef _Iterator _Inner_type;

	typedef _Iterator _Checked_iterator_base_type;
 
	_Checked_iterator_base_type _Checked_iterator_base() const
	{
		return _Mycont + _Current;
	}

	void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
	{
		_Current = _Base - _Mycont;
	}

	

	checked_array_iterator():
		_Size(0), _Current(0)
	{
	}

	checked_array_iterator(_Iterator _Cont, size_t _S, size_t _Index = 0)
	{
		{ if (!(_Index <= _S)) { (void) ((!!((("_Index <= _S", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3257, 0, L"(\"_Index <= _S\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3257, 0); } ; };
		_Mycont = _Cont;
		_Size = _S;
		_Current =_Index;
	}

	_Iterator base() const
	{
		return _Mycont + _Current;
	}

	size_t __Size() const
	{
		return _Size;
	}

	bool operator==(const _Myt& _Right) const
	{
		{ if (!(_Mycont == _Right._Mycont)) { (void) ((!!((("_Mycont == _Right._Mycont", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3275, 0, L"(\"_Mycont == _Right._Mycont\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3275, 0); } ; };
		return _Current == _Right._Current;
	}

	bool operator!=(const _Myt& _Right) const
	{
		return !(*this == _Right);
	}

	bool operator<(const _Myt& _Right) const
	{
		{ if (!(_Mycont == _Right._Mycont)) { (void) ((!!((("_Mycont == _Right._Mycont", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3286, 0, L"(\"_Mycont == _Right._Mycont\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3286, 0); } ; };
		return _Current < _Right._Current;
	}

	bool operator>(const _Myt& _Right) const
	{
		return _Right < *this;
	}

	bool operator<=(const _Myt& _Right) const
	{
		return !(_Right < *this);
	}

	bool operator>=(const _Myt& _Right) const
	{
		return !(*this < _Right);
	}

	reference operator*() const
	{
		{ if (!(_Current < _Size)) { (void) ((!!((("_Current < _Size", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3307, 0, L"(\"_Current < _Size\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3307, 0); } ; };
		return *(_Mycont + _Current);
	}

	pointer operator->() const
	{
		return (&**this);
	}

	checked_array_iterator& operator++()
	{
		{ if (!(_Current < _Size)) { (void) ((!!((("_Current < _Size", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3318, 0, L"(\"_Current < _Size\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3318, 0); } ; };
		++_Current;
		return *this;
	}

	_Myt operator++(int)
	{
		checked_array_iterator _Tmp = *this;
		++*this;
		return _Tmp;
	}

	_Myt& operator--()
	{
		{ if (!(_Current > 0)) { (void) ((!!((("_Current > 0", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3332, 0, L"(\"_Current > 0\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3332, 0); } ; };
		--_Current;
		return *this;
	}

	_Myt operator--(int)
	{
		checked_array_iterator _Tmp = *this;
		--*this;
		return _Tmp;
	}

	

	_Myt& operator+=(difference_type _Off)
	{
		{ if (!(_Current + _Off <= _Size && _Current + _Off >= 0)) { (void) ((!!((("_Current + _Off <= _Size && _Current + _Off >= 0", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3348, 0, L"(\"_Current + _Off <= _Size && _Current + _Off >= 0\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3348, 0); } ; };
		_Current += _Off;
		return *this;
	}

	_Myt operator+(difference_type _Off) const
	{
		checked_array_iterator _Tmp = *this;
		return (_Tmp += _Off);
	}

	_Myt& operator-=(difference_type _Off)
	{
		return (*this += -_Off);
	}

	_Myt operator-(difference_type _Off) const
	{
		checked_array_iterator _Tmp = *this;
		return (_Tmp -= _Off);
	}

	difference_type operator-(const checked_array_iterator& _Right) const
	{
		{ if (!(_Mycont == _Right._Mycont)) { (void) ((!!((("_Mycont == _Right._Mycont", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3372, 0, L"(\"_Mycont == _Right._Mycont\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3372, 0); } ; };
		return _Current - _Right._Current;
	}

	reference operator[](difference_type _Off) const
	{
		{ if (!(_Current + _Off < _Size && _Current + _Off >= 0)) { (void) ((!!((("_Current + _Off < _Size && _Current + _Off >= 0", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3378, 0, L"(\"_Current + _Off < _Size && _Current + _Off >= 0\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility", 3378, 0); } ; };
		return *(_Mycont + _Current + _Off);
	}

protected:
	void _Xran() const
	{	
		throw ::std:: out_of_range("invalid checked_array_iterator<T> subscript");
	}

	void _Xinvarg() const
	{	
		throw ::std:: invalid_argument("invalid checked_array_iterator<T> argument");
	}

	_Iterator _Mycont; 
	size_t _Current; 
	size_t _Size; 
	};

template <class _Iter>
checked_array_iterator<_Iter> make_checked_array_iterator(_Iter _Ptr, size_t _Size)
{
	return checked_array_iterator<_Iter>(_Ptr, _Size);
}

template<class _InIt,
	class _OutIt> inline
	_OutIt __cdecl unchecked_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
		return (::std:: _Copy_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
			::std:: _Iter_random(_First, _Dest), ::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt, class _OutIt>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl checked_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
	return (::std:: _Copy_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, 
		::std:: _Iter_random(_First, _Dest), ::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt, class _OutElem, size_t _Size>
inline
_OutElem* __cdecl checked_copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size])
	{	
	return checked_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), ::stdext:: make_checked_array_iterator(_Dest, _Size)).base();
	}

template<class _InIt, class _OutIt>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl checked_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
	return (::std:: _Copy_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, 
		::std:: _Iter_random(_First, _Dest), ::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 __cdecl unchecked_copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	
		return (::std:: _Copy_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
			::std:: _Iter_random(_First, _Dest), ::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _BidIt1,
	class _BidIt2> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl checked_copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	
	return ::std:: _Copy_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		::std:: _Iter_random(_First, _Dest), ::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt1,
	class _BidIt2> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl checked_copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	
	return ::std:: _Copy_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		::std:: _Iter_random(_First, _Dest), ::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt __cdecl _Unchecked_move(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
		return (::std:: _Move_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
			::std:: _Iter_random(_First, _Dest), ::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt, class _OutIt>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl _Checked_move(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
	return ::std:: _Move_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		::std:: _Iter_random(_First, _Dest), ::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt, class _OutElem, size_t _Size>
inline
_OutElem* __cdecl _Checked_move(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size])
	{	
	return _Checked_move(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last),
		::stdext:: make_checked_array_iterator(_Dest, _Size)).base();
	}

template<class _InIt, class _OutIt>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl _Checked_move(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
	return ::std:: _Move_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		::std:: _Iter_random(_First, _Dest), ::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 __cdecl _Unchecked_move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	
		return (::std:: _Move_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
			::std:: _Iter_random(_First, _Dest), ::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _BidIt1, class _BidIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl _Checked_move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	
	return ::std:: _Move_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		::std:: _Iter_random(_First, _Dest), ::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt1, class _BidIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl _Checked_move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	
	return ::std:: _Move_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		::std:: _Iter_random(_First, _Dest), ::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	void __cdecl unchecked_fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val)
	{	
		::std:: _Fill_n(_First, _Count, _Val, ::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag());
	}

template<class _OutIt,
	class _Diff,
	class _Ty>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result __cdecl checked_fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val)
	{	
		_Fill_n(_First, _Count, _Val, ::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag());
	}

template<class _OutElem,
	class _Diff,
	class _Ty, size_t _Size>
inline
void __cdecl checked_fill_n(_OutElem (&_First)[_Size], _Diff _Count, const _Ty& _Val)
	{	
		checked_fill_n(::stdext:: make_checked_array_iterator( _First, _Size), _Count, _Val);
	}

template<class _OutIt,
	class _Diff,
	class _Ty>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result __cdecl checked_fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val)
	{	
		_Fill_n(_First, _Count, _Val, ::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2>
inline
	::std:: pair<_InIt1, _InIt2>
		__cdecl unchecked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	

	::std:: pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
		::std:: _Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
			::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	::std:: _Checked_assign_from_base(_First1, _Result.first);
	return (::std:: pair<_InIt1, _InIt2>(_First1, _Result.second));



#line 3570 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"
	}

template<class _InIt1, class _InIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
		__cdecl checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	
	::std:: pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
		::std:: _Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
			::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	::std:: _Checked_assign_from_base(_First1, _Result.first);
	return (::std:: pair<_InIt1, _InIt2>(_First1, _Result.second));
	}

template<class _InIt1, class _InElem2, size_t _Size>
inline
::std:: pair<_InIt1, _InElem2*>
		__cdecl checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size])
	{	
	::std:: pair<_InIt1, ::stdext:: checked_array_iterator<_InElem2*> > _Result =
		checked_mismatch(_First1, _Last1, ::stdext:: make_checked_array_iterator(_First2, _Size));
	return (::std:: pair<_InIt1, _InElem2*>(_Result.first, _Result.second.base()));
	}

template<class _InIt1, class _InIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
		__cdecl checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	
	::std:: pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
		::std:: _Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
			::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	::std:: _Checked_assign_from_base(_First1, _Result.first);
	return (::std:: pair<_InIt1, _InIt2>(_First1, _Result.second));
	}

template<class _InIt1, class _InIt2, class _Pr>
inline
	::std:: pair<_InIt1, _InIt2>
		__cdecl unchecked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{	

	::std:: pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
		::std:: _Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
			::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	::std:: _Checked_assign_from_base(_First1, _Result.first);
	return (::std:: pair<_InIt1, _InIt2>(_First1, _Result.second));



#line 3622 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"
	}

template<class _InIt1, class _InIt2, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
		__cdecl checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{	
	::std:: pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
		::std:: _Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
			::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	::std:: _Checked_assign_from_base(_First1, _Result.first);
	return (::std:: pair<_InIt1, _InIt2>(_First1, _Result.second));
	}

template<class _InIt1, class _InElem2, class _Pr, size_t _Size>
inline
::std:: pair<_InIt1, _InElem2*>
		__cdecl checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size], _Pr _Pred)
	{	
	::std:: pair<_InIt1, ::stdext:: checked_array_iterator<_InElem2*> > _Result =
		checked_mismatch(_First1, _Last1, ::stdext:: make_checked_array_iterator(_First2, _Size), _Pred);
	return (::std:: pair<_InIt1, _InElem2*>(_Result.first, _Result.second.base()));
	}

template<class _InIt1, class _InIt2, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
		__cdecl checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{	
	::std:: pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
		::std:: _Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
			::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	::std:: _Checked_assign_from_base(_First1, _Result.first);
	return (::std:: pair<_InIt1, _InIt2>(_First1, _Result.second));
	}

template<class _InIt1, class _InIt2>
inline
	bool __cdecl unchecked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	
	return ::std:: _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
		::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl checked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	
	return ::std:: _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
		::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InElem2, size_t _Size>
inline
bool __cdecl checked_equal(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size])
	{	
	return checked_equal(_First1, _Last1,
		::stdext:: make_checked_array_iterator(_First2, _Size));
	}

template<class _InIt1, class _InIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl checked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	
	return ::std:: _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
		::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _Pr>
inline
	bool __cdecl unchecked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{	
	return ::std:: _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
		::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl checked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{	
	return ::std:: _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
		::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InElem2, class _Pr, size_t _Size>
inline
bool __cdecl checked_equal(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size], _Pr _Pred)
	{	
	return checked_equal(_First1, _Last1,
		::stdext:: make_checked_array_iterator(_First2, _Size), _Pred);
	}

template<class _InIt1, class _InIt2, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl checked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{	
	return ::std:: _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
		::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	}

}



 
 

 
 

 





#line 3742 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

 








 




 














#line 3773 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"
extern "C"
#line 3775 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"
__declspec(dllimport) void __cdecl _invalid_parameter(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t);






#line 3783 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"



#pragma warning(pop)
#pragma pack(pop)
#line 3789 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"

#line 3791 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"
#line 3792 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xutility"























#line 10 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xmemory"


#pragma pack(push,8)
#pragma warning(push,3)

 #pragma warning(disable: 4100)
#line 17 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xmemory"


 
 
 
#line 23 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xmemory"

 

 

 

 


namespace std {
		
template<class _Ty> inline
	_Ty  *_Allocate(size_t _Count, _Ty  *)
	{	
	if (_Count <= 0)
		_Count = 0;
	else if (((size_t)(-1) / _Count) < sizeof (_Ty))
		throw std::bad_alloc(0);

		
	return ((_Ty  *)::operator new(_Count * sizeof (_Ty)));
	}

		
template<class _T1,
	class _T2> inline
	void _Construct(_T1  *_Ptr, const _T2& _Val)
	{	
	void  *_Vptr = _Ptr;
	::new (_Vptr) _T1(_Val);
	}

		
template<class _Ty> inline
	void _Destroy(_Ty  *_Ptr)
	{	
	(_Ptr)->~_Ty();
	}

template<> inline
	void _Destroy(char  *)
	{	
	}

template<> inline
	void _Destroy(wchar_t  *)
	{	
	}


		
template<class _Ty>
	struct _Allocator_base
	{	
	typedef _Ty value_type;
	};

		
template<class _Ty>
	struct _Allocator_base<const _Ty>
	{	
	typedef _Ty value_type;
	};

		
template<class _Ty>
	class allocator
		: public _Allocator_base<_Ty>
	{	
public:
	typedef _Allocator_base<_Ty> _Mybase;
	typedef typename _Mybase::value_type value_type;
	typedef value_type  *pointer;
	typedef value_type & reference;
	typedef const value_type  *const_pointer;
	typedef const value_type & const_reference;

	typedef size_t size_type;
	typedef ptrdiff_t difference_type;

	template<class _Other>
		struct rebind
		{	
		typedef allocator<_Other> other;
		};

	pointer address(reference _Val) const
		{	
		return (&_Val);
		}

	const_pointer address(const_reference _Val) const
		{	
		return (&_Val);
		}

	allocator() throw ()
		{	
		}

	allocator(const allocator<_Ty>&) throw ()
		{	
		}

	template<class _Other>
		allocator(const allocator<_Other>&) throw ()
		{	
		}

	template<class _Other>
		allocator<_Ty>& operator=(const allocator<_Other>&)
		{	
		return (*this);
		}

	void deallocate(pointer _Ptr, size_type)
		{	
		::operator delete(_Ptr);
		}

	pointer allocate(size_type _Count)
		{	
		return (_Allocate(_Count, (pointer)0));
		}

	pointer allocate(size_type _Count, const void  *)
		{	
		return (allocate(_Count));
		}

	void construct(pointer _Ptr, const _Ty& _Val)
		{	
		_Construct(_Ptr, _Val);
		}

	void destroy(pointer _Ptr)
		{	
		_Destroy(_Ptr);
		}

	size_t max_size() const throw ()
		{	
		size_t _Count = (size_t)(-1) / sizeof (_Ty);
		return (0 < _Count ? _Count : 1);
		}
	};

		
template<class _Ty,
	class _Other> inline
	bool operator==(const allocator<_Ty>&, const allocator<_Other>&) throw ()
	{	
	return (true);
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const allocator<_Ty>&, const allocator<_Other>&) throw ()
	{	
	return (false);
	}

		
template<> class __declspec(dllimport) allocator<void>
	{	
public:
	typedef void _Ty;
	typedef _Ty  *pointer;
	typedef const _Ty  *const_pointer;
	typedef _Ty value_type;

	template<class _Other>
		struct rebind
		{	
		typedef allocator<_Other> other;
		};

	allocator() throw ()
		{	
		}

	allocator(const allocator<_Ty>&) throw ()
		{	
		}

	template<class _Other>
		allocator(const allocator<_Other>&) throw ()
		{	
		}

	template<class _Other>
		allocator<_Ty>& operator=(const allocator<_Other>&)
		{	
		return (*this);
		}
	};

		
template<class _Ty,
	class _Alloc> inline
	void _Destroy_range(_Ty *_First, _Ty *_Last, _Alloc& _Al)
	{	
	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
	}

template<class _Ty,
	class _Alloc> inline
	void _Destroy_range(_Ty *_First, _Ty *_Last, _Alloc& _Al,
		_Nonscalar_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		_Al.destroy(_First);
	}

template<class _Ty,
	class _Alloc> inline
	void _Destroy_range(_Ty *_First, _Ty *_Last, _Alloc& _Al,
		_Scalar_ptr_iterator_tag)
	{	
	}
}


  #pragma warning(default: 4100)

#pragma warning(pop)
#pragma pack(pop)
#line 252 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xmemory"

#line 254 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xmemory"
#line 255 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xmemory"






















#line 7 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"


#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable:4412)
#line 13 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

 
 

namespace std {

  #pragma warning(disable:4251)

template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Ax = allocator<_Elem> >
	class basic_string;

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class _String_const_iterator
		: public _Ranit_base<_Elem, typename _Alloc::difference_type,
			typename _Alloc::const_pointer, typename _Alloc::const_reference, _Iterator_base_secure>
	{	
public:
	typedef _String_const_iterator<_Elem, _Traits, _Alloc> _Myt;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystring;

	typedef random_access_iterator_tag iterator_category;
	typedef _Elem value_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef typename _Alloc::const_pointer pointer;
	typedef typename _Alloc::const_reference reference;


	typedef _Range_checked_iterator_tag _Checked_iterator_category;
#line 47 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"













#line 61 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

	 _String_const_iterator()
		{	
		_Myptr = 0;
		}

 
 

	 _String_const_iterator(pointer _Ptr, const _Container_base *_Pstring)
		{	
		{ if (!(_Pstring == 0 || _Ptr != 0 && ((_Mystring *)_Pstring)->_Myptr() <= _Ptr && _Ptr <= (((_Mystring *)_Pstring)->_Myptr() + ((_Mystring *)_Pstring)->_Mysize))) { (void) ((!!((("_Pstring == NULL || _Ptr != NULL && ((_Mystring *)_Pstring)->_Myptr() <= _Ptr && _Ptr <= (((_Mystring *)_Pstring)->_Myptr() + ((_Mystring *)_Pstring)->_Mysize)", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 75, 0, L"(\"_Pstring == NULL || _Ptr != NULL && ((_Mystring *)_Pstring)->_Myptr() <= _Ptr && _Ptr <= (((_Mystring *)_Pstring)->_Myptr() + ((_Mystring *)_Pstring)->_Mysize)\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 75, 0); } ; };
#line 76 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"
		this->_Adopt(_Pstring);
		_Myptr = _Ptr;
		}

 



















#line 101 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

	reference  operator*() const
		{	

 
		if (this->_Mycont == 0 || _Myptr == 0
			|| _Myptr < ((_Mystring *)this->_Mycont)->_Myptr()
			|| ((_Mystring *)this->_Mycont)->_Myptr()
				+ ((_Mystring *)this->_Mycont)->_Mysize <= _Myptr)
			{
			_Debug_message(L"string iterator not dereferencable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 111);
			{ (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 112, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 112, 0); };
			}
		;
 





#line 122 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

		return (*_Myptr);
		}

	pointer  operator->() const
		{	
		return (&**this);
		}

	_Myt&  operator++()
		{	
		if (this->_Mycont != ((const _Container_base *)-2))
		{
			{ if (!(this->_Mycont != 0)) { (void) ((!!((("this->_Mycont != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 135, 0, L"(\"this->_Mycont != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 135, 0); } ; };
			{ if (!(_Myptr < (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize))) { (void) ((!!((("_Myptr < (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize)", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 136, 0, L"(\"_Myptr < (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize)\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 136, 0); } ; };
		}
		++_Myptr;
		return (*this);
		}

	_Myt  operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt&  operator--()
		{	
		if (this->_Mycont != ((const _Container_base *)-2))
		{
			{ if (!(this->_Mycont != 0)) { (void) ((!!((("this->_Mycont != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 153, 0, L"(\"this->_Mycont != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 153, 0); } ; };
			{ if (!(_Myptr > ((_Mystring *)this->_Mycont)->_Myptr())) { (void) ((!!((("_Myptr > ((_Mystring *)this->_Mycont)->_Myptr()", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 154, 0, L"(\"_Myptr > ((_Mystring *)this->_Mycont)->_Myptr()\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 154, 0); } ; };
		}
		--_Myptr;
		return (*this);
		}

	_Myt  operator--(int)
		{	
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt&  operator+=(difference_type _Off)
		{	
		if (this->_Mycont != ((const _Container_base *)-2))
		{
			{ if (!(this->_Mycont != 0)) { (void) ((!!((("this->_Mycont != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 171, 0, L"(\"this->_Mycont != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 171, 0); } ; };
			{ if (!(_Myptr + _Off <= (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize) && _Myptr + _Off >= ((_Mystring *)this->_Mycont)->_Myptr())) { (void) ((!!((("_Myptr + _Off <= (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize) && _Myptr + _Off >= ((_Mystring *)this->_Mycont)->_Myptr()", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 174, 0, L"(\"_Myptr + _Off <= (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize) && _Myptr + _Off >= ((_Mystring *)this->_Mycont)->_Myptr()\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 174, 0); } ; };
#line 175 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"
		}
		_Myptr += _Off;
		return (*this);
		}

	_Myt  operator+(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt&  operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myt  operator-(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type  operator-(const _Myt& _Right) const
		{	

 
		_Compat(_Right);
 




#line 208 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

		return (_Myptr - _Right._Myptr);
		}

	reference  operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool  operator==(const _Myt& _Right) const
		{	

 
		_Compat(_Right);
 




#line 228 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

		return (_Myptr == _Right._Myptr);
		}

	bool  operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool  operator<(const _Myt& _Right) const
		{	

 
		_Compat(_Right);
 




#line 248 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

		return (_Myptr < _Right._Myptr);
		}

	bool  operator>(const _Myt& _Right) const
		{	
		return (_Right < *this);
		}

	bool  operator<=(const _Myt& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool  operator>=(const _Myt& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void  _Compat(const _Myt& _Right) const
		{	
		if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
			{
			_Debug_message(L"string iterators incompatible", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 272);
			{ (void) ((!!((("Standard C++ Libraries Invalid Argument", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 273, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 273, 0); };
			}
		}
 #line 277 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

	static void __cdecl _Xlen()
		{
		_Mystring::_Xlen();
		}

	static void __cdecl _Xran()
		{
		_Mystring::_Xran();
		}

	static void __cdecl _Xinvarg()
		{
		_Mystring::_Xinvarg();
		}

	pointer _Myptr;	
	};

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	_String_const_iterator<_Elem, _Traits, _Alloc> __cdecl operator+(
		typename _String_const_iterator<_Elem, _Traits, _Alloc>
			::difference_type _Off,
		_String_const_iterator<_Elem, _Traits, _Alloc> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class _String_iterator
		: public _String_const_iterator<_Elem, _Traits, _Alloc>
	{	
public:
	typedef _String_iterator<_Elem, _Traits, _Alloc> _Myt;
	typedef _String_const_iterator<_Elem, _Traits, _Alloc> _Mybase;

	typedef random_access_iterator_tag iterator_category;
	typedef _Elem value_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef typename _Alloc::pointer pointer;
	typedef typename _Alloc::reference reference;

	 _String_iterator()
		{	
		}

 
 

	 _String_iterator(pointer _Ptr, const _Container_base *_Pstring)
		: _Mybase(_Ptr, _Pstring)
		{	
		}

  













#line 351 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"













#line 365 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

	reference  operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer  operator->() const
		{	
		return (&**this);
		}

	_Myt&  operator++()
		{	
		++(*(_Mybase *)this);
		return (*this);
		}

	_Myt  operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt&  operator--()
		{	
		--(*(_Mybase *)this);
		return (*this);
		}

	_Myt  operator--(int)
		{	
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt&  operator+=(difference_type _Off)
		{	
		(*(_Mybase *)this) += _Off;
		return (*this);
		}

	_Myt  operator+(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt&  operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myt  operator-(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type  operator-(const _Mybase& _Right) const
		{	
		return ((_Mybase)*this - _Right);
		}

	reference  operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	_String_iterator<_Elem, _Traits, _Alloc>  operator+(
		typename _String_iterator<_Elem, _Traits, _Alloc>
			::difference_type _Off,
		_String_iterator<_Elem, _Traits, _Alloc> _Next)
	{	
	return (_Next += _Off);
	}

		
class __declspec(dllimport) _String_base
		: public _Container_base
	{	
public:
	 static void __cdecl _Xlen();	

	 static void __cdecl _Xran();	

	 static void __cdecl _Xinvarg();
	};

		
template<class _Ty,
	class _Alloc>
	class _String_val
		: public _String_base
	{	
protected:
	typedef typename _Alloc::template
		rebind<_Ty>::other _Alty;

	 _String_val(_Alty _Al = _Alty())
		: _Alval(_Al)
		{	
		}

public:
	 _String_val(const _String_val &_Right)
		: _Alval(_Right._Alval)
		{	

		if (_Right._Myfirstiter == ((_Iterator_base *)-3))
			{
			this->_Myfirstiter = ((_Iterator_base *)-3);
			}
#line 484 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"
		}

protected:
	_Alty _Alval;	
	};

		
template<class _Elem,
	class _Traits,
	class _Ax>
	class basic_string
		: public _String_val<_Elem, _Ax>
	{	
public:
	typedef basic_string<_Elem, _Traits, _Ax> _Myt;
	typedef _String_val<_Elem, _Ax> _Mybase;
	typedef typename _Mybase::_Alty _Alloc;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type _Dift;
	typedef _Dift difference_type;
	typedef typename _Alloc::pointer _Tptr;
	typedef typename _Alloc::const_pointer _Ctptr;
	typedef _Tptr pointer;
	typedef _Ctptr const_pointer;
	typedef typename _Alloc::reference _Reft;
	typedef _Reft reference;
	typedef typename _Alloc::const_reference const_reference;
	typedef typename _Alloc::value_type value_type;

  

	typedef _String_iterator<_Elem, _Traits, _Alloc> iterator;
	typedef _String_const_iterator<_Elem, _Traits, _Alloc> const_iterator;


	friend class _String_const_iterator<_Elem, _Traits, _Alloc>;

	typedef std::reverse_iterator<iterator> reverse_iterator;
	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    

    




    





#line 538 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

    




    



#line 549 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

  
	struct _Has_debug_it
	{
		bool _Value;
		explicit _Has_debug_it(bool _Val): _Value(_Val) { }
	};
  #line 557 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

 #line 559 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

 







#line 569 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

  

	 basic_string(_Has_debug_it _Hdi = _Has_debug_it(true))
		: _Mybase()
		{	
		if (!_Hdi._Value)
			{
			this->_Myfirstiter = ((_Iterator_base *)-3);
			}
		_Tidy();
		}

  











#line 595 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

 #line 597 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

 

	explicit  basic_string(const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		}

	 basic_string(const _Myt& _Right, size_type _Roff,
		size_type _Count = npos)
		: _Mybase()
		{	

		if (_Right._Myfirstiter == ((_Iterator_base *)-3))
			{
			this->_Myfirstiter = ((_Iterator_base *)-3);
			}
#line 616 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	 basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
		const _Alloc& _Al)
		: _Mybase(_Al)
		{	

		if (_Right._Myfirstiter == ((_Iterator_base *)-3))
			{
			this->_Myfirstiter = ((_Iterator_base *)-3);
			}
#line 630 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	 basic_string(const _Elem *_Ptr, size_type _Count)
		: _Mybase()
		{	
		_Tidy();
		assign(_Ptr, _Count);
		}

	 basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ptr, _Count);
		}

	 basic_string(const _Elem *_Ptr)
		: _Mybase()
		{	
		_Tidy();
		assign(_Ptr);
		}

	 basic_string(const _Elem *_Ptr, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ptr);
		}

	 basic_string(size_type _Count, _Elem _Ch)
		: _Mybase()
		{	
		_Tidy();
		assign(_Count, _Ch);
		}

	 basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Count, _Ch);
		}

	template<class _It>
		 basic_string(_It _First, _It _Last)
		: _Mybase()
		{	
		_Tidy();
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _It>
		 basic_string(_It _First, _It _Last, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	 basic_string(const_pointer _First, const_pointer _Last)
		: _Mybase()
		{	

		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 696);
#line 698 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"
		_Tidy();
		if (_First != _Last)
			assign(&*_First, _Last - _First);
		}

	 basic_string(const_iterator _First, const_iterator _Last)
		: _Mybase()
		{	

		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 707);
#line 709 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"
		_Tidy();
		if (_First != _Last)
			assign(&*_First, _Last - _First);
		}

 #line 715 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

	
	
	 basic_string(const _Myt& _Right)
		: _Mybase(_Right)
		{	
		_Tidy();
		assign(_Right, 0, npos);
		}

 

  































































































































#line 856 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

 #line 858 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

	template<class _It>
		void  _Construct(_It _Count,
			_It _Ch, _Int_iterator_tag)
		{	
		assign((size_type)_Count, (_Elem)_Ch);
		}

	template<class _It>
		void  _Construct(_It _First,
			_It _Last, input_iterator_tag)
		{	
		try {
		for (; _First != _Last; ++_First)
			append((size_type)1, (_Elem)*_First);
		} catch (...) {
		_Tidy(true);
		throw;
		}
		}

	template<class _It>
		void  _Construct(_It _First,
			_It _Last, forward_iterator_tag)
		{	

		
		if (this->_Myfirstiter != ((_Iterator_base *)-3))
			{
			_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 887);
			}
#line 890 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"
		size_type _Count = 0;
		_Distance(_First, _Last, _Count);
		reserve(_Count);

		try {
		for (; _First != _Last; ++_First)
			append((size_type)1, (_Elem)*_First);
		} catch (...) {
		_Tidy(true);
		throw;
		}
		}

	 ~basic_string()
		{	
		_Tidy(true);
		}

	typedef _Traits traits_type;
	typedef _Alloc allocator_type;

	 static const size_type npos;	

	_Myt&  operator=(const _Myt& _Right)
		{	
		return (assign(_Right));
		}

	_Myt&  operator=(const _Elem *_Ptr)
		{	
		return (assign(_Ptr));
		}

	_Myt&  operator=(_Elem _Ch)
		{	
		return (assign(1, _Ch));
		}

	_Myt&  operator+=(const _Myt& _Right)
		{	
		return (append(_Right));
		}

	_Myt&  operator+=(const _Elem *_Ptr)
		{	
		return (append(_Ptr));
		}

	_Myt&  operator+=(_Elem _Ch)
		{	
		return (append((size_type)1, _Ch));
		}

	_Myt&  append(const _Myt& _Right)
		{	
		return (append(_Right, 0, npos));
		}

	_Myt&  append(const _Myt& _Right,
		size_type _Roff, size_type _Count)
		{	
		if (_Right.size() < _Roff)
			_String_base::_Xran();	
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	
		if (npos - _Mysize <= _Count || _Mysize + _Count < _Mysize)
			_String_base::_Xlen();	

		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{	
			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize,
				_Right._Myptr() + _Roff, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt&  append(const _Elem *_Ptr, size_type _Count)
		{	
		if (_Inside(_Ptr))
			return (append(*this, _Ptr - _Myptr(), _Count));	
		if (npos - _Mysize <= _Count || _Mysize + _Count < _Mysize)
			_String_base::_Xlen();	

		size_type _Num;
		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{	
			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize, _Ptr, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt&  append(const _Elem *_Ptr)
		{	
		return (append(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt&  append(size_type _Count, _Elem _Ch)
		{	
			if (npos - _Mysize <= _Count)
			_String_base::_Xlen();	

		size_type _Num;
		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{	
			_Chassign(_Mysize, _Count, _Ch);
			_Eos(_Num);
			}
		return (*this);
		}

	template<class _It>
		_Myt&  append(_It _First, _It _Last)
		{	
		return (_Append(_First, _Last, _Iter_cat(_First)));
		}

	template<class _It>
		_Myt&  _Append(_It _Count, _It _Ch, _Int_iterator_tag)
		{	
		return (append((size_type)_Count, (_Elem)_Ch));
		}

	template<class _It>
		_Myt&  _Append(_It _First, _It _Last, input_iterator_tag)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt&  append(const_pointer _First, const_pointer _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt&  append(const_iterator _First, const_iterator _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt&  assign(const _Myt& _Right)
		{	
		return (assign(_Right, 0, npos));
		}

	_Myt&  assign(const _Myt& _Right,
		size_type _Roff, size_type _Count)
		{	
		if (_Right.size() < _Roff)
			_String_base::_Xran();	
		size_type _Num = _Right.size() - _Roff;
		if (_Count < _Num)
			_Num = _Count;	

		if (this == &_Right)
			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	
		else if (_Grow(_Num))
			{	
			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt&  assign(const _Elem *_Ptr, size_type _Num)
		{	
		if (_Inside(_Ptr))
			return (assign(*this, _Ptr - _Myptr(), _Num));	

		if (_Grow(_Num))
			{	
			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Num);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt&  assign(const _Elem *_Ptr)
		{	
		return (assign(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt&  assign(size_type _Count, _Elem _Ch)
		{	
		if (_Count == npos)
			_String_base::_Xlen();	

		if (_Grow(_Count))
			{	
			_Chassign(0, _Count, _Ch);
			_Eos(_Count);
			}
		return (*this);
		}

	template<class _It>
		_Myt&  assign(_It _First, _It _Last)
		{	
		return (_Assign(_First, _Last, _Iter_cat(_First)));
		}

	template<class _It>
		_Myt&  _Assign(_It _Count, _It _Ch, _Int_iterator_tag)
		{	
		return (assign((size_type)_Count, (_Elem)_Ch));
		}

	template<class _It>
		_Myt&  _Assign(_It _First, _It _Last, input_iterator_tag)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt&  assign(const_pointer _First, const_pointer _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt&  assign(const_iterator _First, const_iterator _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt&  insert(size_type _Off, const _Myt& _Right)
		{	
		return (insert(_Off, _Right, 0, npos));
		}

	_Myt&  insert(size_type _Off,
		const _Myt& _Right, size_type _Roff, size_type _Count)
		{	
		if (_Mysize < _Off || _Right.size() < _Roff)
			_String_base::_Xran();	
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	
		if (npos - _Mysize <= _Count)
			_String_base::_Xlen();	

		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{	
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
				_Myptr() + _Off, _Mysize - _Off);	
			if (this == &_Right)
				_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
					_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
						_Count);	
			else
				_Traits_helper::copy_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
					_Right._Myptr() + _Roff, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt&  insert(size_type _Off,
		const _Elem *_Ptr, size_type _Count)
		{	
		if (_Inside(_Ptr))
			return (insert(_Off, *this,
				_Ptr - _Myptr(), _Count));	
		if (_Mysize < _Off)
			_String_base::_Xran();	
		if (npos - _Mysize <= _Count)
			_String_base::_Xlen();	
		size_type _Num;
		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{	
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
				_Myptr() + _Off, _Mysize - _Off);	
			_Traits_helper::copy_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Ptr, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt&  insert(size_type _Off, const _Elem *_Ptr)
		{	
		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt&  insert(size_type _Off,
		size_type _Count, _Elem _Ch)
		{	
		if (_Mysize < _Off)
			_String_base::_Xran();	
		if (npos - _Mysize <= _Count)
			_String_base::_Xlen();	
		size_type _Num;
		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{	
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
				_Myptr() + _Off, _Mysize - _Off);	
			_Chassign(_Off, _Count, _Ch);	
			_Eos(_Num);
			}
		return (*this);
		}

	iterator  insert(iterator _Where)
		{	
		return (insert(_Where, _Elem()));
		}

	iterator  insert(iterator _Where, _Elem _Ch)
		{	
		size_type _Off = _Pdif(_Where, begin());
		insert(_Off, 1, _Ch);
		return (begin() + _Off);
		}

	void  insert(iterator _Where, size_type _Count, _Elem _Ch)
		{	
		size_type _Off = _Pdif(_Where, begin());
		insert(_Off, _Count, _Ch);
		}

	template<class _It>
		void  insert(iterator _Where, _It _First, _It _Last)
		{	
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}

	template<class _It>
		void  _Insert(iterator _Where, _It _Count, _It _Ch,
			_Int_iterator_tag)
		{	
		insert(_Where, (size_type)_Count, (_Elem)_Ch);
		}

	template<class _It>
		void  _Insert(iterator _Where, _It _First, _It _Last,
			input_iterator_tag)
		{	
		replace(_Where, _Where, _First, _Last);
		}

	void  insert(iterator _Where, const_pointer _First, const_pointer _Last)
		{	
		replace(_Where, _Where, _First, _Last);
		}

	void  insert(iterator _Where, const_iterator _First, const_iterator _Last)
		{	
		replace(_Where, _Where, _First, _Last);
		}

	_Myt&  erase(size_type _Off = 0,
		size_type _Count = npos)
		{	
		if (_Mysize < _Off)
			_String_base::_Xran();	
		if (_Mysize - _Off < _Count)
			_Count = _Mysize - _Off;	
		if (0 < _Count)
			{	
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Myptr() + _Off + _Count,
				_Mysize - _Off - _Count);
			size_type _Newsize = _Mysize - _Count;
			_Eos(_Newsize);
			}
		return (*this);
		}

	iterator  erase(iterator _Where)
		{	
		size_type _Count = _Pdif(_Where, begin());
		erase(_Count, 1);
		return (iterator(_Myptr() + _Count, this));
		}

	iterator  erase(iterator _First, iterator _Last)
		{	
		size_type _Count = _Pdif(_First, begin());
		erase(_Count, _Pdif(_Last, _First));
		return (iterator(_Myptr() + _Count, this));
		}

	void  clear()
		{	
		erase(begin(), end());
		}

	_Myt&  replace(size_type _Off, size_type _N0, const _Myt& _Right)
		{	
		return (replace(_Off, _N0, _Right, 0, npos));
		}

	_Myt&  replace(size_type _Off,
		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
		{	
		if (_Mysize < _Off || _Right.size() < _Roff)
			_String_base::_Xran();	
		if (_Mysize - _Off < _N0)
			_N0 = _Mysize - _Off;	
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	
		if (npos - _Count <= _Mysize - _N0)
			_String_base::_Xlen();	

		size_type _Nm = _Mysize - _N0 - _Off;	
		size_type _Newsize = _Mysize + _Count - _N0;
		if (_Mysize < _Newsize)
			_Grow(_Newsize);

		if (this != &_Right)
			{	
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
				_Myptr() + _Off + _N0, _Nm);	
			_Traits_helper::copy_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
				_Right._Myptr() + _Roff, _Count);	
			}
		else if (_Count <= _N0)
			{	
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
				_Myptr() + _Roff, _Count);	
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
				_Myptr() + _Off + _N0, _Nm);	
			}
		else if (_Roff <= _Off)
			{	
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
				_Myptr() + _Off + _N0, _Nm);	
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
				_Myptr() + _Roff, _Count);	
			}
		else if (_Off + _N0 <= _Roff)
			{	
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
				_Myptr() + _Off + _N0, _Nm);	
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
				_Myptr() + (_Roff + _Count - _N0), _Count);	
			}
		else
			{	
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
				_Myptr() + _Roff, _N0);	
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
				_Myptr() + _Off + _N0, _Nm);	
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _N0, _Myres - _Off - _N0, _Myptr() + _Roff + _Count,
				_Count - _N0);	
			}

		_Eos(_Newsize);
		return (*this);
		}

	_Myt&  replace(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count)
		{	
		if (_Inside(_Ptr))
			return (replace(_Off, _N0, *this,
				_Ptr - _Myptr(), _Count));	
		if (_Mysize < _Off)
			_String_base::_Xran();	
		if (_Mysize - _Off < _N0)
			_N0 = _Mysize - _Off;	
		if (npos - _Count <= _Mysize - _N0)
			_String_base::_Xlen();	
		size_type _Nm = _Mysize - _N0 - _Off;

		if (_Count < _N0)
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
				_Myptr() + _Off + _N0, _Nm);	
		size_type _Num;
		if ((0 < _Count || 0 < _N0) && _Grow(_Num = _Mysize + _Count - _N0))
			{	
			if (_N0 < _Count)
				_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
					_Myptr() + _Off + _N0, _Nm);	
			_Traits_helper::copy_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Ptr, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt&  replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
		{	
		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt&  replace(size_type _Off,
		size_type _N0, size_type _Count, _Elem _Ch)
		{	
		if (_Mysize < _Off)
			_String_base::_Xran();	
		if (_Mysize - _Off < _N0)
			_N0 = _Mysize - _Off;	
		if (npos - _Count <= _Mysize - _N0)
			_String_base::_Xlen();	
		size_type _Nm = _Mysize - _N0 - _Off;

		if (_Count < _N0)
			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
				_Myptr() + _Off + _N0, _Nm);	
		size_type _Num;
		if ((0 < _Count || 0 < _N0) && _Grow(_Num = _Mysize + _Count - _N0))
			{	
			if (_N0 < _Count)
				_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
					_Myptr() + _Off + _N0, _Nm);	
			_Chassign(_Off, _Count, _Ch);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt&  replace(iterator _First, iterator _Last, const _Myt& _Right)
		{	
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
		}

	_Myt&  replace(iterator _First, iterator _Last, const _Elem *_Ptr,
		size_type _Count)
		{	
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
		}

	_Myt&  replace(iterator _First, iterator _Last, const _Elem *_Ptr)
		{	
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
		}

	_Myt&  replace(iterator _First, iterator _Last,
		size_type _Count, _Elem _Ch)
		{	
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
		}

	template<class _It>
		_Myt&  replace(iterator _First, iterator _Last,
			_It _First2, _It _Last2)
		{	
		return (_Replace(_First, _Last,
			_First2, _Last2, _Iter_cat(_First2)));
		}

	template<class _It>
		_Myt&  _Replace(iterator _First, iterator _Last,
			_It _Count, _It _Ch, _Int_iterator_tag)
		{	
		return (replace(_First, _Last, (size_type)_Count, (_Elem)_Ch));
		}

	template<class _It>
		_Myt&  _Replace(iterator _First, iterator _Last,
			_It _First2, _It _Last2, input_iterator_tag)
		{	
		_Myt _Right(_First2, _Last2);
		replace(_First, _Last, _Right);
		return (*this);
		}

	_Myt&  replace(iterator _First, iterator _Last,
		const_pointer _First2, const_pointer _Last2)
		{	
		if (_First2 == _Last2)
			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
		else
			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt&  replace(iterator _First, iterator _Last,
		const_iterator _First2, const_iterator _Last2)
		{	
		if (_First2 == _Last2)
			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
		else
			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	iterator  begin()
		{	
		return (iterator(_Myptr(), this));
		}

	const_iterator  begin() const
		{	
		return (const_iterator(_Myptr(), this));
		}

	iterator  end()
		{	
		return (iterator(_Myptr() + _Mysize, this));
		}

	const_iterator  end() const
		{	
		return (const_iterator(_Myptr() + _Mysize, this));
		}

	reverse_iterator  rbegin()
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator  rbegin() const
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator  rend()
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator  rend() const
		{	
		return (const_reverse_iterator(begin()));
		}

	reference  at(size_type _Off)
		{	
		if (_Mysize <= _Off)
			_String_base::_Xran();	
		return (_Myptr()[_Off]);
		}

	const_reference  at(size_type _Off) const
		{	
		if (_Mysize <= _Off)
			_String_base::_Xran();	
		return (_Myptr()[_Off]);
		}

 

	reference  operator[](size_type _Off)
		{	

 
		
		if (this->_Myfirstiter != ((_Iterator_base *)-3))
			{
			if (_Mysize < _Off)
				{
				_Debug_message(L"string subscript out of range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 1536);
				{ (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 1537, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 1537, 0); };
				}
			}
 

#line 1543 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

		return (_Myptr()[_Off]);
		}

	const_reference  operator[](size_type _Off) const
		{	

 
		
		if (this->_Myfirstiter != ((_Iterator_base *)-3))
			{
			if (_Mysize < _Off)	
				{
				_Debug_message(L"string subscript out of range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 1556);
				{ (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 1557, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring", 1557, 0); };
				}
			}
 

#line 1563 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

		return (_Myptr()[_Off]);
		}

 #line 1568 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

 

  







































#line 1612 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

 #line 1614 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

	void  push_back(_Elem _Ch)
		{	
		insert(end(), _Ch);
		}

	const _Elem * c_str() const
		{	
		return (_Myptr());
		}

	const _Elem * data() const
		{	
		return (c_str());
		}

	size_type  length() const
		{	
		return (_Mysize);
		}

	size_type  size() const
		{	
		return (_Mysize);
		}

	size_type  max_size() const
		{	
		size_type _Num = _Mybase::_Alval.max_size();
		return (_Num <= 1 ? 1 : _Num - 1);
		}

	void  resize(size_type _Newsize)
		{	
		resize(_Newsize, _Elem());
		}

	void  resize(size_type _Newsize, _Elem _Ch)
		{	
		if (_Newsize <= _Mysize)
			erase(_Newsize);
		else
			append(_Newsize - _Mysize, _Ch);
		}

	size_type  capacity() const
		{	
		return (_Myres);
		}

	void  reserve(size_type _Newcap = 0)
		{	
		if (_Mysize <= _Newcap && _Myres != _Newcap)
			{	
			size_type _Size = _Mysize;
			if (_Grow(_Newcap, true))
				_Eos(_Size);
			}
		}

	bool  empty() const
		{	
		return (_Mysize == 0);
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	size_type  copy(_Elem *_Dest,
		size_type _Count, size_type _Off = 0) const
		{	
		
		return _Copy_s(_Dest, _Count, _Count, _Off);
		}

	size_type  _Copy_s(_Elem *_Dest, size_type _Dest_size,
		size_type _Count, size_type _Off = 0) const
		{	
		_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring",1690);
		if (_Mysize < _Off)
			_String_base::_Xran();	
		if (_Mysize - _Off < _Count)
			_Count = _Mysize - _Off;
		_Traits_helper::copy_s<_Traits>(_Dest, _Dest_size, _Myptr() + _Off, _Count);
		return (_Count);
		}

	void  swap(_Myt& _Right)
		{	
		if (_Mybase::_Alval == _Right._Alval)
			{	

 
			this->_Swap_all(_Right);
 #line 1707 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

			_Bxty _Tbx = _Bx;
			_Bx = _Right._Bx, _Right._Bx = _Tbx;

			size_type _Tlen = _Mysize;
			_Mysize = _Right._Mysize, _Right._Mysize = _Tlen;

			size_type _Tres = _Myres;
			_Myres = _Right._Myres, _Right._Myres = _Tres;
			}
		else
			{	
			_Myt _Tmp = *this; *this = _Right, _Right = _Tmp;
			}
		}

	size_type  find(const _Myt& _Right, size_type _Off = 0) const
		{	
		return (find(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type  find(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer(_Ptr, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring",1731);
		if (_Count == 0 && _Off <= _Mysize)
			return (_Off);	

		size_type _Nm;
		if (_Off < _Mysize && _Count <= (_Nm = _Mysize - _Off))
			{	
			const _Elem *_Uptr, *_Vptr;
			for (_Nm -= _Count - 1, _Vptr = _Myptr() + _Off;
				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - _Myptr());	
			}

		return (npos);	
		}

	size_type  find(const _Elem *_Ptr, size_type _Off = 0) const
		{	
		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type  find(_Elem _Ch, size_type _Off = 0) const
		{	
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type  rfind(const _Myt& _Right, size_type _Off = npos) const
		{	
		return (rfind(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type  rfind(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer(_Ptr, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring",1767);
		if (_Count == 0)
			return (_Off < _Mysize ? _Off : _Mysize);	
		if (_Count <= _Mysize)
			{	
			const _Elem *_Uptr = _Myptr() +
				(_Off < _Mysize - _Count ? _Off : _Mysize - _Count);
			for (; ; --_Uptr)
				if (_Traits::eq(*_Uptr, *_Ptr)
					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - _Myptr());	
				else if (_Uptr == _Myptr())
					break;	
			}

		return (npos);	
		}

	size_type  rfind(const _Elem *_Ptr, size_type _Off = npos) const
		{	
		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type  rfind(_Elem _Ch, size_type _Off = npos) const
		{	
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type  find_first_of(const _Myt& _Right,
		size_type _Off = 0) const
		{	
		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type  find_first_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer(_Ptr, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring",1804);
		if (0 < _Count && _Off < _Mysize)
			{	
			const _Elem *const _Vptr = _Myptr() + _Mysize;
			for (const _Elem *_Uptr = _Myptr() + _Off; _Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - _Myptr());	
			}

		return (npos);	
		}

	size_type  find_first_of(const _Elem *_Ptr, size_type _Off = 0) const
		{	
		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type  find_first_of(_Elem _Ch, size_type _Off = 0) const
		{	
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type  find_last_of(const _Myt& _Right,
		size_type _Off = npos) const
		{	
		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type  find_last_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer(_Ptr, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring",1835);
		if (0 < _Count && 0 < _Mysize)
			for (const _Elem *_Uptr = _Myptr()
				+ (_Off < _Mysize ? _Off : _Mysize - 1); ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - _Myptr());	
				else if (_Uptr == _Myptr())
					break;	

		return (npos);	
		}

	size_type  find_last_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	
		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type  find_last_of(_Elem _Ch, size_type _Off = npos) const
		{	
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type  find_first_not_of(const _Myt& _Right,
		size_type _Off = 0) const
		{	
		return (find_first_not_of(_Right._Myptr(), _Off,
			_Right.size()));
		}

	size_type  find_first_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer(_Ptr, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring",1868);
		if (_Off < _Mysize)
			{	
			const _Elem *const _Vptr = _Myptr() + _Mysize;
			for (const _Elem *_Uptr = _Myptr() + _Off; _Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - _Myptr());
			}
		return (npos);
		}

	size_type  find_first_not_of(const _Elem *_Ptr,
		size_type _Off = 0) const
		{	
		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type  find_first_not_of(_Elem _Ch, size_type _Off = 0) const
		{	
		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	size_type  find_last_not_of(const _Myt& _Right,
		size_type _Off = npos) const
		{	
		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type  find_last_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer(_Ptr, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring",1899);
		if (0 < _Mysize)
			for (const _Elem *_Uptr = _Myptr()
				+ (_Off < _Mysize ? _Off : _Mysize - 1); ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - _Myptr());
				else if (_Uptr == _Myptr())
					break;
		return (npos);
		}

	size_type  find_last_not_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	
		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type  find_last_not_of(_Elem _Ch, size_type _Off = npos) const
		{	
		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	_Myt  substr(size_type _Off = 0, size_type _Count = npos) const
		{	
		return (_Myt(*this, _Off, _Count));
		}

	int  compare(const _Myt& _Right) const
		{	
		return (compare(0, _Mysize, _Right._Myptr(), _Right.size()));
		}

	int  compare(size_type _Off, size_type _N0,
		const _Myt& _Right) const
		{	
		return (compare(_Off, _N0, _Right, 0, npos));
		}

	int  compare(size_type _Off,
		size_type _N0, const _Myt& _Right,
		size_type _Roff, size_type _Count) const
		{	
		if (_Right.size() < _Roff)
			_String_base::_Xran();	
		if (_Right._Mysize - _Roff < _Count)
			_Count = _Right._Mysize - _Roff;	
		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
		}

	int  compare(const _Elem *_Ptr) const
		{	
		return (compare(0, _Mysize, _Ptr, _Traits::length(_Ptr)));
		}

	int  compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
		{	
		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	int  compare(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count) const
		{	
		_Debug_pointer(_Ptr, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring",1961);
		if (_Mysize < _Off)
			_String_base::_Xran();	
		if (_Mysize - _Off < _N0)
			_N0 = _Mysize - _Off;	

		size_type _Ans = _Traits::compare(_Myptr() + _Off, _Ptr,
			_N0 < _Count ? _N0 : _Count);
		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
			: _N0 == _Count ? 0 : +1);
		}

	allocator_type  get_allocator() const
		{	
		return (_Mybase::_Alval);
		}

	enum
		{	
		_BUF_SIZE = 16 / sizeof (_Elem) < 1 ? 1
			: 16 / sizeof(_Elem)};

protected:
	enum
		{	
		_ALLOC_MASK = sizeof (_Elem) <= 1 ? 15
			: sizeof (_Elem) <= 2 ? 7
			: sizeof (_Elem) <= 4 ? 3
			: sizeof (_Elem) <= 8 ? 1 : 0};

	void  _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
		{	
		if (_Count == 1)
			_Traits::assign(*(_Myptr() + _Off), _Ch);
		else
			_Traits::assign(_Myptr() + _Off, _Count, _Ch);
		}

	void  _Copy(size_type _Newsize, size_type _Oldlen)
		{	
		size_type _Newres = _Newsize | _ALLOC_MASK;
		if (max_size() < _Newres)
			_Newres = _Newsize;	
		else if (_Newres / 3 < _Myres / 2
			&& _Myres <= max_size() - _Myres / 2)
			_Newres = _Myres + _Myres / 2;	
		_Elem *_Ptr = 0;

		try {
			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);
		} catch (...) {
			_Newres = _Newsize;	
			try {
				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);
			} catch (...) {
			_Tidy(true);	
			throw;
			}
		}

		if (0 < _Oldlen)
			_Traits_helper::copy_s<_Traits>(_Ptr, _Newres + 1, _Myptr(), _Oldlen);	
		_Tidy(true);
		_Bx._Ptr = _Ptr;
		_Myres = _Newres;
		_Eos(_Oldlen);
		}

	void  _Eos(size_type _Newsize)
		{	
		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());
		}

	bool  _Grow(size_type _Newsize,
		bool _Trim = false)
		{	
			if (max_size() < _Newsize)
			_String_base::_Xlen();	
		if (_Myres < _Newsize)
			_Copy(_Newsize, _Mysize);	
		else if (_Trim && _Newsize < _BUF_SIZE)
			_Tidy(true,	
				_Newsize < _Mysize ? _Newsize : _Mysize);
		else if (_Newsize == 0)
			_Eos(0);	
		return (0 < _Newsize);	
		}

	bool  _Inside(const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring",2051);
		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)
			return (false);	
		else
			return (true);
		}

	static size_type __cdecl _Pdif(const_iterator _P2,
		const_iterator _P1)
		{	
		return ((_P2)._Myptr == 0 ? 0 : _P2 - _P1);
		}

	void  _Tidy(bool _Built = false,
		size_type _Newsize = 0)
		{	
		if (!_Built)
			;
		else if (_BUF_SIZE <= _Myres)
			{	
			_Elem *_Ptr = _Bx._Ptr;
			if (0 < _Newsize)
				_Traits_helper::copy_s<_Traits>(_Bx._Buf, _BUF_SIZE, _Ptr, _Newsize);
			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);
			}
		_Myres = _BUF_SIZE - 1;
		_Eos(_Newsize);
		}

	union _Bxty
		{	
		_Elem _Buf[_BUF_SIZE];
		_Elem *_Ptr;
		} _Bx;

	_Elem * _Myptr()
		{	
		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);
		}

	const _Elem * _Myptr() const
		{	
		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);
		}

	size_type _Mysize;	
	size_type _Myres;	
	};

	
template<class _Elem, class _Traits, class _Ax>
	class _Move_operation_category<basic_string<_Elem, _Traits, _Ax> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	 const typename basic_string<_Elem, _Traits, _Alloc>::size_type
		basic_string<_Elem, _Traits, _Alloc>::npos =
			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);

		

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void __cdecl swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

typedef basic_string<char, char_traits<char>, allocator<char> >
	string;
typedef basic_string<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstring;

 

template class __declspec(dllimport) allocator<char>;
template class __declspec(dllimport) allocator<wchar_t>;
template class __declspec(dllimport) _String_val<char, allocator<char> >;
template class __declspec(dllimport) _String_val<wchar_t, allocator<wchar_t> >;
template class __declspec(dllimport) basic_string<char, char_traits<char>,
	allocator<char> >;
template class __declspec(dllimport) basic_string<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> >;




 #line 2147 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"
}

 #pragma warning(default: 4251)
#pragma warning(pop)
#pragma pack(pop)
#line 2153 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"

#line 2155 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"
#line 2156 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xstring"






#line 8 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"


#pragma pack(push,8)
#pragma warning(push,3)
#line 13 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"

namespace std {





		
class logic_error
	: public std:: exception
	{	
public:
	explicit  logic_error(const string& _Message)
		: _Str(_Message)
		{	
		}

	virtual  ~logic_error() throw ()
		{	
		}

	virtual const char * what() const throw ()
		{	
		return (_Str.c_str());
		}

 





#line 46 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"

private:
	string _Str;	
	};

		
class domain_error
	: public logic_error
	{	
public:
	explicit  domain_error(const string& _Message)
		: logic_error(_Message)
		{	
		}

	virtual  ~domain_error() throw ()
		{	
		}

 





#line 72 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"

	};

		
class invalid_argument
	: public logic_error
	{	
public:
	explicit  invalid_argument(const string& _Message)
		: logic_error(_Message)
		{	
		}

	virtual  ~invalid_argument() throw ()
		{	
		}

 





#line 96 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"

	};

		
class length_error
	: public logic_error
	{	
public:
	explicit  length_error(const string& _Message)
		: logic_error(_Message)
		{	
		}

	virtual  ~length_error() throw ()
		{	
		}

 





#line 120 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"

	};

		
class out_of_range
	: public logic_error
	{	
public:
	explicit  out_of_range(const string& _Message)
		: logic_error(_Message)
		{	
		}

	virtual  ~out_of_range() throw ()
		{	
		}

 





#line 144 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"

	};

		
class runtime_error
	: public std:: exception
	{	
public:
	explicit  runtime_error(const string& _Message)
		: _Str(_Message)
		{	
		}

	virtual  ~runtime_error() throw ()
		{	
		}

	virtual const char * what() const throw ()
		{	
		return (_Str.c_str());
		}

 





#line 173 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"

private:
	string _Str;	
	};

		
class overflow_error
	: public runtime_error
	{	
public:
	explicit  overflow_error(const string& _Message)
		: runtime_error(_Message)
		{	
		}

	virtual  ~overflow_error() throw ()
		{	
		}

 





#line 199 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"

	};

		
class underflow_error
	: public runtime_error
	{	
public:
	explicit  underflow_error(const string& _Message)
		: runtime_error(_Message)
		{	
		}

	virtual  ~underflow_error() throw ()
		{	
		}

 





#line 223 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"

	};

		
class range_error
	: public runtime_error
	{	
public:
	explicit  range_error(const string& _Message)
		: runtime_error(_Message)
		{	
		}

	virtual  ~range_error() throw ()
		{	
		}

 





#line 247 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"

	};























}


#pragma warning(pop)
#pragma pack(pop)
#line 278 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"

#line 280 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"
#line 281 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdexcept"





#line 9 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\typeinfo"















#pragma once
#line 18 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\typeinfo"







#pragma pack(push,8)
#line 27 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\typeinfo"

 



 

#line 35 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\typeinfo"

struct __type_info_node {
    void *memPtr;
    __type_info_node* next;
};

extern __type_info_node __type_info_root_node;

class type_info {
public:
    virtual ~type_info();
    __declspec(dllimport) bool  operator==(const type_info& rhs) const;
    __declspec(dllimport) bool  operator!=(const type_info& rhs) const;
    __declspec(dllimport) int  before(const type_info& rhs) const;
    __declspec(dllimport) const char*  name(__type_info_node* __ptype_info_node = &__type_info_root_node) const;
    __declspec(dllimport) const char*  raw_name() const;
private:
    void *_m_data;
    char _m_d_name[1];
     type_info(const type_info& rhs);
    type_info&  operator=(const type_info& rhs);
    __declspec(dllimport) static const char *__cdecl _Name_base(const type_info *,__type_info_node* __ptype_info_node);
    __declspec(dllimport) static void __cdecl _Type_info_dtor(type_info *);
};

 

 namespace std {

using ::type_info;

 }





 namespace std {

class __declspec(dllimport) bad_cast : public exception {
public:










     bad_cast(const char * _Message = "bad cast");
     bad_cast(const bad_cast &);
    virtual  ~bad_cast();
#line 90 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\typeinfo"
};

class __declspec(dllimport) bad_typeid : public exception {
public:










     bad_typeid(const char * _Message = "bad typeid");
     bad_typeid(const bad_typeid &);
    virtual  ~bad_typeid();
#line 108 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\typeinfo"

};

class __declspec(dllimport) __non_rtti_object : public bad_typeid {
public:










     __non_rtti_object(const char * _Message);
     __non_rtti_object(const __non_rtti_object &);
    virtual  ~__non_rtti_object();
#line 127 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\typeinfo"
};

 }
 

 
























































#line 190 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\typeinfo"

#line 192 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\typeinfo"


#pragma pack(pop)
#line 196 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\typeinfo"

#line 198 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\typeinfo"







#line 10 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xdebug"

#pragma once






#pragma pack(push,8)
#pragma warning(push,3)
#line 12 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xdebug"

namespace std {
struct _DebugHeapTag_t
	{	
	int _Type;
	};
}

		

 
   
   
   
   

  
  
  

__declspec(dllimport)   void * __cdecl operator new(size_t _Size,
	const std::_DebugHeapTag_t&,          char *, int)
		throw (...);	

__declspec(dllimport)   void * __cdecl operator new[](size_t _Size,
	const std::_DebugHeapTag_t&,          char *, int)
		throw (...);	

__declspec(dllimport) void __cdecl operator delete(void *,
	const std::_DebugHeapTag_t&,          char *, int)
		throw ();	

__declspec(dllimport) void __cdecl operator delete[](void *,
	const std::_DebugHeapTag_t&,          char *, int)
		throw ();	

namespace std {

__declspec(dllimport) const _DebugHeapTag_t& __cdecl _DebugHeapTag_func();

		
template<class _Ty>
	void __cdecl _DebugHeapDelete(_Ty *_Ptr)
	{	
	if (_Ptr != 0)
		{	
		_Ptr->~_Ty();
		
		
		free(_Ptr);
		}
	}

		
template<class _Ty>
	class _DebugHeapAllocator
	: public allocator<_Ty>
	{	
public:

	template<class _Other>
		struct rebind
		{	
		typedef typename _DebugHeapAllocator<_Other> other;
		};

	typename allocator<_Ty>::pointer __cdecl allocate(typename allocator<_Ty>::size_type _Count, const void *)
		{	
		if (_Count <= 0)
			_Count = 0;
		else if (((size_t)(-1) / _Count) < sizeof(_Ty))
			throw std::bad_alloc(0);

			
		return ((_Ty *)new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xdebug", 86) char[_Count * sizeof(_Ty)]);
		}

	typename allocator<_Ty>::pointer  allocate(typename allocator<_Ty>::size_type _Count)
		{	
		if (_Count <= 0)
			_Count = 0;
		else if (((size_t)(-1) / _Count) < sizeof(_Ty))
			throw std::bad_alloc(0);

			
		return ((_Ty *)new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xdebug", 97) char[_Count * sizeof(_Ty)]);
		}

	void  deallocate(typename allocator<_Ty>::pointer _Ptr, typename allocator<_Ty>::size_type)
		{	
		std::_DebugHeapDelete((void *)_Ptr);
		}
	};

template class __declspec(dllimport) _DebugHeapAllocator<char>;

		
class __declspec(dllimport) _DebugHeapString
	: public basic_string<char, char_traits<char>, _DebugHeapAllocator<char> >
	{	
public:
	typedef _DebugHeapString _Myt;
	typedef basic_string<char, char_traits<char>, _DebugHeapAllocator<char> >
		_Mybase;
	typedef char _Elem;

	 _DebugHeapString()
		: _Mybase()
		{	
		}

	 _DebugHeapString(const _Myt& _Right)
		: _Mybase(_Right)
		{	
		}

	 _DebugHeapString(const _Elem *_Ptr)
		: _Mybase(_Ptr)
		{	
		}

	 _DebugHeapString(const string &_Str)
		: _Mybase(_Str.c_str())
		{	
		}

	 operator string() const
		{	
		return (string(c_str()));
		}
	};
}

  




#line 151 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xdebug"


#pragma warning(pop)
#pragma pack(pop)
#line 156 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xdebug"


#line 159 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xdebug"
#line 160 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xdebug"





#line 11 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo"

#pragma once



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo.h"

#pragma once


#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ctype.h"














#pragma once
#line 17 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ctype.h"




#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ctype.h"


extern "C" {
#line 26 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ctype.h"











































#line 70 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ctype.h"










                                













__declspec(dllimport)  int __cdecl _isctype(     int _C,      int _Type);
__declspec(dllimport)  int __cdecl _isctype_l(     int _C,      int _Type,        _locale_t _Locale);
 __declspec(dllimport)  int __cdecl isalpha(     int _C);
__declspec(dllimport)  int __cdecl _isalpha_l(     int _C,        _locale_t _Locale);
 __declspec(dllimport)  int __cdecl isupper(     int _C);
__declspec(dllimport)  int __cdecl _isupper_l(     int _C,        _locale_t _Locale);
 __declspec(dllimport)  int __cdecl islower(     int _C);
__declspec(dllimport)  int __cdecl _islower_l(     int _C,        _locale_t _Locale);
 __declspec(dllimport)  int __cdecl isdigit(     int _C);
__declspec(dllimport)  int __cdecl _isdigit_l(     int _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl isxdigit(     int _C);
__declspec(dllimport)  int __cdecl _isxdigit_l(     int _C,        _locale_t _Locale);
 __declspec(dllimport)  int __cdecl isspace(     int _C);
__declspec(dllimport)  int __cdecl _isspace_l(     int _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl ispunct(     int _C);
__declspec(dllimport)  int __cdecl _ispunct_l(     int _C,        _locale_t _Locale);
 __declspec(dllimport)  int __cdecl isalnum(     int _C);
__declspec(dllimport)  int __cdecl _isalnum_l(     int _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl isprint(     int _C);
__declspec(dllimport)  int __cdecl _isprint_l(     int _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl isgraph(     int _C);
__declspec(dllimport)  int __cdecl _isgraph_l(     int _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl iscntrl(     int _C);
__declspec(dllimport)  int __cdecl _iscntrl_l(     int _C,        _locale_t _Locale);
 __declspec(dllimport)  int __cdecl toupper(     int _C);
 __declspec(dllimport)  int __cdecl tolower(     int _C);
 __declspec(dllimport)  int __cdecl _tolower(     int _C);
__declspec(dllimport)  int __cdecl _tolower_l(     int _C,        _locale_t _Locale);
 __declspec(dllimport)  int __cdecl _toupper(     int _C);
__declspec(dllimport)  int __cdecl _toupper_l(     int _C,        _locale_t _Locale);
__declspec(dllimport)  int __cdecl __isascii(     int _C);
__declspec(dllimport)  int __cdecl __toascii(     int _C);
__declspec(dllimport)  int __cdecl __iscsymf(     int _C);
__declspec(dllimport)  int __cdecl __iscsym(     int _C);

#line 130 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ctype.h"















































































__declspec(dllimport) int __cdecl _chvalidator(     int _Ch,      int _Mask);



#line 214 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ctype.h"












































#line 259 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ctype.h"


int __cdecl _chvalidator_l(       _locale_t,      int _Ch,      int _Mask);



#line 266 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ctype.h"





























































































#line 360 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ctype.h"
















#line 377 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ctype.h"

#line 379 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ctype.h"


}
#line 383 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ctype.h"

#line 385 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ctype.h"
#line 6 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\locale.h"














#pragma once
#line 17 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\locale.h"




#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\locale.h"






#pragma pack(push,8)
#line 30 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\locale.h"


extern "C" {
#line 34 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\locale.h"

























struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        };

#line 81 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\locale.h"




















#line 102 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\locale.h"

__declspec(dllimport)  int __cdecl _configthreadlocale(     int _Flag);
__declspec(dllimport)  char * __cdecl setlocale(     int _Category,          const char * _Locale);
__declspec(dllimport)  struct lconv * __cdecl localeconv(void);
__declspec(dllimport)  _locale_t __cdecl _get_current_locale(void);
__declspec(dllimport)  _locale_t __cdecl _create_locale(     int _Category,        const char * _Locale);
__declspec(dllimport) void __cdecl _free_locale(       _locale_t _Locale);


__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "_get_current_locale" " instead. See online help for details.")) __declspec(dllimport)  _locale_t __cdecl __get_current_locale(void);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "_create_locale" " instead. See online help for details.")) __declspec(dllimport)  _locale_t __cdecl __create_locale(     int _Category,        const char * _Locale);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "_free_locale" " instead. See online help for details.")) __declspec(dllimport) void __cdecl __free_locale(       _locale_t _Locale);











}
#line 127 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\locale.h"


#pragma pack(pop)
#line 131 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\locale.h"

#line 133 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\locale.h"
#line 7 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo.h"






#pragma pack(push,8)
#line 15 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo.h"



extern "C" {
#line 20 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo.h"

		











		



















typedef struct _Collvec
	{	
	unsigned long _Hand;	
	unsigned int _Page;		
	} _Collvec;

typedef struct _Ctypevec
	{	
	unsigned long _Hand;	
	unsigned int _Page;		
	const short *_Table;
	int _Delfl;
	} _Ctypevec;

typedef struct _Cvtvec
	{	
	unsigned long _Hand;	
	unsigned int _Page;		
	} _Cvtvec;

		
__declspec(dllimport) _Collvec __cdecl _Getcoll();
__declspec(dllimport) _Ctypevec __cdecl _Getctype();
__declspec(dllimport) _Cvtvec __cdecl _Getcvt();

__declspec(dllimport) int __cdecl _Getdateorder();

__declspec(dllimport) int __cdecl _Mbrtowc(       wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
__declspec(dllimport) float __cdecl _Stof(const char *,                     char **, long);
__declspec(dllimport) double __cdecl _Stod(const char *,                     char **, long);
__declspec(dllimport) long double __cdecl _Stold(const char *,                     char **, 
  long);
__declspec(dllimport) int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Strxfrm(
         char * _String1, 
         char * _End1, const char *, const char *, const _Collvec *);
__declspec(dllimport) int __cdecl _Tolower(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Toupper(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Wcrtomb(     char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
__declspec(dllimport) int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Wcsxfrm(
         wchar_t *_String1, 
         wchar_t *_End1, const wchar_t *, const wchar_t *, const _Collvec *);

__declspec(dllimport) short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
__declspec(dllimport) const wchar_t * __cdecl _Getwctypes(const wchar_t *, const wchar_t *,
	short*, const _Ctypevec*);
__declspec(dllimport) wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
__declspec(dllimport) wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);

}
#line 109 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo.h"


extern "C" {
__declspec(dllimport) void *__cdecl _Gettnames();
__declspec(dllimport) char *__cdecl _Getdays();
__declspec(dllimport) char *__cdecl _Getmonths();
__declspec(dllimport) size_t __cdecl _Strftime(
       char *,      size_t _Maxsize, 
          const char *,      const struct tm *, void *);
}

extern "C" {
_locale_t __cdecl _GetLocaleForCP(unsigned int);
}


#pragma pack(pop)
#line 127 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo.h"

#line 129 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo.h"





#line 7 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo"




#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable:4412)
#line 15 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo"

namespace std {

		
class __declspec(dllimport) _Timevec
	{	
public:
	 _Timevec(void *_Ptr = 0)
		: _Timeptr(_Ptr)
		{	
		}

	 _Timevec(const _Timevec& _Right)
		{	
		*this = _Right;
		}

	 ~_Timevec()
		{	
		free(_Timeptr);
		}

	_Timevec&  operator=(const _Timevec& _Right)
		{	
		_Timeptr = _Right._Timeptr;
		((_Timevec *)&_Right)->_Timeptr = 0;
		return (*this);
		}

	void * _Getptr() const
		{	
		return (_Timeptr);
		}

private:
	void *_Timeptr;	
	};

		


#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) _Locinfo
	{	
public:
	typedef ::_Collvec _Collvec;
	typedef ::_Ctypevec _Ctypevec;
	typedef ::_Cvtvec _Cvtvec;
	typedef std::_Timevec _Timevec;

    static  void __cdecl _Locinfo_ctor(_Locinfo *, const char *);
    static  void __cdecl _Locinfo_ctor(_Locinfo *, int, const char *);
    static  void __cdecl _Locinfo_dtor(_Locinfo *);
    static  _Locinfo& __cdecl _Locinfo_Addcats(_Locinfo *, int, const char *);

	 _Locinfo(const char *_Pch = "C")

        : _Lock(0)
#line 75 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo"
        {
        if (_Pch == 0)
            throw runtime_error("bad locale name");
        _Locinfo_ctor(this, _Pch);
        }

	 _Locinfo(int _I, const char *_Pch)

        : _Lock(0)
#line 85 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo"
        {
        if (_Pch == 0)
            throw runtime_error("bad locale name");
        _Locinfo_ctor(this, _I, _Pch);
        }

	 ~_Locinfo()
        {
        _Locinfo_dtor(this);
        }

	_Locinfo&  _Addcats(int _I, const char *_Pch)
		{
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		return _Locinfo_Addcats(this, _I, _Pch);
		}

	string  _Getname() const
		{	
		return (_Newlocname);
		}

	_Collvec  _Getcoll() const
		{	
		return (::_Getcoll());
		}

	_Ctypevec  _Getctype() const
		{	
		return (::_Getctype());
		}

	_Cvtvec  _Getcvt() const
		{	
		return (::_Getcvt());
		}

	const lconv * _Getlconv() const
		{	
		return (localeconv());
		}

	_Timevec  _Gettnames() const
		{	
		return (_Timevec(::_Gettnames()));
		}

	const char * _Getdays() const
		{	
		const char *_Ptr = ::_Getdays();
		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_Days = _Ptr;
			free((void *)_Ptr);
			}
		return (_Days.size() != 0 ? _Days.c_str()
			: ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				":Thu:Thursday:Fri:Friday:Sat:Saturday");
		}

	const char * _Getmonths() const
		{	
		const char *_Ptr = ::_Getmonths();
		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_Months = _Ptr;
			free((void *)_Ptr);
			}
		return (_Months.size() != 0 ? _Months.c_str()
			: ":Jan:January:Feb:February:Mar:March"
				":Apr:April:May:May:Jun:June"
				":Jul:July:Aug:August:Sep:September"
				":Oct:October:Nov:November:Dec:December");
		}

	const char * _Getfalse() const
		{	
		return ("false");
		}

	const char * _Gettrue() const
		{	
		return ("true");
		}

	int  _Getdateorder() const
		{	
		return ::_Getdateorder();
		}

private:





	_Lockit _Lock;	
#line 184 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo"
	string _Days;	
	string _Months;	
	string _Oldlocname;	
	string _Newlocname;	
	};
#pragma warning(pop)

		
template<class _Elem> inline
	int __cdecl _LStrcoll(const _Elem *_First1, const _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (*_First1 < *_First2)
			return (-1);	
		else if (*_First2 < *_First1)
			return (+1);	
	return (_First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0);
	}

template<> inline
	int __cdecl _LStrcoll(const char *_First1, const char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	int __cdecl _LStrcoll(const wchar_t *_First1, const wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

		
template<class _Elem> inline
	size_t __cdecl _LStrxfrm(_Elem *_First1, _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	
	size_t _Count = _Last2 - _First2;
	if (_Count <= (size_t)(_Last1 - _First1))
		::memcpy_s((_First1), ((_Last1 - _First1)* sizeof(_Elem)), (_First2), (_Count * sizeof (_Elem)));
	return (_Count);
	}

template<> inline
	size_t __cdecl _LStrxfrm(
		       char *_First1, 
		       char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	size_t __cdecl _LStrxfrm(
		       wchar_t *_First1, 
		       wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}
}


#pragma warning(pop)
#pragma pack(pop)
#line 258 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo"

#line 260 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo"
#line 261 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocinfo"





#line 12 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"


#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable:4412)
#line 18 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"

namespace std {

		
template<class _Dummy>
	class _Locbase
	{	
public:
	 static const int collate = ((1 << (1)) >> 1);
	 static const int ctype = ((1 << (2)) >> 1);
	 static const int monetary = ((1 << (3)) >> 1);
	 static const int numeric = ((1 << (4)) >> 1);
	 static const int time = ((1 << (5)) >> 1);
	 static const int messages = ((1 << (6)) >> 1);
	 static const int all = (((1 << (7)) >> 1) - 1);
	 static const int none = 0;
	};

template<class _Dummy>
	const int _Locbase<_Dummy>::collate;
template<class _Dummy>
	const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
	const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
	const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
	const int _Locbase<_Dummy>::time;
template<class _Dummy>
	const int _Locbase<_Dummy>::messages;
template<class _Dummy>
	const int _Locbase<_Dummy>::all;
template<class _Dummy>
	const int _Locbase<_Dummy>::none;

		
class locale;
template<class _Facet>
	const _Facet& __cdecl use_facet(const locale&);


#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) locale
	: public _Locbase<int>
	{	
public:
	typedef int category;

			
	class __declspec(dllimport) id
		{	
	public:
		 id(size_t _Val = 0)
			: _Id(_Val)
			{	
			}

		 operator size_t()
			{	
			if (_Id == 0)
				{	
				{ ::std:: _Lockit _Lock(0);
					if (_Id == 0)
						_Id = ++_Id_cnt;
				}
				}
			return (_Id);
			}

	private:
		 id(const id&);	
		id&  operator=(const id&);	

		size_t _Id;	
		static  int& __cdecl _Id_cnt_func();



		 static int _Id_cnt;	
#line 99 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"
		};

	class _Locimp;

			
	class __declspec(dllimport) facet
		{	
		friend class locale;
		friend class _Locimp;

	public:
		static size_t __cdecl _Getcat(const facet ** = 0)
			{	
			return ((size_t)(-1));
			}

		void  _Incref()
			{	
			{ ::std:: _Lockit _Lock(0);
				if (_Refs < (size_t)(-1))
					++_Refs;
			}
			}

		facet * _Decref()
			{	
			{ ::std:: _Lockit _Lock(0);
				if (0 < _Refs && _Refs < (size_t)(-1))
					--_Refs;
				return (_Refs == 0 ? this : 0);
			}
			}

		void  _Register()
			{
			facet_Register(this);
			}

 
		void * __cdecl operator new(size_t _Size)
			{	
			return (operator new(_Size, std::_DebugHeapTag_func(),
				"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 141));
			}

		void * __cdecl operator new(size_t _Size,
			const std::_DebugHeapTag_t& _Tag,          char *_File, int _Line)
			{	
			return (::operator new(_Size, _Tag, _File, _Line));
			}

		void __cdecl operator delete(void *_Ptr,
			const std::_DebugHeapTag_t&,          char *, int)
			{	
			operator delete(_Ptr);
			}

		void __cdecl operator delete(void *_Ptr)
			{	
			std::_DebugHeapDelete((facet*)_Ptr);
			}
 #line 161 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"



		virtual  ~facet()
			{	
			}

	protected:
		explicit  facet(size_t _Initrefs = 0)
			: _Refs(_Initrefs)
			{	
			}

	private:
		 static void __cdecl facet_Register(facet *);	

		 facet(const facet&);	
		facet&  operator=(const facet&);	

		size_t _Refs;	
		};

			
	class __declspec(dllimport) _Locimp
		: public facet
		{	
	protected:
		 ~_Locimp()
			{
			_Locimp_dtor(this);
			}

	private:
		static  void __cdecl _Locimp_dtor(_Locimp *); 
		static  void __cdecl _Locimp_ctor(_Locimp *,const _Locimp&);	
		static  void __cdecl _Locimp_Addfac(_Locimp *,facet *, size_t);	
		friend class locale;

		 _Locimp(bool _Transparent = false)
			: locale::facet(1), _Facetvec(0), _Facetcount(0),
				_Catmask(none), _Xparent(_Transparent), _Name("*")
			{ }
		
		 _Locimp(const _Locimp& _Right)
			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent), _Name(_Right._Name)
			{
			_Locimp_ctor(this, _Right);
			}
		
		void  _Addfac(facet *_Pfacet, size_t _Id)
			{
			_Locimp_Addfac(this, _Pfacet, _Id);
			}

		static  _Locimp *__cdecl _Makeloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

		static  void __cdecl _Makewloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

 




		static  void __cdecl _Makexloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

		facet **_Facetvec;	
		size_t _Facetcount;	
		category _Catmask;	
		bool _Xparent;	
		_DebugHeapString _Name;	

		static  _Locimp *& __cdecl _Clocptr_func();	



		 static _Locimp *_Clocptr;	
#line 242 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"
private:
		_Locimp&  operator=(const _Locimp&);	
	
		};

	__declspec(deprecated("This is an obsolete part of the Standard C++ Library Implementation. Do not use it.")) locale&  _Addfac(facet *_Fac, size_t _Id,
		size_t _Catmask)
		{
		if (1 < this->_Ptr->_Refs)
			{	
			this->_Ptr->_Decref();
			this->_Ptr = new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 253) _Locimp(*this->_Ptr);
			}
		this->_Ptr->_Addfac(_Fac, _Id);

		if (_Catmask != 0)
			this->_Ptr->_Name = "*";
		return (*this);
		}

	template<class _Elem,
		class _Traits,
		class _Alloc>
		bool  operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
		{	
		const std::collate<_Elem>& _Coll_fac =
			std::use_facet<std::collate<_Elem> >(*this);

		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
		}

	template<class _Facet>
		locale  combine(const locale& _Loc) const
		{	
		_Facet *_Facptr;

		try {
			_Facptr = (_Facet *)&std::use_facet<_Facet>(_Loc);
		} catch (...) {
			throw runtime_error("locale::combine facet missing");
		}

		_Locimp *_Newimp = new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 286) _Locimp(*_Ptr);
		_Newimp->_Addfac(_Facptr, _Facet::id);
		_Newimp->_Catmask = 0;
		_Newimp->_Name = "*";
		return (locale(_Newimp));
		}

	template<class _Facet>
		 locale(const locale& _Loc, const _Facet *_Facptr)
			: _Ptr(new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 295) _Locimp(*_Loc._Ptr))
		{	
		if (_Facptr != 0)
			{	
			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
			if (_Facet::_Getcat() != (size_t)(-1))
				_Ptr->_Catmask = 0, _Ptr->_Name = "*";	
			}
		}


	 locale() throw ()
		: _Ptr(_Init())
		{	
		_Getgloballocale()->_Incref();
		}

	 locale(_Uninitialized)
		{	
		}

	 locale(const locale& _Right) throw ()
		: _Ptr(_Right._Ptr)
		{	
		_Ptr->_Incref();
		}

	 locale(const locale& _Loc, const locale& _Other,
		category _Cat) 	
		: _Ptr(new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 324) _Locimp(*_Loc._Ptr))
		{	
		try {
			{ _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str());
				_Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
					_Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
			}
		} catch (...) {
			std::_DebugHeapDelete(_Ptr->_Decref());
			throw;
		}
		}

	explicit  locale(const char *_Locname,
		category _Cat = all) 	
		: _Ptr(new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 339) _Locimp)
		{	
		try {
		_Init();
		{ _Locinfo _Lobj(_Cat, _Locname);
			if (_Lobj._Getname().compare("*") == 0)
				throw runtime_error("bad locale name");
			_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
		}
		} catch (...) {
		std::_DebugHeapDelete(_Ptr->_Decref());
		throw;
		}
		}

	 locale(const locale& _Loc, const char * _Locname,
		category _Cat) 	
		: _Ptr(new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 356) _Locimp(*_Loc._Ptr))
		{	
		try {
		{ _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str());
			bool _Hadname = _Lobj._Getname().compare("*") != 0;
			_Lobj._Addcats(_Cat, _Locname);

			if (_Hadname && _Lobj._Getname().compare("*") == 0)
				throw runtime_error("bad locale name");
			_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
		}
		} catch (...) {
		std::_DebugHeapDelete(_Ptr->_Decref());
		throw;
		}
		}

	 ~locale() throw ()
		{	
		if (_Ptr != 0)
			std::_DebugHeapDelete(_Ptr->_Decref());
		}

	locale&  operator=(const locale& _Right) throw ()
		{	
		if (_Ptr != _Right._Ptr)
			{	
			std::_DebugHeapDelete(_Ptr->_Decref());
			_Ptr = _Right._Ptr;
			_Ptr->_Incref();
			}
		return (*this);
		}

	string  name() const
		{	
		return (_Ptr->_Name);
		}

	const facet * _Getfacet(size_t _Id) const 	
		{	
		const facet *_Facptr = _Id < _Ptr->_Facetcount
			? _Ptr->_Facetvec[_Id] : 0;	
		if (_Facptr != 0 || !_Ptr->_Xparent)
			return (_Facptr);	
		else
			{	
			locale::_Locimp *_Ptr = _Getgloballocale();
			return (_Id < _Ptr->_Facetcount
				? _Ptr->_Facetvec[_Id]	
				: 0);	
			}
		}


	bool  operator==(const locale& _Loc) const
		{	
		return (_Ptr == _Loc._Ptr
			|| name().compare("*") != 0 && name().compare(_Loc.name()) == 0);
		}

	bool  operator!=(const locale& _Right) const
		{	
		return (!(*this == _Right));
		}

	static  const locale& __cdecl classic();	

	static  locale __cdecl global(const locale&);	

	static  locale __cdecl empty();	

private:
	locale(_Locimp *_Ptrimp)
		: _Ptr(_Ptrimp)
		{	
		}

	static  _Locimp *__cdecl _Getgloballocale();
	static  _Locimp *__cdecl _Init();	
	static  void __cdecl _Setgloballocale(void *);

	_Locimp *_Ptr;	
	};
#pragma warning(pop)

		
template<class _Facet>
	struct _Facetptr
	{	
	 static const locale::facet *_Psave;
	};

template<class _Facet>
	 const locale::facet *_Facetptr<_Facet>::_Psave = 0;

template<class _Facet> inline __declspec(deprecated("This is an obsolete part of the Standard C++ Library Implementation. Do not use it."))
	locale _Addfac(locale _Loc, const _Facet *_Facptr)
		{	
		return (_Loc._Addfac((_Facet *)_Facptr, _Facet::id,
			_Facet::_Getcat()));
		}

  

  


template<class _Facet> inline
	const _Facet& __cdecl use_facet(const locale& _Loc)
	{	
	{ ::std:: _Lockit _Lock(0);	
		const locale::facet *_Psave =
			_Facetptr<_Facet>::_Psave;	

		size_t _Id = _Facet::id;
		const locale::facet *_Pf = _Loc._Getfacet(_Id);

		if (_Pf != 0)
			;	
		else if (_Psave != 0)
			_Pf = _Psave;	
		else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

 
		throw bad_cast();	

	

#line 486 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"

		else
			{	
			_Pf = _Psave;
			_Facetptr<_Facet>::_Psave = _Psave;

			locale::facet *_Pfmod = (_Facet *)_Psave;
			_Pfmod->_Incref();
			_Pfmod->_Register();
			}

		return ((const _Facet&)(*_Pf));	
	}
	}

template<class _Facet> inline __declspec(deprecated("This is an obsolete part of the Standard C++ Library Implementation. Do not use it."))
	const _Facet& __cdecl use_facet(const locale& _Loc, const _Facet *,
		bool = false)
	{	
	return use_facet<_Facet>(_Loc);
	}

		
template<class _Elem,
	class _InIt> inline
	int __cdecl _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
		const _Elem *_Ptr)
	{	
	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
		if (_Ptr[_Off] == _Ptr[0])
			++_Numfields;	
	string _Str(_Numfields, '\0');	

	int _Ans = -2;	
	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)
		{	
		bool  _Prefix = false;	
		size_t _Off = 0;	
		size_t _Field = 0;	

		for (; _Field < _Numfields; ++_Field)
			{	
			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
				;	

			if (_Str[_Field] != '\0')
				_Off += _Str[_Field];	
			else if (_Ptr[_Off += _Column] == _Ptr[0]
				|| _Ptr[_Off] == (_Elem)0)
				{	
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	
				_Ans = (int)_Field;	
				}
			else if (_First == _Last || _Ptr[_Off] != *_First)
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	
			else
				_Prefix = true;	
			}

		if (!_Prefix || _First == _Last)
			break;	
		}
	return (_Ans);	
	}

		



template<class _Elem> inline
	char __cdecl _Maklocbyte(_Elem _Char,
		const _Locinfo::_Cvtvec&)
	{	
	return ((char)(unsigned char)_Char);
	}

template<> inline
	char __cdecl _Maklocbyte(wchar_t _Char,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	char _Byte = '\0';
	mbstate_t _Mbst1 = {0};
	_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}


		



template<class _Elem> inline
	_Elem __cdecl _Maklocchr(char _Byte, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	
	return ((_Elem)(unsigned char)_Byte);
	}

template<> inline
	wchar_t __cdecl _Maklocchr(char _Byte,          wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	wchar_t _Wc = L'\0';
	mbstate_t _Mbst1 = {0};
	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}


		



template<class _Elem> inline
	_Elem *__cdecl _Maklocstr(const char *_Ptr, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	
	size_t _Count = ::strlen(_Ptr) + 1;
	_Elem *_Ptrdest = new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 606) _Elem[_Count];

#pragma warning(push)
#pragma warning(disable: 6011)
	
	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;
	return (_Ptrdest);
#pragma warning(pop)
	}

template<> inline
	wchar_t *__cdecl _Maklocstr(const char *_Ptr,          wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	wchar_t _Wc;
	mbstate_t _Mbst1 = {0};

	_Count1 = ::strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	

	wchar_t *_Ptrdest = new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 635) wchar_t[_Wchars];
	wchar_t *_Ptrnext = _Ptrdest;
	mbstate_t _Mbst2 = {0};
#pragma warning(push)
#pragma warning(disable: 6011)
	
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
#pragma warning(pop)
	return (_Ptrdest);
	}


		
class __declspec(dllimport) codecvt_base
	: public locale::facet
	{	
public:
	enum
		{	
		ok, partial, error, noconv};
	typedef int result;

	 codecvt_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}

	bool  always_noconv() const throw ()
		{	
		return (do_always_noconv());
		}

	int  max_length() const throw ()
		{	
		return (do_max_length());
		}

	int  encoding() const throw ()
		{	
		return (do_encoding());
		}

	 ~codecvt_base()
		{	
		}

protected:
	virtual bool  do_always_noconv() const throw ()
		{	
		return (true);
		}

	virtual int  do_max_length() const throw ()
		{	
		return (1);
		}

	virtual int  do_encoding() const throw ()
		{	
		return (1);	
		}
	};

		
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt
		: public codecvt_base
	{	
public:
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State, _First2, _Last2, _Mid2));
		}

	int  length(const _Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;	

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 761) codecvt<_Elem, _Byte, _Statype>;
		return (2);
		}

protected:
	virtual  ~codecvt()
		{	
		}

protected:
	void  _Init(const _Locinfo&)
		{	
		}

	virtual result  do_in(_Statype&,
		const _Byte *_First1, const _Byte *, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *, _Elem *& _Mid2) const
		{	
		_Mid1 = _First1, _Mid2 = _First2;
		return (noconv);	
		}

	virtual result  do_out(_Statype&,
		const _Elem *_First1, const _Elem *, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{	
		_Mid1 = _First1, _Mid2 = _First2;
		return (noconv);	
		}

	virtual result  do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *&_Mid2) const
		{	
		_Mid2 = _First2;
		return (noconv);	
		}

	virtual int  do_length(const _Statype&, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return ((int)(_Count < (size_t)(_Last1 - _First1)
			? _Count : _Last1 - _First1));	
		}
	};

		
template<class _Elem,
	class _Byte,
	class _Statype>
	 locale::id codecvt<_Elem, _Byte, _Statype>::id;

		
template<> class __declspec(dllimport) codecvt<wchar_t, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef wchar_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(const _Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	static  locale::id& __cdecl _Id_func();



	 static locale::id id;	
#line 859 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 877) codecvt<_Elem, _Byte, _Statype>;
		return (2);
		}

protected:
	virtual  ~codecvt()
		{	
		}

protected:
	void  _Init(const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 896);
		_Debug_range(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 897);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	
			case -2:	
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	
				return (error);

			case 0:	
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int)::strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 932);
		_Debug_range(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 933);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if (5 <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
			else
				{	
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else if (_Last2 - _Mid2 < _Bytes)
					{	
					_State = _Stsave;
					return (_Ans);
					}
				else
					{	
					::memcpy_s((_Mid2), (_Last2 - _Mid2), (_Buf), (_Bytes));
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
					}
				}
		return (_Ans);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 970);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	
		else if (_Last2 - _Mid2 < --_Bytes)
			{	
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	
			::memcpy_s((_Mid2), (_Last2 - _Mid2), (_Buf), (_Bytes));
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int  do_length(const _Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 995);
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	
			case -2:	
				return (_Wchars);

			case -1:	
				return (_Wchars);

			case 0:	
				if (_Ch == (_Elem)0)
					_Bytes = (int)::strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool  do_always_noconv() const throw ()
		{	
		return (false);
		}

	virtual int  do_max_length() const throw ()
		{	
		return (5);
		}

	virtual int  do_encoding() const throw ()
		{	
		return (0);
		}

private:
	_Locinfo::_Cvtvec _Cvt;	
	};
























































































































































































































































		
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt_byname
		: public codecvt<_Elem, _Byte, _Statype>
	{	
public:
	explicit  codecvt_byname(const char *_Locname, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locname, _Refs)
		{	
		}

protected:
	virtual  ~codecvt_byname()
		{	
		}
	};

		
struct __declspec(dllimport) ctype_base
	: public locale::facet
	{	
	enum
		{	
		alnum = 0x4|0x2|0x1|0x100, alpha = 0x2|0x1|0x100,
		cntrl = 0x20, digit = 0x4, graph = 0x4|0x2|0x10|0x1|0x100,
		lower = 0x2, print = 0x4|0x2|0x10|0x40|0x1|0x100|0x80,
		punct = 0x10, space = 0x8|0x40|0x000, upper = 0x1,
		xdigit = 0x80};
	typedef short mask;	

	 ctype_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}

	 ~ctype_base()
		{	
		}

protected:
	static void __cdecl _Xran()
		{	
		throw out_of_range("out_of_range in ctype<T>");
		}
	};

		
template<class _Elem>
	class ctype
		: public ctype_base
	{	
public:
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
#pragma warning(push)
#pragma warning(disable:4996)
		return (do_widen(_First, _Last, _Dest));
#pragma warning(pop)
		}

	const char * _Widen_s(const char *_First, const char *_Last,
		_Elem *_Dest, size_t _Dest_size) const
		{	
		return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt,      char *_Dest) const
		{	
		
#pragma warning(push)
#pragma warning(disable:4996)
		return (do_narrow(_First, _Last, _Dflt, _Dest));
#pragma warning(pop)
		}

	const _Elem * _Narrow_s(const _Elem *_First, const _Elem *_Last,
		char _Dflt,        char *_Dest, size_t _Dest_size) const
		{	
		return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
		}

	 static locale::id id;	

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1457) ctype<_Elem>;
		return (2);
		}

protected:
	virtual  ~ctype()
		{	
		if (_Ctype._Delfl)
			free((void *)_Ctype._Table);
		}

protected:
	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
			& _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1483);
		_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale",1484);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
		return (_First);
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1493);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1502);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Tolower(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_tolower(_Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1519);
		for (; _First != _Last; ++_First)
			{	
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Tolower(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Toupper(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_toupper(_Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1540);
		for (; _First != _Last; ++_First)
			{	
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Toupper(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Maklocchr(_Byte, (_Elem *)0, _Cvt));
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		
		return _Do_widen_s(_First, _Last, _Dest, _Last - _First);
		}

	virtual const char * _Do_widen_s(const char *_First,
		const char *_Last, _Elem *_Dest, size_t _Dest_size) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1566);
		_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale",1567);
		{ if (!(_Dest_size >= (size_t)(_Last - _First))) { (void) ((!!((("_Dest_size >= (size_t)(_Last - _First)", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1568, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1568, 0); } ; };
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Maklocchr(*_First, (_Elem *)0, _Cvt);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Byte;
		if (_Ch == (_Elem)0)
			return ('\0');
		else if ((_Byte = _Maklocbyte((_Elem)_Ch, _Cvt)) == '\0')
			return (_Dflt);
		else
			return (_Byte);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt,      char *_Dest) const
		{	
		
		return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First);
		}

	virtual const _Elem * _Do_narrow_s(const _Elem *_First,
		const _Elem *_Last, char _Dflt, 
		       char *_Dest, 
		size_t _Dest_size) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1603);
		_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale",1604);
		{ if (!(_Dest_size >= (size_t)(_Last - _First))) { (void) ((!!((("_Dest_size >= (size_t)(_Last - _First)", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1605, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1605, 0); } ; };
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};

		
template<class _Elem>
	 locale::id ctype<_Elem>::id;

		
template<> class __declspec(dllimport) ctype<char>
	: public ctype_base
	{	
	typedef ctype<char> _Myt;

public:
	typedef char _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
		}

	const _Elem * is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1638);
		_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale",1639);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)*_First];
		return (_First);
		}

	const _Elem * scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1648);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	const _Elem * scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1657);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	const _Elem * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		
#pragma warning(push)
#pragma warning(disable:4996)
		return (do_widen(_First, _Last, _Dest));
#pragma warning(pop)
		}

	const _Elem * _Widen_s(const char *_First, const char *_Last,
		_Elem *_Dest, size_t _Dest_size) const
		{	
		return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
		}

	_Elem  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt,      char *_Dest) const
		{	
		
#pragma warning(push)
#pragma warning(disable:4996)
		return (do_narrow(_First, _Last, _Dflt, _Dest));
#pragma warning(pop)
		}

	const _Elem * _Narrow_s(const _Elem *_First, const _Elem *_Last,
		char _Dflt,        char *_Dest, 
		size_t _Dest_size) const
		{	
		return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
		}

	static  locale::id& __cdecl _Id_func();



	 static locale::id id;	
#line 1734 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"

	explicit  ctype(const mask *_Table = 0,
		bool _Deletetable = false,
		size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		if (_Table != 0)
			{	
			_Tidy();
			_Ctype._Table = _Table;
			_Ctype._Delfl = _Deletetable ? -1 : 0;
			}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1760) ctype<_Elem>;
		return (2);
		}

	 static const size_t table_size = 1 << 8;	

protected:
	virtual  ~ctype()
		{	
		_Tidy();
		}

protected:
	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		}

	void  _Tidy()
		{	
		if (0 < _Ctype._Delfl)
			free((void *)_Ctype._Table);
		else if (_Ctype._Delfl < 0)
			delete[] (void *)_Ctype._Table;
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1794);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1808);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Byte);
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	virtual const _Elem * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		
		return _Do_widen_s(_First, _Last, _Dest, _Last - _First);
		}

	virtual const _Elem * _Do_widen_s(const char *_First,
		const char *_Last, _Elem *_Dest, size_t _Dest_size) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1830);
		_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale",1831);
		{ if (!(_Dest_size >= (size_t)(_Last - _First))) { (void) ((!!((("_Dest_size >= (size_t)(_Last - _First)", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1832, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1832, 0); } ; };
		::memcpy_s((_Dest), (_Dest_size), (_First), (_Last - _First));
		return (_Last);
		}

	virtual _Elem  do_narrow(_Elem _Ch, char) const
		{	
		return (_Ch);
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, 
		     char *_Dest) const
		{	
		
		return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First);
		}

	virtual const _Elem * _Do_narrow_s(const _Elem *_First,
		const _Elem *_Last, char,        char *_Dest, 
		size_t _Dest_size) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1855);
		_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale",1856);
		{ if (!(_Dest_size >= (size_t)(_Last - _First))) { (void) ((!!((("_Dest_size >= (size_t)(_Last - _First)", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1857, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1857, 0); } ; };
		::memcpy_s((_Dest), (_Dest_size), (_First), (_Last - _First));
		return (_Last);
		}

	const mask * table() const throw ()
		{	
		return (_Ctype._Table);
		}

	static const mask *__cdecl classic_table() throw ()
		{	
		const _Myt& _Ctype_fac = use_facet<_Myt >(locale::classic());
		return (_Ctype_fac.table());
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	};

		
template<> class __declspec(dllimport) ctype<wchar_t>
	: public ctype_base
	{	
	typedef ctype<wchar_t> _Myt;

public:
	typedef wchar_t _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		
#pragma warning(push)
#pragma warning(disable:4996)
		return (do_widen(_First, _Last, _Dest));
#pragma warning(pop)
		}

	const char * _Widen_s(const char *_First, const char *_Last,
		_Elem *_Dest, size_t _Dest_size) const
		{	
		return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt,      char *_Dest) const
		{	
		
#pragma warning(push)
#pragma warning(disable:4996)
		return (do_narrow(_First, _Last, _Dflt, _Dest));
#pragma warning(pop)
		}

	const _Elem * _Narrow_s(const _Elem *_First, const _Elem *_Last,
		char _Dflt,        char *_Dest, 
		size_t _Dest_size) const
		{	
		return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
		}

	static  locale::id& __cdecl _Id_func();



	 static locale::id id;	
#line 1981 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 1999) ctype<_Elem>;
		return (2);
		}

protected:
	virtual  ~ctype()
		{	
		if (_Ctype._Delfl)
			free((void *)_Ctype._Table);
		}

protected:
	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((::_Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const wchar_t * do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 2025);
		_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale",2026);
		return (::_Getwctypes(_First, _Last, _Dest, &_Ctype));
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 2033);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 2042);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 2056);
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 2070);
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem  _Dowiden(char _Byte) const
		{	
		mbstate_t _Mbst = {0};
		wchar_t _Wc;
		return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (wchar_t)(wint_t)(0xFFFF) : _Wc);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Dowiden(_Byte));
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		
		return _Do_widen_s(_First, _Last, _Dest, _Last - _First);
		}

	virtual const char * _Do_widen_s(const char *_First,
		const char *_Last, _Elem *_Dest, size_t _Dest_size) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 2100);
		_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale",2101);
		{ if (!(_Dest_size >= (size_t)(_Last - _First))) { (void) ((!!((("_Dest_size >= (size_t)(_Last - _First)", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 2102, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 2102, 0); } ; };
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Buf[5];
		mbstate_t _Mbst = {0};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt,  
		     char *_Dest) const
		{	
		
		return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First);
		}

	virtual const _Elem * _Do_narrow_s(const _Elem *_First,
		const _Elem *_Last, char _Dflt, 
		       char *_Dest, 
		size_t _Dest_size) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 2135);
		_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale",2136);
		{ if (!(_Dest_size >= (size_t)(_Last - _First))) { (void) ((!!((("_Dest_size >= (size_t)(_Last - _First)", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 2137, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale", 2137, 0); } ; };
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};


























































































































































































































































































		
template<class _Elem>
	class ctype_byname
	: public ctype<_Elem>
	{	
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<_Elem>(_Locname, _Refs)
		{	
		}

protected:
	virtual  ~ctype_byname()
		{	
		}
	};

		
template<> class ctype_byname<char>
	: public ctype<char>
	{	
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<char>(_Locname, _Refs)
		{	
		}

protected:
	virtual  ~ctype_byname()
		{	
		}
	};

 

template class __declspec(dllimport) codecvt<char, char, _Mbstatet>;

 #line 2467 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"
}


#pragma warning(pop)
#pragma pack(pop)
#line 2473 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"

#line 2475 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"
#line 2476 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocale"






#line 7 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xiosbase"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\share.h"













#pragma once
#line 16 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\share.h"






#line 23 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\share.h"














#line 38 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\share.h"

#line 40 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\share.h"
#line 8 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xiosbase"


#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable:4412)
#line 14 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xiosbase"

namespace std {

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
		
template<class _Dummy>
	class _Iosb
	{	
public:
	enum _Dummy_enum {_Dummy_enum_val = 1};	

	enum _Fmtflags
		{	
		_Fmtmask = 0xffff, _Fmtzero = 0};

	static const _Fmtflags skipws = (_Fmtflags)0x0001;
	static const _Fmtflags unitbuf = (_Fmtflags)0x0002;
	static const _Fmtflags uppercase = (_Fmtflags)0x0004;
	static const _Fmtflags showbase = (_Fmtflags)0x0008;
	static const _Fmtflags showpoint = (_Fmtflags)0x0010;
	static const _Fmtflags showpos = (_Fmtflags)0x0020;
	static const _Fmtflags left = (_Fmtflags)0x0040;
	static const _Fmtflags right = (_Fmtflags)0x0080;
	static const _Fmtflags internal = (_Fmtflags)0x0100;
	static const _Fmtflags dec = (_Fmtflags)0x0200;
	static const _Fmtflags oct = (_Fmtflags)0x0400;
	static const _Fmtflags hex = (_Fmtflags)0x0800;
	static const _Fmtflags scientific = (_Fmtflags)0x1000;
	static const _Fmtflags fixed = (_Fmtflags)0x2000;
	static const _Fmtflags boolalpha = (_Fmtflags)0x4000;
	static const _Fmtflags _Stdio = (_Fmtflags)0x8000;
	static const _Fmtflags adjustfield = (_Fmtflags)(0x0040
		| 0x0080 | 0x0100);
	static const _Fmtflags basefield = (_Fmtflags)(0x0200
		| 0x0400 | 0x0800);
	static const _Fmtflags floatfield = (_Fmtflags)(0x1000
		| 0x2000);

	enum _Iostate
		{	
		_Statmask = 0x17};

	static const _Iostate goodbit = (_Iostate)0x0;
	static const _Iostate eofbit = (_Iostate)0x1;
	static const _Iostate failbit = (_Iostate)0x2;
	static const _Iostate badbit = (_Iostate)0x4;
	static const _Iostate _Hardfail = (_Iostate)0x10;

	enum _Openmode
		{	
		_Openmask = 0xff};

	static const _Openmode in = (_Openmode)0x01;
	static const _Openmode out = (_Openmode)0x02;
	static const _Openmode ate = (_Openmode)0x04;
	static const _Openmode app = (_Openmode)0x08;
	static const _Openmode trunc = (_Openmode)0x10;
	static const _Openmode _Nocreate = (_Openmode)0x40;
	static const _Openmode _Noreplace = (_Openmode)0x80;
	static const _Openmode binary = (_Openmode)0x20;

	enum _Seekdir
		{	
		_Seekmask = 0x3};
	static const _Seekdir beg = (_Seekdir)0;
	static const _Seekdir cur = (_Seekdir)1;
	static const _Seekdir end = (_Seekdir)2;

	enum
		{	
		_Openprot = 0x40};
	};

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::_Hardfail;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;

		
class __declspec(dllimport) ios_base
	: public _Iosb<int>
	{	
public:
	typedef int fmtflags;
	typedef int iostate;
	typedef int openmode;
	typedef int seekdir;

	typedef std::streamoff streamoff;
	typedef std::streampos streampos;

	enum event
		{	
		erase_event, imbue_event, copyfmt_event};

	typedef void (__cdecl *event_callback)(event, ios_base&, int);
	typedef unsigned int io_state, open_mode, seek_dir;

			
	class failure
		: public runtime_error
		{	
	public:
		explicit  failure(const string &_Message)
			: runtime_error(_Message)
			{	
			}

		virtual  ~failure() throw ()
			{	
			}








#line 223 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xiosbase"

		};

			
	class __declspec(dllimport) Init
		{	
	public:
		 Init()
            {
            _Init_ctor(this);
            }

		 ~Init()
            {
            _Init_dtor(this);
            }

	private:
        static  void __cdecl _Init_ctor(Init *);
        static  void __cdecl _Init_dtor(Init *);

		 static int& __cdecl _Init_cnt_func();	



		 static int _Init_cnt;	
#line 250 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xiosbase"
		};

	ios_base&  operator=(const ios_base& _Right)
		{	
		if (this != &_Right)
			{	
			_Mystate = _Right._Mystate;
			copyfmt(_Right);
			}
		return (*this);
		}

	 operator void *() const
		{	
		return (fail() ? 0 : (void *)this);
		}

	bool  operator!() const
		{	
		return (fail());
		}

    void  clear(iostate _State, bool _Reraise)
        {	
        _Mystate = (iostate)(_State & _Statmask);
        if ((_Mystate & _Except) == 0)
            ;
        else if (_Reraise)
            throw;
        else if (_Mystate & _Except & badbit)
            throw failure("ios_base::badbit set");
        else if (_Mystate & _Except & failbit)
            throw failure("ios_base::failbit set");
        else
            throw failure("ios_base::eofbit set");
        }

	void  clear(iostate _State = goodbit)
		{	
		clear(_State, false);
		}

	void  clear(io_state _State)
		{	
		clear((iostate)_State);
		}

	iostate  rdstate() const
		{	
		return (_Mystate);
		}


	void  setstate(iostate _State, bool _Exreraise)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
		}

	void  setstate(iostate _State)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), false);
		}

	void  setstate(io_state _State)
		{	
		setstate((iostate)_State);
		}

	bool  good() const
		{	
		return (rdstate() == goodbit);
		}

	bool  eof() const
		{	
		return ((int)rdstate() & (int)eofbit);
		}

	bool  fail() const
		{	
		return (((int)rdstate()
			& ((int)badbit | (int)failbit)) != 0);
		}

	bool  bad() const
		{	
		return (((int)rdstate() & (int)badbit) != 0);
		}

	
	
	
	iostate  exceptions() const
		{	
		return (_Except);
		}

	void  exceptions(iostate _Newexcept)
		{	
		_Except = (iostate)((int)_Newexcept & (int)_Statmask);
		clear(_Mystate);
		}

	void  exceptions(io_state _State)
		{	
		exceptions((iostate)_State);
		}

	fmtflags  flags() const
		{	
		return (_Fmtfl);
		}

	fmtflags  flags(fmtflags _Newfmtflags)
		{	
		fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Newfmtflags & (int)_Fmtmask);
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags)
		{	
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Fmtfl
			| (int)_Newfmtflags & (int)_Fmtmask);
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags, fmtflags _Mask)
		{	
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
			| ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));
		return (_Oldfmtflags);
		}

	void  unsetf(fmtflags _Mask)
		{	
		_Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_Mask);
		}

	streamsize  precision() const
		{	
		return (_Prec);
		}

	streamsize  precision(streamsize _Newprecision)
		{	
		streamsize _Oldprecision = _Prec;
		_Prec = _Newprecision;
		return (_Oldprecision);
		}

	streamsize  width() const
		{	
		return (_Wide);
		}

	streamsize  width(streamsize _Newwidth)
		{	
		streamsize _Oldwidth = _Wide;
		_Wide = _Newwidth;
		return (_Oldwidth);
		}

	locale  getloc() const
		{	
		return (*_Ploc);
		}

	locale  imbue(const locale& _Loc)
        {	
        locale _Oldlocale = *_Ploc;
        *_Ploc = _Loc;
        _Callfns(imbue_event);
        return (_Oldlocale);
        }

	static int __cdecl xalloc()
		{	
		{ ::std:: _Lockit _Lock(2);	
			return (_Index++);
		}
		}

	long&  iword(int _Idx)
		{	
		return (_Findarr(_Idx)._Lo);
		}

	void *&  pword(int _Idx)
		{	
		return (_Findarr(_Idx)._Vp);
		}

	void  register_callback(event_callback _Pfn, int _Idx)
        {	
        _Calls = new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xiosbase", 449) _Fnarray(_Idx, _Pfn, _Calls);
        }

	ios_base&  copyfmt(const ios_base& _Other)
        {	
        if (this != &_Other)
            {	
            _Tidy();
            *_Ploc = *_Other._Ploc;
            _Fmtfl = _Other._Fmtfl;
            _Prec = _Other._Prec;
            _Wide = _Other._Wide;
            _Iosarray *_Ptr = _Other._Arr;

            for (_Arr = 0; _Ptr != 0; _Ptr = _Ptr->_Next)
                if (_Ptr->_Lo != 0 || _Ptr->_Vp != 0)
                    {	
                    iword(_Ptr->_Index) = _Ptr->_Lo;
                    pword(_Ptr->_Index) = _Ptr->_Vp;
                    }

            for (_Fnarray *_Q = _Other._Calls; _Q != 0; _Q = _Q->_Next)
                register_callback(_Q->_Pfn, _Q->_Index);	

            _Callfns(copyfmt_event);	
            exceptions(_Other._Except);	
            }
        return (*this);
        }


	virtual  ~ios_base()
        {
        _Ios_base_dtor(this);
        }

	static bool __cdecl sync_with_stdio(bool _Newsync = true)
		{	
		{ ::std:: _Lockit _Lock(2);	
			const bool _Oldsync = _Sync;
			_Sync = _Newsync;
			return (_Oldsync);
		}
		}

	static  void __cdecl _Addstd(ios_base *);
	size_t _Stdstr;	

protected:
	 ios_base()
		{	
		}

	void  _Init()
        {	
        _Ploc = 0;
        _Except = goodbit;
        _Fmtfl = skipws | dec;
        _Prec = 6;
        _Wide = 0;
        _Arr = 0;
        _Calls = 0;
        clear(goodbit);
        _Ploc = new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xiosbase", 512) locale;
        }

private:
			
	struct _Iosarray
		{	
	public:
		 _Iosarray(int _Idx, _Iosarray *_Link)
			: _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
			{	
			}

		_Iosarray *_Next;	
		int _Index;	
		long _Lo;	
		void *_Vp;	
		};

			
	struct _Fnarray
		{	
		 _Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link)
			: _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
			{	
			}

		_Fnarray *_Next;	
		int _Index;	
		event_callback _Pfn;	
		};

	void  _Callfns(event _Ev)
        {	
        for (_Fnarray *_Ptr = _Calls; _Ptr != 0; _Ptr = _Ptr->_Next)
            (*_Ptr->_Pfn)(_Ev, *this, _Ptr->_Index);
        }

	_Iosarray&  _Findarr(int _Idx)
        {	
        _Iosarray *_Ptr, *_Q;

        for (_Ptr = _Arr, _Q = 0; _Ptr != 0; _Ptr = _Ptr->_Next)
            if (_Ptr->_Index == _Idx)
                return (*_Ptr);	
            else if (_Q == 0 && _Ptr->_Lo == 0 && _Ptr->_Vp == 0)
                _Q = _Ptr;	

        if (_Q != 0)
            {	
            _Q->_Index = _Idx;
            return (*_Q);
            }

        _Arr = new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xiosbase", 566) _Iosarray(_Idx, _Arr);	
        return (*_Arr);
        }

	void __cdecl _Tidy()
        {	
        _Callfns(erase_event);
        _Iosarray *_Q1, *_Q2;

        for (_Q1 = _Arr; _Q1 != 0; _Q1 = _Q2)
            _Q2 = _Q1->_Next, std::_DebugHeapDelete(_Q1);	
        _Arr = 0;

        _Fnarray *_Q3, *_Q4;
        for (_Q3 = _Calls; _Q3 != 0; _Q3 = _Q4)
            _Q4 = _Q3->_Next, std::_DebugHeapDelete(_Q3);	
        _Calls = 0;
        }

    static  void __cdecl _Ios_base_dtor(ios_base *);

	iostate _Mystate;	
	iostate _Except;	
	fmtflags _Fmtfl;	
	streamsize _Prec;	
	streamsize _Wide;	
	_Iosarray *_Arr;	
	_Fnarray *_Calls;	
	locale *_Ploc;	




#line 600 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xiosbase"
	 static int _Index;	
	 static bool _Sync;	
#line 603 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xiosbase"
    static  int& __cdecl _Index_func();
    static  bool& __cdecl _Sync_func();
	};





}


#pragma warning(pop)
#pragma pack(pop)
#line 617 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xiosbase"

#line 619 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xiosbase"
#line 620 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xiosbase"





#line 7 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\streambuf"


#pragma pack(push,8)
#pragma warning(push,3)
#line 12 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\streambuf"

namespace std {

		
template<class _Elem,
	class _Traits>
	class basic_streambuf
	{	

	basic_streambuf(const basic_streambuf<_Elem, _Traits>&);	
	basic_streambuf<_Elem, _Traits>&
		operator=(const basic_streambuf<_Elem, _Traits>&);	


protected:
	basic_streambuf()
		: _Plocale(new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\streambuf", 28)(locale))
		{	
		_Init();
		}

	basic_streambuf(_Uninitialized)
		{	
		}

public:
	typedef basic_streambuf<_Elem, _Traits> _Myt;
	typedef _Elem char_type;
	typedef _Traits traits_type;

	virtual  ~basic_streambuf()
		{	
		std::_DebugHeapDelete(_Plocale);
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	pos_type pubseekoff(off_type _Off, ios_base::seekdir _Way,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		return (seekoff(_Off, _Way, _Mode));
		}

	pos_type pubseekoff(off_type _Off, ios_base::seek_dir _Way,
		ios_base::open_mode _Mode)
		{	
		return (pubseekoff(_Off, (ios_base::seekdir)_Way,
			(ios_base::openmode)_Mode));
		}

	pos_type pubseekpos(pos_type _Pos,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		return (seekpos(_Pos, _Mode));
		}

	pos_type pubseekpos(pos_type _Pos, ios_base::open_mode _Mode)
		{	
		return (seekpos(_Pos, (ios_base::openmode)_Mode));
		}

	_Myt *pubsetbuf(_Elem *_Buffer, streamsize _Count)
		{	
		return (setbuf(_Buffer, _Count));
		}

	locale pubimbue(const locale &_Newlocale)
		{	
		locale _Oldlocale = *_Plocale;
		imbue(_Newlocale);
		*_Plocale = _Newlocale;
		return (_Oldlocale);
		}

	locale getloc() const
		{	
		return (*_Plocale);
		}

	streamsize in_avail()
		{	
		streamsize _Res = _Gnavail();
		return (0 < _Res ? _Res : showmanyc());
		}

	int pubsync()
		{	
		return (sync());
		}

	int_type sbumpc()
		{	
		return (0 < _Gnavail()
			? _Traits::to_int_type(*_Gninc()) : uflow());
		}

	int_type sgetc()
		{	
		return (0 < _Gnavail()
			? _Traits::to_int_type(*gptr()) : underflow());
		}

	streamsize _Sgetn_s(_Elem *_Ptr, size_t _Ptr_size, streamsize _Count)
		{	
		return _Xsgetn_s(_Ptr, _Ptr_size, _Count);
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	streamsize sgetn(_Elem *_Ptr, streamsize _Count)
		{	
#pragma warning(push)
#pragma warning(disable:4996)
		return xsgetn(_Ptr, _Count);
#pragma warning(pop)
		}

	int_type snextc()
		{	
		return (1 < _Gnavail()
			? _Traits::to_int_type(*_Gnpreinc())
			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
				? _Traits::eof() : sgetc());
		}

	int_type sputbackc(_Elem _Ch)
		{	
		return (gptr() != 0 && eback() < gptr()
			&& _Traits::eq(_Ch, gptr()[-1])
			? _Traits::to_int_type(*_Gndec())
			: pbackfail(_Traits::to_int_type(_Ch)));
		}

	void stossc()
		{	
		if (0 < _Gnavail())
			_Gninc();
		else
			uflow();
		}

	int_type sungetc()
		{	
		return (gptr() != 0 && eback() < gptr()
			? _Traits::to_int_type(*_Gndec()) : pbackfail());
		}

	int_type sputc(_Elem _Ch)
		{	
		return (0 < _Pnavail()
			? _Traits::to_int_type(*_Pninc() = _Ch)
			: overflow(_Traits::to_int_type(_Ch)));
		}

	streamsize sputn(const _Elem *_Ptr, streamsize _Count)
		{	
		return (xsputn(_Ptr, _Count));
		}

	void _Lock()
		{	
		_Mylock._Lock();
		}

	void _Unlock()
		{	
		_Mylock._Unlock();
		}


protected:
	_Elem *eback() const
		{	
		return (*_IGfirst);
		}

	_Elem *gptr() const
		{	
		return (*_IGnext);
		}

	_Elem *pbase() const
		{	
		return (*_IPfirst);
		}

	_Elem *pptr() const
		{	
		return (*_IPnext);
		}

	_Elem *egptr() const
		{	
		return (*_IGnext + *_IGcount);
		}

	void gbump(int _Off)
		{	
		*_IGcount -= _Off;
		*_IGnext += _Off;
		}

	void setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	
		*_IGfirst = _First;
		*_IGnext = _Next;
		*_IGcount = (int)(_Last - _Next);
		}

	_Elem *epptr() const
		{	
		return (*_IPnext + *_IPcount);
		}

	_Elem *_Gndec()
		{	
		++*_IGcount;
		return (--*_IGnext);
		}

	_Elem *_Gninc()
		{	
		--*_IGcount;
		return ((*_IGnext)++);
		}

	_Elem *_Gnpreinc()
		{	
		--*_IGcount;
		return (++(*_IGnext));
		}

	streamsize _Gnavail() const
		{	
		return (*_IGnext != 0 ? *_IGcount : 0);
		}

	void pbump(int _Off)
		{	
		*_IPcount -= _Off;
		*_IPnext += _Off;
		}

	void setp(_Elem *_First, _Elem *_Last)
		{	
		*_IPfirst = _First;
		*_IPnext = _First;
		*_IPcount = (int)(_Last - _First);
		}

	void setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	
		*_IPfirst = _First;
		*_IPnext = _Next;
		*_IPcount = (int)(_Last - _Next);
		}

	_Elem *_Pninc()
		{	
		--*_IPcount;
		return ((*_IPnext)++);
		}

	streamsize _Pnavail() const
		{	
		return (*_IPnext != 0 ? *_IPcount : 0);
		}

	void _Init()
		{	
		_IGfirst = &_Gfirst, _IPfirst = &_Pfirst;
		_IGnext = &_Gnext, _IPnext = &_Pnext;
		_IGcount = &_Gcount, _IPcount = &_Pcount;
		setp(0, 0), setg(0, 0, 0);
		}

	void _Init(_Elem **_Gf, _Elem **_Gn, int *_Gc,
		_Elem **_Pf, _Elem **_Pn, int *_Pc)
		{	
		_IGfirst = _Gf, _IPfirst = _Pf;
		_IGnext = _Gn, _IPnext = _Pn;
		_IGcount = _Gc, _IPcount = _Pc;
		}

	virtual int_type  overflow(int_type = _Traits::eof())
		{	
		return (_Traits::eof());
		}

	virtual int_type  pbackfail(int_type = _Traits::eof())
		{	
		return (_Traits::eof());
		}

	virtual streamsize  showmanyc()
		{	
		return (0);
		}

	virtual int_type  underflow()
		{	
		return (_Traits::eof());
		}

	virtual int_type  uflow()
		{	
		return (_Traits::eq_int_type(_Traits::eof(), underflow())
			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	virtual streamsize  xsgetn(_Elem * _Ptr,
		streamsize _Count)
		{	
		
		return _Xsgetn_s(_Ptr, (size_t)-1, _Count);
		}

	virtual streamsize  _Xsgetn_s(_Elem * _Ptr,
		size_t _Ptr_size, streamsize _Count)
		{	
		int_type _Meta;
		streamsize _Stream_size, _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Stream_size = _Gnavail()))
				{	
				_Size = _Stream_size;
				if (_Count < _Size)
					_Size = _Count;
				_Traits_helper::copy_s<_Traits>(_Ptr, _Ptr_size, gptr(), _Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				gbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
				break;	
			else
				{	
				*_Ptr++ = _Traits::to_char_type(_Meta);
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual streamsize  xsputn(const _Elem *_Ptr,
		streamsize _Count)
		{	
		streamsize _Stream_size, _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Stream_size = _Pnavail()))
				{	
				_Size = _Stream_size;
				if (_Count < _Size)
					_Size = _Count;
				_Traits_helper::copy_s<_Traits>(pptr(), _Stream_size, _Ptr, _Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				pbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(),
				overflow(_Traits::to_int_type(*_Ptr))))
				break;	
			else
				{	
				++_Ptr;
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual pos_type  seekoff(off_type, ios_base::seekdir,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	
		return (streampos(_BADOFF));
		}

	virtual pos_type  seekpos(pos_type,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	
		return (streampos(_BADOFF));
		}

	virtual _Myt * setbuf(_Elem *, streamsize)
		{	
		return (this);
		}

	virtual int  sync()
		{	
		return (0);
		}

	virtual void  imbue(const locale&)
		{	
		}

private:
	_Mutex _Mylock;	
	_Elem *_Gfirst;	
	_Elem *_Pfirst;	
	_Elem **_IGfirst;	
	_Elem **_IPfirst;	
	_Elem *_Gnext;	
	_Elem *_Pnext;	
	_Elem **_IGnext;	
	_Elem **_IPnext;	
	int _Gcount;	
	int _Pcount;	
	int *_IGcount;	
	int *_IPcount;	
	locale *_Plocale;	
	};

 

template class __declspec(dllimport) basic_streambuf<char, char_traits<char> >;
template class __declspec(dllimport) basic_streambuf<wchar_t, char_traits<wchar_t> >;



 #line 442 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\streambuf"
}


#pragma warning(pop)
#pragma pack(pop)
#line 448 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\streambuf"

#line 450 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\streambuf"
#line 451 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\streambuf"





#line 10 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"


#pragma pack(push,8)
#pragma warning(push,3)
#line 15 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"

		


extern "C" {
#line 21 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"
extern __declspec(dllimport) long __cdecl _Stolx(const char *,                     char **,
	int, int *);
extern __declspec(dllimport) unsigned long __cdecl _Stoulx(const char *, 
	                    char **, int, int *);
extern __declspec(dllimport) float __cdecl _Stofx(const char *,                     char **,
	long, int *);
extern __declspec(dllimport) double __cdecl _Stodx(const char *,                     char **,
	long, int *);
extern __declspec(dllimport) long double __cdecl _Stoldx(const char *, 
	                    char **, long, int *);

}
#line 34 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"



  
   
   
  #line 41 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"

namespace std {

 

		
template<class _Elem>
	class numpunct
		: public locale::facet
	{	
public:
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;
	typedef _Elem char_type;

	 static locale::id id;	

	_Elem  decimal_point() const
		{	
		return (do_decimal_point());
		}

	_Elem  thousands_sep() const
		{	
		return (do_thousands_sep());
		}

	string  grouping() const
		{	
		return (do_grouping());
		}

	string_type  falsename() const
		{	
		return (do_falsename());
		}

	string_type  truename() const
		{	
		return (do_truename());
		}

	explicit  numpunct(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
			if (_Kseparator == 0)
				_Kseparator =	
					_Maklocchr(',', (_Elem *)0, _Lobj._Getcvt());
		}
		}

	 numpunct(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum", 103) numpunct<_Elem>;
		return (4);
		}

protected:
	virtual  ~numpunct()
		{	
		_Tidy();
		}

protected:
	 numpunct(const char *_Locname, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj);
		}
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		const lconv *_Ptr = _Lobj._Getlconv();

		_Grouping = 0;
		_Falsename = 0;
		_Truename = 0;

		try {
		_Grouping = _Maklocstr(_Ptr->grouping, (char *)0, _Lobj._Getcvt());
		_Falsename = _Maklocstr(_Lobj._Getfalse(), (_Elem *)0, _Lobj._Getcvt());
		_Truename = _Maklocstr(_Lobj._Gettrue(), (_Elem *)0, _Lobj._Getcvt());
		} catch (...) {
		_Tidy();
		throw;
		}

		_Dp = _Maklocchr(_Ptr->decimal_point[0], (_Elem *)0, _Lobj._Getcvt());
		_Kseparator =
			_Maklocchr(_Ptr->thousands_sep[0], (_Elem *)0, _Lobj._Getcvt());
		}

	virtual _Elem  do_decimal_point() const
		{	
		return (_Dp);
		}

	virtual _Elem  do_thousands_sep() const
		{	
		return (_Kseparator);
		}

	virtual string  do_grouping() const
		{	
		return (string(_Grouping));
		}

	virtual string_type  do_falsename() const
		{	
		return (string_type(_Falsename));
		}

	virtual string_type  do_truename() const
		{	
		return (string_type(_Truename));
		}

private:
	void  _Tidy()
		{	
		std::_DebugHeapDelete((void *)(void *)_Grouping);
		std::_DebugHeapDelete((void *)(void *)_Falsename);
		std::_DebugHeapDelete((void *)(void *)_Truename);
		}

	const char *_Grouping;	
	_Elem _Dp;	
	_Elem _Kseparator;	
	const _Elem *_Falsename;	
	const _Elem *_Truename;	
	};

typedef numpunct<char> _Npc;
typedef numpunct<wchar_t> _Npwc;

		
template<class _Elem>
	class numpunct_byname
		: public numpunct<_Elem>
	{	
public:
	explicit  numpunct_byname(const char *_Locname, size_t _Refs = 0)
		: numpunct<_Elem>(_Locname, _Refs)
		{	
		}

protected:
	virtual  ~numpunct_byname()
		{	
		}
	};

		
template<class _Elem>
	 locale::id numpunct<_Elem>::id;

		
template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_get
		: public locale::facet
	{	
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum", 222) num_get<_Elem, _InIt>;
		return (4);
		}

	 static locale::id id;	

protected:
	virtual  ~num_get()
		{	
		}

protected:
	void _Init(const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		}

	_Locinfo::_Cvtvec _Cvt;		

public:
	explicit  num_get(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _InIt iter_type;

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			_Bool& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			unsigned short& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			unsigned int& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

 
	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			__int64& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned __int64& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
 #line 309 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

protected:
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			_Bool& _Val) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum", 343);
		int _Ans = -1;	

		if (_Iosbase.flags() & ios_base::boolalpha)
			{	
			typedef typename _Mystr::size_type _Mystrsize;
			const _Mypunct& _Punct_fac = use_facet<_Mypunct >(_Iosbase.getloc());
			_Mystr _Str((_Mystrsize)1, (char_type)0);
			_Str += _Punct_fac.falsename();
			_Str += (char_type)0;
			_Str += _Punct_fac.truename();	
			_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
			}
		else
			{	
			char _Ac[32], *_Ep;
			int _Errno = 0;
			const unsigned long _Ulo = ::_Stoulx(_Ac, &_Ep,
				_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
					_Iosbase.getloc()), &_Errno);
			if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)
				_Ans = _Ulo;
			}

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ans < 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans != 0;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned short& _Val) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum", 380);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
		const unsigned long _Ans =
			::_Stoulx(_Ptr, &_Ep, _Base, &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || 0xffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = (unsigned short)(_Ac[0] == '-'
				? 0 -_Ans : _Ans);	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned int& _Val) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum", 403);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
		const unsigned long _Ans =
			::_Stoulx(_Ptr, &_Ep, _Base, &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || 0xffffffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = _Ac[0] == '-' ? 0 -_Ans : _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum", 425);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const long _Ans = ::_Stolx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum", 445);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const unsigned long _Ans = ::_Stoulx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

 
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			__int64& _Val) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum", 466);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const __int64 _Ans = ::_strtoi64(_Ac, &_Ep, _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()));	
#line 472 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned __int64& _Val) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum", 486);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const unsigned __int64 _Ans = ::_strtoui64(_Ac, &_Ep, _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()));	
#line 492 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}
 #line 502 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum", 507);
		char _Ac[8 + 36 + 16], *_Ep;
		int _Errno = 0;
		const float _Ans = ::_Stofx(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum", 527);
		char _Ac[8 + 36 + 16], *_Ep;
		int _Errno = 0;
		const double _Ans = ::_Stodx(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum", 547);
		char _Ac[8 + 36 + 16], *_Ep;
		int _Errno = 0;
		const long double _Ans = ::_Stoldx(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum", 567);
		char _Ac[32], *_Ep;
		int _Errno = 0;

 
		int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,
			_Iosbase.getloc());	
		const unsigned __int64 _Ans =
			(sizeof (void *) == sizeof (unsigned long))
				? (unsigned __int64)::_Stoulx(_Ac, &_Ep, _Base, &_Errno)
				: ::_strtoui64(_Ac, &_Ep, _Base);

 



#line 584 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = (void *)(uintptr_t)_Ans;	
		return (_First);
		}

private:
	int __cdecl _Getifld(     char *_Ac,
		_InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
			const locale& _Loc) const
		{	
		const _Mypunct& _Punct_fac = use_facet<_Mypunct >(_Loc);
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Grouping.size() == 0
			? (_Elem)0 : _Punct_fac.thousands_sep();
		const _Elem _E0 = _Maklocchr('0', (_Elem *)0, _Cvt);
		char *_Ptr = _Ac;

		if (_First == _Last)
			;	
		else if (*_First == _Maklocchr('+', (_Elem *)0, _Cvt))
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Maklocchr('-', (_Elem *)0, _Cvt))
			*_Ptr++ = '-', ++_First;	

		_Basefield &= ios_base::basefield;
		int _Base = _Basefield == ios_base::oct ? 8
			: _Basefield == ios_base::hex ? 16
			: _Basefield == ios_base::_Fmtzero ? 0 : 10;

		bool _Seendigit = false;	
		bool _Nonzero = false;	

		if (_First != _Last && *_First == _E0)
			{	
			_Seendigit = true, ++_First;
			if (_First != _Last && (*_First == _Maklocchr('x', (_Elem *)0, _Cvt)
					|| *_First == _Maklocchr('X', (_Elem *)0, _Cvt))
				&& (_Base == 0 || _Base == 16))
				_Base = 16, _Seendigit = false, ++_First;
			else if (_Base == 0)
				_Base = 8;
			}

		int _Dlen = _Base == 0 || _Base == 10 ? 10
			: _Base == 8 ? 8 : 16 + 6;
		string _Groups((size_t)1, (char)_Seendigit);
		size_t _Group = 0;

		for (char *const _Pe = &_Ac[32 - 1];
			_First != _Last; ++_First)
			if (::memchr("0123456789abcdefABCDEF",
				*_Ptr = _Maklocbyte((_Elem)*_First, _Cvt), _Dlen) != 0)
				{	
				if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
					++_Ptr, _Nonzero = true;
				_Seendigit = true;
				if (_Groups[_Group] != 127)
					++_Groups[_Group];
				}
			else if (_Groups[_Group] == '\0'
				|| _Kseparator == (_Elem)0
				|| *_First != _Kseparator)
				break;	
			else
				{	
				_Groups.append((string::size_type)1, '\0');
				++_Group;
				}

		if (_Group == 0)
			;	
		else if ('\0' < _Groups[_Group])
			++_Group;	
		else
			_Seendigit = false;	

		for (const char *_Pg = _Grouping.c_str(); _Seendigit && 0 < _Group; )
			if (*_Pg == 127)
				break;	
			else if (0 < --_Group && *_Pg != _Groups[_Group]
				|| 0 == _Group && *_Pg < _Groups[_Group])
				_Seendigit = false;	
			else if ('\0' < _Pg[1])
				++_Pg;	

		if (_Seendigit && !_Nonzero)
			*_Ptr++ = '0';	
		else if (!_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		return (_Base);
		}

	int __cdecl _Getffld(     char *_Ac,
		_InIt& _First, _InIt &_Last, const locale& _Loc) const
		{	
		const _Mypunct& _Punct_fac = use_facet<_Mypunct >(_Loc);
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _E0 = _Maklocchr('0', (_Elem *)0, _Cvt);
		char *_Ptr = _Ac;
		bool _Bad = false;

		if (_First == _Last)
			;	
		else if (*_First == _Maklocchr('+', (_Elem *)0, _Cvt))
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Maklocchr('-', (_Elem *)0, _Cvt))
			*_Ptr++ = '-', ++_First;	

		bool _Seendigit = false;	
		int _Significant = 0;	
		int _Pten = 0;	

		if (*_Grouping.c_str() == 127 || *_Grouping.c_str() <= '\0')
			for (; _First != _Last
				&& _E0 <= *_First && *_First <= _E0 + 9;
					_Seendigit = true, ++_First)
				if (36 <= _Significant)
					++_Pten;	
				else if (*_First == _E0 && _Significant == 0)
					;	
				else
					{	
					*_Ptr++ = (char)((*_First - _E0) + '0');
					++_Significant;
					}
		else
			{	
			const _Elem _Kseparator = _Punct_fac.thousands_sep();

			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				if (_E0 <= *_First && *_First <= _E0 + 9)
					{	
					_Seendigit = true;
					if (36 <= _Significant)
						++_Pten;	
					else if (*_First == _E0 && _Significant == 0)
						;	
					else
						{	
						*_Ptr++ = (char)((*_First - _E0) + '0');
						++_Significant;
						}
					if (_Groups[_Group] != 127)
						++_Groups[_Group];
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					break;	
				else
					{	
					_Groups.append((size_t)1, '\0');
					++_Group;
					}
			if (_Group == 0)
				;	
			else if ('\0' < _Groups[_Group])
				++_Group;	
			else
				_Bad = true;	

			for (const char *_Pg = _Grouping.c_str();
				!_Bad && 0 < _Group; )
				if (*_Pg == 127)
					break;	
				else if (0 < --_Group && *_Pg != _Groups[_Group]
					|| 0 == _Group && *_Pg < _Groups[_Group])
					_Bad = true;	
				else if ('\0' < _Pg[1])
					++_Pg;	
			}

		if (_Seendigit && _Significant == 0)
			*_Ptr++ = '0';	

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	

		if (_Significant == 0)
			{	
			for (; _First != _Last && *_First == _E0;
				_Seendigit = true, ++_First)
				--_Pten;	
			if (_Pten < 0)
				*_Ptr++ = '0', ++_Pten;	
			}

		for (; _First != _Last
				&& _E0 <= *_First && *_First <= _E0 + 9;
				_Seendigit = true, ++_First)
			if (_Significant < 36)
				{	
				*_Ptr++ = (char)((*_First - _E0) + '0');
				++_Significant;
				}

		if (_Seendigit && _First != _Last
			&& (*_First == _Maklocchr('e', (_Elem *)0, _Cvt)
				|| *_First == _Maklocchr('E', (_Elem *)0, _Cvt)))
			{	
			*_Ptr++ = 'e', ++_First;
			_Seendigit = false, _Significant = 0;

			if (_First == _Last)
				;	
			else if (*_First == _Maklocchr('+', (_Elem *)0, _Cvt))
				*_Ptr++ = '+', ++_First;	
			else if (*_First == _Maklocchr('-', (_Elem *)0, _Cvt))
				*_Ptr++ = '-', ++_First;	
			for (; _First != _Last && *_First == _E0; )
				_Seendigit = true, ++_First;	
			if (_Seendigit)
				*_Ptr++ = '0';	
			for (; _First != _Last
				&& _E0 <= *_First && *_First <= _E0 + 9;
				_Seendigit = true, ++_First)
				if (_Significant < 8)
					{	
					*_Ptr++ = (char)((*_First - _E0) + '0');
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		return (_Pten);
		}
	};

		
template<class _Elem,
	class _InIt>
	 locale::id num_get<_Elem, _InIt>::id;

		
template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_put
		: public locale::facet
	{	
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(std::_DebugHeapTag_func(), "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum", 842) num_put<_Elem, _OutIt>;
		return (4);
		}

	 static locale::id id;	

protected:
	virtual  ~num_put()
		{	
		}

protected:
	void  _Init(const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		}

	_Locinfo::_Cvtvec _Cvt;		

public:
	explicit  num_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _OutIt iter_type;

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, _Bool _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

 
	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, __int64 _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned __int64 _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
 #line 910 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

protected:
	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, _Bool _Val) const
		{	
		_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum",933);
		if (!(_Iosbase.flags() & ios_base::boolalpha))
			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
		else
			{	
			const _Mypunct& _Punct_fac = use_facet<_Mypunct >(_Iosbase.getloc());
			_Mystr _Str;
			if (_Val)
				_Str.assign(_Punct_fac.truename());
			else
				_Str.assign(_Punct_fac.falsename());

			size_t _Fillcount = _Iosbase.width() <= 0
				|| (size_t)_Iosbase.width() <= _Str.size()
					? 0 : (size_t)_Iosbase.width() - _Str.size();

			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
				{	
				_Dest = _Rep(_Dest, _Fill, _Fillcount);
				_Fillcount = 0;
				}
			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	
			_Iosbase.width(0);
			return (_Rep(_Dest, _Fill, _Fillcount));	
			}
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	
		const size_t _Buf_size = 2 * 32;
		char _Buf[_Buf_size], _Fmt[6];
		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	
		const size_t _Buf_size = 2 * 32;
		char _Buf[_Buf_size], _Fmt[6];
		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "lu",
				_Iosbase.flags()), _Val)));
		}

 
	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, __int64 _Val) const
		{	
		const size_t _Buf_size = 2 * 32;
		char _Buf[_Buf_size], _Fmt[8];
		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "Ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned __int64 _Val) const
		{	
		const size_t _Buf_size = 2 * 32;
		char _Buf[_Buf_size], _Fmt[8];
		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "Lu",
				_Iosbase.flags()), _Val)));
		}
 #line 1001 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	
		const size_t _Buf_size = 8 + 36 + 64;
		char _Buf[_Buf_size], _Fmt[8];
		streamsize _Precision = _Iosbase.precision() <= 0
			&& !(_Iosbase.flags() & ios_base::fixed)
				? 6 : _Iosbase.precision();	
		int _Significance = 36 < _Precision
			? 36 : (int)_Precision;	
		_Precision -= _Significance;
		size_t _Beforepoint = 0;	
		size_t _Afterpoint = 0;	

		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)
			{	
			bool _Signed = _Val < 0;
			if (_Signed)
				_Val = -_Val;

			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)
				_Val /= 1e10;	

			if (0 < _Val)
				for (; 10 <= _Precision && _Val <= 1e-35
					&& _Afterpoint < 5000; _Afterpoint += 10)
					{	
					_Val *= 1e10;
					_Precision -= 10;
					}

			if (_Signed)
				_Val = -_Val;
			}

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
			_Beforepoint, _Afterpoint, _Precision,
				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 0, _Iosbase.flags()),
					_Significance, _Val)));	
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	
		const size_t _Buf_size = 8 + 36 + 64;
		char _Buf[_Buf_size], _Fmt[8];
		streamsize _Precision = _Iosbase.precision() <= 0
			&& !(_Iosbase.flags() & ios_base::fixed)
				? 6 : _Iosbase.precision();	
		int _Significance = 36 < _Precision
			? 36 : (int)_Precision;	
		_Precision -= _Significance;
		size_t _Beforepoint = 0;	
		size_t _Afterpoint = 0;	

		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)
			{	
			bool _Signed = _Val < 0;
			if (_Signed)
				_Val = -_Val;

			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)
				_Val /= 1e10;	

			if (0 < _Val)
				for (; 10 <= _Precision && _Val <= 1e-35
					&& _Afterpoint < 5000; _Afterpoint += 10)
					{	
					_Val *= 1e10;
					_Precision -= 10;
					}

			if (_Signed)
				_Val = -_Val;
			}

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
			_Beforepoint, _Afterpoint, _Precision,
				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 'L', _Iosbase.flags()),
					_Significance, _Val)));	
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	
		const size_t _Buf_size = 2 * 32;
		char _Buf[_Buf_size];
		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			::sprintf_s(_Buf, _Buf_size, "%p", _Val)));
		}

private:
	char *__cdecl _Ffmt(     char *_Fmt,
		char _Spec, ios_base::fmtflags _Flags) const
		{	
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showpoint)
			*_Ptr++ = '#';
		*_Ptr++ = '.';
		*_Ptr++ = '*';	
		if (_Spec != '\0')
			*_Ptr++ = _Spec;	

		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
		*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
			: _Ffl == ios_base::scientific ? 'e' : 'g';	
		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Fput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
			size_t _Beforepoint, size_t _Afterpoint,
				size_t _Trailing, size_t _Count) const
		{	
		_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum",1121);
		const _Mypunct& _Punct_fac = use_facet<_Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Punct_fac.thousands_sep();
		string _Groupstring;
		const _Elem _E0 = _Maklocchr('0', (_Elem *)0, _Cvt);
		size_t _Prefix = _Buf[0] == '+' || _Buf[0] == '-' ? 1 : 0;

		char _Enders[3];
		_Enders[0] = ::localeconv()->decimal_point[0];
		_Enders[1] = 'e';
		_Enders[2] = '\0';

		const char *_Eptr = (const char *)::memchr(_Buf,
			'e', _Count);	
		const char *_Pointptr = (const char *)::memchr(_Buf,
			_Enders[0], _Count);	
		if (_Pointptr == 0)
			_Trailing = 0;

		if (*_Grouping.c_str() != 127 && '\0' < *_Grouping.c_str())
			{	
			_Groupstring.append(_Buf, _Count);	
			if (_Eptr == 0)
				_Groupstring.append(_Trailing, '0');
			else
				{	
				if (_Pointptr == 0)
					{	
					_Groupstring.append(_Beforepoint, '0');
					_Beforepoint = 0;
					}
				_Groupstring.insert(_Eptr - _Buf, _Trailing, '0');
				}
			_Trailing = 0;

			if (_Pointptr == 0)
				_Groupstring.append(_Beforepoint, '0');
			else
				{	
				_Groupstring.insert(_Pointptr - _Buf + 1, _Afterpoint, '0');
				_Groupstring.insert(_Pointptr - _Buf, _Beforepoint, '0');
				_Afterpoint = 0;
				}
			_Beforepoint = 0;

			const char *_Pg = _Grouping.c_str();
			size_t _Off = ::strcspn(&_Groupstring[0], &_Enders[0]);
			while (*_Pg != 127 && '\0' < *_Pg
				&& (size_t)*_Pg < _Off - _Prefix)
				{	
				_Groupstring.insert(_Off -= *_Pg, (size_t)1, '\0');
				if ('\0' < _Pg[1])
					++_Pg;	
				}

			_Buf = &_Groupstring[0];
			_Trailing = 0;
			_Count = _Groupstring.size();
			}

		size_t _Fillcount = _Beforepoint + _Afterpoint + _Trailing + _Count;
		_Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Fillcount
				? 0 : (size_t)_Iosbase.width() - _Fillcount;
		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else if (_Adjustfield == ios_base::internal)
			{	
			if (0 < _Prefix)
				{	
				_Dest = _Putc(_Dest, _Buf, 1);
				++_Buf, --_Count;
				}
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}

		_Pointptr = (const char *)::memchr(_Buf,
			_Enders[0], _Count);	
		if (_Pointptr != 0)
			{	
			size_t _Fracoffset = _Pointptr - _Buf + 1;
			_Dest = _Putgrouped(_Dest, _Buf, _Fracoffset - 1, _Kseparator);
			_Dest = _Rep(_Dest, _E0, _Beforepoint);
			_Dest = _Rep(_Dest, _Punct_fac.decimal_point(), 1);
			_Dest = _Rep(_Dest, _E0, _Afterpoint);
			_Buf += _Fracoffset, _Count -= _Fracoffset;
			}

		_Eptr = (const char *)::memchr(_Buf,
			'e', _Count);	
		if (_Eptr != 0)
			{	
			size_t _Expoffset = _Eptr - _Buf + 1;
			_Dest = _Putgrouped(_Dest, _Buf, _Expoffset - 1, _Kseparator);
			_Dest = _Rep(_Dest, _E0, _Trailing), _Trailing = 0;
			_Dest = _Putc(_Dest, _Iosbase.flags() & ios_base::uppercase
				? "E" : "e", 1);
			_Buf += _Expoffset, _Count -= _Expoffset;
			}

		_Dest = _Putgrouped(_Dest, _Buf, _Count,
			_Kseparator);	
		_Dest = _Rep(_Dest, _E0, _Trailing);	
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	
		}

	char *__cdecl _Ifmt(     char *_Fmt,
		const char *_Spec, ios_base::fmtflags _Flags) const
		{	
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showbase)
			*_Ptr++ = '#';
		if (_Spec[0] != 'L')
			*_Ptr++ = _Spec[0];	
		else
			{	
			*_Ptr++ = 'I';
			*_Ptr++ = '6';
			*_Ptr++ = '4';
			}

		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
			: _Basefield != ios_base::hex ? _Spec[1]	
			: _Flags & ios_base::uppercase ? 'X' : 'x';
		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Iput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill,        char *_Buf, size_t _Count) const
		{	
		_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum",1266);
		const _Mypunct& _Punct_fac = use_facet<_Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const size_t _Prefix = *_Buf == '+' || *_Buf == '-' ? 1
			: *_Buf == '0' && (_Buf[1] == 'x' || _Buf[1] == 'X') ? 2
			: 0;

		if (*_Grouping.c_str() != 127 && '\0' < *_Grouping.c_str())
			{	
			const char *_Pg = _Grouping.c_str();
			size_t _Off = _Count;
			while (*_Pg != 127 && '\0' < *_Pg
				&& (size_t)*_Pg < _Off - _Prefix)
				{	
				_Off -= *_Pg;
				::memmove_s((&_Buf[_Off + 1]), (_Count + 1 - _Off), (&_Buf[_Off]), (_Count + 1 - _Off));
#line 1283 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"
				_Buf[_Off] = '\0', ++_Count;
				if ('\0' < _Pg[1])
					++_Pg;	
				}
			}

		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else if (_Adjustfield == ios_base::internal)
			{	
			_Dest = _Putc(_Dest, _Buf, _Prefix);	
			_Buf += _Prefix, _Count -= _Prefix;
			_Dest = _Rep(_Dest, _Fill, _Fillcount), _Fillcount = 0;
			}

		_Dest = _Putgrouped(_Dest, _Buf, _Count,
			_Punct_fac.thousands_sep());	
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	
		}

	_OutIt __cdecl _Put(_OutIt _Dest,
		const _Elem *_Ptr, size_t _Count) const
		{	
		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)
			*_Dest = *_Ptr;
		return (_Dest);
		}

	_OutIt __cdecl _Putc(_OutIt _Dest,
		const char *_Ptr, size_t _Count) const
		{	
		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)
			*_Dest = _Maklocchr(*_Ptr, (_Elem *)0, _Cvt);
		return (_Dest);
		}

	_OutIt __cdecl _Putgrouped(_OutIt _Dest,
		const char *_Ptr, size_t _Count, _Elem _Kseparator) const
		{	
		for (; ; ++_Ptr, --_Count)
			{	
			const char *_Pend =
				(const char *)::memchr(_Ptr, '\0', _Count);
			size_t _Groupsize = _Pend != 0 ? _Pend - _Ptr : _Count;

			_Dest = _Putc(_Dest, _Ptr, _Groupsize);
			_Ptr += _Groupsize, _Count -= _Groupsize;
			if (_Count == 0)
				break;
			if (_Kseparator != (_Elem)0)
				_Dest = _Rep(_Dest, _Kseparator, 1);
			}
		return (_Dest);
		}

	_OutIt __cdecl _Rep(_OutIt _Dest,
		_Elem _Ch, size_t _Count) const
		{	
		for (; 0 < _Count; --_Count, ++_Dest)
			*_Dest = _Ch;
		return (_Dest);
		}
	};

		
template<class _Elem,
	class _OutIt>
	 locale::id num_put<_Elem, _OutIt>::id;

 

template class __declspec(dllimport) numpunct<char>;
template class __declspec(dllimport) num_get<char,
	istreambuf_iterator<char, char_traits<char> > >;
template class __declspec(dllimport) num_put<char,
	ostreambuf_iterator<char, char_traits<char> > >;

template class __declspec(dllimport) numpunct<wchar_t>;
template class __declspec(dllimport) num_get<wchar_t,
	istreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
template class __declspec(dllimport) num_put<wchar_t,
	ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >;



 #line 1380 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"
}


#pragma warning(pop)
#pragma pack(pop)
#line 1386 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"

#line 1388 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"
#line 1389 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xlocnum"






#line 7 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ios"


#pragma pack(push,8)
#pragma warning(push,3)
#line 12 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ios"

namespace std {

		
template<class _Elem,
	class _Traits>
	class basic_ios
		: public ios_base
	{	
public:
	typedef basic_ios<_Elem, _Traits> _Myt;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ctype<_Elem> _Ctype;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_ios(_Mysb *_Strbuf)
		{	
		init(_Strbuf);
		}

	virtual  ~basic_ios()
		{	
		}

	void  clear(iostate _State = goodbit, bool _Reraise = false)
		{	
		ios_base::clear((iostate)(_Mystrbuf == 0
			? (int)_State | (int)badbit : (int)_State), _Reraise);
		}

	void  clear(io_state _State)
		{	
		clear((iostate)_State);
		}

	void  setstate(iostate _State, bool _Reraise = false)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Reraise);
		}

	void  setstate(io_state _State)
		{	
		setstate((iostate)_State);
		}

	_Myt&  copyfmt(const _Myt& _Right)
		{	
		_Tiestr = _Right.tie();
		_Fillch = _Right.fill();
		ios_base::copyfmt(_Right);
		return (*this);
		}

	_Myos * tie() const
		{	
		return (_Tiestr);
		}

	_Myos * tie(_Myos *_Newtie)
		{	
		_Myos *_Oldtie = _Tiestr;
		_Tiestr = _Newtie;
		return (_Oldtie);
		}

	_Mysb * rdbuf() const
		{	
		return (_Mystrbuf);
		}

	_Mysb * rdbuf(_Mysb *_Strbuf)
		{	
		_Mysb *_Oldstrbuf = _Mystrbuf;
		_Mystrbuf = _Strbuf;
		clear();
		return (_Oldstrbuf);
		}

	locale  imbue(const locale& _Loc)
		{	
		locale _Oldlocale = ios_base::imbue(_Loc);
		if (rdbuf() != 0)
			rdbuf()->pubimbue(_Loc);
		return (_Oldlocale);
		}

	_Elem  fill() const
		{	
		return (_Fillch);
		}

	_Elem  fill(_Elem _Newfill)
		{	
		_Elem _Oldfill = _Fillch;
		_Fillch = _Newfill;
		return (_Oldfill);
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		const _Ctype& _Ctype_fac = use_facet<_Ctype >(getloc());
		return (_Ctype_fac.narrow(_Ch, _Dflt));
		}

	_Elem  widen(char _Byte) const
		{	
		const _Ctype& _Ctype_fac = use_facet<_Ctype >(getloc());
		return (_Ctype_fac.widen(_Byte));
		}

protected:
	void  init(_Mysb *_Strbuf = 0,
		bool _Isstd = false)
		{	
		_Init();	
		_Mystrbuf = _Strbuf;
		_Tiestr = 0;
		_Fillch = widen(' ');

		if (_Mystrbuf == 0)
			setstate(badbit);

		if (_Isstd)
			_Addstd(this);	
		else
			_Stdstr = 0;
		}

	 basic_ios()
		{	
		}

private:
	 basic_ios(const _Myt&);	
	_Myt&  operator=(const _Myt&);	

	_Mysb *_Mystrbuf;	
	_Myos *_Tiestr;	
	_Elem _Fillch;	
	};

 

template class __declspec(dllimport) basic_ios<char,
	char_traits<char> >;
template class __declspec(dllimport) basic_ios<wchar_t,
	char_traits<wchar_t> >;



 #line 169 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ios"

		
inline ios_base& __cdecl boolalpha(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl dec(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::dec, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl fixed(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::fixed, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hex(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::hex, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl internal(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::internal, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl left(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::left, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowbase(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpos(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl noskipws(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl nouppercase(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::uppercase);
	return (_Iosbase);
	}

inline ios_base& __cdecl oct(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::oct, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl right(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::right, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl scientific(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::scientific, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl showbase(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpoint(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpos(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl skipws(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl unitbuf(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl uppercase(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::uppercase);
	return (_Iosbase);
	}
}


#pragma warning(pop)
#pragma pack(pop)
#line 308 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ios"

#line 310 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ios"
#line 311 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ios"





#line 7 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream"


#pragma pack(push,8)
#pragma warning(push,3)
#line 12 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream"

namespace std {

		

 
 

 



 



 





#line 35 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream"

		
template<class _Elem,
	class _Traits>
	class basic_ostream
		: virtual public basic_ios<_Elem, _Traits>
	{	
public:
	typedef basic_ostream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
	typedef num_put<_Elem, _Iter> _Nput;

	explicit  basic_ostream(basic_streambuf<_Elem, _Traits> *_Strbuf,
		bool _Isstd = false)
		{	
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_ostream(_Uninitialized)
		{	
		ios_base::_Addstd(this);
		}

	 basic_ostream(_Uninitialized, bool _Addit)
		{	
		if (_Addit)
			ios_base::_Addstd(this);
		}

	virtual  ~basic_ostream()
		{	
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	class _Sentry_base
		{	
	public:
		 _Sentry_base(_Myt& _Ostr)
			: _Myostr(_Ostr)
			{	
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Lock();
			}

		 ~_Sentry_base()
			{	
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Unlock();
			}

		_Myt& _Myostr;	
		};

	class sentry
		: public _Sentry_base
		{	
	public:
		explicit  sentry(_Myt& _Ostr)
			: _Sentry_base(_Ostr)
			{	
			if (_Ostr.good() && _Ostr.tie() != 0)
				_Ostr.tie()->flush();
			_Ok = _Ostr.good();	
			}

		 ~sentry()
			{	

 
			if (!std:: uncaught_exception())
				this->_Myostr._Osfx();
			}

 


#line 117 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream"

		 operator bool() const
			{	
			return (_Ok);
			}

	private:
		 sentry(const sentry&);	
		sentry&  operator=(const sentry&);	

		bool _Ok;	
		};

	bool  opfx()
		{	
		if (ios_base::good() && _Myios::tie() != 0)
			_Myios::tie()->flush();
		return (ios_base::good());
		}

	void  osfx()
		{	
		_Osfx();
		}

	void  _Osfx()
		{	
		try {
		if (ios_base::flags() & ios_base::unitbuf)
			flush();	
		} catch (...) {
		}
		}
























	_Myt&  operator<<(_Myt& (__cdecl *_Pfn)(_Myt&))
		{	
		_Debug_pointer(_Pfn, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream",176);
		return ((*_Pfn)(*this));
		}

	_Myt&  operator<<(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	
		_Debug_pointer(_Pfn, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream",182);
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt&  operator<<(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	
		_Debug_pointer(_Pfn, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream",189);
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt&  operator<<(_Bool _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(short _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());
			ios_base::fmtflags _Bfl =
				ios_base::flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned short)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

        







	_Myt&  operator<<(unsigned short _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(int __w64 _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());
			ios_base::fmtflags _Bfl =
				ios_base::flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned int)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned int __w64 _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned long __w64 _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

 
	_Myt&  operator<<(__int64 _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned __int64 _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}
 #line 393 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream"

	_Myt&  operator<<(float _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (double)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(double _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long double _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(const void *_Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(_Mysb *_Strbuf)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			for (int_type _Meta = _Traits::eof(); ; _Copied = true)
				{	
				try {
				_Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
					? _Strbuf->sgetc() : _Strbuf->snextc();
				} catch (...) {
					_Myios::setstate(ios_base::failbit);
					throw;
				}

				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					break;	

				try {
					if (_Traits::eq_int_type(_Traits::eof(),
						_Myios::rdbuf()->sputc(
							_Traits::to_char_type(_Meta))))
						{	
						_State |= ios_base::badbit;
						break;
						}
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

		ios_base::width(0);
		_Myios::setstate(_Strbuf == 0 ? ios_base::badbit
			: !_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt&  put(_Elem _Ch)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputc(_Ch)))
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  write(const _Elem *_Str,
		streamsize _Count)
		{	
		_Debug_pointer(_Str, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream",534);
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else
			{	
			try {
			if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  flush()
		{	
		ios_base::iostate _State = ios_base::goodbit;
		if (!ios_base::fail() && _Myios::rdbuf()->pubsync() == -1)
			_State |= ios_base::badbit;	
		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  seekp(pos_type _Pos)
		{	
		if (!ios_base::fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	_Myt&  seekp(off_type _Off, ios_base::seekdir _Way)
		{	
		if (!ios_base::fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	pos_type  tellp()
		{	
		if (!ios_base::fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::out));
		else
			return (pos_type(_BADOFF));
		}
	};













template <> inline
	basic_ostream<unsigned short, char_traits<unsigned short> >&  
        basic_ostream<unsigned short, char_traits<unsigned short> >::operator<<(
		unsigned short _Ch)
	{	
	typedef basic_ostream<unsigned short, char_traits<unsigned short> > _Myos;
        typedef char_traits<unsigned short> _Traits;
        _Myos &_Ostr=*this;
	ios_base::iostate _State = ios_base::goodbit;
	const _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}
#line 642 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream"

 

template class __declspec(dllimport) basic_ostream<char, char_traits<char> >;
template class __declspec(dllimport) basic_ostream<wchar_t, char_traits<wchar_t> >;



 #line 651 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream"

		

 template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& __cdecl operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const char *_Val)
	{	
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)::strlen(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		const ctype<_Elem>& _Ctype_fac = use_facet<ctype<_Elem> >(_Ostr.getloc());
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& __cdecl operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, char _Ch)
	{	
	ios_base::iostate _State = ios_base::goodbit;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		const ctype<_Elem>& _Ctype_fac = use_facet<ctype<_Elem> >(_Ostr.getloc());
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& __cdecl operator<<(
		basic_ostream<char, _Traits>& _Ostr,
		const char *_Val)
	{	
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& __cdecl operator<<(
		basic_ostream<char, _Traits>& _Ostr, char _Ch)
	{	
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& __cdecl operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const _Elem *_Val)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& __cdecl operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& __cdecl operator<<(
		basic_ostream<char, _Traits>& _Ostr, const signed char *_Val)
	{	
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& __cdecl operator<<(
		basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
	{	
	return (_Ostr << (char)_Ch);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& __cdecl operator<<(
		basic_ostream<char, _Traits>& _Ostr, const unsigned char *_Val)
	{	
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& __cdecl operator<<(
		basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
	{	
	return (_Ostr << (char)_Ch);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl endl(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.put(_Ostr.widen('\n'));
	_Ostr.flush();
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.put(_Elem());
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.flush();
	return (_Ostr);
	}

__declspec(dllimport) inline basic_ostream<char, char_traits<char> >&
	__cdecl endl(basic_ostream<char, char_traits<char> >& _Ostr)
	{	
	_Ostr.put('\n');
	_Ostr.flush();
	return (_Ostr);
	}

__declspec(dllimport) inline basic_ostream<wchar_t, char_traits<wchar_t> >&
	__cdecl endl(basic_ostream<wchar_t,
		char_traits<wchar_t> >& _Ostr)
	{	
	_Ostr.put('\n');
	_Ostr.flush();
	return (_Ostr);
	}


__declspec(dllimport) inline basic_ostream<char, char_traits<char> >&
	__cdecl ends(basic_ostream<char, char_traits<char> >& _Ostr)
	{	
	_Ostr.put('\0');
	return (_Ostr);
	}

__declspec(dllimport) inline basic_ostream<wchar_t, char_traits<wchar_t> >&
	__cdecl ends(basic_ostream<wchar_t,
		char_traits<wchar_t> >& _Ostr)
	{	
	_Ostr.put('\0');
	return (_Ostr);
	}


__declspec(dllimport) inline basic_ostream<char, char_traits<char> >&
	__cdecl flush(basic_ostream<char, char_traits<char> >& _Ostr)
	{	
	_Ostr.flush();
	return (_Ostr);
	}

__declspec(dllimport) inline basic_ostream<wchar_t, char_traits<wchar_t> >&
	__cdecl flush(basic_ostream<wchar_t,
		char_traits<wchar_t> >& _Ostr)
	{	
	_Ostr.flush();
	return (_Ostr);
	}


 

 #line 1021 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream"

}


#pragma warning(pop)
#pragma pack(pop)
#line 1028 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream"

#line 1030 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream"
#line 1031 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\ostream"






#line 7 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream"


#pragma pack(push,8)
#pragma warning(push,3)
#line 12 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream"

namespace std {

		
template<class _Elem,
	class _Traits>
	class basic_istream
		: virtual public basic_ios<_Elem, _Traits>
	{	
public:
	typedef basic_istream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef istreambuf_iterator<_Elem, _Traits> _Iter;
	typedef ctype<_Elem> _Ctype;
	typedef num_get<_Elem, _Iter> _Nget;


	explicit  basic_istream(_Mysb *_Strbuf, bool _Isstd = false)
		: _Chcount(0)
		{	
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_istream(_Uninitialized)
		{	
		ios_base::_Addstd(this);
		}

	virtual  ~basic_istream()
		{	
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

		
	class _Sentry_base
		{	
	public:
		 _Sentry_base(_Myt& _Istr)
			: _Myistr(_Istr)
			{	
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Lock();
			}

		 ~_Sentry_base()
			{	
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Unlock();
			}

		_Myt& _Myistr;	
		};

	class sentry
		: public _Sentry_base
		{	
	public:
		explicit  sentry(_Myt& _Istr, bool _Noskip = false)
			: _Sentry_base(_Istr)
			{	
			_Ok = this->_Myistr._Ipfx(_Noskip);
			}

		 operator bool() const
			{	
			return (_Ok);
			}

	private:
		 sentry(const sentry&);	
		sentry&  operator=(const sentry&);	

		bool _Ok;	
		};

	bool  _Ipfx(bool _Noskip = false)
		{	
		if (ios_base::good())
			{	
			if (_Myios::tie() != 0)
				_Myios::tie()->flush();

			if (!_Noskip && ios_base::flags() & ios_base::skipws)
				{	
				const _Ctype& _Ctype_fac = use_facet<_Ctype >(ios_base::getloc());

				try {
				int_type _Meta = _Myios::rdbuf()->sgetc();

				for (; ; _Meta = _Myios::rdbuf()->snextc())
					if (_Traits::eq_int_type(_Traits::eof(), _Meta))
						{	
						_Myios::setstate(ios_base::eofbit);
						break;
						}
					else if (!_Ctype_fac.is(_Ctype::space,
						_Traits::to_char_type(_Meta)))
						break;	
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

			if (ios_base::good())
				return (true);
			}
		_Myios::setstate(ios_base::failbit);
		return (false);
		}

	bool  ipfx(bool _Noskip = false)
		{	
		return _Ipfx(_Noskip);
		}

	void  isfx()
		{	
		}























	_Myt&  operator>>(_Myt& (__cdecl *_Pfn)(_Myt&))
		{	
		_Debug_pointer(_Pfn, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream",157);
		return ((*_Pfn)(*this));
		}

	_Myt&  operator>>(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	
		_Debug_pointer(_Pfn, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream",163);
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt&  operator>>(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	
		_Debug_pointer(_Pfn, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream",170);
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt&  operator>>(_Bool& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(short& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			long _Tmp = 0;
			const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-32768) || 32767 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = (short)_Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}

        







	_Myt&  operator>>(unsigned short& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(int& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			long _Tmp = 0;
			const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-2147483647 - 1) || 2147483647 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = _Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned int& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());
			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned long __w64& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, (unsigned long)_Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

 
	_Myt&  operator>>(__int64& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned __int64& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}
 #line 366 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream"

	_Myt&  operator>>(float& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(double& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long double& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());
			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(void *& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(_Mysb *_Strbuf)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					try {
						if (_Traits::eq_int_type(_Traits::eof(),
							_Strbuf->sputc(_Traits::to_char_type(_Meta))))
							break;
					} catch (...) {
						break;
					}
					_Copied = true;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(!_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	int_type  get()
		{	
		int_type _Meta = 0;
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	
		else
			{	
			try {
			_Meta = _Myios::rdbuf()->sbumpc();

			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				_State |= ios_base::eofbit | ios_base::failbit;	
			else
				++_Chcount;	
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt&  get(_Elem *_Str, streamsize _Count)
		{	
		return (get(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt&  get(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	
		_Debug_pointer(_Str, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream",509);
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Traits::to_char_type(_Meta) == _Delim)
					break;	
				else
					{	
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_Chcount == 0
			? _State | ios_base::failbit : _State);
		*_Str = _Elem();	
		return (*this);
		}

	_Myt&  get(_Elem& _Ch)
		{	
		int_type _Meta = get();
		if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
			_Ch = _Traits::to_char_type(_Meta);
		return (*this);
		}

	_Myt&  get(_Mysb& _Strbuf)
		{	
		return (get(_Strbuf, _Myios::widen('\n')));
		}

	_Myt&  get(_Mysb& _Strbuf, _Elem _Delim)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					try {
						_Elem _Ch = _Traits::to_char_type(_Meta);
						if (_Ch == _Delim
							|| _Traits::eq_int_type(_Traits::eof(),
								_Strbuf.sputc(_Ch)))
							break;
					} catch (...) {
						break;
					}
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		if (_Chcount == 0)
			_State |= ios_base::failbit;
		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  getline(_Elem *_Str, streamsize _Count)
		{	
		return (getline(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt&  getline(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	
		_Debug_pointer(_Str, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream",601);
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			int_type _Metadelim = _Traits::to_int_type(_Delim);

			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Meta == _Metadelim)
					{	
					++_Chcount;
					_Myios::rdbuf()->sbumpc();
					break;
					}
				else if (--_Count <= 0)
					{	
					_State |= ios_base::failbit;
					break;
					}
				else
					{	
					++_Chcount;
					*_Str++ = _Traits::to_char_type(_Meta);
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		*_Str = _Elem();	
		_Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt&  ignore(streamsize _Count = 1,
		int_type _Metadelim = _Traits::eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			for (; ; )
				{	
				int_type _Meta;
				if (_Count != 2147483647 && --_Count < 0)
					break;	
				else if (_Traits::eq_int_type(_Traits::eof(),
					_Meta = _Myios::rdbuf()->sbumpc()))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					++_Chcount;
					if (_Meta == _Metadelim)
						break;	
					}
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  _Read_s(_Elem *_Str, size_t _Str_size, streamsize _Count)
		{	
		_Debug_pointer(_Str, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream",680);
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			const streamsize _Num = _Myios::rdbuf()->_Sgetn_s(_Str, _Str_size, _Count);
			_Chcount += _Num;
			if (_Num != _Count)
				_State |= ios_base::eofbit | ios_base::failbit;	
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  read(_Elem *_Str, streamsize _Count)
		{
		return _Read_s(_Str, (size_t)-1, _Count);
		}

	streamsize  _Readsome_s(_Elem *_Str, size_t _Str_size, streamsize _Count)
		{	
		_Debug_pointer(_Str, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream",706);
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		streamsize _Num;

		if (!_Ok)
			_State |= ios_base::failbit;	
		else if ((_Num = _Myios::rdbuf()->in_avail()) < 0)
			_State |= ios_base::eofbit;	
		else if (0 < _Num)
			_Read_s(_Str, _Str_size, _Num < _Count ? _Num : _Count);	

		_Myios::setstate(_State);
		return (gcount());
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	streamsize  readsome(_Elem *_Str, streamsize _Count)
		{
		return _Readsome_s(_Str, (size_t)-1, _Count);
		}

	int_type  peek()
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		int_type _Meta = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	
		else
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Meta = _Myios::rdbuf()->sgetc()))
				_State |= ios_base::eofbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt&  putback(_Elem _Ch)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputbackc(_Ch)))
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  unget()
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sungetc()))
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize  gcount() const
		{	
		return (_Chcount);
		}

	int  sync()
		{	
		ios_base::iostate _State = ios_base::goodbit;
		int _Ans;

		if (_Myios::rdbuf() == 0)
			_Ans = -1;	
		else if (_Myios::rdbuf()->pubsync() == -1)
			{	
			_State |= ios_base::badbit;
			_Ans = -1;
			}
		else
			_Ans = 0;	

		_Myios::setstate(_State);
		return (_Ans);
		}

	_Myt&  seekg(pos_type _Pos)
		{	
		if (!ios_base::fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::in) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	_Myt&  seekg(off_type _Off, ios_base::seekdir _Way)
		{	
		if (!ios_base::fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::in) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	pos_type  tellg()
		{	
		if (!ios_base::fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::in));
		else
			return (pos_type(_BADOFF));
		}

private:
	streamsize _Chcount;	
	};













template <> inline
	basic_istream<unsigned short, char_traits<unsigned short> >&  
	basic_istream<unsigned short, char_traits<unsigned short> >::operator>>(
		unsigned short& _Ch)
	{	
	typedef basic_istream<unsigned short, char_traits<unsigned short> > _Myis;
	typedef char_traits<unsigned short> _Traits;
	_Myis::int_type _Meta;
	_Myis &_Istr=*this;
	ios_base::iostate _State = ios_base::goodbit;
	const _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		try {
		_Meta = _Istr.rdbuf()->sbumpc();
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			_State |= ios_base::eofbit | ios_base::failbit;	
		else
			_Ch = _Traits::to_char_type(_Meta);	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.setstate(_State);
	return (_Istr);
	}
#line 883 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream"

 

template class __declspec(dllimport) basic_istream<char, char_traits<char> >;
template class __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >;



 #line 892 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream"

		
template<class _Elem,
	class _Traits>
	class basic_iostream
	: public basic_istream<_Elem, _Traits>,
		public basic_ostream<_Elem, _Traits>
	{	
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_iostream(basic_streambuf<_Elem, _Traits> *_Strbuf)
		: basic_istream<_Elem, _Traits>(_Strbuf, false),
			basic_ostream<_Elem, _Traits>(_Noinit, false)
		{	
		}

	virtual  ~basic_iostream()
		{	
		}
	};

 

template class __declspec(dllimport) basic_iostream<char, char_traits<char> >;
template class __declspec(dllimport) basic_iostream<wchar_t, char_traits<wchar_t> >;



 #line 926 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream"

		
template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& __cdecl operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem *_Str)
	{	
	_Debug_pointer(_Str, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream",933);
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;
	ios_base::iostate _State = ios_base::goodbit;
	_Elem *_Str0 = _Str;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Ctype& _Ctype_fac = use_facet<_Ctype >(_Istr.getloc());

		try {
		streamsize _Count = 0 < _Istr.width() ? _Istr.width() : 2147483647;
		typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
		_Elem _Ch;
		for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Ch = _Traits::to_char_type(_Meta))
					|| _Ch == _Elem())
				break;	
			else
				*_Str++ = _Traits::to_char_type(_Meta);	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	*_Str = _Elem();	
	_Istr.width(0);
	_Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& __cdecl  operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;
	typename _Myis::int_type _Meta;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		try {
		_Meta = _Istr.rdbuf()->sbumpc();
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			_State |= ios_base::eofbit | ios_base::failbit;	
		else
			_Ch = _Traits::to_char_type(_Meta);	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& __cdecl  operator>>(
		basic_istream<char, _Traits>& _Istr, signed char *_Str)
	{	
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& __cdecl  operator>>(
		basic_istream<char, _Traits>& _Istr, signed char& _Ch)
	{	
	return (_Istr >> (char&)_Ch);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& __cdecl  operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char *_Str)
	{	
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& __cdecl  operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char& _Ch)
	{	
	return (_Istr >> (char&)_Ch);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>&
		__cdecl ws(basic_istream<_Elem, _Traits>& _Istr)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;

	if (!_Istr.eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const typename _Myis::sentry _Ok(_Istr, true);

		if (_Ok)
			{	
			const _Ctype& _Ctype_fac = use_facet<_Ctype >(_Istr.getloc());

			try {
			for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(_Ctype::space,
					_Traits::to_char_type(_Meta)))
					break;	
			} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}

__declspec(dllimport) inline basic_istream<char, char_traits<char> >&
	__cdecl ws(basic_istream<char, char_traits<char> >& _Istr)
	{	
	typedef char _Elem;
	typedef char_traits<_Elem> _Traits;

	if (!_Istr.eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

		if (_Ok)
			{	
			const ctype<_Elem>& _Ctype_fac =
				use_facet<ctype<_Elem> >(_Istr.getloc());

			try {
			for (_Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(ctype<_Elem>::space,
					_Traits::to_char_type(_Meta)))
					break;	
			} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}

__declspec(dllimport) inline basic_istream<wchar_t, char_traits<wchar_t> >&
	__cdecl ws(basic_istream<wchar_t, char_traits<wchar_t> >& _Istr)
	{	
	typedef wchar_t _Elem;
	typedef char_traits<_Elem> _Traits;

	if (!_Istr.eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

		if (_Ok)
			{	
			const ctype<_Elem>& _Ctype_fac =
				use_facet<ctype<_Elem> >(_Istr.getloc());

			try {
			for (_Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(ctype<_Elem>::space,
					_Traits::to_char_type(_Meta)))
					break;	
			} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}



 
template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl
	operator>>(basic_istream<char, char_traits<char> >&, char *);
template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl
	operator>>(basic_istream<char, char_traits<char> >&, char&);
template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl
	operator>>(basic_istream<char, char_traits<char> >&, signed char *);
template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl
	operator>>(basic_istream<char, char_traits<char> >&, signed char&);
template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl
	operator>>(basic_istream<char, char_traits<char> >&, unsigned char *);
template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl
	operator>>(basic_istream<char, char_traits<char> >&, unsigned char&);
template __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl
	operator>>(basic_istream<wchar_t, char_traits<wchar_t> >&, wchar_t *);
template __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl
	operator>>(basic_istream<wchar_t, char_traits<wchar_t> >&, wchar_t&);



 #line 1152 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream"
}


#pragma warning(pop)
#pragma pack(pop)
#line 1158 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream"

#line 1160 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream"
#line 1161 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\istream"






#line 7 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string"


#pragma pack(push,8)
#pragma warning(push,3)

 #pragma warning(disable: 4189)
#line 14 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string"

namespace std {

		
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> __cdecl operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> __cdecl operator+(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> __cdecl operator+(
		const _Elem _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> __cdecl operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> __cdecl operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem _Right)
	{	
	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator==(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right.compare(_Left) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator!=(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator<(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right.compare(_Left) > 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator>(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator<=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator>=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Left < _Right));
	}

 
template __declspec(dllimport) basic_string<char,
	char_traits<char>, allocator<char> > __cdecl operator+(
		const basic_string<char, char_traits<char>, allocator<char> >&,
		const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) basic_string<char,
	char_traits<char>, allocator<char> > __cdecl operator+(
		const char *,
		const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) basic_string<char,
	char_traits<char>, allocator<char> > __cdecl operator+(
		const char,
		const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) basic_string<char,
	char_traits<char>, allocator<char> > __cdecl operator+(
		const basic_string<char, char_traits<char>, allocator<char> >&,
		const char *);
template __declspec(dllimport) basic_string<char,
	char_traits<char>, allocator<char> > __cdecl operator+(
		const basic_string<char, char_traits<char>, allocator<char> >&,
		const char);

template __declspec(dllimport) bool __cdecl operator==(
	const basic_string<char, char_traits<char>, allocator<char> >&,
	const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator==(
	const char *,
	const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator==(
	const basic_string<char, char_traits<char>, allocator<char> >&,
	const char *);

template __declspec(dllimport) bool __cdecl operator!=(
	const basic_string<char, char_traits<char>, allocator<char> >&,
	const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator!=(
	const char *,
	const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator!=(
	const basic_string<char, char_traits<char>, allocator<char> >&,
	const char *);

template __declspec(dllimport) bool __cdecl operator<(
	const basic_string<char, char_traits<char>, allocator<char> >&,
	const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator<(
	const char *,
	const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator<(
	const basic_string<char, char_traits<char>, allocator<char> >&,
	const char *);

template __declspec(dllimport) bool __cdecl operator>(
	const basic_string<char, char_traits<char>, allocator<char> >&,
	const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator>(
	const char *,
	const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator>(
	const basic_string<char, char_traits<char>, allocator<char> >&,
	const char *);

template __declspec(dllimport) bool __cdecl operator<=(
	const basic_string<char, char_traits<char>, allocator<char> >&,
	const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator<=(
	const char *,
	const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator<=(
	const basic_string<char, char_traits<char>, allocator<char> >&,
	const char *);

template __declspec(dllimport) bool __cdecl operator>=(
	const basic_string<char, char_traits<char>, allocator<char> >&,
	const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator>=(
	const char *,
	const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator>=(
	const basic_string<char, char_traits<char>, allocator<char> >&,
	const char *);

template __declspec(dllimport) basic_string<wchar_t,
	char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
		const basic_string<wchar_t, char_traits<wchar_t>,
			allocator<wchar_t> >&,
		const basic_string<wchar_t, char_traits<wchar_t>,
			allocator<wchar_t> >&);
template __declspec(dllimport) basic_string<wchar_t,
	char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
		const wchar_t *,
		const basic_string<wchar_t, char_traits<wchar_t>,
			allocator<wchar_t> >&);
template __declspec(dllimport) basic_string<wchar_t,
	char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
		const wchar_t,
		const basic_string<wchar_t, char_traits<wchar_t>,
			allocator<wchar_t> >&);
template __declspec(dllimport) basic_string<wchar_t,
	char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
		const basic_string<wchar_t, char_traits<wchar_t>,
			allocator<wchar_t> >&,
		const wchar_t *);
template __declspec(dllimport) basic_string<wchar_t,
	char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
		const basic_string<wchar_t, char_traits<wchar_t>,
			allocator<wchar_t> >&,
		const wchar_t);

template __declspec(dllimport) bool __cdecl operator==(
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator==(
	const wchar_t *,
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator==(
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
	const wchar_t *);

template __declspec(dllimport) bool __cdecl operator!=(
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator!=(
	const wchar_t *,
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator!=(
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
	const wchar_t *);

template __declspec(dllimport) bool __cdecl operator<(
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator<(
	const wchar_t *,
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator<(
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
	const wchar_t *);

template __declspec(dllimport) bool __cdecl operator>(
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator>(
	const wchar_t *,
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator>(
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
	const wchar_t *);

template __declspec(dllimport) bool __cdecl operator<=(
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator<=(
	const wchar_t *,
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator<=(
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
	const wchar_t *);

template __declspec(dllimport) bool __cdecl operator>=(
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator>=(
	const wchar_t *,
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator>=(
	const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
	const wchar_t *);



 #line 420 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string"

		
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& __cdecl operator>>(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	typedef ctype<_Elem> _Ctype;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Ctype& _Ctype_fac = use_facet<_Ctype >(_Istr.getloc());
		_Str.erase();

		try {
		_Mysizt _Size = 0 < _Istr.width()
			&& (_Mysizt)_Istr.width() < _Str.max_size()
				? (_Mysizt)_Istr.width() : _Str.max_size();
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())
			if(_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Traits::to_char_type(_Meta)))
				break;	
			else
				{	
				_Str.append(1, _Traits::to_char_type(_Meta));
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.width(0);
	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& __cdecl getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;
	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr, true);

	if (_Ok)
		{	
		try {
		_Str.erase();
		const typename _Traits::int_type _Metadelim =
			_Traits::to_int_type(_Delim);
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; ; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Traits::eq_int_type(_Meta, _Metadelim))
				{	
				_Changed = true;
				_Istr.rdbuf()->sbumpc();
				break;
				}
			else if (_Str.max_size() <= _Str.size())
				{	
				_State |= ios_base::failbit;
				break;
				}
			else
				{	
				_Str += _Traits::to_char_type(_Meta);
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& __cdecl getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (getline(_Istr, _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_ostream<_Elem, _Traits>& __cdecl operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr,
		const basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	_Mysizt _Size = _Str.size();
	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
			? 0 : (_Mysizt)_Ostr.width() - _Size;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
	try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit)
			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Str[_Count])))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

 
template __declspec(dllimport) basic_istream<char,
	char_traits<char> >& __cdecl operator>>(
		basic_istream<char, char_traits<char> >&,
		basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) basic_istream<char,
	char_traits<char> >& __cdecl getline(
		basic_istream<char, char_traits<char> >&,
		basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) basic_istream<char,
	char_traits<char> >& __cdecl getline(
		basic_istream<char, char_traits<char> >&,
		basic_string<char, char_traits<char>, allocator<char> >&,
		const char);
template __declspec(dllimport) basic_ostream<char,
	char_traits<char> >& __cdecl operator<<(
		basic_ostream<char, char_traits<char> >&,
		const basic_string<char, char_traits<char>, allocator<char> >&);

template __declspec(dllimport) basic_istream<wchar_t,
	char_traits<wchar_t> >& __cdecl operator>>(
		basic_istream<wchar_t, char_traits<wchar_t> >&,
		basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) basic_istream<wchar_t,
	char_traits<wchar_t> >& __cdecl getline(
		basic_istream<wchar_t, char_traits<wchar_t> >&,
		basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) basic_istream<wchar_t,
	char_traits<wchar_t> >& __cdecl getline(
		basic_istream<wchar_t, char_traits<wchar_t> >&,
		basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
		const wchar_t);
template __declspec(dllimport) basic_ostream<wchar_t,
	char_traits<wchar_t> >& __cdecl operator<<(
		basic_ostream<wchar_t, char_traits<wchar_t> >&,
		const basic_string<wchar_t, char_traits<wchar_t>,
			allocator<wchar_t> >&);



 #line 632 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string"
}


 #pragma warning(default: 4189)
#pragma warning(pop)
#pragma pack(pop)
#line 639 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string"

#line 641 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string"
#line 642 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\string"





#line 57 "c:\\qt-3.3.8\\include\\qstring.h"
#line 58 "c:\\qt-3.3.8\\include\\qstring.h"


#line 61 "c:\\qt-3.3.8\\include\\qstring.h"
#line 62 "c:\\qt-3.3.8\\include\\qstring.h"






class QRegExp;
class QString;
class QCharRef;
template <class T> class QDeepCopy;

class __declspec(dllimport) QChar {
public:
    QChar();
    QChar( char c );
    QChar( uchar c );
    QChar( uchar c, uchar r );
    QChar( const QChar& c ); 
    QChar( ushort rc );
    QChar( short rc );
    QChar( uint rc );
    QChar( int rc );

    static QChar null;            
    static QChar replacement;     
    static QChar byteOrderMark;     
    static QChar byteOrderSwapped;     
    static QChar nbsp;            

    

    enum Category
    {
        NoCategory,

        Mark_NonSpacing,          
        Mark_SpacingCombining,    
        Mark_Enclosing,           

        Number_DecimalDigit,      
        Number_Letter,            
        Number_Other,             

        Separator_Space,          
        Separator_Line,           
        Separator_Paragraph,      

        Other_Control,            
        Other_Format,             
        Other_Surrogate,          
        Other_PrivateUse,         
        Other_NotAssigned,        

        Letter_Uppercase,         
        Letter_Lowercase,         
        Letter_Titlecase,         
        Letter_Modifier,          
        Letter_Other,             

        Punctuation_Connector,    
        Punctuation_Dash,         
        Punctuation_Dask = Punctuation_Dash, 
        Punctuation_Open,         
        Punctuation_Close,        
        Punctuation_InitialQuote, 
        Punctuation_FinalQuote,   
        Punctuation_Other,        

        Symbol_Math,              
        Symbol_Currency,          
        Symbol_Modifier,          
        Symbol_Other              
    };

    enum Direction
    {
        DirL, DirR, DirEN, DirES, DirET, DirAN, DirCS, DirB, DirS, DirWS, DirON,
        DirLRE, DirLRO, DirAL, DirRLE, DirRLO, DirPDF, DirNSM, DirBN
    };

    enum Decomposition
    {
        Single, Canonical, Font, NoBreak, Initial, Medial,
        Final, Isolated, Circle, Super, Sub, Vertical,
        Wide, Narrow, Small, Square, Compat, Fraction
    };

    enum Joining
    {
        OtherJoining, Dual, Right, Center
    };

    enum CombiningClass
    {
        Combining_BelowLeftAttached       = 200,
        Combining_BelowAttached           = 202,
        Combining_BelowRightAttached      = 204,
        Combining_LeftAttached            = 208,
        Combining_RightAttached           = 210,
        Combining_AboveLeftAttached       = 212,
        Combining_AboveAttached           = 214,
        Combining_AboveRightAttached      = 216,

        Combining_BelowLeft               = 218,
        Combining_Below                   = 220,
        Combining_BelowRight              = 222,
        Combining_Left                    = 224,
        Combining_Right                   = 226,
        Combining_AboveLeft               = 228,
        Combining_Above                   = 230,
        Combining_AboveRight              = 232,

        Combining_DoubleBelow             = 233,
        Combining_DoubleAbove             = 234,
        Combining_IotaSubscript           = 240
    };

    

    int digitValue() const;
    QChar lower() const;
    QChar upper() const;

    Category category() const;
    Direction direction() const;
    Joining joining() const;
    bool mirrored() const;
    QChar mirroredChar() const;
    const QString &decomposition() const; 
    Decomposition decompositionTag() const;
    unsigned char combiningClass() const;

    char latin1() const { return ucs > 0xff ? 0 : (char) ucs; }
    ushort unicode() const { return ucs; }



    ushort &unicode() { return ucs; }
#line 201 "c:\\qt-3.3.8\\include\\qstring.h"

    
    operator char() const { return latin1(); }
#line 205 "c:\\qt-3.3.8\\include\\qstring.h"

    bool isNull() const { return unicode()==0; }
    bool isPrint() const;
    bool isPunct() const;
    bool isSpace() const;
    bool isMark() const;
    bool isLetter() const;
    bool isNumber() const;
    bool isLetterOrNumber() const;
    bool isDigit() const;
    bool isSymbol() const;

    uchar cell() const { return ((uchar) ucs & 0xff); }
    uchar row() const { return ((uchar) (ucs>>8)&0xff); }
    void setCell( uchar cell ) { ucs = (ucs & 0xff00) + cell; }
    void setRow( uchar row ) { ucs = (((ushort) row)<<8) + (ucs&0xff); }

    static bool networkOrdered() {
	int wordSize;
	bool bigEndian = FALSE;
	qSysInfo( &wordSize, &bigEndian );
	return bigEndian;
    }

    friend inline bool operator==( char ch, QChar c );
    friend inline bool operator==( QChar c, char ch );
    friend inline bool operator==( QChar c1, QChar c2 );
    friend inline bool operator!=( QChar c1, QChar c2 );
    friend inline bool operator!=( char ch, QChar c );
    friend inline bool operator!=( QChar c, char ch );
    friend inline bool operator<=( QChar c, char ch );
    friend inline bool operator<=( char ch, QChar c );
    friend inline bool operator<=( QChar c1, QChar c2 );

private:
    ushort ucs;


#line 244 "c:\\qt-3.3.8\\include\\qstring.h"
} ;

inline QChar::QChar() : ucs( 0 )



{
}
inline QChar::QChar( char c ) : ucs( (uchar)c )



{
}
inline QChar::QChar( uchar c ) : ucs( c )



{
}
inline QChar::QChar( uchar c, uchar r ) : ucs( (r << 8) | c )



{
}
inline QChar::QChar( const QChar& c ) : ucs( c.ucs )



{
}

inline QChar::QChar( ushort rc ) : ucs( rc )



{
}
inline QChar::QChar( short rc ) : ucs( (ushort) rc )



{
}
inline QChar::QChar( uint rc ) : ucs(  (ushort ) (rc & 0xffff) )



{
}
inline QChar::QChar( int rc ) : ucs( (ushort) (rc & 0xffff) )



{
}

inline bool operator==( char ch, QChar c )
{
    return ((uchar) ch) == c.ucs;
}

inline bool operator==( QChar c, char ch )
{
    return ((uchar) ch) == c.ucs;
}

inline bool operator==( QChar c1, QChar c2 )
{
    return c1.ucs == c2.ucs;
}

inline bool operator!=( QChar c1, QChar c2 )
{
    return c1.ucs != c2.ucs;
}

inline bool operator!=( char ch, QChar c )
{
    return ((uchar)ch) != c.ucs;
}

inline bool operator!=( QChar c, char ch )
{
    return ((uchar) ch) != c.ucs;
}

inline bool operator<=( QChar c, char ch )
{
    return c.ucs <= ((uchar) ch);
}

inline bool operator<=( char ch, QChar c )
{
    return ((uchar) ch) <= c.ucs;
}

inline bool operator<=( QChar c1, QChar c2 )
{
    return c1.ucs <= c2.ucs;
}

inline bool operator>=( QChar c, char ch ) { return ch <= c; }
inline bool operator>=( char ch, QChar c ) { return c <= ch; }
inline bool operator>=( QChar c1, QChar c2 ) { return c2 <= c1; }
inline bool operator<( QChar c, char ch ) { return !(ch<=c); }
inline bool operator<( char ch, QChar c ) { return !(c<=ch); }
inline bool operator<( QChar c1, QChar c2 ) { return !(c2<=c1); }
inline bool operator>( QChar c, char ch ) { return !(ch>=c); }
inline bool operator>( char ch, QChar c ) { return !(c>=ch); }
inline bool operator>( QChar c1, QChar c2 ) { return !(c2>=c1); }


struct __declspec(dllimport) QStringData : public QShared {
    QStringData() :
        QShared(), unicode(0), ascii(0), len(0), issimpletext(TRUE), maxl(0), islatin1(FALSE) { ref(); }
    QStringData(QChar *u, uint l, uint m) :
        QShared(), unicode(u), ascii(0), len(l), issimpletext(FALSE), maxl(m), islatin1(FALSE) { }
    ~QStringData() { if ( unicode ) delete[] ((char*)unicode);
                     if ( ascii ) delete[] ascii; }

    void deleteSelf();
    QChar *unicode;
    char *ascii;
    void setDirty() {
	if ( ascii ) {
	    delete [] ascii;
	    ascii = 0;
	}
	issimpletext = FALSE;
    }



    uint len : 30;
#line 381 "c:\\qt-3.3.8\\include\\qstring.h"
    uint issimpletext : 1;



    uint maxl : 30;
#line 387 "c:\\qt-3.3.8\\include\\qstring.h"
    uint islatin1 : 1;

private:



#line 394 "c:\\qt-3.3.8\\include\\qstring.h"
};


class __declspec(dllimport) QString
{
public:
    QString();                                  
    QString( QChar );                           
    QString( const QString & );                 
    QString( const QByteArray& );               
    QString( const QChar* unicode, uint length ); 

    QString( const char *str );                 
#line 408 "c:\\qt-3.3.8\\include\\qstring.h"

    QString( const std::string& );                   
#line 411 "c:\\qt-3.3.8\\include\\qstring.h"
    ~QString();

    QString    &operator=( const QString & );   
    QString    &operator=( const char * );      

    QString    &operator=( const std::string& );     
#line 418 "c:\\qt-3.3.8\\include\\qstring.h"
    QString    &operator=( const QCString& );   
    QString    &operator=( QChar c );
    QString    &operator=( char c );

    static QString null;

    bool        isNull()        const;
    bool        isEmpty()       const;
    uint        length()        const;
    void        truncate( uint pos );

    QString &   fill( QChar c, int len = -1 );

    QString     copy()  const;

    QString arg( long a, int fieldWidth = 0, int base = 10 ) const;
    QString arg( ulong a, int fieldWidth = 0, int base = 10 ) const;
    QString arg( Q_LLONG a, int fieldwidth=0, int base=10 ) const;
    QString arg( Q_ULLONG a, int fieldwidth=0, int base=10 ) const;
    QString arg( int a, int fieldWidth = 0, int base = 10 ) const;
    QString arg( uint a, int fieldWidth = 0, int base = 10 ) const;
    QString arg( short a, int fieldWidth = 0, int base = 10 ) const;
    QString arg( ushort a, int fieldWidth = 0, int base = 10 ) const;
    QString arg( double a, int fieldWidth = 0, char fmt = 'g',
		 int prec = -1 ) const;
    QString arg( char a, int fieldWidth = 0 ) const;
    QString arg( QChar a, int fieldWidth = 0 ) const;
    QString arg( const QString& a, int fieldWidth = 0 ) const;
    QString arg( const QString& a1, const QString& a2 ) const;
    QString arg( const QString& a1, const QString& a2,
		 const QString& a3 ) const;
    QString arg( const QString& a1, const QString& a2, const QString& a3,
		 const QString& a4 ) const;


    QString    &sprintf( const char* format, ... )


#line 457 "c:\\qt-3.3.8\\include\\qstring.h"
        ;
#line 459 "c:\\qt-3.3.8\\include\\qstring.h"

    int         find( QChar c, int index=0, bool cs=TRUE ) const;
    int         find( char c, int index=0, bool cs=TRUE ) const;
    int         find( const QString &str, int index=0, bool cs=TRUE ) const;

    int         find( const QRegExp &, int index=0 ) const;
#line 466 "c:\\qt-3.3.8\\include\\qstring.h"

    int         find( const char* str, int index=0 ) const;
#line 469 "c:\\qt-3.3.8\\include\\qstring.h"
    int         findRev( QChar c, int index=-1, bool cs=TRUE) const;
    int         findRev( char c, int index=-1, bool cs=TRUE) const;
    int         findRev( const QString &str, int index=-1, bool cs=TRUE) const;

    int         findRev( const QRegExp &, int index=-1 ) const;
#line 475 "c:\\qt-3.3.8\\include\\qstring.h"

    int         findRev( const char* str, int index=-1 ) const;
#line 478 "c:\\qt-3.3.8\\include\\qstring.h"
    int         contains( QChar c, bool cs=TRUE ) const;
    int         contains( char c, bool cs=TRUE ) const
                    { return contains(QChar(c), cs); }

    int         contains( const char* str, bool cs=TRUE ) const;
#line 484 "c:\\qt-3.3.8\\include\\qstring.h"
    int         contains( const QString &str, bool cs=TRUE ) const;

    int         contains( const QRegExp & ) const;
#line 488 "c:\\qt-3.3.8\\include\\qstring.h"

    enum SectionFlags {
	SectionDefault             = 0x00,
	SectionSkipEmpty           = 0x01,
	SectionIncludeLeadingSep   = 0x02,
	SectionIncludeTrailingSep  = 0x04,
	SectionCaseInsensitiveSeps = 0x08
    };
    QString     section( QChar sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const;
    QString     section( char sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const;

    QString      section( const char *in_sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const;
#line 501 "c:\\qt-3.3.8\\include\\qstring.h"
    QString     section( const QString &in_sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const;

    QString     section( const QRegExp &reg, int start, int end = 0xffffffff, int flags = SectionDefault ) const;
#line 505 "c:\\qt-3.3.8\\include\\qstring.h"

    QString     left( uint len )  const;
    QString     right( uint len ) const;
    QString     mid( uint index, uint len=0xffffffff) const;

    QString     leftJustify( uint width, QChar fill=' ', bool trunc=FALSE)const;
    QString     rightJustify( uint width, QChar fill=' ',bool trunc=FALSE)const;

    QString     lower() const;
    QString     upper() const;

    QString     stripWhiteSpace()       const;
    QString     simplifyWhiteSpace()    const;

    QString    &insert( uint index, const QString & );

    QString    &insert( uint index, const QByteArray & );
    QString    &insert( uint index, const char * );
#line 524 "c:\\qt-3.3.8\\include\\qstring.h"
    QString    &insert( uint index, const QChar*, uint len );
    QString    &insert( uint index, QChar );
    QString    &insert( uint index, char c ) { return insert(index,QChar(c)); }
    QString    &append( char );
    QString    &append( QChar );
    QString    &append( const QString & );

    QString    &append( const QByteArray & );
    QString    &append( const char * );
#line 534 "c:\\qt-3.3.8\\include\\qstring.h"

    QString    &append( const std::string& );
#line 537 "c:\\qt-3.3.8\\include\\qstring.h"
    QString    &prepend( char );
    QString    &prepend( QChar );
    QString    &prepend( const QString & );

    QString    &prepend( const QByteArray & );
    QString    &prepend( const char * );
#line 544 "c:\\qt-3.3.8\\include\\qstring.h"

    QString    &prepend( const std::string& );
#line 547 "c:\\qt-3.3.8\\include\\qstring.h"
    QString    &remove( uint index, uint len );


#line 551 "c:\\qt-3.3.8\\include\\qstring.h"
    
    QString    &remove( const QString & );
    QString    &remove( const QString &, bool cs );
#line 555 "c:\\qt-3.3.8\\include\\qstring.h"
    QString    &remove( QChar c );
    QString    &remove( char c )
    { return remove( QChar(c) ); }

    QString    &remove( const char * );
#line 561 "c:\\qt-3.3.8\\include\\qstring.h"

    QString    &remove( const QRegExp & );
#line 564 "c:\\qt-3.3.8\\include\\qstring.h"
    QString    &replace( uint index, uint len, const QString & );
    QString    &replace( uint index, uint len, const QChar*, uint clen );
    QString    &replace( uint index, uint len, QChar );
    QString    &replace( uint index, uint len, char c )
    { return replace( index, len, QChar(c) ); }





#line 575 "c:\\qt-3.3.8\\include\\qstring.h"
    
    QString    &replace( QChar c, const QString & );
    QString    &replace( QChar c, const QString &, bool );

    
    QString    &replace( char c, const QString & after )
    { return replace( QChar(c), after, TRUE ); }
    QString    &replace( char c, const QString & after, bool cs )
    { return replace( QChar(c), after, cs ); }

    
    QString    &replace( const QString &, const QString & );
    QString    &replace( const QString &, const QString &, bool );
#line 589 "c:\\qt-3.3.8\\include\\qstring.h"

    QString    &replace( const QRegExp &, const QString & );
#line 592 "c:\\qt-3.3.8\\include\\qstring.h"
    QString    &replace( QChar, QChar );

    short       toShort( bool *ok=0, int base=10 )      const;
    ushort      toUShort( bool *ok=0, int base=10 )     const;
    int         toInt( bool *ok=0, int base=10 )        const;
    uint        toUInt( bool *ok=0, int base=10 )       const;
    long        toLong( bool *ok=0, int base=10 )       const;
    ulong       toULong( bool *ok=0, int base=10 )      const;
    Q_LLONG     toLongLong( bool *ok=0, int base=10 )   const;
    Q_ULLONG    toULongLong( bool *ok=0, int base=10 )  const;
    float       toFloat( bool *ok=0 )   const;
    double      toDouble( bool *ok=0 )  const;

    QString    &setNum( short, int base=10 );
    QString    &setNum( ushort, int base=10 );
    QString    &setNum( int, int base=10 );
    QString    &setNum( uint, int base=10 );
    QString    &setNum( long, int base=10 );
    QString    &setNum( ulong, int base=10 );
    QString    &setNum( Q_LLONG, int base=10 );
    QString    &setNum( Q_ULLONG, int base=10 );
    QString    &setNum( float, char f='g', int prec=6 );
    QString    &setNum( double, char f='g', int prec=6 );

    static QString number( long, int base=10 );
    static QString number( ulong, int base=10);
    static QString number( Q_LLONG, int base=10 );
    static QString number( Q_ULLONG, int base=10);
    static QString number( int, int base=10 );
    static QString number( uint, int base=10);
    static QString number( double, char f='g', int prec=6 );

    void        setExpand( uint index, QChar c );

    QString    &operator+=( const QString &str );

    QString    &operator+=( const QByteArray &str );
    QString    &operator+=( const char *str );
#line 631 "c:\\qt-3.3.8\\include\\qstring.h"

    QString    &operator+=( const std::string& );
#line 634 "c:\\qt-3.3.8\\include\\qstring.h"
    QString    &operator+=( QChar c );
    QString    &operator+=( char c );

    QChar at( uint i ) const
        { return i < d->len ? d->unicode[i] : QChar::null; }
    QChar operator[]( int i ) const { return at((uint)i); }
    QCharRef at( uint i );
    QCharRef operator[]( int i );

    QChar constref(uint i) const
        { return at(i); }
    QChar& ref(uint i)
        { 
            if ( d->count != 1 || i >= d->len )
                subat( i );
            d->setDirty();
            return d->unicode[i];
        }

    const QChar* unicode() const { return d->unicode; }
    const char* ascii() const;
    static QString fromAscii(const char*, int len=-1);
    const char* latin1() const;
    static QString fromLatin1(const char*, int len=-1);
    QCString utf8() const;
    static QString fromUtf8(const char*, int len=-1);
    QCString local8Bit() const;
    static QString fromLocal8Bit(const char*, int len=-1);
    bool operator!() const;

    operator const char *() const { return ascii(); }
#line 666 "c:\\qt-3.3.8\\include\\qstring.h"

    operator std::string() const { return ascii() ? ascii() : ""; }
#line 669 "c:\\qt-3.3.8\\include\\qstring.h"

    static QString fromUcs2( const unsigned short *ucs2 );
    const unsigned short *ucs2() const;

    QString &setUnicode( const QChar* unicode, uint len );
    QString &setUnicodeCodes( const ushort* unicode_as_ushorts, uint len );
    QString &setAscii( const char*, int len=-1 );
    QString &setLatin1( const char*, int len=-1 );

    int compare( const QString& s ) const;
    static int compare( const QString& s1, const QString& s2 )
    { return s1.compare( s2 ); }

    int localeAwareCompare( const QString& s ) const;
    static int localeAwareCompare( const QString& s1, const QString& s2 )
    { return s1.localeAwareCompare( s2 ); }


    friend __declspec(dllimport) QDataStream &operator>>( QDataStream &, QString & );
#line 689 "c:\\qt-3.3.8\\include\\qstring.h"

    void compose();


    const char* data() const { return ascii(); }
#line 695 "c:\\qt-3.3.8\\include\\qstring.h"




#line 700 "c:\\qt-3.3.8\\include\\qstring.h"
    
    bool startsWith( const QString& str ) const;
    bool startsWith( const QString& str, bool cs ) const;

    
    bool endsWith( const QString& str ) const;
    bool endsWith( const QString& str, bool cs ) const;
#line 708 "c:\\qt-3.3.8\\include\\qstring.h"

    void setLength( uint newLength );

    uint capacity() const;
    void reserve( uint minCapacity );
    void squeeze();

    bool simpleText() const { if ( !d->issimpletext ) checkSimpleText(); return (bool)d->issimpletext; }
    bool isRightToLeft() const;


private:
    QString( int size, bool  );	

    void deref();
    void real_detach();
    void subat( uint );
    QString multiArg( int numArgs, const QString& a1, const QString& a2,
		      const QString& a3 = QString::null,
		      const QString& a4 = QString::null ) const;

    void checkSimpleText() const;
    void grow( uint newLength );

    QString &insertHelper( uint index, const char *s, uint len=0xffffffff );
    QString &operatorPlusEqHelper( const char *s, uint len2=0xffffffff );
#line 735 "c:\\qt-3.3.8\\include\\qstring.h"

    static QChar* latin1ToUnicode( const char*, uint * len, uint maxlen=(uint)-1 );
    static QChar* latin1ToUnicode( const QByteArray&, uint * len );
    static char* unicodeToLatin1( const QChar*, uint len );

    QStringData *d;
    static QStringData* shared_null;
    static QStringData* makeSharedNull();

    friend class QConstString;
    friend class QTextStream;
    QString( QStringData* dd, bool  ) : d(dd) { }

    
    void detach();
    friend class QDeepCopy<QString>;
};

class __declspec(dllimport) QCharRef {
    friend class QString;
    QString& s;
    uint p;
    QCharRef(QString* str, uint pos) : s(*str), p(pos) { }

public:
    

    

    ushort unicode() const { return s.constref(p).unicode(); }
    char latin1() const { return s.constref(p).latin1(); }

    
    QCharRef operator=(char c ) { s.ref(p)=c; return *this; }
    QCharRef operator=(uchar c ) { s.ref(p)=c; return *this; }
    QCharRef operator=(QChar c ) { s.ref(p)=c; return *this; }
    QCharRef operator=(const QCharRef& c ) { s.ref(p)=c.unicode(); return *this; }
    QCharRef operator=(ushort rc ) { s.ref(p)=rc; return *this; }
    QCharRef operator=(short rc ) { s.ref(p)=rc; return *this; }
    QCharRef operator=(uint rc ) { s.ref(p)=rc; return *this; }
    QCharRef operator=(int rc ) { s.ref(p)=rc; return *this; }

    operator QChar () const { return s.constref(p); }

    
    bool isNull() const { return unicode()==0; }
    bool isPrint() const { return s.constref(p).isPrint(); }
    bool isPunct() const { return s.constref(p).isPunct(); }
    bool isSpace() const { return s.constref(p).isSpace(); }
    bool isMark() const { return s.constref(p).isMark(); }
    bool isLetter() const { return s.constref(p).isLetter(); }
    bool isNumber() const { return s.constref(p).isNumber(); }
    bool isLetterOrNumber() { return s.constref(p).isLetterOrNumber(); }
    bool isDigit() const { return s.constref(p).isDigit(); }

    int digitValue() const { return s.constref(p).digitValue(); }
    QChar lower() const { return s.constref(p).lower(); }
    QChar upper() const { return s.constref(p).upper(); }

    QChar::Category category() const { return s.constref(p).category(); }
    QChar::Direction direction() const { return s.constref(p).direction(); }
    QChar::Joining joining() const { return s.constref(p).joining(); }
    bool mirrored() const { return s.constref(p).mirrored(); }
    QChar mirroredChar() const { return s.constref(p).mirroredChar(); }
    const QString &decomposition() const { return s.constref(p).decomposition(); }
    QChar::Decomposition decompositionTag() const { return s.constref(p).decompositionTag(); }
    unsigned char combiningClass() const { return s.constref(p).combiningClass(); }

    
    uchar cell() const { return s.constref(p).cell(); }
    uchar row() const { return s.constref(p).row(); }
#line 807 "c:\\qt-3.3.8\\include\\qstring.h"
};

inline QCharRef QString::at( uint i ) { return QCharRef(this,i); }
inline QCharRef QString::operator[]( int i ) { return at((uint)i); }


class __declspec(dllimport) QConstString : private QString {
public:
    QConstString( const QChar* unicode, uint length );
    ~QConstString();
    const QString& string() const { return *this; }
};






__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QString & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QString & );
#line 828 "c:\\qt-3.3.8\\include\\qstring.h"










inline QString::QString() :
    d(shared_null ? shared_null : makeSharedNull())
{
    d->ref();
}

inline QString::~QString()
{
    if ( d->deref() ) {
        if ( d != shared_null )
	    d->deleteSelf();
    }
}


inline void QString::detach()
{ real_detach(); }

inline QString QString::section( QChar sep, int start, int end, int flags ) const
{ return section(QString(sep), start, end, flags); }

inline QString QString::section( char sep, int start, int end, int flags ) const
{ return section(QChar(sep), start, end, flags); }


inline QString QString::section( const char *in_sep, int start, int end, int flags ) const
{ return section(QString(in_sep), start, end, flags); }
#line 866 "c:\\qt-3.3.8\\include\\qstring.h"

inline QString &QString::operator=( QChar c )
{ *this = QString(c); return *this; }

inline QString &QString::operator=( char c )
{ *this = QString(QChar(c)); return *this; }

inline bool QString::isNull() const
{ return unicode() == 0; }

inline bool QString::operator!() const
{ return isNull(); }

inline uint QString::length() const
{ return d->len; }

inline uint QString::capacity() const
{ return d->maxl; }

inline bool QString::isEmpty() const
{ return length() == 0; }

inline QString QString::copy() const
{ return QString( *this ); }


inline QString &QString::insert( uint index, const char *s )
{ return insertHelper( index, s ); }

inline QString &QString::insert( uint index, const QByteArray &s )
{
    int pos = s.find( 0 );
    return insertHelper( index, s, pos==-1 ? s.size() : pos );
}
#line 901 "c:\\qt-3.3.8\\include\\qstring.h"

inline QString &QString::prepend( const QString & s )
{ return insert(0,s); }

inline QString &QString::prepend( QChar c )
{ return insert(0,c); }

inline QString &QString::prepend( char c )
{ return insert(0,c); }


inline QString &QString::prepend( const QByteArray & s )
{ return insert(0,s); }
#line 915 "c:\\qt-3.3.8\\include\\qstring.h"


inline QString &QString::operator+=( const QByteArray &s )
{
    int pos = s.find( 0 );
    return operatorPlusEqHelper( s, pos==-1 ? s.size() : pos );
}
#line 923 "c:\\qt-3.3.8\\include\\qstring.h"

inline QString &QString::append( const QString & s )
{ return operator+=(s); }


inline QString &QString::append( const QByteArray &s )
{ return operator+=(s); }

inline QString &QString::append( const char * s )
{ return operator+=(s); }
#line 934 "c:\\qt-3.3.8\\include\\qstring.h"

inline QString &QString::append( QChar c )
{ return operator+=(c); }

inline QString &QString::append( char c )
{ return operator+=(c); }


inline QString &QString::operator=( const std::string& str )
{ return operator=(str.c_str()); }

inline QString &QString::operator+=( const std::string& s )
{ return operator+=(s.c_str()); }
inline QString &QString::append( const std::string& s )
{ return operator+=(s); }
inline QString &QString::prepend( const std::string& s )
{ return insert(0, s); }
#line 952 "c:\\qt-3.3.8\\include\\qstring.h"
#line 953 "c:\\qt-3.3.8\\include\\qstring.h"

inline QString &QString::setNum( short n, int base )
{ return setNum((Q_LLONG)n, base); }

inline QString &QString::setNum( ushort n, int base )
{ return setNum((Q_ULLONG)n, base); }

inline QString &QString::setNum( int n, int base )
{ return setNum((Q_LLONG)n, base); }

inline QString &QString::setNum( uint n, int base )
{ return setNum((Q_ULLONG)n, base); }

inline QString &QString::setNum( float n, char f, int prec )
{ return setNum((double)n,f,prec); }

inline QString QString::arg( int a, int fieldWidth, int base ) const
{ return arg( (Q_LLONG)a, fieldWidth, base ); }

inline QString QString::arg( uint a, int fieldWidth, int base ) const
{ return arg( (Q_ULLONG)a, fieldWidth, base ); }

inline QString QString::arg( short a, int fieldWidth, int base ) const
{ return arg( (Q_LLONG)a, fieldWidth, base ); }

inline QString QString::arg( ushort a, int fieldWidth, int base ) const
{ return arg( (Q_ULLONG)a, fieldWidth, base ); }

inline QString QString::arg( const QString& a1, const QString& a2 ) const {
    return multiArg( 2, a1, a2 );
}

inline QString QString::arg( const QString& a1, const QString& a2,
			     const QString& a3 ) const {
    return multiArg( 3, a1, a2, a3 );
}

inline QString QString::arg( const QString& a1, const QString& a2,
			     const QString& a3, const QString& a4 ) const {
    return multiArg( 4, a1, a2, a3, a4 );
}

inline int QString::find( char c, int index, bool cs ) const
{ return find(QChar(c), index, cs); }

inline int QString::findRev( char c, int index, bool cs ) const
{ return findRev( QChar(c), index, cs ); }


inline int QString::find( const char* str, int index ) const
{ return find(QString::fromAscii(str), index); }

inline int QString::findRev( const char* str, int index ) const
{ return findRev(QString::fromAscii(str), index); }
#line 1008 "c:\\qt-3.3.8\\include\\qstring.h"






__declspec(dllimport) bool operator!=( const QString &s1, const QString &s2 );
__declspec(dllimport) bool operator<( const QString &s1, const QString &s2 );
__declspec(dllimport) bool operator<=( const QString &s1, const QString &s2 );
__declspec(dllimport) bool operator==( const QString &s1, const QString &s2 );
__declspec(dllimport) bool operator>( const QString &s1, const QString &s2 );
__declspec(dllimport) bool operator>=( const QString &s1, const QString &s2 );

__declspec(dllimport) bool operator!=( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator<( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator<=( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator==( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator>( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator>=( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator!=( const char *s1, const QString &s2 );
__declspec(dllimport) bool operator<( const char *s1, const QString &s2 );
__declspec(dllimport) bool operator<=( const char *s1, const QString &s2 );
__declspec(dllimport) bool operator==( const char *s1, const QString &s2 );

__declspec(dllimport) bool operator>=( const char *s1, const QString &s2 );
#line 1034 "c:\\qt-3.3.8\\include\\qstring.h"

__declspec(dllimport) inline const QString operator+( const QString &s1, const QString &s2 )
{
    QString tmp( s1 );
    tmp += s2;
    return tmp;
}


__declspec(dllimport) inline const QString operator+( const QString &s1, const char *s2 )
{
    QString tmp( s1 );
    tmp += QString::fromAscii(s2);
    return tmp;
}

__declspec(dllimport) inline const QString operator+( const char *s1, const QString &s2 )
{
    QString tmp = QString::fromAscii( s1 );
    tmp += s2;
    return tmp;
}
#line 1057 "c:\\qt-3.3.8\\include\\qstring.h"

__declspec(dllimport) inline const QString operator+( const QString &s1, QChar c2 )
{
    QString tmp( s1 );
    tmp += c2;
    return tmp;
}

__declspec(dllimport) inline const QString operator+( const QString &s1, char c2 )
{
    QString tmp( s1 );
    tmp += c2;
    return tmp;
}

__declspec(dllimport) inline const QString operator+( QChar c1, const QString &s2 )
{
    QString tmp;
    tmp += c1;
    tmp += s2;
    return tmp;
}

__declspec(dllimport) inline const QString operator+( char c1, const QString &s2 )
{
    QString tmp;
    tmp += c1;
    tmp += s2;
    return tmp;
}


__declspec(dllimport) inline const QString operator+(const QString& s1, const std::string& s2)
{
    return s1 + QString(s2);
}

__declspec(dllimport) inline const QString operator+(const std::string& s1, const QString& s2)
{
    QString tmp(s2);
    return QString(tmp.prepend(s1));
}
#line 1100 "c:\\qt-3.3.8\\include\\qstring.h"



extern __declspec(dllimport) QString qt_winQString(void*);
extern __declspec(dllimport) const void* qt_winTchar(const QString& str, bool addnul);
extern __declspec(dllimport) void* qt_winTchar_new(const QString& str);
extern __declspec(dllimport) QCString qt_winQString2MB( const QString& s, int len=-1 );
extern __declspec(dllimport) QString qt_winMB2QString( const char* mb, int len=-1 );
#line 1109 "c:\\qt-3.3.8\\include\\qstring.h"


#line 1 "c:\\qt-3.3.8\\include\\qwinexport.h"










































#line 44 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 49 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 54 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 59 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 65 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 70 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 75 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 81 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 87 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 94 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 101 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 106 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 112 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 118 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 124 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 130 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 136 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 141 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 146 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 151 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 156 "c:\\qt-3.3.8\\include\\qwinexport.h"







#line 164 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 170 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 176 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 182 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 187 "c:\\qt-3.3.8\\include\\qwinexport.h"








#line 196 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 202 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 207 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 211 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 218 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 222 "c:\\qt-3.3.8\\include\\qwinexport.h"
#line 1112 "c:\\qt-3.3.8\\include\\qstring.h"
#line 1113 "c:\\qt-3.3.8\\include\\qstring.h"

#line 45 "c:\\qt-3.3.8\\include\\qwindowdefs.h"
#line 1 "c:\\qt-3.3.8\\include\\qnamespace.h"









































#line 1 "c:\\qt-3.3.8\\include\\qglobal.h"





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1111 "c:\\qt-3.3.8\\include\\qglobal.h"


#pragma warning(disable: 4244) 
#pragma warning(disable: 4275) 
#pragma warning(disable: 4514) 
#pragma warning(disable: 4800) 
#pragma warning(disable: 4097) 
#pragma warning(disable: 4706) 
#pragma warning(disable: 4786) 
#pragma warning(disable: 4660) 
#pragma warning(disable: 4355) 
#pragma warning(disable: 4231) 
#pragma warning(disable: 4710) 








#line 1133 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 1134 "c:\\qt-3.3.8\\include\\qglobal.h"


#line 43 "c:\\qt-3.3.8\\include\\qnamespace.h"
#line 44 "c:\\qt-3.3.8\\include\\qnamespace.h"


class QColor;
class QCursor;


class __declspec(dllimport) Qt {
public:
    static QColor & color0;
    static QColor & color1;
    static QColor & black;
    static QColor & white;
    static QColor & darkGray;
    static QColor & gray;
    static QColor & lightGray;
    static QColor & red;
    static QColor & green;
    static QColor & blue;
    static QColor & cyan;
    static QColor & magenta;
    static QColor & yellow;
    static QColor & darkRed;
    static QColor & darkGreen;
    static QColor & darkBlue;
    static QColor & darkCyan;
    static QColor & darkMagenta;
    static QColor & darkYellow;

    
    enum ButtonState {				
	NoButton	= 0x0000,
	LeftButton	= 0x0001,
	RightButton	= 0x0002,
	MidButton	= 0x0004,
	MouseButtonMask = 0x0007,
	ShiftButton	= 0x0100,
	ControlButton   = 0x0200,
	AltButton	= 0x0400,
	MetaButton	= 0x0800,
	KeyButtonMask	= 0x0f00,
	Keypad		= 0x4000
    };

    
    
    enum Orientation {
        Horizontal = 0,
	Vertical
    };

    
    enum SortOrder {
	Ascending,
	Descending
    };

    
    
    

    
    enum AlignmentFlags {
	AlignAuto		= 0x0000, 	
	AlignLeft		= 0x0001,
	AlignRight		= 0x0002,
	AlignHCenter		= 0x0004,
	AlignJustify		= 0x0008,
	AlignHorizontal_Mask	= AlignLeft | AlignRight | AlignHCenter | AlignJustify,
	AlignTop		= 0x0010,
	AlignBottom		= 0x0020,
	AlignVCenter		= 0x0040,
	AlignVertical_Mask 	= AlignTop | AlignBottom | AlignVCenter,
	AlignCenter		= AlignVCenter | AlignHCenter
    };

    
    enum TextFlags {
	SingleLine	= 0x0080,		
	DontClip	= 0x0100,
	ExpandTabs	= 0x0200,
	ShowPrefix	= 0x0400,
	WordBreak	= 0x0800,
	BreakAnywhere = 0x1000,

	DontPrint	= 0x2000,
	Underline = 0x01000000,
	Overline  = 0x02000000,
	StrikeOut = 0x04000000,
	IncludeTrailingSpaces = 0x08000000,
#line 134 "c:\\qt-3.3.8\\include\\qnamespace.h"
	NoAccel = 0x4000
    };

    
    typedef uint WState;

    
    enum WidgetState {
	WState_Created		= 0x00000001,
	WState_Disabled		= 0x00000002,
	WState_Visible		= 0x00000004,
	WState_ForceHide	= 0x00000008,
	WState_OwnCursor	= 0x00000010,
	WState_MouseTracking	= 0x00000020,
	WState_CompressKeys	= 0x00000040,
	WState_BlockUpdates	= 0x00000080,
	WState_InPaintEvent	= 0x00000100,
	WState_Reparented	= 0x00000200,
	WState_ConfigPending	= 0x00000400,
	WState_Resized		= 0x00000800,
	WState_AutoMask		= 0x00001000,
	WState_Polished		= 0x00002000,
	WState_DND		= 0x00004000,
	WState_Reserved0	= 0x00008000,
	WState_FullScreen	= 0x00010000,
	WState_OwnSizePolicy	= 0x00020000,
	WState_CreatedHidden	= 0x00040000,
	WState_Maximized	= 0x00080000,
	WState_Minimized	= 0x00100000,
	WState_ForceDisabled	= 0x00200000,
	WState_Exposed		= 0x00400000,
	WState_HasMouse		= 0x00800000
    };

    
    typedef uint WFlags;

    
    enum WidgetFlags {
	WType_TopLevel		= 0x00000001,	
	WType_Dialog		= 0x00000002,
	WType_Popup		= 0x00000004,
	WType_Desktop		= 0x00000008,
	WType_Mask		= 0x0000000f,

	WStyle_Customize	= 0x00000010,	
	WStyle_NormalBorder	= 0x00000020,
	WStyle_DialogBorder	= 0x00000040, 
	WStyle_NoBorder		= 0x00002000,
	WStyle_Title		= 0x00000080,
	WStyle_SysMenu		= 0x00000100,
	WStyle_Minimize		= 0x00000200,
	WStyle_Maximize		= 0x00000400,
	WStyle_MinMax		= WStyle_Minimize | WStyle_Maximize,
	WStyle_Tool		= 0x00000800,
	WStyle_StaysOnTop	= 0x00001000,
	WStyle_ContextHelp	= 0x00004000,
	WStyle_Reserved		= 0x00008000,
	WStyle_Mask		= 0x0000fff0,

	WDestructiveClose	= 0x00010000,	
	WPaintDesktop		= 0x00020000,
	WPaintUnclipped		= 0x00040000,
	WPaintClever		= 0x00080000,
	WResizeNoErase		= 0x00100000, 
	WMouseNoMask		= 0x00200000,
	WStaticContents		= 0x00400000,
	WRepaintNoErase		= 0x00800000, 





#line 208 "c:\\qt-3.3.8\\include\\qnamespace.h"




#line 213 "c:\\qt-3.3.8\\include\\qnamespace.h"
	WX11BypassWM		= 0x00000000,
	WWinOwnDC		= 0x01000000,
	WMacNoSheet             = 0x00000000,
        WMacDrawer              = 0x00000000,
#line 218 "c:\\qt-3.3.8\\include\\qnamespace.h"
	WGroupLeader		= 0x02000000,
	WShowModal		= 0x04000000,
	WNoMousePropagation	= 0x08000000,
	WSubWindow              = 0x10000000,


#line 225 "c:\\qt-3.3.8\\include\\qnamespace.h"
	WStyle_Splash           = WStyle_NoBorder | WMacNoSheet | WStyle_Tool | WWinOwnDC,
#line 227 "c:\\qt-3.3.8\\include\\qnamespace.h"
	WNoAutoErase		= WRepaintNoErase | WResizeNoErase

	,
	WNorthWestGravity	= WStaticContents,
	WType_Modal		= WType_Dialog | WShowModal,
	WStyle_Dialog		= WType_Dialog,
	WStyle_NoBorderEx	= WStyle_NoBorder
#line 235 "c:\\qt-3.3.8\\include\\qnamespace.h"
    };

    enum WindowState {
	WindowNoState   = 0x00000000,
	WindowMinimized = 0x00000001,
	WindowMaximized = 0x00000002,
	WindowFullScreen = 0x00000004,
	WindowActive = 0x00000008
    };


    
    
    

    enum ImageConversionFlags {
	ColorMode_Mask		= 0x00000003,
	AutoColor		= 0x00000000,
	ColorOnly		= 0x00000003,
	MonoOnly		= 0x00000002,
	

	AlphaDither_Mask	= 0x0000000c,
	ThresholdAlphaDither	= 0x00000000,
	OrderedAlphaDither	= 0x00000004,
	DiffuseAlphaDither	= 0x00000008,
	NoAlpha			= 0x0000000c, 

	Dither_Mask		= 0x00000030,
	DiffuseDither		= 0x00000000,
	OrderedDither		= 0x00000010,
	ThresholdDither		= 0x00000020,
	

	DitherMode_Mask		= 0x000000c0,
	AutoDither		= 0x00000000,
	PreferDither		= 0x00000040,
	AvoidDither		= 0x00000080
    };

    
    enum BGMode	{				
	TransparentMode,
	OpaqueMode
    };


    
    enum PaintUnit {				
	PixelUnit,
	LoMetricUnit, 
	HiMetricUnit, 
	LoEnglishUnit, 
	HiEnglishUnit, 
	TwipsUnit 
    };
#line 292 "c:\\qt-3.3.8\\include\\qnamespace.h"

    






    enum GUIStyle {
	MacStyle, 
	WindowsStyle,
	Win3Style, 
	PMStyle, 
	MotifStyle
    };
#line 308 "c:\\qt-3.3.8\\include\\qnamespace.h"

    
    enum SequenceMatch {
	NoMatch,
	PartialMatch,
	Identical
    };

    
    enum Modifier {		
	META          = 0x00100000,
	SHIFT         = 0x00200000,
	CTRL          = 0x00400000,
	ALT           = 0x00800000,
	MODIFIER_MASK = 0x00f00000,
	UNICODE_ACCEL = 0x10000000,

	ASCII_ACCEL = UNICODE_ACCEL 
    };

    
    enum Key {
	Key_Escape = 0x1000,		
	Key_Tab = 0x1001,
	Key_Backtab = 0x1002, Key_BackTab = Key_Backtab,
	Key_Backspace = 0x1003, Key_BackSpace = Key_Backspace,
	Key_Return = 0x1004,
	Key_Enter = 0x1005,
	Key_Insert = 0x1006,
	Key_Delete = 0x1007,
	Key_Pause = 0x1008,
	Key_Print = 0x1009,
	Key_SysReq = 0x100a,
	Key_Clear = 0x100b,
	Key_Home = 0x1010,		
	Key_End = 0x1011,
	Key_Left = 0x1012,
	Key_Up = 0x1013,
	Key_Right = 0x1014,
	Key_Down = 0x1015,
	Key_Prior = 0x1016, Key_PageUp = Key_Prior,
	Key_Next = 0x1017, Key_PageDown = Key_Next,
	Key_Shift = 0x1020,		
	Key_Control = 0x1021,
	Key_Meta = 0x1022,
	Key_Alt = 0x1023,
	Key_CapsLock = 0x1024,
	Key_NumLock = 0x1025,
	Key_ScrollLock = 0x1026,
	Key_F1 = 0x1030,		
	Key_F2 = 0x1031,
	Key_F3 = 0x1032,
	Key_F4 = 0x1033,
	Key_F5 = 0x1034,
	Key_F6 = 0x1035,
	Key_F7 = 0x1036,
	Key_F8 = 0x1037,
	Key_F9 = 0x1038,
	Key_F10 = 0x1039,
	Key_F11 = 0x103a,
	Key_F12 = 0x103b,
	Key_F13 = 0x103c,
	Key_F14 = 0x103d,
	Key_F15 = 0x103e,
	Key_F16 = 0x103f,
	Key_F17 = 0x1040,
	Key_F18 = 0x1041,
	Key_F19 = 0x1042,
	Key_F20 = 0x1043,
	Key_F21 = 0x1044,
	Key_F22 = 0x1045,
	Key_F23 = 0x1046,
	Key_F24 = 0x1047,
	Key_F25 = 0x1048,		
	Key_F26 = 0x1049,
	Key_F27 = 0x104a,
	Key_F28 = 0x104b,
	Key_F29 = 0x104c,
	Key_F30 = 0x104d,
	Key_F31 = 0x104e,
	Key_F32 = 0x104f,
	Key_F33 = 0x1050,
	Key_F34 = 0x1051,
	Key_F35 = 0x1052,
	Key_Super_L = 0x1053, 		
	Key_Super_R = 0x1054,
	Key_Menu = 0x1055,
	Key_Hyper_L = 0x1056,
	Key_Hyper_R = 0x1057,
	Key_Help = 0x1058,
	Key_Direction_L = 0x1059,
	Key_Direction_R = 0x1060,
	Key_Space = 0x20,		
	Key_Any = Key_Space,
	Key_Exclam = 0x21,
	Key_QuoteDbl = 0x22,
	Key_NumberSign = 0x23,
	Key_Dollar = 0x24,
	Key_Percent = 0x25,
	Key_Ampersand = 0x26,
	Key_Apostrophe = 0x27,
	Key_ParenLeft = 0x28,
	Key_ParenRight = 0x29,
	Key_Asterisk = 0x2a,
	Key_Plus = 0x2b,
	Key_Comma = 0x2c,
	Key_Minus = 0x2d,
	Key_Period = 0x2e,
	Key_Slash = 0x2f,
	Key_0 = 0x30,
	Key_1 = 0x31,
	Key_2 = 0x32,
	Key_3 = 0x33,
	Key_4 = 0x34,
	Key_5 = 0x35,
	Key_6 = 0x36,
	Key_7 = 0x37,
	Key_8 = 0x38,
	Key_9 = 0x39,
	Key_Colon = 0x3a,
	Key_Semicolon = 0x3b,
	Key_Less = 0x3c,
	Key_Equal = 0x3d,
	Key_Greater = 0x3e,
	Key_Question = 0x3f,
	Key_At = 0x40,
	Key_A = 0x41,
	Key_B = 0x42,
	Key_C = 0x43,
	Key_D = 0x44,
	Key_E = 0x45,
	Key_F = 0x46,
	Key_G = 0x47,
	Key_H = 0x48,
	Key_I = 0x49,
	Key_J = 0x4a,
	Key_K = 0x4b,
	Key_L = 0x4c,
	Key_M = 0x4d,
	Key_N = 0x4e,
	Key_O = 0x4f,
	Key_P = 0x50,
	Key_Q = 0x51,
	Key_R = 0x52,
	Key_S = 0x53,
	Key_T = 0x54,
	Key_U = 0x55,
	Key_V = 0x56,
	Key_W = 0x57,
	Key_X = 0x58,
	Key_Y = 0x59,
	Key_Z = 0x5a,
	Key_BracketLeft = 0x5b,
	Key_Backslash = 0x5c,
	Key_BracketRight = 0x5d,
	Key_AsciiCircum = 0x5e,
	Key_Underscore = 0x5f,
	Key_QuoteLeft = 0x60,
	Key_BraceLeft = 0x7b,
	Key_Bar = 0x7c,
	Key_BraceRight = 0x7d,
	Key_AsciiTilde = 0x7e,

	

	Key_nobreakspace = 0x0a0,
	Key_exclamdown = 0x0a1,
	Key_cent = 0x0a2,
	Key_sterling = 0x0a3,
	Key_currency = 0x0a4,
	Key_yen = 0x0a5,
	Key_brokenbar = 0x0a6,
	Key_section = 0x0a7,
	Key_diaeresis = 0x0a8,
	Key_copyright = 0x0a9,
	Key_ordfeminine = 0x0aa,
	Key_guillemotleft = 0x0ab,	
	Key_notsign = 0x0ac,
	Key_hyphen = 0x0ad,
	Key_registered = 0x0ae,
	Key_macron = 0x0af,
	Key_degree = 0x0b0,
	Key_plusminus = 0x0b1,
	Key_twosuperior = 0x0b2,
	Key_threesuperior = 0x0b3,
	Key_acute = 0x0b4,
	Key_mu = 0x0b5,
	Key_paragraph = 0x0b6,
	Key_periodcentered = 0x0b7,
	Key_cedilla = 0x0b8,
	Key_onesuperior = 0x0b9,
	Key_masculine = 0x0ba,
	Key_guillemotright = 0x0bb,	
	Key_onequarter = 0x0bc,
	Key_onehalf = 0x0bd,
	Key_threequarters = 0x0be,
	Key_questiondown = 0x0bf,
	Key_Agrave = 0x0c0,
	Key_Aacute = 0x0c1,
	Key_Acircumflex = 0x0c2,
	Key_Atilde = 0x0c3,
	Key_Adiaeresis = 0x0c4,
	Key_Aring = 0x0c5,
	Key_AE = 0x0c6,
	Key_Ccedilla = 0x0c7,
	Key_Egrave = 0x0c8,
	Key_Eacute = 0x0c9,
	Key_Ecircumflex = 0x0ca,
	Key_Ediaeresis = 0x0cb,
	Key_Igrave = 0x0cc,
	Key_Iacute = 0x0cd,
	Key_Icircumflex = 0x0ce,
	Key_Idiaeresis = 0x0cf,
	Key_ETH = 0x0d0,
	Key_Ntilde = 0x0d1,
	Key_Ograve = 0x0d2,
	Key_Oacute = 0x0d3,
	Key_Ocircumflex = 0x0d4,
	Key_Otilde = 0x0d5,
	Key_Odiaeresis = 0x0d6,
	Key_multiply = 0x0d7,
	Key_Ooblique = 0x0d8,
	Key_Ugrave = 0x0d9,
	Key_Uacute = 0x0da,
	Key_Ucircumflex = 0x0db,
	Key_Udiaeresis = 0x0dc,
	Key_Yacute = 0x0dd,
	Key_THORN = 0x0de,
	Key_ssharp = 0x0df,
	Key_agrave = 0x0e0,
	Key_aacute = 0x0e1,
	Key_acircumflex = 0x0e2,
	Key_atilde = 0x0e3,
	Key_adiaeresis = 0x0e4,
	Key_aring = 0x0e5,
	Key_ae = 0x0e6,
	Key_ccedilla = 0x0e7,
	Key_egrave = 0x0e8,
	Key_eacute = 0x0e9,
	Key_ecircumflex = 0x0ea,
	Key_ediaeresis = 0x0eb,
	Key_igrave = 0x0ec,
	Key_iacute = 0x0ed,
	Key_icircumflex = 0x0ee,
	Key_idiaeresis = 0x0ef,
	Key_eth = 0x0f0,
	Key_ntilde = 0x0f1,
	Key_ograve = 0x0f2,
	Key_oacute = 0x0f3,
	Key_ocircumflex = 0x0f4,
	Key_otilde = 0x0f5,
	Key_odiaeresis = 0x0f6,
	Key_division = 0x0f7,
	Key_oslash = 0x0f8,
	Key_ugrave = 0x0f9,
	Key_uacute = 0x0fa,
	Key_ucircumflex = 0x0fb,
	Key_udiaeresis = 0x0fc,
	Key_yacute = 0x0fd,
	Key_thorn = 0x0fe,
	Key_ydiaeresis = 0x0ff,

	

	Key_Back  = 0x1061,
	Key_Forward  = 0x1062,
	Key_Stop  = 0x1063,
	Key_Refresh  = 0x1064,

	Key_VolumeDown = 0x1070,
	Key_VolumeMute  = 0x1071,
	Key_VolumeUp = 0x1072,
	Key_BassBoost = 0x1073,
	Key_BassUp = 0x1074,
	Key_BassDown = 0x1075,
	Key_TrebleUp = 0x1076,
	Key_TrebleDown = 0x1077,

	Key_MediaPlay  = 0x1080,
	Key_MediaStop  = 0x1081,
	Key_MediaPrev  = 0x1082,
	Key_MediaNext  = 0x1083,
	Key_MediaRecord = 0x1084,

	Key_HomePage  = 0x1090,
	Key_Favorites  = 0x1091,
	Key_Search  = 0x1092,
	Key_Standby = 0x1093,
	Key_OpenUrl = 0x1094,

	Key_LaunchMail  = 0x10a0,
	Key_LaunchMedia = 0x10a1,
	Key_Launch0  = 0x10a2,
	Key_Launch1  = 0x10a3,
	Key_Launch2  = 0x10a4,
	Key_Launch3  = 0x10a5,
	Key_Launch4  = 0x10a6,
	Key_Launch5  = 0x10a7,
	Key_Launch6  = 0x10a8,
	Key_Launch7  = 0x10a9,
	Key_Launch8  = 0x10aa,
	Key_Launch9  = 0x10ab,
	Key_LaunchA  = 0x10ac,
	Key_LaunchB  = 0x10ad,
	Key_LaunchC  = 0x10ae,
	Key_LaunchD  = 0x10af,
	Key_LaunchE  = 0x10b0,
	Key_LaunchF  = 0x10b1,

	Key_MediaLast = 0x1fff,

	Key_unknown = 0xffff
    };

    
    enum ArrowType {
	UpArrow,
	DownArrow,
	LeftArrow,
	RightArrow
    };

    
    enum RasterOp { 
	CopyROP,
	OrROP,
	XorROP,
	NotAndROP, EraseROP=NotAndROP,
	NotCopyROP,
	NotOrROP,
	NotXorROP,
	AndROP,	NotEraseROP=AndROP,
	NotROP,
	ClearROP,
	SetROP,
	NopROP,
	AndNotROP,
	OrNotROP,
	NandROP,
	NorROP,	LastROP=NorROP
    };

    
    enum PenStyle { 
	NoPen,
	SolidLine,
	DashLine,
	DotLine,
	DashDotLine,
	DashDotDotLine,
	MPenStyle = 0x0f
    };

    
    enum PenCapStyle { 
	FlatCap = 0x00,
	SquareCap = 0x10,
	RoundCap = 0x20,
	MPenCapStyle = 0x30
    };

    
    enum PenJoinStyle { 
	MiterJoin = 0x00,
	BevelJoin = 0x40,
	RoundJoin = 0x80,
	MPenJoinStyle = 0xc0
    };

    
    enum BrushStyle { 
	NoBrush,
	SolidPattern,
	Dense1Pattern,
	Dense2Pattern,
	Dense3Pattern,
	Dense4Pattern,
	Dense5Pattern,
	Dense6Pattern,
	Dense7Pattern,
	HorPattern,
	VerPattern,
	CrossPattern,
	BDiagPattern,
	FDiagPattern,
	DiagCrossPattern,
	CustomPattern=24
    };

    
    enum MacintoshVersion {
	
	MV_Unknown      = 0x0000,

	
	MV_9            = 0x0001,
	MV_10_DOT_0     = 0x0002,
	MV_10_DOT_1     = 0x0003,
	MV_10_DOT_2     = 0x0004,
	MV_10_DOT_3     = 0x0005,
	MV_10_DOT_4     = 0x0006,

	
	MV_CHEETAH      = MV_10_DOT_0,
	MV_PUMA         = MV_10_DOT_1,
	MV_JAGUAR       = MV_10_DOT_2,
	MV_PANTHER      = MV_10_DOT_3,
	MV_TIGER        = MV_10_DOT_4
    };

    
    enum WindowsVersion {
	WV_32s 		= 0x0001,
	WV_95 		= 0x0002,
	WV_98		= 0x0003,
	WV_Me		= 0x0004,
	WV_DOS_based	= 0x000f,

	WV_NT 		= 0x0010,
	WV_2000 	= 0x0020,
	WV_XP		= 0x0030,
	WV_2003		= 0x0040,
	WV_VISTA 	= 0x0080,
	WV_NT_based	= 0x00f0,

	WV_CE           = 0x0100,
	WV_CENET	= 0x0200,
	WV_CE_based	= 0x0f00
    };

    
    enum UIEffect {
	UI_General,
	UI_AnimateMenu,
	UI_FadeMenu,
	UI_AnimateCombo,
	UI_AnimateTooltip,
	UI_FadeTooltip,
	UI_AnimateToolBox
    };

    
    enum CursorShape {
	ArrowCursor,
	UpArrowCursor,
	CrossCursor,
	WaitCursor,
	IbeamCursor,
	SizeVerCursor,
	SizeHorCursor,
	SizeBDiagCursor,
	SizeFDiagCursor,
	SizeAllCursor,
	BlankCursor,
	SplitVCursor,
	SplitHCursor,
	PointingHandCursor,
	ForbiddenCursor,
	WhatsThisCursor,
	BusyCursor,
	LastCursor	= BusyCursor,
	BitmapCursor	= 24
    };

    

    static QCursor & arrowCursor;	
    static QCursor & upArrowCursor;	
    static QCursor & crossCursor;	
    static QCursor & waitCursor;	
    static QCursor & ibeamCursor;	
    static QCursor & sizeVerCursor;	
    static QCursor & sizeHorCursor;	
    static QCursor & sizeBDiagCursor;	
    static QCursor & sizeFDiagCursor;	
    static QCursor & sizeAllCursor;	
    static QCursor & blankCursor;	
    static QCursor & splitVCursor;	
						
    static QCursor & splitHCursor;	
						
    static QCursor & pointingHandCursor;	
    static QCursor & forbiddenCursor;	
    static QCursor & whatsThisCursor;  
    static QCursor & busyCursor;	


    enum TextFormat {
	PlainText,
	RichText,
	AutoText,
	LogText
    };

    
    enum AnchorAttribute {
	AnchorName,
	AnchorHref
    };

    
    enum Dock {
	DockUnmanaged,
	DockTornOff,
	DockTop,
	DockBottom,
	DockRight,
	DockLeft,
	DockMinimized

        ,
	Unmanaged = DockUnmanaged,
	TornOff = DockTornOff,
	Top = DockTop,
	Bottom = DockBottom,
	Right = DockRight,
	Left = DockLeft,
	Minimized = DockMinimized
#line 827 "c:\\qt-3.3.8\\include\\qnamespace.h"
    };
    
    typedef Dock ToolBarDock;

    
    enum DateFormat {
	TextDate,      
	ISODate,       
	LocalDate      
    };

    
    enum TimeSpec {
	LocalTime,
	UTC
    };

    
    enum BackgroundMode {
	FixedColor,
	FixedPixmap,
	NoBackground,
	PaletteForeground,
	PaletteButton,
	PaletteLight,
	PaletteMidlight,
	PaletteDark,
	PaletteMid,
	PaletteText,
	PaletteBrightText,
	PaletteBase,
	PaletteBackground,
	PaletteShadow,
	PaletteHighlight,
	PaletteHighlightedText,
	PaletteButtonText,
	PaletteLink,
	PaletteLinkVisited,
	X11ParentRelative
    };

    typedef uint ComparisonFlags;

    
    enum StringComparisonMode {
        CaseSensitive   = 0x00001, 
        BeginsWith      = 0x00002, 
        EndsWith        = 0x00004, 
        Contains        = 0x00008, 
        ExactMatch      = 0x00010  
    };

    
    enum Corner {
	TopLeft     = 0x00000,
	TopRight    = 0x00001,
	BottomLeft  = 0x00002,
	BottomRight = 0x00003
    };

    
    


#line 892 "c:\\qt-3.3.8\\include\\qnamespace.h"
    typedef void *HANDLE;




#line 898 "c:\\qt-3.3.8\\include\\qnamespace.h"
};


class __declspec(dllimport) QInternal {
public:
    enum PaintDeviceFlags {
	UndefinedDevice = 0x00,
	Widget = 0x01,
	Pixmap = 0x02,
	Printer = 0x03,
	Picture = 0x04,
	System = 0x05,
	DeviceTypeMask = 0x0f,
	ExternalDevice = 0x10,
	
	CompatibilityMode = 0x20
    };
};

#line 918 "c:\\qt-3.3.8\\include\\qnamespace.h"
#line 46 "c:\\qt-3.3.8\\include\\qwindowdefs.h"
#line 47 "c:\\qt-3.3.8\\include\\qwindowdefs.h"



class QPaintDevice;
class QPaintDeviceMetrics;
class QWidget;
class QWidgetMapper;
class QDialog;
class QColor;
class QColorGroup;
class QPalette;
class QCursor;
class QPoint;
class QSize;
class QRect;
class QPointArray;
class QPainter;
class QRegion;
class QFont;
class QFontMetrics;
class QFontInfo;
class QPen;
class QBrush;
class QWMatrix;
class QPixmap;
class QBitmap;
class QMovie;
class QImage;
class QImageIO;
class QPicture;
class QPrinter;
class QAccel;
class QTimer;
class QTime;
class QClipboard;




class QWidgetList;
class QWidgetListIt;








































#line 129 "c:\\qt-3.3.8\\include\\qwindowdefs.h"


#line 1 "c:\\qt-3.3.8\\include\\qwindowdefs_win.h"









































#line 43 "c:\\qt-3.3.8\\include\\qwindowdefs_win.h"



struct HINSTANCE__; typedef struct HINSTANCE__ *HINSTANCE;
struct HDC__; typedef struct HDC__ *HDC;
struct HWND__; typedef struct HWND__ *HWND;
struct HFONT__; typedef struct HFONT__ *HFONT;
struct HPEN__; typedef struct HPEN__ *HPEN;
struct HBRUSH__; typedef struct HBRUSH__ *HBRUSH;
struct HBITMAP__; typedef struct HBITMAP__ *HBITMAP;
struct HICON__; typedef struct HICON__ *HICON;
typedef HICON HCURSOR;
struct HPALETTE__; typedef struct HPALETTE__ *HPALETTE;
struct HRGN__; typedef struct HRGN__ *HRGN;

typedef struct tagMSG MSG;
typedef HWND WId;


__declspec(dllimport) HINSTANCE qWinAppInst();       
__declspec(dllimport) HINSTANCE qWinAppPrevInst();   
__declspec(dllimport) int qWinAppCmdShow();          
__declspec(dllimport) HDC qt_display_dc();           














#line 81 "c:\\qt-3.3.8\\include\\qwindowdefs_win.h"

#line 83 "c:\\qt-3.3.8\\include\\qwindowdefs_win.h"
#line 132 "c:\\qt-3.3.8\\include\\qwindowdefs.h"
#line 133 "c:\\qt-3.3.8\\include\\qwindowdefs.h"




#line 138 "c:\\qt-3.3.8\\include\\qwindowdefs.h"


















#line 157 "c:\\qt-3.3.8\\include\\qwindowdefs.h"







#line 165 "c:\\qt-3.3.8\\include\\qwindowdefs.h"

class QApplication;



#line 171 "c:\\qt-3.3.8\\include\\qwindowdefs.h"



typedef Q_INT32 QCOORD;				
const QCOORD QCOORD_MAX =  2147483647;
const QCOORD QCOORD_MIN = -QCOORD_MAX - 1;

typedef unsigned int QRgb;			

__declspec(dllimport) const char *qAppName();		



typedef void (*QtCleanUpFunction)();
__declspec(dllimport) void qAddPostRoutine( QtCleanUpFunction );
__declspec(dllimport) void qRemovePostRoutine( QtCleanUpFunction );



typedef QtCleanUpFunction Q_CleanUpFunction;
#line 192 "c:\\qt-3.3.8\\include\\qwindowdefs.h"


#line 195 "c:\\qt-3.3.8\\include\\qwindowdefs.h"
#line 43 "c:\\qt-3.3.8\\include\\qwidget.h"
#line 1 "c:\\qt-3.3.8\\include\\qobject.h"









































#line 1 "c:\\qt-3.3.8\\include\\qobjectdefs.h"














































































































































































#line 43 "c:\\qt-3.3.8\\include\\qobject.h"
#line 1 "c:\\qt-3.3.8\\include\\qwindowdefs.h"


































































































































































































#line 44 "c:\\qt-3.3.8\\include\\qobject.h"
#line 1 "c:\\qt-3.3.8\\include\\qstring.h"

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 45 "c:\\qt-3.3.8\\include\\qobject.h"
#line 1 "c:\\qt-3.3.8\\include\\qevent.h"









































#line 1 "c:\\qt-3.3.8\\include\\qwindowdefs.h"


































































































































































































#line 43 "c:\\qt-3.3.8\\include\\qevent.h"
#line 1 "c:\\qt-3.3.8\\include\\qregion.h"









































#line 1 "c:\\qt-3.3.8\\include\\qshared.h"























































#line 43 "c:\\qt-3.3.8\\include\\qregion.h"
#line 1 "c:\\qt-3.3.8\\include\\qrect.h"









































#line 1 "c:\\qt-3.3.8\\include\\qsize.h"









































#line 1 "c:\\qt-3.3.8\\include\\qpoint.h"









































#line 1 "c:\\qt-3.3.8\\include\\qwindowdefs.h"


































































































































































































#line 43 "c:\\qt-3.3.8\\include\\qpoint.h"
#line 44 "c:\\qt-3.3.8\\include\\qpoint.h"


class __declspec(dllimport) QPoint
{
public:
    QPoint();
    QPoint( int xpos, int ypos );

    bool   isNull()	const;

    int	   x()		const;
    int	   y()		const;
    void   setX( int x );
    void   setY( int y );

    int manhattanLength() const;

    QCOORD &rx();
    QCOORD &ry();

    QPoint &operator+=( const QPoint &p );
    QPoint &operator-=( const QPoint &p );
    QPoint &operator*=( int c );
    QPoint &operator*=( double c );
    QPoint &operator/=( int c );
    QPoint &operator/=( double c );

    friend inline bool	 operator==( const QPoint &, const QPoint & );
    friend inline bool	 operator!=( const QPoint &, const QPoint & );
    friend inline const QPoint operator+( const QPoint &, const QPoint & );
    friend inline const QPoint operator-( const QPoint &, const QPoint & );
    friend inline const QPoint operator*( const QPoint &, int );
    friend inline const QPoint operator*( int, const QPoint & );
    friend inline const QPoint operator*( const QPoint &, double );
    friend inline const QPoint operator*( double, const QPoint & );
    friend inline const QPoint operator-( const QPoint & );
    friend inline const QPoint operator/( const QPoint &, int );
    friend inline const QPoint operator/( const QPoint &, double );

private:
    static void warningDivByZero();




#line 90 "c:\\qt-3.3.8\\include\\qpoint.h"
    QCOORD xp;
    QCOORD yp;
#line 93 "c:\\qt-3.3.8\\include\\qpoint.h"
};






__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QPoint & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QPoint & );
#line 103 "c:\\qt-3.3.8\\include\\qpoint.h"





inline QPoint::QPoint()
{ xp=0; yp=0; }

inline QPoint::QPoint( int xpos, int ypos )
{ xp=(QCOORD)xpos; yp=(QCOORD)ypos; }

inline bool QPoint::isNull() const
{ return xp == 0 && yp == 0; }

inline int QPoint::x() const
{ return xp; }

inline int QPoint::y() const
{ return yp; }

inline void QPoint::setX( int x )
{ xp = (QCOORD)x; }

inline void QPoint::setY( int y )
{ yp = (QCOORD)y; }

inline QCOORD &QPoint::rx()
{ return xp; }

inline QCOORD &QPoint::ry()
{ return yp; }

inline QPoint &QPoint::operator+=( const QPoint &p )
{ xp+=p.xp; yp+=p.yp; return *this; }

inline QPoint &QPoint::operator-=( const QPoint &p )
{ xp-=p.xp; yp-=p.yp; return *this; }

inline QPoint &QPoint::operator*=( int c )
{ xp*=(QCOORD)c; yp*=(QCOORD)c; return *this; }

inline QPoint &QPoint::operator*=( double c )
{ xp=(QCOORD)(xp*c); yp=(QCOORD)(yp*c); return *this; }

inline bool operator==( const QPoint &p1, const QPoint &p2 )
{ return p1.xp == p2.xp && p1.yp == p2.yp; }

inline bool operator!=( const QPoint &p1, const QPoint &p2 )
{ return p1.xp != p2.xp || p1.yp != p2.yp; }

inline const QPoint operator+( const QPoint &p1, const QPoint &p2 )
{ return QPoint(p1.xp+p2.xp, p1.yp+p2.yp); }

inline const QPoint operator-( const QPoint &p1, const QPoint &p2 )
{ return QPoint(p1.xp-p2.xp, p1.yp-p2.yp); }

inline const QPoint operator*( const QPoint &p, int c )
{ return QPoint(p.xp*c, p.yp*c); }

inline const QPoint operator*( int c, const QPoint &p )
{ return QPoint(p.xp*c, p.yp*c); }

inline const QPoint operator*( const QPoint &p, double c )
{ return QPoint((QCOORD)(p.xp*c), (QCOORD)(p.yp*c)); }

inline const QPoint operator*( double c, const QPoint &p )
{ return QPoint((QCOORD)(p.xp*c), (QCOORD)(p.yp*c)); }

inline const QPoint operator-( const QPoint &p )
{ return QPoint(-p.xp, -p.yp); }

inline QPoint &QPoint::operator/=( int c )
{

    if ( c == 0 )
	warningDivByZero();
#line 180 "c:\\qt-3.3.8\\include\\qpoint.h"
    xp/=(QCOORD)c;
    yp/=(QCOORD)c;
    return *this;
}

inline QPoint &QPoint::operator/=( double c )
{

    if ( c == 0.0 )
	warningDivByZero();
#line 191 "c:\\qt-3.3.8\\include\\qpoint.h"
    xp=(QCOORD)(xp/c);
    yp=(QCOORD)(yp/c);
    return *this;
}

inline const QPoint operator/( const QPoint &p, int c )
{

    if ( c == 0 )
	QPoint::warningDivByZero();
#line 202 "c:\\qt-3.3.8\\include\\qpoint.h"
    return QPoint(p.xp/c, p.yp/c);
}

inline const QPoint operator/( const QPoint &p, double c )
{

    if ( c == 0.0 )
	QPoint::warningDivByZero();
#line 211 "c:\\qt-3.3.8\\include\\qpoint.h"
    return QPoint((QCOORD)(p.xp/c), (QCOORD)(p.yp/c));
}


#line 1 "c:\\qt-3.3.8\\include\\qwinexport.h"










































#line 44 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 49 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 54 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 59 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 65 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 70 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 75 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 81 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 87 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 94 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 101 "c:\\qt-3.3.8\\include\\qwinexport.h"



extern template class __declspec(dllimport) QMemArray<QPoint>;
#line 106 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 112 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 118 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 124 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 130 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 136 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 141 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 146 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 151 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 156 "c:\\qt-3.3.8\\include\\qwinexport.h"







#line 164 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 170 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 176 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 182 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 187 "c:\\qt-3.3.8\\include\\qwinexport.h"








#line 196 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 202 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 207 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 211 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 218 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 222 "c:\\qt-3.3.8\\include\\qwinexport.h"
#line 216 "c:\\qt-3.3.8\\include\\qpoint.h"
#line 217 "c:\\qt-3.3.8\\include\\qpoint.h"
#line 43 "c:\\qt-3.3.8\\include\\qsize.h"
#line 44 "c:\\qt-3.3.8\\include\\qsize.h"

class __declspec(dllimport) QSize

{
public:
    
    enum ScaleMode {
	ScaleFree,
	ScaleMin,
	ScaleMax
    };

    QSize();
    QSize( int w, int h );

    bool isNull() const;
    bool isEmpty() const;
    bool isValid() const;

    int width() const;
    int height() const;
    void setWidth( int w );
    void setHeight( int h );
    void transpose();

    void scale( int w, int h, ScaleMode mode );
    void scale( const QSize &s, ScaleMode mode );

    QSize expandedTo( const QSize & ) const;
    QSize boundedTo( const QSize & ) const;

    QCOORD &rwidth();
    QCOORD &rheight();

    QSize &operator+=( const QSize & );
    QSize &operator-=( const QSize & );
    QSize &operator*=( int c );
    QSize &operator*=( double c );
    QSize &operator/=( int c );
    QSize &operator/=( double c );

    friend inline bool operator==( const QSize &, const QSize & );
    friend inline bool operator!=( const QSize &, const QSize & );
    friend inline const QSize operator+( const QSize &, const QSize & );
    friend inline const QSize operator-( const QSize &, const QSize & );
    friend inline const QSize operator*( const QSize &, int );
    friend inline const QSize operator*( int, const QSize & );
    friend inline const QSize operator*( const QSize &, double );
    friend inline const QSize operator*( double, const QSize & );
    friend inline const QSize operator/( const QSize &, int );
    friend inline const QSize operator/( const QSize &, double );

private:
    static void warningDivByZero();

    QCOORD wd;
    QCOORD ht;
};






__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QSize & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QSize & );






inline QSize::QSize()
{ wd = ht = -1; }

inline QSize::QSize( int w, int h )
{ wd=(QCOORD)w; ht=(QCOORD)h; }

inline bool QSize::isNull() const
{ return wd==0 && ht==0; }

inline bool QSize::isEmpty() const
{ return wd<1 || ht<1; }

inline bool QSize::isValid() const
{ return wd>=0 && ht>=0; }

inline int QSize::width() const
{ return wd; }

inline int QSize::height() const
{ return ht; }

inline void QSize::setWidth( int w )
{ wd=(QCOORD)w; }

inline void QSize::setHeight( int h )
{ ht=(QCOORD)h; }

inline QCOORD &QSize::rwidth()
{ return wd; }

inline QCOORD &QSize::rheight()
{ return ht; }

inline QSize &QSize::operator+=( const QSize &s )
{ wd+=s.wd; ht+=s.ht; return *this; }

inline QSize &QSize::operator-=( const QSize &s )
{ wd-=s.wd; ht-=s.ht; return *this; }

inline QSize &QSize::operator*=( int c )
{ wd*=(QCOORD)c; ht*=(QCOORD)c; return *this; }

inline QSize &QSize::operator*=( double c )
{ wd=(QCOORD)(wd*c); ht=(QCOORD)(ht*c); return *this; }

inline bool operator==( const QSize &s1, const QSize &s2 )
{ return s1.wd == s2.wd && s1.ht == s2.ht; }

inline bool operator!=( const QSize &s1, const QSize &s2 )
{ return s1.wd != s2.wd || s1.ht != s2.ht; }

inline const QSize operator+( const QSize & s1, const QSize & s2 )
{ return QSize(s1.wd+s2.wd, s1.ht+s2.ht); }

inline const QSize operator-( const QSize &s1, const QSize &s2 )
{ return QSize(s1.wd-s2.wd, s1.ht-s2.ht); }

inline const QSize operator*( const QSize &s, int c )
{ return QSize(s.wd*c, s.ht*c); }

inline const QSize operator*( int c, const QSize &s )
{  return QSize(s.wd*c, s.ht*c); }

inline const QSize operator*( const QSize &s, double c )
{ return QSize((QCOORD)(s.wd*c), (QCOORD)(s.ht*c)); }

inline const QSize operator*( double c, const QSize &s )
{ return QSize((QCOORD)(s.wd*c), (QCOORD)(s.ht*c)); }

inline QSize &QSize::operator/=( int c )
{

    if ( c == 0 )
	warningDivByZero();
#line 191 "c:\\qt-3.3.8\\include\\qsize.h"
    wd/=(QCOORD)c; ht/=(QCOORD)c;
    return *this;
}

inline QSize &QSize::operator/=( double c )
{

    if ( c == 0.0 )
	warningDivByZero();
#line 201 "c:\\qt-3.3.8\\include\\qsize.h"
    wd=(QCOORD)(wd/c); ht=(QCOORD)(ht/c);
    return *this;
}

inline const QSize operator/( const QSize &s, int c )
{

    if ( c == 0 )
	QSize::warningDivByZero();
#line 211 "c:\\qt-3.3.8\\include\\qsize.h"
    return QSize(s.wd/c, s.ht/c);
}

inline const QSize operator/( const QSize &s, double c )
{

    if ( c == 0.0 )
	QSize::warningDivByZero();
#line 220 "c:\\qt-3.3.8\\include\\qsize.h"
    return QSize((QCOORD)(s.wd/c), (QCOORD)(s.ht/c));
}

inline QSize QSize::expandedTo( const QSize & otherSize ) const
{
    return QSize( ((otherSize.wd) < (wd) ? (wd) : (otherSize.wd)), ((otherSize.ht) < (ht) ? (ht) : (otherSize.ht)) );
}

inline QSize QSize::boundedTo( const QSize & otherSize ) const
{
    return QSize( ((wd) < (otherSize.wd) ? (wd) : (otherSize.wd)), ((ht) < (otherSize.ht) ? (ht) : (otherSize.ht)) );
}


#line 235 "c:\\qt-3.3.8\\include\\qsize.h"
#line 43 "c:\\qt-3.3.8\\include\\qrect.h"
#line 44 "c:\\qt-3.3.8\\include\\qrect.h"




#line 49 "c:\\qt-3.3.8\\include\\qrect.h"

class __declspec(dllimport) QRect					
{
public:
    QRect()	{ x1 = y1 = 0; x2 = y2 = -1; }
    QRect( const QPoint &topleft, const QPoint &bottomright );
    QRect( const QPoint &topleft, const QSize &size );
    QRect( int left, int top, int width, int height );

    bool   isNull()	const;
    bool   isEmpty()	const;
    bool   isValid()	const;
    QRect  normalize()	const;

    int	   left()	const;
    int	   top()	const;
    int	   right()	const;
    int	   bottom()	const;

    QCOORD &rLeft();
    QCOORD &rTop();
    QCOORD &rRight();
    QCOORD &rBottom();

    int	   x()		const;
    int	   y()		const;
    void   setLeft( int pos );
    void   setTop( int pos );
    void   setRight( int pos );
    void   setBottom( int pos );
    void   setX( int x );
    void   setY( int y );

    void   setTopLeft( const QPoint &p );
    void   setBottomRight( const QPoint &p );
    void   setTopRight( const QPoint &p );
    void   setBottomLeft( const QPoint &p );

    QPoint topLeft()	 const;
    QPoint bottomRight() const;
    QPoint topRight()	 const;
    QPoint bottomLeft()	 const;
    QPoint center()	 const;

    void   rect( int *x, int *y, int *w, int *h ) const;
    void   coords( int *x1, int *y1, int *x2, int *y2 ) const;

    void   moveLeft( int pos );
    void   moveTop( int pos );
    void   moveRight( int pos );
    void   moveBottom( int pos );
    void   moveTopLeft( const QPoint &p );
    void   moveBottomRight( const QPoint &p );
    void   moveTopRight( const QPoint &p );
    void   moveBottomLeft( const QPoint &p );
    void   moveCenter( const QPoint &p );
    void   moveBy( int dx, int dy );

    void   setRect( int x, int y, int w, int h );
    void   setCoords( int x1, int y1, int x2, int y2 );
    void   addCoords( int x1, int y1, int x2, int y2 );

    QSize  size()	const;
    int	   width()	const;
    int	   height()	const;
    void   setWidth( int w );
    void   setHeight( int h );
    void   setSize( const QSize &s );

    QRect  operator|(const QRect &r) const;
    QRect  operator&(const QRect &r) const;
    QRect&  operator|=(const QRect &r);
    QRect&  operator&=(const QRect &r);

    bool   contains( const QPoint &p, bool proper=FALSE ) const;
    bool   contains( int x, int y ) const; 
    bool   contains( int x, int y, bool proper ) const;
    bool   contains( const QRect &r, bool proper=FALSE ) const;
    QRect  unite( const QRect &r ) const;
    QRect  intersect( const QRect &r ) const;
    bool   intersects( const QRect &r ) const;

    friend __declspec(dllimport) bool operator==( const QRect &, const QRect & );
    friend __declspec(dllimport) bool operator!=( const QRect &, const QRect & );

private:


#line 138 "c:\\qt-3.3.8\\include\\qrect.h"





#line 144 "c:\\qt-3.3.8\\include\\qrect.h"
    QCOORD x1;
    QCOORD y1;
    QCOORD x2;
    QCOORD y2;
#line 149 "c:\\qt-3.3.8\\include\\qrect.h"
};

__declspec(dllimport) bool operator==( const QRect &, const QRect & );
__declspec(dllimport) bool operator!=( const QRect &, const QRect & );






__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QRect & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QRect & );
#line 162 "c:\\qt-3.3.8\\include\\qrect.h"





inline QRect::QRect( int left, int top, int width, int height )
{
    x1 = (QCOORD)left;
    y1 = (QCOORD)top;
    x2 = (QCOORD)(left+width-1);
    y2 = (QCOORD)(top+height-1);
}

inline bool QRect::isNull() const
{ return x2 == x1-1 && y2 == y1-1; }

inline bool QRect::isEmpty() const
{ return x1 > x2 || y1 > y2; }

inline bool QRect::isValid() const
{ return x1 <= x2 && y1 <= y2; }

inline int QRect::left() const
{ return x1; }

inline int QRect::top() const
{ return y1; }

inline int QRect::right() const
{ return x2; }

inline int QRect::bottom() const
{ return y2; }

inline QCOORD &QRect::rLeft()
{ return x1; }

inline QCOORD & QRect::rTop()
{ return y1; }

inline QCOORD & QRect::rRight()
{ return x2; }

inline QCOORD & QRect::rBottom()
{ return y2; }

inline int QRect::x() const
{ return x1; }

inline int QRect::y() const
{ return y1; }

inline void QRect::setLeft( int pos )
{ x1 = (QCOORD)pos; }

inline void QRect::setTop( int pos )
{ y1 = (QCOORD)pos; }

inline void QRect::setRight( int pos )
{ x2 = (QCOORD)pos; }

inline void QRect::setBottom( int pos )
{ y2 = (QCOORD)pos; }

inline void QRect::setX( int x )
{ x1 = (QCOORD)x; }

inline void QRect::setY( int y )
{ y1 = (QCOORD)y; }

inline QPoint QRect::topLeft() const
{ return QPoint(x1, y1); }

inline QPoint QRect::bottomRight() const
{ return QPoint(x2, y2); }

inline QPoint QRect::topRight() const
{ return QPoint(x2, y1); }

inline QPoint QRect::bottomLeft() const
{ return QPoint(x1, y2); }

inline QPoint QRect::center() const
{ return QPoint((x1+x2)/2, (y1+y2)/2); }

inline int QRect::width() const
{ return  x2 - x1 + 1; }

inline int QRect::height() const
{ return  y2 - y1 + 1; }

inline QSize QRect::size() const
{ return QSize(x2-x1+1, y2-y1+1); }

inline bool QRect::contains( int x, int y, bool proper ) const
{
    if ( proper )
        return x > x1 && x < x2 &&
               y > y1 && y < y2;
    else
        return x >= x1 && x <= x2 &&
               y >= y1 && y <= y2;
}

inline bool QRect::contains( int x, int y ) const
{
    return x >= x1 && x <= x2 &&
	   y >= y1 && y <= y2;
}

#line 1 "c:\\qt-3.3.8\\include\\qwinexport.h"










































#line 44 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 49 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 54 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 59 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 65 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 70 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 75 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 81 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 87 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 94 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 101 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 106 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 112 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 118 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 124 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 130 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 136 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 141 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 146 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 151 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 156 "c:\\qt-3.3.8\\include\\qwinexport.h"







#line 164 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 170 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 176 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 182 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 187 "c:\\qt-3.3.8\\include\\qwinexport.h"








#line 196 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 202 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 207 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 211 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 218 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 222 "c:\\qt-3.3.8\\include\\qwinexport.h"
#line 273 "c:\\qt-3.3.8\\include\\qrect.h"
#line 274 "c:\\qt-3.3.8\\include\\qrect.h"
#line 44 "c:\\qt-3.3.8\\include\\qregion.h"
#line 45 "c:\\qt-3.3.8\\include\\qregion.h"





class __declspec(dllimport) QRegion
{
public:
    enum RegionType { Rectangle, Ellipse };

    QRegion();
    QRegion( int x, int y, int w, int h, RegionType = Rectangle );
    QRegion( const QRect &, RegionType = Rectangle );
    QRegion( const QPointArray &, bool winding=FALSE );
    QRegion( const QRegion & );
    QRegion( const QBitmap & );
   ~QRegion();
    QRegion &operator=( const QRegion & );

    bool    isNull()   const;
    bool    isEmpty()  const;

    bool    contains( const QPoint &p ) const;
    bool    contains( const QRect &r )	const;

    void    translate( int dx, int dy );

    QRegion unite( const QRegion & )	const;
    QRegion intersect( const QRegion &) const;
    QRegion subtract( const QRegion & ) const;
    QRegion eor( const QRegion & )	const;

    QRect   boundingRect() const;
    QMemArray<QRect> rects() const;
    void setRects( const QRect *, int );

    const QRegion operator|( const QRegion & ) const;
    const QRegion operator+( const QRegion & ) const;
    const QRegion operator&( const QRegion & ) const;
    const QRegion operator-( const QRegion & ) const;
    const QRegion operator^( const QRegion & ) const;
    QRegion& operator|=( const QRegion & );
    QRegion& operator+=( const QRegion & );
    QRegion& operator&=( const QRegion & );
    QRegion& operator-=( const QRegion & );
    QRegion& operator^=( const QRegion & );

    bool    operator==( const QRegion & )  const;
    bool    operator!=( const QRegion &r ) const
			{ return !(operator==(r)); }


    HRGN    handle() const { return data->rgn; }







#line 106 "c:\\qt-3.3.8\\include\\qregion.h"


    friend __declspec(dllimport) QDataStream &operator<<( QDataStream &, const QRegion & );
    friend __declspec(dllimport) QDataStream &operator>>( QDataStream &, QRegion & );
#line 111 "c:\\qt-3.3.8\\include\\qregion.h"
private:
    QRegion( bool );
    QRegion copy() const;
    void    detach();

    QRegion winCombine( const QRegion &, int ) const;
#line 118 "c:\\qt-3.3.8\\include\\qregion.h"




#line 123 "c:\\qt-3.3.8\\include\\qregion.h"
    void    exec( const QByteArray &, int ver = 0 );
    struct QRegionData : public QShared {

	HRGN   rgn;










#line 138 "c:\\qt-3.3.8\\include\\qregion.h"
	bool   is_null;
    } *data;





#line 146 "c:\\qt-3.3.8\\include\\qregion.h"
    friend class QETWidget;
#line 148 "c:\\qt-3.3.8\\include\\qregion.h"

};



















__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QRegion & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QRegion & );
#line 172 "c:\\qt-3.3.8\\include\\qregion.h"


#line 175 "c:\\qt-3.3.8\\include\\qregion.h"
#line 44 "c:\\qt-3.3.8\\include\\qevent.h"
#line 1 "c:\\qt-3.3.8\\include\\qnamespace.h"





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 45 "c:\\qt-3.3.8\\include\\qevent.h"
#line 1 "c:\\qt-3.3.8\\include\\qmime.h"









































#line 1 "c:\\qt-3.3.8\\include\\qwindowdefs.h"


































































































































































































#line 43 "c:\\qt-3.3.8\\include\\qmime.h"
#line 1 "c:\\qt-3.3.8\\include\\qmap.h"









































#line 1 "c:\\qt-3.3.8\\include\\qglobal.h"





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1111 "c:\\qt-3.3.8\\include\\qglobal.h"


#pragma warning(disable: 4244) 
#pragma warning(disable: 4275) 
#pragma warning(disable: 4514) 
#pragma warning(disable: 4800) 
#pragma warning(disable: 4097) 
#pragma warning(disable: 4706) 
#pragma warning(disable: 4786) 
#pragma warning(disable: 4660) 
#pragma warning(disable: 4355) 
#pragma warning(disable: 4231) 
#pragma warning(disable: 4710) 








#line 1133 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 1134 "c:\\qt-3.3.8\\include\\qglobal.h"


#line 43 "c:\\qt-3.3.8\\include\\qmap.h"
#line 1 "c:\\qt-3.3.8\\include\\qshared.h"























































#line 44 "c:\\qt-3.3.8\\include\\qmap.h"
#line 1 "c:\\qt-3.3.8\\include\\qdatastream.h"









































#line 1 "c:\\qt-3.3.8\\include\\qiodevice.h"









































#line 1 "c:\\qt-3.3.8\\include\\qglobal.h"





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1111 "c:\\qt-3.3.8\\include\\qglobal.h"


#pragma warning(disable: 4244) 
#pragma warning(disable: 4275) 
#pragma warning(disable: 4514) 
#pragma warning(disable: 4800) 
#pragma warning(disable: 4097) 
#pragma warning(disable: 4706) 
#pragma warning(disable: 4786) 
#pragma warning(disable: 4660) 
#pragma warning(disable: 4355) 
#pragma warning(disable: 4231) 
#pragma warning(disable: 4710) 








#line 1133 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 1134 "c:\\qt-3.3.8\\include\\qglobal.h"


#line 43 "c:\\qt-3.3.8\\include\\qiodevice.h"
#line 1 "c:\\qt-3.3.8\\include\\qcstring.h"





































































































































































































































































































































































































#line 44 "c:\\qt-3.3.8\\include\\qiodevice.h"
#line 45 "c:\\qt-3.3.8\\include\\qiodevice.h"











































class __declspec(dllimport) QIODevice
{
public:


#line 94 "c:\\qt-3.3.8\\include\\qiodevice.h"
    typedef Q_ULONG Offset;
#line 96 "c:\\qt-3.3.8\\include\\qiodevice.h"

    QIODevice();
    virtual ~QIODevice();

    int		 flags()  const { return ioMode; }
    int		 mode()	  const { return ioMode & 0x00ff; }
    int		 state()  const { return ioMode & 0xf000; }

    bool	 isDirectAccess()     const { return ((ioMode & 0x0100)     == 0x0100); }
    bool	 isSequentialAccess() const { return ((ioMode & 0x0200) == 0x0200); }
    bool	 isCombinedAccess()   const { return ((ioMode & 0x0300)   == 0x0300); }
    bool	 isBuffered()	      const { return ((ioMode & 0x0040)        != 0x0040); }
    bool	 isRaw()	      const { return ((ioMode & 0x0040)        == 0x0040); }
    bool	 isSynchronous()      const { return ((ioMode & 0x0080)      != 0x0080); }
    bool	 isAsynchronous()     const { return ((ioMode & 0x0080)      == 0x0080); }
    bool	 isTranslated()	      const { return ((ioMode & 0x0010)  == 0x0010); }
    bool	 isReadable()	      const { return ((ioMode & 0x0001)   == 0x0001); }
    bool	 isWritable()	      const { return ((ioMode & 0x0002)  == 0x0002); }
    bool	 isReadWrite()	      const { return ((ioMode & 0x0003)  == 0x0003); }
    bool	 isInactive()	      const { return state() == 0; }
    bool	 isOpen()	      const { return state() == 0x1000; }

    int		 status() const { return ioSt; }
    void	 resetStatus()	{ ioSt = 0; }

    virtual bool open( int mode ) = 0;
    virtual void close() = 0;
    virtual void flush() = 0;

    virtual Offset size()  const = 0;
    virtual Offset at()  const;
    virtual bool at( Offset );
    virtual bool atEnd()  const;
    bool	 reset() { return at(0); }

    virtual Q_LONG readBlock( char *data, Q_ULONG maxlen ) = 0;
    virtual Q_LONG writeBlock( const char *data, Q_ULONG len ) = 0;
    virtual Q_LONG readLine( char *data, Q_ULONG maxlen );
    Q_LONG writeBlock( const QByteArray& data );
    virtual QByteArray readAll();

    virtual int	 getch() = 0;
    virtual int	 putch( int ) = 0;
    virtual int	 ungetch( int ) = 0;

protected:
    void	 setFlags( int f ) { ioMode = f; }
    void	 setType( int );
    void	 setMode( int );
    void	 setState( int );
    void	 setStatus( int );
    Offset	 ioIndex;

private:
    int		 ioMode;
    int		 ioSt;

private:	



#line 158 "c:\\qt-3.3.8\\include\\qiodevice.h"
};


#line 162 "c:\\qt-3.3.8\\include\\qiodevice.h"
#line 43 "c:\\qt-3.3.8\\include\\qdatastream.h"
#line 1 "c:\\qt-3.3.8\\include\\qstring.h"

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 44 "c:\\qt-3.3.8\\include\\qdatastream.h"
#line 45 "c:\\qt-3.3.8\\include\\qdatastream.h"


class __declspec(dllimport) QDataStream				
{
public:
    QDataStream();
    QDataStream( QIODevice * );
    QDataStream( QByteArray, int mode );
    virtual ~QDataStream();

    QIODevice	*device() const;
    void	 setDevice( QIODevice * );
    void	 unsetDevice();

    bool	 atEnd() const;
    bool	 eof() const;

    enum ByteOrder { BigEndian, LittleEndian };
    int		 byteOrder()	const;
    void	 setByteOrder( int );

    bool	 isPrintableData() const;
    void	 setPrintableData( bool );

    int		 version() const;
    void	 setVersion( int );

    QDataStream &operator>>( Q_INT8 &i );
    QDataStream &operator>>( Q_UINT8 &i );
    QDataStream &operator>>( Q_INT16 &i );
    QDataStream &operator>>( Q_UINT16 &i );
    QDataStream &operator>>( Q_INT32 &i );
    QDataStream &operator>>( Q_UINT32 &i );
    QDataStream &operator>>( Q_INT64 &i );
    QDataStream &operator>>( Q_UINT64 &i );

    QDataStream &operator>>( Q_LONG &i );
    QDataStream &operator>>( Q_ULONG &i );
#line 84 "c:\\qt-3.3.8\\include\\qdatastream.h"

    QDataStream &operator>>( float &f );
    QDataStream &operator>>( double &f );
    QDataStream &operator>>( char *&str );

    QDataStream &operator<<( Q_INT8 i );
    QDataStream &operator<<( Q_UINT8 i );
    QDataStream &operator<<( Q_INT16 i );
    QDataStream &operator<<( Q_UINT16 i );
    QDataStream &operator<<( Q_INT32 i );
    QDataStream &operator<<( Q_UINT32 i );
    QDataStream &operator<<( Q_INT64 i );
    QDataStream &operator<<( Q_UINT64 i );

    QDataStream &operator<<( Q_LONG i );
    QDataStream &operator<<( Q_ULONG i );
#line 101 "c:\\qt-3.3.8\\include\\qdatastream.h"
    QDataStream &operator<<( float f );
    QDataStream &operator<<( double f );
    QDataStream &operator<<( const char *str );

    QDataStream &readBytes( char *&, uint &len );
    QDataStream &readRawBytes( char *, uint len );

    QDataStream &writeBytes( const char *, uint len );
    QDataStream &writeRawBytes( const char *, uint len );

private:
    QIODevice	*dev;
    bool	 owndev;
    int		 byteorder;
    bool	 printable;
    bool	 noswap;
    int		 ver;

private:	



#line 124 "c:\\qt-3.3.8\\include\\qdatastream.h"
};






inline QIODevice *QDataStream::device() const
{ return dev; }

inline bool QDataStream::atEnd() const
{ return dev ? dev->atEnd() : TRUE; }

inline bool QDataStream::eof() const
{ return atEnd(); }

inline int QDataStream::byteOrder() const
{ return byteorder; }

inline bool QDataStream::isPrintableData() const
{ return printable; }

inline void QDataStream::setPrintableData( bool p )
{ printable = p; }

inline int QDataStream::version() const
{ return ver; }

inline void QDataStream::setVersion( int v )
{ ver = v; }

inline QDataStream &QDataStream::operator>>( Q_UINT8 &i )
{ return *this >> (Q_INT8&)i; }

inline QDataStream &QDataStream::operator>>( Q_UINT16 &i )
{ return *this >> (Q_INT16&)i; }

inline QDataStream &QDataStream::operator>>( Q_UINT32 &i )
{ return *this >> (Q_INT32&)i; }

inline QDataStream &QDataStream::operator>>( Q_UINT64 &i )
{ return *this >> (Q_INT64&)i; }


inline QDataStream &QDataStream::operator>>( Q_ULONG &i )
{ return *this >> (Q_LONG&)i; }
#line 171 "c:\\qt-3.3.8\\include\\qdatastream.h"

inline QDataStream &QDataStream::operator<<( Q_UINT8 i )
{ return *this << (Q_INT8)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT16 i )
{ return *this << (Q_INT16)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT32 i )
{ return *this << (Q_INT32)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT64 i )
{ return *this << (Q_INT64)i; }


inline QDataStream &QDataStream::operator<<( Q_ULONG i )
{ return *this << (Q_LONG)i; }
#line 188 "c:\\qt-3.3.8\\include\\qdatastream.h"

#line 190 "c:\\qt-3.3.8\\include\\qdatastream.h"
#line 191 "c:\\qt-3.3.8\\include\\qdatastream.h"
#line 45 "c:\\qt-3.3.8\\include\\qmap.h"
#line 1 "c:\\qt-3.3.8\\include\\qpair.h"







































#line 1 "c:\\qt-3.3.8\\include\\qglobal.h"





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1111 "c:\\qt-3.3.8\\include\\qglobal.h"


#pragma warning(disable: 4244) 
#pragma warning(disable: 4275) 
#pragma warning(disable: 4514) 
#pragma warning(disable: 4800) 
#pragma warning(disable: 4097) 
#pragma warning(disable: 4706) 
#pragma warning(disable: 4786) 
#pragma warning(disable: 4660) 
#pragma warning(disable: 4355) 
#pragma warning(disable: 4231) 
#pragma warning(disable: 4710) 








#line 1133 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 1134 "c:\\qt-3.3.8\\include\\qglobal.h"


#line 41 "c:\\qt-3.3.8\\include\\qpair.h"
#line 1 "c:\\qt-3.3.8\\include\\qdatastream.h"






























































































































































































#line 42 "c:\\qt-3.3.8\\include\\qpair.h"
#line 43 "c:\\qt-3.3.8\\include\\qpair.h"

template <class T1, class T2>
struct QPair
{
    typedef T1 first_type;
    typedef T2 second_type;

    QPair()
	: first( T1() ), second( T2() )
    {}
    QPair( const T1& t1, const T2& t2 )
	: first( t1 ), second( t2 )
    {}

    QPair<T1, T2>& operator=(const QPair<T1, T2>& other)
    {
	if (this != &other) {
	    first = other.first;
	    second = other.second;
	}
	return *this;
    }

    T1 first;
    T2 second;
};

template <class T1, class T2>
inline bool operator==( const QPair<T1, T2>& x, const QPair<T1, T2>& y )
{
    return x.first == y.first && x.second == y.second;
}

template <class T1, class T2>
inline bool operator<( const QPair<T1, T2>& x, const QPair<T1, T2>& y )
{
    return x.first < y.first ||
	   ( !( y.first < x.first ) && x.second < y.second );
}

template <class T1, class T2>
inline QPair<T1, T2> qMakePair( const T1& x, const T2& y )
{
    return QPair<T1, T2>( x, y );
}


template <class T1, class T2>
inline QDataStream& operator>>( QDataStream& s, QPair<T1, T2>& p )
{
    s >> p.first >> p.second;
    return s;
}

template <class T1, class T2>
inline QDataStream& operator<<( QDataStream& s, const QPair<T1, T2>& p )
{
    s << p.first << p.second;
    return s;
}
#line 104 "c:\\qt-3.3.8\\include\\qpair.h"

#line 106 "c:\\qt-3.3.8\\include\\qpair.h"
#line 46 "c:\\qt-3.3.8\\include\\qmap.h"
#line 1 "c:\\qt-3.3.8\\include\\qvaluelist.h"









































#line 1 "c:\\qt-3.3.8\\include\\qtl.h"









































#line 1 "c:\\qt-3.3.8\\include\\qglobal.h"





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1111 "c:\\qt-3.3.8\\include\\qglobal.h"


#pragma warning(disable: 4244) 
#pragma warning(disable: 4275) 
#pragma warning(disable: 4514) 
#pragma warning(disable: 4800) 
#pragma warning(disable: 4097) 
#pragma warning(disable: 4706) 
#pragma warning(disable: 4786) 
#pragma warning(disable: 4660) 
#pragma warning(disable: 4355) 
#pragma warning(disable: 4231) 
#pragma warning(disable: 4710) 








#line 1133 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 1134 "c:\\qt-3.3.8\\include\\qglobal.h"


#line 43 "c:\\qt-3.3.8\\include\\qtl.h"
#line 1 "c:\\qt-3.3.8\\include\\qtextstream.h"









































#line 1 "c:\\qt-3.3.8\\include\\qiodevice.h"

































































































































































#line 43 "c:\\qt-3.3.8\\include\\qtextstream.h"
#line 1 "c:\\qt-3.3.8\\include\\qstring.h"

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 44 "c:\\qt-3.3.8\\include\\qtextstream.h"

#line 46 "c:\\qt-3.3.8\\include\\qtextstream.h"


class QTextCodec;
class QTextDecoder;

class QTextStreamPrivate;

class __declspec(dllimport) QTextStream				
{
public:
    enum Encoding { Locale, Latin1, Unicode, UnicodeNetworkOrder,
		    UnicodeReverse, RawUnicode, UnicodeUTF8 };

    void	setEncoding( Encoding );

    void	setCodec( QTextCodec* );
    QTextCodec *codec();
#line 64 "c:\\qt-3.3.8\\include\\qtextstream.h"

    QTextStream();
    QTextStream( QIODevice * );
    QTextStream( QString*, int mode );
    QTextStream( QString&, int mode );		
    QTextStream( QByteArray, int mode );
    QTextStream( FILE *, int mode );
    virtual ~QTextStream();

    QIODevice	*device() const;
    void	 setDevice( QIODevice * );
    void	 unsetDevice();

    bool	 atEnd() const;
    bool	 eof() const;

    QTextStream &operator>>( QChar & );
    QTextStream &operator>>( char & );
    QTextStream &operator>>( signed short & );
    QTextStream &operator>>( unsigned short & );
    QTextStream &operator>>( signed int & );
    QTextStream &operator>>( unsigned int & );
    QTextStream &operator>>( signed long & );
    QTextStream &operator>>( unsigned long & );
    QTextStream &operator>>( float & );
    QTextStream &operator>>( double & );
    QTextStream &operator>>( char * );
    QTextStream &operator>>( QString & );
    QTextStream &operator>>( QCString & );

    QTextStream &operator<<( QChar );
    QTextStream &operator<<( char );
    QTextStream &operator<<( signed short );
    QTextStream &operator<<( unsigned short );
    QTextStream &operator<<( signed int );
    QTextStream &operator<<( unsigned int );
    QTextStream &operator<<( signed long );
    QTextStream &operator<<( unsigned long );
    QTextStream &operator<<( float );
    QTextStream &operator<<( double );
    QTextStream &operator<<( const char* );
    QTextStream &operator<<( const QString & );
    QTextStream &operator<<( const QCString & );
    QTextStream &operator<<( void * );		

    QTextStream &readRawBytes( char *, uint len );
    QTextStream &writeRawBytes( const char* , uint len );

    QString	readLine();
    QString	read();
    void	skipWhiteSpace();

    enum {
	skipws	  = 0x0001,			
	left	  = 0x0002,			
	right	  = 0x0004,			
	internal  = 0x0008,			
	bin	  = 0x0010,			
	oct	  = 0x0020,			
	dec	  = 0x0040,			
	hex	  = 0x0080,			
	showbase  = 0x0100,			
	showpoint = 0x0200,			
	uppercase = 0x0400,			
	showpos	  = 0x0800,			
	scientific= 0x1000,			
	fixed	  = 0x2000			
    };

    static const int basefield;			
    static const int adjustfield;		
    static const int floatfield;		

    int	  flags() const;
    int	  flags( int f );
    int	  setf( int bits );
    int	  setf( int bits, int mask );
    int	  unsetf( int bits );

    void  reset();

    int	  width()	const;
    int	  width( int );
    int	  fill()	const;
    int	  fill( int );
    int	  precision()	const;
    int	  precision( int );

private:
    long	input_int();
    void	init();
    QTextStream &output_int( int, ulong, bool );
    QIODevice	*dev;

    int		fflags;
    int		fwidth;
    int		fillchar;
    int		fprec;
    bool	doUnicodeHeader;
    bool	owndev;
    QTextCodec 	*mapper;
    QTextStreamPrivate * d;
    QChar	unused1; 
    bool	latin1;
    bool 	internalOrder;
    bool	networkOrder;
    void	*unused2; 

    QChar	eat_ws();
    uint 	ts_getline( QChar* );
    void	ts_ungetc( QChar );
    QChar	ts_getc();
    uint	ts_getbuf( QChar*, uint );
    void	ts_putc(int);
    void	ts_putc(QChar);
    bool	ts_isspace(QChar);
    bool	ts_isdigit(QChar);
    ulong	input_bin();
    ulong	input_oct();
    ulong	input_dec();
    ulong	input_hex();
    double	input_double();
    QTextStream &writeBlock( const char* p, uint len );
    QTextStream &writeBlock( const QChar* p, uint len );

private:	



#line 194 "c:\\qt-3.3.8\\include\\qtextstream.h"
};

typedef QTextStream QTS;

class __declspec(dllimport) QTextIStream : public QTextStream {
public:
    QTextIStream( const QString* s ) :
	QTextStream((QString*)s,0x0001) { }
    QTextIStream( QByteArray ba ) :
	QTextStream(ba,0x0001) { }
    QTextIStream( FILE *f ) :
	QTextStream(f,0x0001) { }

private:	



#line 212 "c:\\qt-3.3.8\\include\\qtextstream.h"
};

class __declspec(dllimport) QTextOStream : public QTextStream {
public:
    QTextOStream( QString* s ) :
	QTextStream(s,0x0002) { }
    QTextOStream( QByteArray ba ) :
	QTextStream(ba,0x0002) { }
    QTextOStream( FILE *f ) :
	QTextStream(f,0x0002) { }

private:	



#line 228 "c:\\qt-3.3.8\\include\\qtextstream.h"
};





inline QIODevice *QTextStream::device() const
{ return dev; }

inline bool QTextStream::atEnd() const
{ return dev ? dev->atEnd() : FALSE; }

inline bool QTextStream::eof() const
{ return atEnd(); }

inline int QTextStream::flags() const
{ return fflags; }

inline int QTextStream::flags( int f )
{ int oldf = fflags;  fflags = f;  return oldf; }

inline int QTextStream::setf( int bits )
{ int oldf = fflags;  fflags |= bits;  return oldf; }

inline int QTextStream::setf( int bits, int mask )
{ int oldf = fflags;  fflags = (fflags & ~mask) | (bits & mask); return oldf; }

inline int QTextStream::unsetf( int bits )
{ int oldf = fflags;  fflags &= ~bits;	return oldf; }

inline int QTextStream::width() const
{ return fwidth; }

inline int QTextStream::width( int w )
{ int oldw = fwidth;  fwidth = w;  return oldw;	 }

inline int QTextStream::fill() const
{ return fillchar; }

inline int QTextStream::fill( int f )
{ int oldc = fillchar;	fillchar = f;  return oldc;  }

inline int QTextStream::precision() const
{ return fprec; }

inline int QTextStream::precision( int p )
{ int oldp = fprec;  fprec = p;	 return oldp;  }




inline QChar QTextStream::ts_getc()
{ QChar r; return ( ts_getbuf( &r,1 ) == 1 ? r : QChar((ushort)0xffff) ); }





typedef QTextStream & (*QTSFUNC)(QTextStream &);
typedef int (QTextStream::*QTSMFI)(int);	

class __declspec(dllimport) QTSManip {			
public:
    QTSManip( QTSMFI m, int a ) { mf=m; arg=a; }
    void exec( QTextStream &s ) { (s.*mf)(arg); }
private:
    QTSMFI mf;					
    int	   arg;					
};

__declspec(dllimport) inline QTextStream &operator>>( QTextStream &s, QTSFUNC f )
{ return (*f)( s ); }

__declspec(dllimport) inline QTextStream &operator<<( QTextStream &s, QTSFUNC f )
{ return (*f)( s ); }

__declspec(dllimport) inline QTextStream &operator<<( QTextStream &s, QTSManip m )
{ m.exec(s); return s; }

__declspec(dllimport) QTextStream &bin( QTextStream &s );	
__declspec(dllimport) QTextStream &oct( QTextStream &s );	
__declspec(dllimport) QTextStream &dec( QTextStream &s );	
__declspec(dllimport) QTextStream &hex( QTextStream &s );	
__declspec(dllimport) QTextStream &endl( QTextStream &s );	
__declspec(dllimport) QTextStream &flush( QTextStream &s );	
__declspec(dllimport) QTextStream &ws( QTextStream &s );	
__declspec(dllimport) QTextStream &reset( QTextStream &s );	

__declspec(dllimport) inline QTSManip qSetW( int w )
{
    QTSMFI func = &QTextStream::width;
    return QTSManip(func,w);
}

__declspec(dllimport) inline QTSManip qSetFill( int f )
{
    QTSMFI func = &QTextStream::fill;
    return QTSManip(func,f);
}

__declspec(dllimport) inline QTSManip qSetPrecision( int p )
{
    QTSMFI func = &QTextStream::precision;
    return QTSManip(func,p);
}

#line 335 "c:\\qt-3.3.8\\include\\qtextstream.h"
#line 336 "c:\\qt-3.3.8\\include\\qtextstream.h"
#line 44 "c:\\qt-3.3.8\\include\\qtl.h"
#line 1 "c:\\qt-3.3.8\\include\\qstring.h"

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 45 "c:\\qt-3.3.8\\include\\qtl.h"
#line 46 "c:\\qt-3.3.8\\include\\qtl.h"


template <class T>
class QTextOStreamIterator
{
protected:
    QTextOStream& stream;
    QString separator;

public:
    QTextOStreamIterator( QTextOStream& s) : stream( s ) {}
    QTextOStreamIterator( QTextOStream& s, const QString& sep )
	: stream( s ), separator( sep )  {}
    QTextOStreamIterator<T>& operator= ( const T& x ) {
	stream << x;
	if ( !separator.isEmpty() )
	    stream << separator;
	return *this;
    }
    QTextOStreamIterator<T>& operator*() { return *this; }
    QTextOStreamIterator<T>& operator++() { return *this; }
    QTextOStreamIterator<T>& operator++(int) { return *this; }
};
#line 70 "c:\\qt-3.3.8\\include\\qtl.h"

template <class InputIterator, class OutputIterator>
inline OutputIterator qCopy( InputIterator _begin, InputIterator _end,
			     OutputIterator _dest )
{
    while( _begin != _end )
	*_dest++ = *_begin++;
    return _dest;
}

template <class BiIterator, class BiOutputIterator>
inline BiOutputIterator qCopyBackward( BiIterator _begin, BiIterator _end,
				       BiOutputIterator _dest )
{
    while ( _begin != _end )
	*--_dest = *--_end;
    return _dest;
}

template <class InputIterator1, class InputIterator2>
inline bool qEqual( InputIterator1 first1, InputIterator1 last1, InputIterator2 first2 )
{
    
    for ( ; first1 != last1; ++first1, ++first2 )
	if ( *first1 != *first2 )
	    return FALSE;
    return TRUE;
}

template <class ForwardIterator, class T>
inline void qFill( ForwardIterator first, ForwardIterator last, const T& val )
{
    for ( ; first != last; ++first )
	*first = val;
}













#line 119 "c:\\qt-3.3.8\\include\\qtl.h"


template <class InputIterator, class T>
inline InputIterator qFind( InputIterator first, InputIterator last,
			    const T& val )
{
    while ( first != last && *first != val )
	++first;
    return first;
}

template <class InputIterator, class T, class Size>
inline void qCount( InputIterator first, InputIterator last, const T& value,
		    Size& n )
{
    for ( ; first != last; ++first )
	if ( *first == value )
	    ++n;
}

template <class T>
inline void qSwap( T& _value1, T& _value2 )
{
    T tmp = _value1;
    _value1 = _value2;
    _value2 = tmp;
}


template <class InputIterator>
inline void qBubbleSort( InputIterator b, InputIterator e )
{
    
    InputIterator last = e;
    --last;
    
    if ( last == b )
	return;

    
    while( b != last ) {
	bool swapped = FALSE;
	InputIterator swap_pos = b;
	InputIterator x = e;
	InputIterator y = x;
	y--;
	do {
	    --x;
	    --y;
	    if ( *x < *y ) {
		swapped = TRUE;
		qSwap( *x, *y );
		swap_pos = y;
	    }
	} while( y != b );
	if ( !swapped )
	    return;
	b = swap_pos;
	b++;
    }
}


template <class Container>
inline void qBubbleSort( Container &c )
{
  qBubbleSort( c.begin(), c.end() );
}


template <class Value>
inline void qHeapSortPushDown( Value* heap, int first, int last )
{
    int r = first;
    while ( r <= last / 2 ) {
	if ( last == 2 * r ) {
	    
	    if ( heap[2 * r] < heap[r] )
		qSwap( heap[r], heap[2 * r] );
	    r = last;
	} else {
	    
	    if ( heap[2 * r] < heap[r] && !(heap[2 * r + 1] < heap[2 * r]) ) {
		
		qSwap( heap[r], heap[2 * r] );
		r *= 2;
	    } else if ( heap[2 * r + 1] < heap[r]
			&& heap[2 * r + 1] < heap[2 * r] ) {
		
		qSwap( heap[r], heap[2 * r + 1] );
		r = 2 * r + 1;
	    } else {
		r = last;
	    }
	}
    }
}


template <class InputIterator, class Value>
inline void qHeapSortHelper( InputIterator b, InputIterator e, Value, uint n )
{
    
    InputIterator insert = b;
    Value* realheap = new Value[n];
    
    Value* heap = realheap - 1;
    int size = 0;
    for( ; insert != e; ++insert ) {
	heap[++size] = *insert;
	int i = size;
	while( i > 1 && heap[i] < heap[i / 2] ) {
	    qSwap( heap[i], heap[i / 2] );
	    i /= 2;
	}
    }

    
    for( uint i = n; i > 0; i-- ) {
	*b++ = heap[1];
	if ( i > 1 ) {
	    heap[1] = heap[i];
	    qHeapSortPushDown( heap, 1, (int)i - 1 );
	}
    }

    delete[] realheap;
}


template <class InputIterator>
inline void qHeapSort( InputIterator b, InputIterator e )
{
    
    if ( b == e )
	return;

    
    InputIterator it = b;
    uint n = 0;
    while ( it != e ) {
	++n;
	++it;
    }

    
    
    qHeapSortHelper( b, e, *b, n );
}


template <class Container>
inline void qHeapSort( Container &c )
{
    if ( c.begin() == c.end() )
	return;

    
    
    qHeapSortHelper( c.begin(), c.end(), *(c.begin()), (uint)c.count() );
}

template <class Container>
class QBackInsertIterator
{
public:
    explicit QBackInsertIterator( Container &c )
	: container( &c )
    {
    }

    QBackInsertIterator<Container>&
    operator=( const typename Container::value_type &value )
    {
	container->push_back( value );
	return *this;
    }

    QBackInsertIterator<Container>& operator*()
    {
	return *this;
    }

    QBackInsertIterator<Container>& operator++()
    {
	return *this;
    }

    QBackInsertIterator<Container>& operator++(int)
    {
	return *this;
    }

protected:
    Container *container;
};

template <class Container>
inline QBackInsertIterator<Container> qBackInserter( Container &c )
{
    return QBackInsertIterator<Container>( c );
}

#line 323 "c:\\qt-3.3.8\\include\\qtl.h"
#line 43 "c:\\qt-3.3.8\\include\\qvaluelist.h"
#line 1 "c:\\qt-3.3.8\\include\\qshared.h"























































#line 44 "c:\\qt-3.3.8\\include\\qvaluelist.h"
#line 1 "c:\\qt-3.3.8\\include\\qdatastream.h"






























































































































































































#line 45 "c:\\qt-3.3.8\\include\\qvaluelist.h"
#line 46 "c:\\qt-3.3.8\\include\\qvaluelist.h"


#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator"

#pragma once






#pragma pack(push,8)
#pragma warning(push,3)
#line 12 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator"

namespace std {

		
template<class _Container>
	class back_insert_iterator
		: public _Outit
	{	
public:
	typedef _Container container_type;
	typedef typename _Container::reference reference;

	typedef _Range_checked_iterator_tag _Checked_iterator_category;

	explicit back_insert_iterator(_Container& _Cont)
		: container(&_Cont)
		{	
		}

	back_insert_iterator<_Container>& operator=(
		typename _Container::const_reference _Val)
		{	
		container->push_back(_Val);
		return (*this);
		}

	back_insert_iterator<_Container>& operator*()
		{	
		return (*this);
		}

	back_insert_iterator<_Container>& operator++()
		{	
		return (*this);
		}

	back_insert_iterator<_Container> operator++(int)
		{	
		return (*this);
		}

protected:
	_Container *container;	
	};

		
template<class _Container> inline
	back_insert_iterator<_Container> back_inserter(_Container& _Cont)
	{	
	return (std::back_insert_iterator<_Container>(_Cont));
	}

		
template<class _Container>
	class front_insert_iterator
		: public _Outit
	{	
public:
	typedef _Container container_type;
	typedef typename _Container::reference reference;

	typedef _Range_checked_iterator_tag _Checked_iterator_category;

	explicit front_insert_iterator(_Container& _Cont)
		: container(&_Cont)
		{	
		}

	front_insert_iterator<_Container>& operator=(
		typename _Container::const_reference _Val)
		{	
		container->push_front(_Val);
		return (*this);
		}

	front_insert_iterator<_Container>& operator*()
		{	
		return (*this);
		}

	front_insert_iterator<_Container>& operator++()
		{	
		return (*this);
		}

	front_insert_iterator<_Container> operator++(int)
		{	
		return (*this);
		}

protected:
	_Container *container;	
	};

		
template<class _Container> inline
	front_insert_iterator<_Container> front_inserter(_Container& _Cont)
	{	
	return (std::front_insert_iterator<_Container>(_Cont));
	}

		
template<class _Container>
	class insert_iterator
		: public _Outit
	{	
public:
	typedef _Container container_type;
	typedef typename _Container::reference reference;

	typedef _Range_checked_iterator_tag _Checked_iterator_category;

	insert_iterator(_Container& _Cont, typename _Container::iterator _Where)
		: container(&_Cont), iter(_Where)
		{	
		}

	insert_iterator<_Container>& operator=(
		typename _Container::const_reference _Val)
		{	
		iter = container->insert(iter, _Val);
		++iter;
		return (*this);
		}

	insert_iterator<_Container>& operator*()
		{	
		return (*this);
		}

	insert_iterator<_Container>& operator++()
		{	
		return (*this);
		}

	insert_iterator<_Container>& operator++(int)
		{	
		return (*this);
		}

protected:
	_Container *container;	
	typename _Container::iterator iter;	
	};

		
template<class _Container,
	class _Iter> inline
	insert_iterator<_Container> inserter(_Container& _Cont, _Iter _Where)
	{	
	return (std::insert_iterator<_Container>(_Cont, _Where));
	}

		
template<class _Ty,
	class _Elem = char,
	class _Traits = char_traits<_Elem>,
	class _Diff = ptrdiff_t>
	class istream_iterator
		: public iterator<input_iterator_tag, _Ty, _Diff,
			const _Ty *, const _Ty&>
	{	
	typedef istream_iterator<_Ty, _Elem, _Traits, _Diff> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_istream<_Elem, _Traits> istream_type;


	typedef _Range_checked_iterator_tag _Checked_iterator_category;
#line 183 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator"

	istream_iterator()
		: _Myistr(0)
		{	
		}

	istream_iterator(istream_type& _Istr)
		: _Myistr(&_Istr)
		{	
		_Getval();
		}

	const _Ty& operator*() const
		{	

 
		if (_Myistr == 0)
			{
			_Debug_message(L"istream_iterator is not dereferencable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 201);
			{ (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 202, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 202, 0); };
			}
 

#line 207 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator"

		return (_Myval);
		}

	const _Ty *operator->() const
		{	
		return (&**this);
		}

	_Myt& operator++()
		{	

 
		if (_Myistr == 0)
			{
			_Debug_message(L"istream_iterator is not incrementable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 222);
			{ (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 223, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 223, 0); };
			}
 

#line 228 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator"

		_Getval();
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	bool _Equal(const _Myt& _Right) const
		{	
		return (_Myistr == _Right._Myistr);
		}

protected:
	void _Getval()
		{	
		if (_Myistr != 0 && !(*_Myistr >> _Myval))
			_Myistr = 0;
		}

	static void _Xran()
		{	
		throw out_of_range("invalid istream_iterator");
		}

	istream_type *_Myistr;	
	_Ty _Myval;	
	};

		
template<class _Ty,
	class _Elem,
	class _Traits,
	class _Diff> inline
	bool operator==(
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
	{	
	return (_Left._Equal(_Right));
	}

template<class _Ty,
	class _Elem,
	class _Traits,
	class _Diff> inline
	bool operator!=(
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
	{	
	return (!(_Left == _Right));
	}

		
template<class _Ty,
	class _Elem = char,
	class _Traits = char_traits<_Elem> >
	class ostream_iterator
		: public _Outit
	{	
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_ostream<_Elem, _Traits> ostream_type;


	typedef _Range_checked_iterator_tag _Checked_iterator_category;
#line 299 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator"

	ostream_iterator(ostream_type& _Ostr,
		const _Elem *_Delim = 0)
		: _Myostr(&_Ostr), _Mydelim(_Delim)
		{	
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator=(const _Ty& _Val)
		{	
		*_Myostr << _Val;
		if (_Mydelim != 0)
			*_Myostr << _Mydelim;

 
		if (!*_Myostr)
			{
			_Debug_message(L"ostream_iterator is not dereferencable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 315);
			{ (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 316, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 316, 0); };
			}
 

#line 321 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator"

		return (*this);
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator*()
		{	
		return (*this);
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator++()
		{	
		return (*this);
		}

	ostream_iterator<_Ty, _Elem, _Traits> operator++(int)
		{	
		return (*this);
		}

protected:
	static void _Xran()
		{	
		throw out_of_range("invalid ostream_iterator");
		}

	const _Elem *_Mydelim;	
	ostream_type *_Myostr;	
	};

}

namespace stdext {


template <class _Cont, class _Iter = typename _Cont::iterator>
	class checked_iterator
		: public ::std:: iterator<
			typename ::std:: iterator_traits<_Iter>::iterator_category, 
			typename ::std:: iterator_traits<_Iter>::value_type, 
			typename ::std:: iterator_traits<_Iter>::difference_type, 
			typename ::std:: iterator_traits<_Iter>::pointer, 
			typename ::std:: iterator_traits<_Iter>::reference>
	{
	friend class checked_iterator;
public:
	typedef checked_iterator<_Cont, _Iter> _Myt;
	typedef typename ::std:: iterator_traits<_Iter>::difference_type difference_type;
	typedef typename ::std:: iterator_traits<_Iter>::pointer pointer;
	typedef typename ::std:: iterator_traits<_Iter>::reference reference;

	typedef ::std:: _Range_checked_iterator_tag _Checked_iterator_category;
	typedef _Iter _Inner_type;

	typedef _Iter _Checked_iterator_base_type;
 
	_Checked_iterator_base_type _Checked_iterator_base() const
	{
		return _Current;
	}

	void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
	{
		_Current = _Base;
	}

	

	checked_iterator()
		: _Mycont(0)
	{
	}

	checked_iterator(_Cont& _C, _Iter _Ptr)
		: _Mycont(&_C), _Current(_Ptr)
	{
	}

	checked_iterator(const _Myt &_Right)
		: _Mycont(_Right._Mycont), _Current(_Right._Current)
	{
	}

	template <class Iter2>
	checked_iterator(const checked_iterator<_Cont, Iter2> &_Right)
		: _Mycont(_Right._Mycont), _Current(_Right._Current)
	{
	}

	_Iter base() const
	{
		{ if (!(_Mycont != 0)) { (void) ((!!((("_Mycont != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 411, 0, L"(\"_Mycont != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 411, 0); } ; };
		return _Current;
	}

	template <class Iter2>
	bool operator==(const checked_iterator<_Cont, Iter2>& _Right) const
	{
		{ if (!(_Mycont == _Right._Mycont)) { (void) ((!!((("_Mycont == _Right._Mycont", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 418, 0, L"(\"_Mycont == _Right._Mycont\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 418, 0); } ; };
		return _Current == _Right._Current;
	}

	template <class Iter2>
	bool operator!=(const checked_iterator<_Cont, Iter2>& _Right) const
	{
		{ if (!(_Mycont != 0)) { (void) ((!!((("_Mycont != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 425, 0, L"(\"_Mycont != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 425, 0); } ; };
		return !(*this == _Right);
	}

	template <class Iter2>
	bool operator<(const checked_iterator<_Cont, Iter2>& _Right) const
	{
		{ if (!(_Mycont != 0 && _Mycont == _Right._Mycont)) { (void) ((!!((("_Mycont != NULL && _Mycont == _Right._Mycont", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 432, 0, L"(\"_Mycont != NULL && _Mycont == _Right._Mycont\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 432, 0); } ; };
		return _Current < _Right._Current;
	}

	template <class Iter2>
	bool operator>(const checked_iterator<_Cont, Iter2>& _Right) const
	{
		return _Right < *this;
	}

	template <class Iter2>
	bool operator<=(const checked_iterator<_Cont, Iter2>& _Right) const
	{
		return !(_Right < *this);
	}

	template <class Iter2>
	bool operator>=(const checked_iterator<_Cont, Iter2>& _Right) const
	{
		return !(*this < _Right);
	}

	reference operator*() const
	{
		{ if (!(_Mycont != 0)) { (void) ((!!((("_Mycont != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 456, 0, L"(\"_Mycont != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 456, 0); } ; };
		{ if (!(_Current != _Mycont->end())) { (void) ((!!((("_Current != _Mycont->end()", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 457, 0, L"(\"_Current != _Mycont->end()\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 457, 0); } ; };
		return *_Current;
	}

	pointer operator->() const
	{
		return (&**this);
	}

	_Myt& operator++()
	{
		{ if (!(_Mycont != 0)) { (void) ((!!((("_Mycont != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 468, 0, L"(\"_Mycont != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 468, 0); } ; };
		{ if (!(_Current != _Mycont->end())) { (void) ((!!((("_Current != _Mycont->end()", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 469, 0, L"(\"_Current != _Mycont->end()\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 469, 0); } ; };
		++_Current;
		return *this;
	}

	_Myt operator++(int)
	{
		_Myt _Tmp = *this;
		++*this;
		return _Tmp;
	}

	_Myt& operator--()
	{
		{ if (!(_Mycont != 0)) { (void) ((!!((("_Mycont != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 483, 0, L"(\"_Mycont != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 483, 0); } ; };
		{ if (!(_Current != _Mycont->begin())) { (void) ((!!((("_Current != _Mycont->begin()", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 484, 0, L"(\"_Current != _Mycont->begin()\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 484, 0); } ; };
		--_Current;
		return *this;
	}

	_Myt operator--(int)
	{
		_Myt _Tmp = *this;
		--*this;
		return _Tmp;
	}

	

	_Myt& operator+=(difference_type _Off)
	{
		{ if (!(_Mycont != 0)) { (void) ((!!((("_Mycont != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 500, 0, L"(\"_Mycont != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 500, 0); } ; };
		{ if (!((_Mycont->end() - _Current) >= _Off && (_Mycont->begin() - _Current) <= _Off)) { (void) ((!!((("(_Mycont->end() - _Current) >= _Off && (_Mycont->begin() - _Current) <= _Off", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 501, 0, L"(\"(_Mycont->end() - _Current) >= _Off && (_Mycont->begin() - _Current) <= _Off\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 501, 0); } ; };
		_Current += _Off;
		return *this;
	}

	_Myt operator+(difference_type _Off) const
	{
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
	}

	_Myt& operator-=(difference_type _Off)
	{
		return (*this += -_Off);
	}

	_Myt operator-(difference_type _Off) const
	{
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
	}

	difference_type operator-(const _Myt& _Right) const
	{
		{ if (!(_Mycont != 0 && _Mycont == _Right._Mycont)) { (void) ((!!((("_Mycont != NULL && _Mycont == _Right._Mycont", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 525, 0, L"(\"_Mycont != NULL && _Mycont == _Right._Mycont\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 525, 0); } ; };
		return _Current - _Right._Current;
	}

	reference operator[](difference_type _Off) const
	{
		{ if (!(_Mycont != 0)) { (void) ((!!((("_Mycont != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 531, 0, L"(\"_Mycont != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 531, 0); } ; };
		{ if (!((_Mycont->end() - _Current) > _Off && (_Mycont->begin() - _Current) <= _Off)) { (void) ((!!((("(_Mycont->end() - _Current) > _Off && (_Mycont->begin() - _Current) <= _Off", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 532, 0, L"(\"(_Mycont->end() - _Current) > _Off && (_Mycont->begin() - _Current) <= _Off\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator", 532, 0); } ; };
		return _Current[_Off];
	}

protected:
	void _Xran() const
	{	
		throw ::std:: out_of_range("invalid checked_iterator<T> subscript");
	}

	void _Xinvarg() const
	{	
		throw ::std:: invalid_argument("invalid checked_iterator<T> argument");
	}

	_Cont *_Mycont; 
	_Iter _Current; 
	};

}


#pragma warning(pop)
#pragma pack(pop)
#line 557 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator"

#line 559 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator"
#line 560 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iterator"






















#line 49 "c:\\qt-3.3.8\\include\\qvaluelist.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

#pragma once



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\functional"

#pragma once






#pragma pack(push,8)
#pragma warning(push,3)

 #pragma warning(disable: 4244)
#line 14 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\functional"

namespace std {

		
template<class _Arg,
	class _Result>
	struct unary_function
	{	
	typedef _Arg argument_type;
	typedef _Result result_type;
	};

		
template<class _Arg1,
	class _Arg2,
	class _Result>
	struct binary_function
	{	
	typedef _Arg1 first_argument_type;
	typedef _Arg2 second_argument_type;
	typedef _Result result_type;
	};

		
template<class _Ty>
	struct plus
		: public binary_function<_Ty, _Ty, _Ty>
	{	
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left + _Right);
		}
	};

		
template<class _Ty>
	struct minus
		: public binary_function<_Ty, _Ty, _Ty>
	{	
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left - _Right);
		}
	};

		
template<class _Ty>
	struct multiplies
		: public binary_function<_Ty, _Ty, _Ty>
	{	
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left * _Right);
		}
	};

		
template<class _Ty>
	struct divides
		: public binary_function<_Ty, _Ty, _Ty>
	{	
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left / _Right);
		}
	};

		
template<class _Ty>
	struct modulus
		: public binary_function<_Ty, _Ty, _Ty>
	{	
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left % _Right);
		}
	};

		
template<class _Ty>
	struct negate
		: public unary_function<_Ty, _Ty>
	{	
	_Ty operator()(const _Ty& _Left) const
		{	
		return (-_Left);
		}
	};

		
template<class _Ty>
	struct equal_to
		: public binary_function<_Ty, _Ty, bool>
	{	
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left == _Right);
		}
	};

		
template<class _Ty>
	struct not_equal_to
		: public binary_function<_Ty, _Ty, bool>
	{	
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left != _Right);
		}
	};

		
template<class _Ty>
	struct greater
		: public binary_function<_Ty, _Ty, bool>
	{	
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left > _Right);
		}
	};

		
template<class _Ty>
	struct less
		: public binary_function<_Ty, _Ty, bool>
	{	
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left < _Right);
		}
	};

		
template<class _Ty>
	struct greater_equal
		: public binary_function<_Ty, _Ty, bool>
	{	
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left >= _Right);
		}
	};

		
template<class _Ty>
	struct less_equal
		: public binary_function<_Ty, _Ty, bool>
	{	
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left <= _Right);
		}
	};

		
template<class _Ty>
	struct logical_and
		: public binary_function<_Ty, _Ty, bool>
	{	
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left && _Right);
		}
	};

		
template<class _Ty>
	struct logical_or
		: public binary_function<_Ty, _Ty, bool>
	{	
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left || _Right);
		}
	};

		
template<class _Ty>
	struct logical_not
		: public unary_function<_Ty, bool>
	{	
	bool operator()(const _Ty& _Left) const
		{	
		return (!_Left);
		}
	};

		
template<class _Fn1>
	class unary_negate
	: public unary_function<typename _Fn1::argument_type, bool>
	{	
public:
	explicit unary_negate(const _Fn1& _Func)
		: _Functor(_Func)
		{	
		}

	bool operator()(const typename _Fn1::argument_type& _Left) const
		{	
		return (!_Functor(_Left));
		}

protected:
	_Fn1 _Functor;	
	};

		
template<class _Fn1> inline
	unary_negate<_Fn1> not1(const _Fn1& _Func)
	{	
	return (std::unary_negate<_Fn1>(_Func));
	}

		
template<class _Fn2>
	class binary_negate
		: public binary_function<typename _Fn2::first_argument_type,
			typename _Fn2::second_argument_type, bool>
	{	
public:
	explicit binary_negate(const _Fn2& _Func)
		: _Functor(_Func)
		{	
		}

	bool operator()(const typename _Fn2::first_argument_type& _Left,
		const typename _Fn2::second_argument_type& _Right) const
		{	
		return (!_Functor(_Left, _Right));
		}

protected:
	_Fn2 _Functor;	
	};

		
template<class _Fn2> inline
	binary_negate<_Fn2> not2(const _Fn2& _Func)
	{	
	return (std::binary_negate<_Fn2>(_Func));
	}

		
template<class _Fn2>
	class binder1st
		: public unary_function<typename _Fn2::second_argument_type,
			typename _Fn2::result_type>
	{	
public:
	typedef unary_function<typename _Fn2::second_argument_type,
		typename _Fn2::result_type> _Base;
	typedef typename _Base::argument_type argument_type;
	typedef typename _Base::result_type result_type;

	binder1st(const _Fn2& _Func,
		const typename _Fn2::first_argument_type& _Left)
		: op(_Func), value(_Left)
		{	
		}

	result_type operator()(const argument_type& _Right) const
		{	
		return (op(value, _Right));
		}

	result_type operator()(argument_type& _Right) const
		{	
		return (op(value, _Right));
		}

protected:
	_Fn2 op;	
	typename _Fn2::first_argument_type value;	
	};

		
template<class _Fn2,
	class _Ty> inline
	binder1st<_Fn2> bind1st(const _Fn2& _Func, const _Ty& _Left)
		{	
		typename _Fn2::first_argument_type _Val(_Left);
		return (std::binder1st<_Fn2>(_Func, _Val));
		}

		
template<class _Fn2>
	class binder2nd
		: public unary_function<typename _Fn2::first_argument_type,
			typename _Fn2::result_type>
	{	
public:
	typedef unary_function<typename _Fn2::first_argument_type,
		typename _Fn2::result_type> _Base;
	typedef typename _Base::argument_type argument_type;
	typedef typename _Base::result_type result_type;

	binder2nd(const _Fn2& _Func,
		const typename _Fn2::second_argument_type& _Right)
		: op(_Func), value(_Right)
		{	
		}

	result_type operator()(const argument_type& _Left) const
		{	
		return (op(_Left, value));
		}

	result_type operator()(argument_type& _Left) const
		{	
		return (op(_Left, value));
		}

protected:
	_Fn2 op;	
	typename _Fn2::second_argument_type value;	
	};

		
template<class _Fn2,
	class _Ty> inline
	binder2nd<_Fn2> bind2nd(const _Fn2& _Func, const _Ty& _Right)
	{	
	typename _Fn2::second_argument_type _Val(_Right);
	return (std::binder2nd<_Fn2>(_Func, _Val));
	}

		
template<class _Arg,
	class _Result,
	class _Fn = _Result (*)(_Arg)>
	class pointer_to_unary_function
		: public unary_function<_Arg, _Result>
	{	
public:
	explicit pointer_to_unary_function(_Fn _Left)
		: _Pfun(_Left)
		{	
		}

	_Result operator()(_Arg _Left) const
		{	
		return (_Pfun(_Left));
		}

protected:
	_Fn _Pfun;	
	};

		
template<class _Arg1,
	class _Arg2,
	class _Result,
	class _Fn = _Result (*)(_Arg1, _Arg2)>
	class pointer_to_binary_function
		: public binary_function<_Arg1, _Arg2, _Result>
	{	
public:
	explicit pointer_to_binary_function(_Fn _Left)
		: _Pfun(_Left)
		{	
		}

	_Result operator()(_Arg1 _Left, _Arg2 _Right) const
		{	
		return (_Pfun(_Left, _Right));
		}

protected:
	_Fn _Pfun;	
	};

		
template<class _Arg,
	class _Result> inline
	pointer_to_unary_function<_Arg, _Result, _Result (__cdecl *)(_Arg)>
		ptr_fun(_Result (__cdecl *_Left)(_Arg))
	{	
	return (std::pointer_to_unary_function<_Arg, _Result, _Result (__cdecl *)(_Arg)>(_Left));
	}

 
template<class _Arg,
	class _Result> inline
	pointer_to_unary_function<_Arg, _Result,
		_Result (__stdcall *)(_Arg)>
			ptr_fun(_Result (__stdcall *_Left)(_Arg))
	{	
	return (std::pointer_to_unary_function<_Arg, _Result, _Result (__stdcall *)(_Arg)>(_Left));
	}


template<class _Arg,
	class _Result> inline
	pointer_to_unary_function<_Arg, _Result,
		_Result (__fastcall *)(_Arg)>
			ptr_fun(_Result (__fastcall *_Left)(_Arg))
	{	
	return (std::pointer_to_unary_function<_Arg, _Result, _Result (__fastcall *)(_Arg)>(_Left));
	}

#line 417 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\functional"
#line 418 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\functional"












template<class _Arg1,
	class _Arg2,
	class _Result> inline
	pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(__cdecl *)(_Arg1, _Arg2)>
		ptr_fun(_Result (__cdecl *_Left)(_Arg1, _Arg2))
	{	
	return (std::pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result (__cdecl *)(_Arg1, _Arg2)>(_Left));
	}

 
template<class _Arg1,
	class _Arg2,
	class _Result> inline
	pointer_to_binary_function<_Arg1, _Arg2, _Result,
		_Result(__stdcall *)(_Arg1, _Arg2)>
			ptr_fun(_Result (__stdcall *_Left)(_Arg1, _Arg2))
	{	
	return (std::pointer_to_binary_function<_Arg1, _Arg2, _Result,
		_Result (__stdcall *)(_Arg1, _Arg2)>(_Left));
	}



template<class _Arg1,
	class _Arg2,
	class _Result> inline
	pointer_to_binary_function<_Arg1, _Arg2, _Result,
		_Result(__fastcall *)(_Arg1, _Arg2)>
			ptr_fun(_Result (__fastcall *_Left)(_Arg1, _Arg2))
	{	
	return (std::pointer_to_binary_function<_Arg1, _Arg2, _Result,
		_Result (__fastcall *)(_Arg1, _Arg2)>(_Left));
	}

#line 465 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\functional"
#line 466 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\functional"















		
template<class _Result,
	class _Ty>
	class mem_fun_t
		: public unary_function<_Ty *, _Result>
	{	
public:
	explicit mem_fun_t(_Result (_Ty::*_Pm)())
		: _Pmemfun(_Pm)
		{	
		}

	_Result operator()(_Ty *_Pleft) const
		{	
		return ((_Pleft->*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)();	
	};

		
template<class _Result,
	class _Ty,
	class _Arg>
	class mem_fun1_t
		: public binary_function<_Ty *, _Arg, _Result>
	{	
public:
	explicit mem_fun1_t(_Result (_Ty::*_Pm)(_Arg))
		: _Pmemfun(_Pm)
		{	
		}

	_Result operator()(_Ty *_Pleft, _Arg _Right) const
		{	
		return ((_Pleft->*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg);	
	};

		
template<class _Result,
	class _Ty>
	class const_mem_fun_t
		: public unary_function<const _Ty *, _Result>
	{	
public:
	explicit const_mem_fun_t(_Result (_Ty::*_Pm)() const)
		: _Pmemfun(_Pm)
		{	
		}

	_Result operator()(const _Ty *_Pleft) const
		{	
		return ((_Pleft->*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)() const;	
	};

		
template<class _Result,
	class _Ty,
	class _Arg>
	class const_mem_fun1_t
		: public binary_function<const _Ty *, _Arg, _Result>
	{	
public:
	explicit const_mem_fun1_t(_Result (_Ty::*_Pm)(_Arg) const)
		: _Pmemfun(_Pm)
		{	
		}

	_Result operator()(const _Ty *_Pleft, _Arg _Right) const
		{	
		return ((_Pleft->*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg) const;	
	};

		
template<class _Result,
	class _Ty> inline
	mem_fun_t<_Result, _Ty> mem_fun(_Result (_Ty::*_Pm)())
	{	
	return (std::mem_fun_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg> inline
	mem_fun1_t<_Result, _Ty, _Arg> mem_fun(_Result (_Ty::*_Pm)(_Arg))
	{	
	return (std::mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}

template<class _Result,
	class _Ty> inline
	const_mem_fun_t<_Result, _Ty>
		mem_fun(_Result (_Ty::*_Pm)() const)
	{	
	return (std::const_mem_fun_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg> inline
	const_mem_fun1_t<_Result, _Ty, _Arg>
		mem_fun(_Result (_Ty::*_Pm)(_Arg) const)
	{	
	return (std::const_mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}

		
template<class _Result,
	class _Ty,
	class _Arg> inline
	mem_fun1_t<_Result, _Ty, _Arg> mem_fun1(_Result (_Ty::*_Pm)(_Arg))
	{	
	return (std::mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}

		
template<class _Result,
	class _Ty>
	class mem_fun_ref_t
		: public unary_function<_Ty, _Result>
	{	
public:
	explicit mem_fun_ref_t(_Result (_Ty::*_Pm)())
		: _Pmemfun(_Pm)
		{	
		}

	_Result operator()(_Ty& _Left) const
		{	
		return ((_Left.*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)();	
	};

		
template<class _Result,
	class _Ty,
	class _Arg>
	class mem_fun1_ref_t
		: public binary_function<_Ty, _Arg, _Result>
	{	
public:
	explicit mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg))
		: _Pmemfun(_Pm)
		{	
		}

	_Result operator()(_Ty& _Left, _Arg _Right) const
		{	
		return ((_Left.*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg);	
	};

		
template<class _Result,
	class _Ty>
	class const_mem_fun_ref_t
		: public unary_function<_Ty, _Result>
	{	
public:
	explicit const_mem_fun_ref_t(_Result (_Ty::*_Pm)() const)
		: _Pmemfun(_Pm)
		{	
		}

	_Result operator()(const _Ty& _Left) const
		{	
		return ((_Left.*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)() const;	
	};

		
template<class _Result,
	class _Ty,
	class _Arg>
	class const_mem_fun1_ref_t
		: public binary_function<_Ty, _Arg, _Result>
	{	
public:
	explicit const_mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg) const)
		: _Pmemfun(_Pm)
		{	
		}

	_Result operator()(const _Ty& _Left, _Arg _Right) const
		{	
		return ((_Left.*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg) const;	
	};

		
template<class _Result,
	class _Ty> inline
	mem_fun_ref_t<_Result, _Ty> mem_fun_ref(_Result (_Ty::*_Pm)())
	{	
	return (std::mem_fun_ref_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg> inline
	mem_fun1_ref_t<_Result, _Ty, _Arg>
		mem_fun_ref(_Result (_Ty::*_Pm)(_Arg))
	{	
	return (std::mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}

template<class _Result,
	class _Ty> inline
	const_mem_fun_ref_t<_Result, _Ty>
		mem_fun_ref(_Result (_Ty::*_Pm)() const)
	{	
	return (std::const_mem_fun_ref_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg> inline
	const_mem_fun1_ref_t<_Result, _Ty, _Arg>
		mem_fun_ref(_Result (_Ty::*_Pm)(_Arg) const)
	{	
	return (std::const_mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}

		
template<class _Result,
	class _Ty,
	class _Arg> inline
	mem_fun1_ref_t<_Result, _Ty, _Arg> mem_fun1_ref(_Result (_Ty::*_Pm)(_Arg))
	{	
	return (std::mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}
}


  #pragma warning(default: 4244)

#pragma warning(pop)
#pragma pack(pop)
#line 745 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\functional"

#line 747 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\functional"
#line 748 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\functional"






















#line 7 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory"

#pragma once







#pragma pack(push,8)
#pragma warning(push,3)
#line 13 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory"

namespace std {

		
template<class _Ty> inline
	pair<_Ty  *, ptrdiff_t>
		get_temporary_buffer(ptrdiff_t _Count)
	{	
	_Ty  *_Pbuf;

	if (_Count <= 0)
		_Count = 0;
	else if (((size_t)(-1) / _Count) < sizeof (_Ty))
		throw std::bad_alloc(0);

	for (_Pbuf = 0; 0 < _Count; _Count /= 2)
		if ((_Pbuf = (_Ty  *)operator new(
			(size_t)_Count * sizeof (_Ty), nothrow)) != 0)
			break;

	return (pair<_Ty  *, ptrdiff_t>(_Pbuf, _Count));
	}

		
template<class _Ty> inline
	void return_temporary_buffer(_Ty *_Pbuf)
	{	
	operator delete(_Pbuf);
	}

		
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory", 49);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory",50);
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, ++_First)
		_Construct(&*_Dest, *_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Destroy(&*_Next);
	throw;
	}
	return (_Dest);
	}

template<class _Ty1,
	class _Ty2> inline
	_Ty2 _Uninit_copy(_Ty1 _First, _Ty1 _Last, _Ty2 _Dest,
		_Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory", 69);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory",70);
	size_t _Count = (size_t)(_Last - _First);
	_Ty2 _Result = _Dest + _Count;
	if (_Count > 0)
		::memmove_s((&*_Dest), (_Count * sizeof (*_First)), (&*_First), (_Count * sizeof (*_First)));	
	return _Result;
	}



template<class _InIt,
	class _FwdIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
	{	
	return (_Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		_Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt, class _FwdElem, size_t _Size>
inline
_FwdElem* uninitialized_copy(_InIt _First, _InIt _Last, _FwdElem (&_Dest)[_Size])
	{	
	return (uninitialized_copy(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _InIt,
	class _FwdIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
	{	
	return (_Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		_Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
	}











#line 116 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory"

		
template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory", 124);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory",125);
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, ++_First)
		_Al.construct(_Dest, *_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	return (_Dest);
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc&, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory", 145);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory",146);
	size_t _Count = (size_t)(_Last - _First);
	_FwdIt _Result = _Dest + _Count;
	if (_Count > 0)
		::memmove_s((&*_Dest), (_Count * sizeof (*_First)), (&*_First), (_Count * sizeof (*_First)));	
	return _Result;
	}



template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (_Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
		_Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt, class _FwdElem, class _Alloc, size_t _Size>
inline
_FwdElem* _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdElem (&_Dest)[_Size],
		_Alloc& _Al)
	{	
	return (_Uninitialized_copy(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Al).base());
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (_Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
		_Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
	}













#line 199 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory"

		
template<class _InIt, class _FwdIt, class _Alloc, class _MoveCatTy>
inline
	_FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al, _MoveCatTy, _Range_checked_iterator_tag)
	{	
	return ::stdext:: unchecked_uninitialized_copy(_First, _Last, _Dest, _Al);
	}

template<class _InIt, class _FwdIt, class _Alloc>
inline
	_FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al, _Swap_move_tag, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory", 214);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory",215);
	_FwdIt _Next = _Dest;
	
	typename _Alloc::value_type _Val;

	try {
	for (; _First != _Last; ++_Dest, ++_First)
		{
		_Al.construct(_Dest, _Val);
		::std:: swap(*_Dest, *_First);
		}
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	return (_Dest);
	}



template<class _InIt, class _FwdIt, class _Alloc>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (_Uninit_move(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
		_Move_cat(_Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt, class _FwdElem, class _Alloc, size_t _Size>
inline
_FwdElem* _Uninitialized_move(_InIt _First, _InIt _Last, _FwdElem (&_Dest)[_Size],
		_Alloc& _Al)
	{	
	return (_Uninitialized_move(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Al).base());
	}

template<class _InIt, class _FwdIt, class _Alloc>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (_Uninit_move(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
		_Move_cat(_Dest), ::std:: _Range_checked_iterator_tag()));
	}












#line 276 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory"

    
template<class _FwdIt,
	class _Tval> inline
	void _Uninit_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val,
		_Nonscalar_ptr_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory", 283);
	_FwdIt _Next = _First;

	try {
	for (; _First != _Last; ++_First)
		_Construct(&*_First, _Val);
	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Destroy(&*_Next);
	throw;
	}
	}

template<class _Ty,
	class _Tval> inline
	void _Uninit_fill(_Ty *_First, _Ty *_Last, const _Tval& _Val,
		_Scalar_ptr_iterator_tag)
	{	
	std::fill(_First, _Last, _Val);
	}

template<class _FwdIt,
	class _Tval> inline
	void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
	{	
	_Uninit_fill(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val, _Ptr_cat(_First, _First));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val,
		_Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{	

 


 #line 323 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory"

	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, ++_First)
		_Construct(&*_First, _Val);
	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Destroy(&*_Next);
	throw;
	}
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val,
		_Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{	
	::stdext:: unchecked_fill_n(&*_First, _Count, _Val);
	}



template<class _FwdIt,
	class _Diff,
	class _Tval> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val)
	{	
	_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
	}

template<class _FwdElem, class _Diff, class _Tval, size_t _Size>
inline
void uninitialized_fill_n(_FwdElem (&_First)[_Size], _Diff _Count, const _Tval& _Val)
	{	
	uninitialized_fill_n(::stdext:: make_checked_array_iterator(_First, _Size), _Count, _Val);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val)
	{	
	_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
	}











#line 382 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory"

		
template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val, _Alloc& _Al, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{	

 


 #line 396 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory"

	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, ++_First)
		_Al.construct(_First, _Val);
	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val, _Alloc&, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{	
		::stdext:: unchecked_fill_n(_First, _Count, _Val);
	}



template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val, _Alloc& _Al)
	{	
	_Uninit_fill_n(_First, _Count, _Val, _Al,
		_Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
	}

template<class _FwdElem, class _Diff, class _Tval, class _Alloc, size_t _Size>
inline
void _Uninitialized_fill_n(_FwdElem (&_First)[_Size], _Diff _Count,
		const _Tval& _Val, _Alloc& _Al)
	{	
	_Uninitialized_fill_n(::stdext:: make_checked_array_iterator(_First, _Size), _Count, _Val, _Al);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val, _Alloc& _Al)
	{	
	_Uninit_fill_n(_First, _Count, _Val, _Al,
		_Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
	}














#line 466 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory"

		
template<class _FwdIt,
	class _Ty>
	class raw_storage_iterator
		: public _Outit
	{	
public:
	typedef _FwdIt iterator_type;	
	typedef _FwdIt iter_type;	
	typedef _Ty element_type;	

	explicit raw_storage_iterator(_FwdIt _First)
		: _Next(_First)
		{	
		}

	raw_storage_iterator<_FwdIt, _Ty>& operator*()
		{	
		return (*this);
		}

	raw_storage_iterator<_FwdIt, _Ty>& operator=(const _Ty& _Val)
		{	
		_Construct(&*_Next, _Val);
		return (*this);
		}

	raw_storage_iterator<_FwdIt, _Ty>& operator++()
		{	
		++_Next;
		return (*this);
		}

	raw_storage_iterator<_FwdIt, _Ty> operator++(int)
		{	
		raw_storage_iterator<_FwdIt, _Ty> _Ans = *this;
		++_Next;
		return (_Ans);
		}

private:
	_FwdIt _Next;	
	};

		
template<class _Ty>
	class _Temp_iterator
		: public _Outit
	{	
public:
	typedef _Ty  *_Pty;


	typedef _Range_checked_iterator_tag _Checked_iterator_category;
#line 522 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory"

	_Temp_iterator(ptrdiff_t _Count = 0)
		{	
		_Buf._Begin = 0;
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = _Count;	
		_Pbuf = &_Buf;
		}

	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)
		{	
		_Buf._Begin = 0;	
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = 0;
		*this = _Right;
		}

	~_Temp_iterator()
		{	
		if (_Buf._Begin != 0)
			{	
			for (_Pty _Next = _Buf._Begin;
				_Next != _Buf._Hiwater; ++_Next)
				_Destroy(&*_Next);
			std::return_temporary_buffer(_Buf._Begin);
			}
		}

	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
		{	
		_Pbuf = _Right._Pbuf;
		return (*this);
		}

	_Temp_iterator<_Ty>& operator=(const _Ty& _Val)
		{	
		if (_Pbuf->_Current < _Pbuf->_Hiwater)
			*_Pbuf->_Current++ = _Val;	
		else
			{	
			{ if (!((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size)) { (void) ((!!((("(_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory", 564, 0, L"(\"(_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory", 564, 0); } ; };
			_Pty _Ptr = &*_Pbuf->_Current;
			_Construct(_Ptr, _Val);
			_Pbuf->_Hiwater = ++_Pbuf->_Current;
			}
		return (*this);
		}

	_Temp_iterator<_Ty>& operator*()
		{	
		return (*this);
		}

	_Temp_iterator<_Ty>& operator++()
		{	
		return (*this);
		}

	_Temp_iterator<_Ty>& operator++(int)
		{	
		return (*this);
		}

	_Temp_iterator<_Ty>& _Init()
		{	
		_Pbuf->_Current = _Pbuf->_Begin;
		return (*this);
		}

	_Pty _First() const
		{	
		return (_Pbuf->_Begin);
		}

	_Pty _Last() const
		{	
		return (_Pbuf->_Current);
		}

	ptrdiff_t _Maxlen()
		{	
		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)
			{	
			pair<_Pty, ptrdiff_t> _Pair =
				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

			_Pbuf->_Begin = _Pair.first;
			_Pbuf->_Current = _Pair.first;
			_Pbuf->_Hiwater = _Pair.first;
			_Pbuf->_Size = _Pair.second;
			}
		return (_Pbuf->_Size);
		}

	static void _Xinvarg()
		{	
		throw invalid_argument("invalid _Temp_iterator<T> argument");
		}

private:
	struct _Bufpar
		{	
		_Pty _Begin;	
		_Pty _Current;	
		_Pty _Hiwater;	
		ptrdiff_t _Size;	
		};
	_Bufpar _Buf;	
	_Bufpar *_Pbuf;	
	};

		
template<class _Ty>
	class auto_ptr;

template<class _Ty>
	struct auto_ptr_ref
		{	
	auto_ptr_ref(void *_Right)
		: _Ref(_Right)
		{	
		}

	void *_Ref;	
	};

template<class _Ty>
	class auto_ptr
		{	
public:
	typedef _Ty element_type;

	explicit auto_ptr(_Ty *_Ptr = 0) throw ()
		: _Myptr(_Ptr)
		{	
		}

	auto_ptr(auto_ptr<_Ty>& _Right) throw ()
		: _Myptr(_Right.release())
		{	
		}

	auto_ptr(auto_ptr_ref<_Ty> _Right) throw ()
		{	
		_Ty **_Pptr = (_Ty **)_Right._Ref;
		_Ty *_Ptr = *_Pptr;
		*_Pptr = 0;	
		_Myptr = _Ptr;	
		}

	template<class _Other>
		operator auto_ptr<_Other>() throw ()
		{	
		return (auto_ptr<_Other>(*this));
		}

	template<class _Other>
		operator auto_ptr_ref<_Other>() throw ()
		{	
		_Other *_Testptr = (_Ty *)_Myptr;	
		auto_ptr_ref<_Other> _Ans(&_Myptr);
		return (_Testptr != 0 ? _Ans : _Ans);
		}

	template<class _Other>
		auto_ptr<_Ty>& operator=(auto_ptr<_Other>& _Right) throw ()
		{	
		reset(_Right.release());
		return (*this);
		}

	template<class _Other>
		auto_ptr(auto_ptr<_Other>& _Right) throw ()
		: _Myptr(_Right.release())
		{	
		}

	auto_ptr<_Ty>& operator=(auto_ptr<_Ty>& _Right) throw ()
		{	
		reset(_Right.release());
		return (*this);
		}

	auto_ptr<_Ty>& operator=(auto_ptr_ref<_Ty> _Right) throw ()
		{	
		_Ty **_Pptr = (_Ty **)_Right._Ref;
		_Ty *_Ptr = *_Pptr;
		*_Pptr = 0;	
		reset(_Ptr);	
		return (*this);
		}

	~auto_ptr()
		{	
		delete (_Ty *)_Myptr;
		}

	_Ty& operator*() const throw ()
		{	

 
		if (_Myptr == 0)
			_Debug_message(L"auto_ptr not dereferencable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory", 726);
 #line 728 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory"

		;

		return (*(_Ty *)_Myptr);
		}

	_Ty *operator->() const throw ()
		{	
		return (&**this);
		}

	_Ty *get() const throw ()
		{	
		return ((_Ty *)_Myptr);
		}

	_Ty *release() throw ()
		{	
		_Ty *_Tmp = (_Ty *)_Myptr;
		_Myptr = 0;
		return (_Tmp);
		}

	void reset(_Ty* _Ptr = 0)
		{	
		if (_Ptr != _Myptr)
			delete (_Ty *)_Myptr;
		_Myptr = _Ptr;
		}

private:
	const _Ty *_Myptr;	
	};
}

namespace stdext {

template<class _InIt,
	class _FwdIt> inline
	_FwdIt unchecked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
	{	
		return (::std:: _Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
			::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt,
	class _FwdIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
	{	
	return (::std:: _Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt, class _FwdElem, size_t _Size>
inline
_FwdElem* checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdElem (&_Dest)[_Size])
	{	
	return (checked_uninitialized_copy(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _InIt,
	class _FwdIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
	{	
	return (::std:: _Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
		::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt unchecked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
		return (::std:: _Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
			::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (::std:: _Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
		::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt, class _FwdElem, class _Alloc, size_t _Size>
inline
_FwdElem* checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdElem (&_Dest)[_Size],
		_Alloc& _Al)
	{	
	return (checked_uninitialized_copy(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Al).base());
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (::std:: _Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
		::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Unchecked_uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
		return (::std:: _Uninit_move(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
			::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt, class _FwdIt, class _Alloc>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result _Checked_uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (::std:: _Uninit_move(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
		::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt, class _FwdElem, class _Alloc, size_t _Size>
inline
_FwdElem* _Checked_uninitialized_move(_InIt _First, _InIt _Last, _FwdElem (&_Dest)[_Size],
		_Alloc& _Al)
	{	
	return (_Checked_uninitialized_move(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Al).base());
	}

template<class _InIt, class _FwdIt, class _Alloc>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result _Checked_uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (::std:: _Uninit_move(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
		::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag()));
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	void unchecked_uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val)
	{	
		::std:: _Uninit_fill_n(_First, _Count, _Val, ::std:: _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result checked_uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val)
	{	
	::std:: _Uninit_fill_n(_First, _Count, _Val, ::std:: _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
	}

template<class _FwdElem, class _Diff, class _Tval, size_t _Size>
inline
void checked_uninitialized_fill_n(_FwdElem (&_First)[_Size], _Diff _Count, const _Tval& _Val)
	{	
	checked_uninitialized_fill_n(::stdext:: make_checked_array_iterator(_First, _Size), _Count, _Val);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result checked_uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val)
	{	
	::std:: _Uninit_fill_n(_First, _Count, _Val, ::std:: _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
	void unchecked_uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val, _Alloc& _Al)
	{	
		::std:: _Uninit_fill_n(_First, _Count, _Val, _Al,
			::std:: _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result checked_uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val, _Alloc& _Al)
	{	
	::std:: _Uninit_fill_n(_First, _Count, _Val, _Al,
		::std:: _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
	}

template<class _FwdElem, class _Diff, class _Tval, class _Alloc, size_t _Size>
inline
void checked_uninitialized_fill_n(_FwdElem (&_First)[_Size], _Diff _Count,
		const _Tval& _Val, _Alloc& _Al)
	{	
	checked_uninitialized_fill_n(::stdext:: make_checked_array_iterator(_First, _Size), _Count, _Val, _Al);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result checked_uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val, _Alloc& _Al)
	{	
	::std:: _Uninit_fill_n(_First, _Count, _Val, _Al,
		::std:: _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
	}

}


#pragma warning(pop)
#pragma pack(pop)
#line 956 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory"

#line 958 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory"
#line 959 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\memory"























#line 8 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"



#pragma pack(push,8)
#line 13 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

  


namespace std {

		
template<class _Ty,
	class _Alloc>
	class _List_nod
		: public _Container_base
	{	
protected:
	struct _Node;
	friend struct _Node;
	typedef typename _Alloc::template
		rebind<_Node>::other::pointer _Genptr;

    
    
    
    
#pragma warning(push)
#pragma warning(disable:4512)
	struct _Node
		{	
		_Genptr _Next;	
		_Genptr _Prev;	
		_Ty _Myval;	
		};
#pragma warning(pop)

	_List_nod(_Alloc _Al)
		: _Alnod(_Al)
		{	
		}

	typename _Alloc::template rebind<_Node>::other
		_Alnod;	
	};

		
template<class _Ty,
	class _Alloc>
	class _List_ptr
		: public _List_nod<_Ty, _Alloc>
	{	
protected:
	typedef typename _List_nod<_Ty, _Alloc>::_Node _Node;
	typedef typename _Alloc::template
		rebind<_Node>::other::pointer _Nodeptr;

	_List_ptr(_Alloc _Al)
		: _List_nod<_Ty, _Alloc>(_Al), _Alptr(_Al)
		{	
		}

	typename _Alloc::template rebind<_Nodeptr>::other
		_Alptr;	
	};

		
template<class _Ty,
	class _Alloc>
	class _List_val
		: public _List_ptr<_Ty, _Alloc>
	{	
public:
	typedef typename _Alloc::template rebind<_Ty>::other _Alty;

	_List_val(_Alloc _Al = _Alloc())
		: _List_ptr<_Ty, _Alloc>(_Al), _Alval(_Al)
		{	
		}

	_Alty _Alval;	
	};

		
template<class _Ty,
	class _Ax = allocator<_Ty> >
	class list
		: public _List_val<_Ty, _Ax>
	{	
public:
	typedef list<_Ty, _Ax> _Myt;
	typedef _List_val<_Ty, _Ax> _Mybase;
	typedef typename _Mybase::_Alty _Alloc;

protected:
	typedef typename _List_nod<_Ty, _Ax>::_Genptr _Genptr;
	typedef typename _List_nod<_Ty, _Ax>::_Node _Node;
	typedef typename _Alloc::template rebind<_Node>::other::pointer _Nodeptr;
	typedef typename _Alloc::template rebind<_Nodeptr>::other::reference _Nodepref;
	typedef typename _Alloc::reference _Vref;

	static _Nodepref _Nextnode(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)(*_Pnode)._Next);
		}

	static _Nodepref _Prevnode(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)(*_Pnode)._Prev);
		}

	static _Vref _Myval(_Nodeptr _Pnode)
		{	
		return ((_Vref)(*_Pnode)._Myval);
		}

public:
	typedef _Alloc allocator_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type _Dift;
	typedef _Dift difference_type;
	typedef typename _Alloc::pointer _Tptr;
	typedef typename _Alloc::const_pointer _Ctptr;
	typedef _Tptr pointer;
	typedef _Ctptr const_pointer;
	typedef typename _Alloc::reference _Reft;
	typedef _Reft reference;
	typedef typename _Alloc::const_reference const_reference;
	typedef typename _Alloc::value_type value_type;

		
	template <bool _Secure_validation> class _Const_iterator;
	friend class _Const_iterator<true>;

	friend class _Const_iterator<false>;
#line 144 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

	template <bool _Secure_validation>
	class _Const_iterator
		: public _Bidit<_Ty, _Dift, _Ctptr, const_reference>
		{	
	public:
		typedef _Const_iterator<_Secure_validation> _Myt_iter;
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef _Dift difference_type;
		typedef _Ctptr pointer;
		typedef const_reference reference;

		_Const_iterator()
			: _Ptr(0)
			{	
			}

 
		_Const_iterator(_Nodeptr _Pnode, const _Myt *_Plist=0)
			: _Ptr(_Pnode)
			{	
			this->_Adopt(_Plist);
			}

 












#line 183 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

 
	typedef typename _Secure_validation_helper<_Secure_validation>::_Checked_iterator_category _Checked_iterator_category;
	typedef typename _If<_Secure_validation,
		_Const_iterator<false>,
		_Unchanged_checked_iterator_base_type_tag>::_Result _Checked_iterator_base_type;

	friend _Const_iterator<false>;
	friend _Const_iterator<true>;

	_Const_iterator<false> _Checked_iterator_base() const
	{
		_Const_iterator<false> _Base(this->_Ptr, ((_Myt *)this->_Mycont));
		return _Base;
	}

	void _Checked_iterator_assign_from_base(_Const_iterator<false> _Base)
	{
		{ if (!(this->_Mycont == _Base._Mycont)) { (void) ((!!((("this->_Mycont == _Base._Mycont", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 201, 0, L"(\"this->_Mycont == _Base._Mycont\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 201, 0); } ; };
		this->_Ptr = _Base._Ptr;
	}
 #line 205 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

		const_reference operator*() const
			{	

 
			if (this->_Mycont == 0
				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
				{
				_Debug_message(L"list iterator not dereferencable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 213);
				{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 214, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 214, 0); } } __pragma(warning(pop)); };
				}
 


#line 220 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

			return (_Myval(_Ptr));
			}

		_Ctptr operator->() const
			{	
			return (&**this);
			}

		_Myt_iter& operator++()
			{	

 
			if (this->_Mycont == 0
				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
				{
				_Debug_message(L"list iterator not incrementable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 236);
				{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 237, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 237, 0); } } __pragma(warning(pop)); };
				}
 


#line 243 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

			_Ptr = _Nextnode(_Ptr);
			return (*this);
			}

		_Myt_iter operator++(int)
			{	
			_Myt_iter _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		_Myt_iter& operator--()
			{	

 
			if (this->_Mycont == 0 || (_Ptr = _Prevnode(_Ptr))
				== ((_Myt *)this->_Mycont)->_Myhead)
				{
				_Debug_message(L"list iterator not decrementable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 262);
				{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 263, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 263, 0); } } __pragma(warning(pop)); };
				}
 



#line 270 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

			return (*this);
			}

		_Myt_iter operator--(int)
			{	
			_Myt_iter _Tmp = *this;
			--*this;
			return (_Tmp);
			}

		bool operator==(const _Myt_iter& _Right) const
			{	

 
			_Compat(_Right);
 

#line 289 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

			return (_Ptr == _Right._Ptr);
			}

		bool operator!=(const _Myt_iter& _Right) const
			{	
			return (!(*this == _Right));
			}

		_Nodeptr _Mynode() const
			{	
			return (_Ptr);
			}


 
		void _Compat(const _Myt_iter& _Right) const
			{	
			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
				{
				_Debug_message(L"list iterators incompatible", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 309);
				{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { (void) ((!!((("Standard C++ Libraries Invalid Argument", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 310, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 310, 0); } } __pragma(warning(pop)); };
				}
			}
 

#line 316 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"
		_Nodeptr _Ptr;	
		};

	typedef _Const_iterator<true> const_iterator;

		
	template <bool _Secure_validation> class _Iterator;
	friend class _Iterator<true>;

	friend class _Iterator<false>;
#line 327 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

	template <bool _Secure_validation>
	class _Iterator
		: public _Const_iterator<_Secure_validation>
		{	
	public:
		friend class list<_Ty, _Ax>;
		typedef _Iterator<_Secure_validation> _Myt_iter;
		typedef _Const_iterator<_Secure_validation> _Mybase_iter;
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef _Dift difference_type;
		typedef _Tptr pointer;
		typedef _Reft reference;

		_Iterator()
			{	
			}

 
		_Iterator(_Nodeptr _Pnode, const _Myt *_Plist=0)
			: _Mybase_iter(_Pnode, _Plist)
			{	
			}

 










#line 364 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

 
	typedef typename _If<_Secure_validation,
		_Iterator<false>,
		_Unchanged_checked_iterator_base_type_tag>::_Result _Checked_iterator_base_type;

	friend _Iterator<false>;
	friend _Iterator<true>;

	_Iterator<false> _Checked_iterator_base() const
	{
		_Iterator<false> _Base(this->_Ptr, ((_Myt *)this->_Mycont));
		return _Base;
	}

	void _Checked_iterator_assign_from_base(_Iterator<false> _Base)
	{
		{ if (!(this->_Mycont == _Base._Mycont)) { (void) ((!!((("this->_Mycont == _Base._Mycont", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 381, 0, L"(\"this->_Mycont == _Base._Mycont\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 381, 0); } ; };
		this->_Ptr = _Base._Ptr;
	}
 #line 385 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

		reference operator*() const
			{	
			return ((reference)**(_Mybase_iter *)this);
			}

		_Tptr operator->() const
			{	
			return (&**this);
			}

		_Myt_iter& operator++()
			{	
			++(*(_Mybase_iter *)this);
			return (*this);
			}

		_Myt_iter operator++(int)
			{	
			_Myt_iter _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		_Myt_iter& operator--()
			{	
			--(*(_Mybase_iter *)this);
			return (*this);
			}

		_Myt_iter operator--(int)
			{	
			_Myt_iter _Tmp = *this;
			--*this;
			return (_Tmp);
			}
		};

	typedef _Iterator<true> iterator;

	typedef std::reverse_iterator<iterator> reverse_iterator;
	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

	list()
		: _Mybase(), _Myhead(_Buynode()), _Mysize(0)
		{	
		}

	explicit list(const _Alloc& _Al)
		: _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
		{	
		}

	explicit list(size_type _Count)
		: _Mybase(), _Mysize(0)
		{	
		_Ty _Val = _Ty();
		_Myhead = _Buynode();
		_Construct_n(_Count, _Val);
		}

	list(size_type _Count, const _Ty& _Val)
		: _Mybase(), _Myhead(_Buynode()), _Mysize(0)
		{	
		_Construct_n(_Count, _Val);
		}

	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
		: _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
		{	
		_Construct_n(_Count, _Val);
		}

	list(const _Myt& _Right)
		: _Mybase(_Right._Alval),
			_Myhead(_Buynode()), _Mysize(0)
		{	
		try {
		insert(begin(), _Right.begin(), _Right.end());
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	template<class _Iter>
		list(_Iter _First, _Iter _Last)
		: _Mybase(), _Myhead(_Buynode()), _Mysize(0)
		{	
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
		{	
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Construct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{	
		_Construct_n((size_type)_Count, (_Ty)_Val);
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, input_iterator_tag)
		{	
		try {
		insert(begin(), _First, _Last);
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	void _Construct_n(size_type _Count,
		const _Ty& _Val)
		{	
		try {
		_Insert_n(begin(), _Count, _Val);
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	~list()
		{	
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			assign(_Right.begin(), _Right.end());
		return (*this);
		}

 
	iterator begin()
		{	
		return (iterator(_Nextnode(_Myhead), this));
		}

	const_iterator begin() const
		{	
		return (const_iterator(_Nextnode(_Myhead), this));
		}

	iterator end()
		{	
		return (iterator(_Myhead, this));
		}

	const_iterator end() const
		{	
		return (const_iterator(_Myhead, this));
		}

 



















#line 567 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

	reverse_iterator rbegin()
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend()
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const
		{	
		return (const_reverse_iterator(begin()));
		}

	void resize(size_type _Newsize)
		{	
		resize(_Newsize, _Ty());
		}

	void resize(size_type _Newsize, _Ty _Val)
		{	
		if (_Mysize < _Newsize)
			_Insert_n(end(), _Newsize - _Mysize, _Val);
		else
			while (_Newsize < _Mysize)
				pop_back();
		}

	size_type size() const
		{	
		return (_Mysize);
		}

	size_type max_size() const
		{	
		return (this->_Alval.max_size());
		}

	bool empty() const
		{	
		return (_Mysize == 0);
		}

	allocator_type get_allocator() const
		{	
		return (this->_Alval);
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(--end()));
		}

	const_reference back() const
		{	
		return (*(--end()));
		}

	void push_front(const _Ty& _Val)
		{	
		_Insert(begin(), _Val);
		}

	void pop_front()
		{	
		erase(begin());
		}

	void push_back(const _Ty& _Val)
		{	
		_Insert(end(), _Val);
		}

	void pop_back()
		{	
		erase(--end());
		}

	template<class _Iter>
		void assign(_Iter _First, _Iter _Last)
		{	
		_Assign(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{	
		_Assign_n((size_type)_Count, (_Ty)_Val);
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{	
		clear();
		insert(begin(), _First, _Last);
		}

	void assign(size_type _Count, const _Ty& _Val)
		{	
		_Assign_n(_Count, _Val);
		}

	iterator insert(iterator _Where, const _Ty& _Val)
		{	
		_Insert(_Where, _Val);
		return (--_Where);
		}

	void _Insert(iterator _Where,
		const _Ty& _Val)
		{	

 
		if (_Where._Mycont != this)
			_Debug_message(L"list insert iterator outside range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 698);
 #line 700 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

		_Nodeptr _Pnode = _Where._Mynode();
		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);
		_Incsize(1);
		_Prevnode(_Pnode) = _Newnode;
		_Nextnode(_Prevnode(_Newnode)) = _Newnode;
		}

	void insert(iterator _Where, size_type _Count, const _Ty& _Val)
		{	
		_Insert_n(_Where, _Count, _Val);
		}

	template<class _Iter>
		void insert(iterator _Where, _Iter _First, _Iter _Last)
		{	
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _Count, _Iter _Val,
			_Int_iterator_tag)
		{	
		_Insert_n(_Where, (size_type)_Count, (_Ty)_Val);
		}

	template<class _Iter>
		void _Insert(iterator _Where,
			_Iter _First, _Iter _Last, input_iterator_tag)
		{	
		size_type _Num = 0;

		try {
		for (; _First != _Last; ++_First, ++_Num)
			_Insert(_Where, *_First);
		} catch (...) {
		for (; 0 < _Num; --_Num)
			{	
			iterator _Before = _Where;
			erase(--_Before);
			}
		throw;
		}
		}

	template<class _Iter>
		void _Insert(iterator _Where,
			_Iter _First, _Iter _Last, forward_iterator_tag)
		{	

 
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 751);
		if (_Debug_get_cont(_First) == this)
			_Debug_message(L"list insertion overlaps range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 753);
 #line 755 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

		_Iter _Next = _First;

		try {
		for (; _First != _Last; ++_First)
			_Insert(_Where, *_First);
		} catch (...) {
		for (; _Next != _First; ++_Next)
			{	
			iterator _Before = _Where;
			erase(--_Before);
			}
		throw;
		}
		}

	iterator erase(iterator _Where)
		{	

 
		if (_Where._Mycont != this || _Where._Ptr == _Myhead)
			_Debug_message(L"list erase iterator outside range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 776);
		_Nodeptr _Pnode = (_Where++)._Mynode();
		_Orphan_ptr(*this, _Pnode);

 

#line 783 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

		if (_Pnode != _Myhead)
			{	
			_Nextnode(_Prevnode(_Pnode)) = _Nextnode(_Pnode);
			_Prevnode(_Nextnode(_Pnode)) = _Prevnode(_Pnode);
			this->_Alnod.destroy(_Pnode);
			this->_Alnod.deallocate(_Pnode, 1);
			--_Mysize;
			}
		return (_Where);
		}

	iterator erase(iterator _First, iterator _Last)
		{	
		if (_First == begin() && _Last == end())
			{	
			clear();
			return (end());
			}
		else
			{	
			while (_First != _Last)
				_First = erase(_First);
			return (_Last);
			}
		}

	void clear()
		{	

 
		this->_Orphan_ptr(*this, 0);
 #line 816 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

		_Nodeptr _Pnext;
		_Nodeptr _Pnode = _Nextnode(_Myhead);
		_Nextnode(_Myhead) = _Myhead;
		_Prevnode(_Myhead) = _Myhead;
		_Mysize = 0;

		for (; _Pnode != _Myhead; _Pnode = _Pnext)
			{	
			_Pnext = _Nextnode(_Pnode);
			this->_Alnod.destroy(_Pnode);
			this->_Alnod.deallocate(_Pnode, 1);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this->_Alval == _Right._Alval)
			{	

 
			this->_Swap_all(_Right);
 #line 839 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

			std::swap(_Myhead, _Right._Myhead);
			std::swap(_Mysize, _Right._Mysize);
			}
		else
			{	
			iterator _Where = begin();
			splice(_Where, _Right);
			_Right.splice(_Right.begin(), *this, _Where, end());
			}
		}

	void splice(iterator _Where, _Myt& _Right)
		{	
		if (this != &_Right && !_Right.empty())
			{	
			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
				_Right._Mysize);
			}
		}

	void splice(iterator _Where, _Myt& _Right, iterator _First)
		{	

 
		if (_First == _Right.end())
			_Debug_message(L"list splice iterator outside range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 865);
		else

 

#line 871 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

			{	
			iterator _Last = _First;
			++_Last;
			if (this != &_Right
				|| (_Where != _First && _Where != _Last))
				_Splice(_Where, _Right, _First, _Last, 1);
			}
		}

	void splice(iterator _Where,
		_Myt& _Right, iterator _First, iterator _Last)
		{	
		if (_First != _Last && (this != &_Right || _Where != _Last))
			{	
			size_type _Count = 0;
			if (this == &_Right)
				;	
			else if (_First == _Right.begin() && _Last == _Right.end())
				_Count = _Right._Mysize;	
			else
				_Distance(_First, _Last, _Count);	
			_Splice(_Where, _Right, _First, _Last, _Count);
			}
		}

	void remove(const _Ty& _Val_arg)
		{	
		





		const _Ty _Val = _Val_arg;	
		iterator _Last = end();
		for (iterator _First = begin(); _First != _Last; )
			if (*_First == _Val)
				_First = erase(_First);
			else
				++_First;
		}

	template<class _Pr1>
		void remove_if(_Pr1 _Pred)
		{	
		iterator _Last = end();
		for (iterator _First = begin(); _First != _Last; )
			if (_Pred(*_First))
				_First = erase(_First);
			else
				++_First;
		}

	void unique()
		{	
		if (2 <= _Mysize)
			{	
			iterator _First = begin();
			iterator _After = _First;
			for (++_After; _After != end(); )
				if (*_First == *_After)
					_After = erase(_After);
				else
					_First = _After++;
			}
		}

	template<class _Pr2>
		void unique(_Pr2 _Pred)
		{	
		if (2 <= _Mysize)
			{	
			iterator _First = begin();
			iterator _After = _First;
			for (++_After; _After != end(); )
				if (_Pred(*_First, *_After))
					_After = erase(_After);
				else
					_First = _After++;
			}
		}

	void merge(_Myt& _Right)
		{	
		if (&_Right != this)
			{	
			iterator _First1 = begin(), _Last1 = end();
			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
			_Debug_order(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 960);
			_Debug_order(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 961);

			while (_First1 != _Last1 && _First2 != _Last2)
				if (_Debug_lt(*_First2, *_First1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 964))
					{	
					iterator _Mid2 = _First2;
					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
					_First2 = _Mid2;
					}
				else
					++_First1;

			if (_First2 != _Last2)
				_Splice(_Last1, _Right, _First2, _Last2,
					_Right._Mysize);	
			}
		}

	template<class _Pr3>
		void merge(_Myt& _Right, _Pr3 _Pred)
		{	
		if (&_Right != this)
			{	
			iterator _First1 = begin(), _Last1 = end();
			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
			_Debug_order(_First1, _Last1, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 986);
			_Debug_order(_First2, _Last2, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 987);

			while (_First1 != _Last1 && _First2 != _Last2)
				if (_Debug_lt_pred(_Pred, *_First2, *_First1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 990))
					{	
					iterator _Mid2 = _First2;
					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
					_First2 = _Mid2;
					}
				else
					++_First1;

			if (_First2 != _Last2)
				_Splice(_Last1, _Right, _First2, _Last2,
					_Right._Mysize);	
			}
		}

	void sort()
		{	
		if (2 <= _Mysize)
			{	
			const size_t _MAXBINS = 25;
			_Myt _Templist(this->_Alval), _Binlist[_MAXBINS + 1];
			size_t _Maxbin = 0;

			while (!empty())
				{	
				_Templist._Splice(_Templist.begin(), *this, begin(),
					++begin(), 1, true);	

				size_t _Bin;
				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
					++_Bin)
					{	
					_Binlist[_Bin].merge(_Templist);
					_Binlist[_Bin].swap(_Templist);
					}

				if (_Bin == _MAXBINS)
					_Binlist[_Bin - 1].merge(_Templist);
				else
					{	
					_Binlist[_Bin].swap(_Templist);
					if (_Bin == _Maxbin)
						++_Maxbin;
					}
				}

			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
				_Binlist[_Bin].merge(_Binlist[_Bin - 1]);	
			splice(begin(), _Binlist[_Maxbin - 1]);	
			}
		}

	template<class _Pr3>
		void sort(_Pr3 _Pred)
		{	
		if (2 <= _Mysize)
			{	
			const size_t _MAXBINS = 25;
			_Myt _Templist(this->_Alval), _Binlist[_MAXBINS + 1];
			size_t _Maxbin = 0;

			while (!empty())
				{	
				_Templist._Splice(_Templist.begin(), *this, begin(),
					++begin(), 1, true);	

				size_t _Bin;
				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
					++_Bin)
					{	
					_Binlist[_Bin].merge(_Templist, _Pred);
					_Binlist[_Bin].swap(_Templist);
					}

				if (_Bin == _MAXBINS)
					_Binlist[_Bin - 1].merge(_Templist, _Pred);
				else
					{	
					_Binlist[_Bin].swap(_Templist);
					if (_Bin == _Maxbin)
						++_Maxbin;
					}
				}

			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
					_Pred);	
			splice(begin(), _Binlist[_Maxbin - 1]);	
			}
		}

	void reverse()
		{	
		if (2 <= _Mysize)
			{	
			iterator _Last = end();
			for (iterator _Next = ++begin(); _Next != _Last; )
				{	
				iterator _Before = _Next;
				_Splice(begin(), *this, _Before, ++_Next, 1);
				}
			}
		}

	void _Splice(iterator _Where,
		_Myt& _Right, iterator _First, iterator _Last,
		size_type _Count, bool _Keep = false)
		{	
 
		if (_Where._Mycont != this)
			_Debug_message(L"list splice iterator outside range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list", 1100);
		if (this->_Alval == _Right._Alval)
			{	
			if (!_Keep && this != &_Right)
				for (iterator _Next = _First; _Next != _Last; )
					_Orphan_ptr(_Right, (_Next++)._Ptr);

 



#line 1112 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

			if (this != &_Right)
				{	
				_Incsize(_Count);
				_Right._Mysize -= _Count;
				}
			_Nextnode(_Prevnode(_First._Mynode())) = _Last._Mynode();
			_Nextnode(_Prevnode(_Last._Mynode())) = _Where._Mynode();
			_Nextnode(_Prevnode(_Where._Mynode())) = _First._Mynode();
			_Nodeptr _Pnode = _Prevnode(_Where._Mynode());
			_Prevnode(_Where._Mynode()) = _Prevnode(_Last._Mynode());
			_Prevnode(_Last._Mynode()) = _Prevnode(_First._Mynode());
			_Prevnode(_First._Mynode()) = _Pnode;
			}
		else
			{	
			insert(_Where, _First, _Last);
			_Right.erase(_First, _Last);
			}
        }

protected:
	void _Assign_n(size_type _Count, const _Ty& _Val)
		{	
		_Ty _Tmp = _Val;	
		clear();
		_Insert_n(begin(), _Count, _Tmp);
		}

	_Nodeptr _Buynode()
		{	
		_Nodeptr _Pnode = this->_Alnod.allocate(1);
		int _Linkcnt = 0;

		try {
		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);
		++_Linkcnt;
		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);
		} catch (...) {
		if (0 < _Linkcnt)
			this->_Alptr.destroy(&_Nextnode(_Pnode));
		this->_Alnod.deallocate(_Pnode, 1);
		throw;
		}
		return (_Pnode);
		}

	_Nodeptr _Buynode(_Nodeptr _Next,
		_Nodeptr _Prev, const _Ty& _Val)
		{	
		_Nodeptr _Pnode = this->_Alnod.allocate(1);
		int _Linkcnt = 0;

		try {
		this->_Alptr.construct(&_Nextnode(_Pnode), _Next);
		++_Linkcnt;
		this->_Alptr.construct(&_Prevnode(_Pnode), _Prev);
		++_Linkcnt;
		this->_Alval.construct(&_Myval(_Pnode), _Val);
		} catch (...) {
		if (1 < _Linkcnt)
			this->_Alptr.destroy(&_Prevnode(_Pnode));
		if (0 < _Linkcnt)
			this->_Alptr.destroy(&_Nextnode(_Pnode));
		this->_Alnod.deallocate(_Pnode, 1);
		throw;
		}
		return (_Pnode);
		}

	void _Tidy()
		{	
		clear();
		this->_Alptr.destroy(&_Nextnode(_Myhead));
		this->_Alptr.destroy(&_Prevnode(_Myhead));
		this->_Alnod.deallocate(_Myhead, 1);
		_Myhead = 0;
		}

	void _Insert_n(iterator _Where,
		size_type _Count, const _Ty& _Val)
		{	
		size_type _Countsave = _Count;

		try {
		for (; 0 < _Count; --_Count)
			_Insert(_Where, _Val);
		} catch (...) {
		for (; _Count < _Countsave; ++_Count)
			{	
			iterator _Before = _Where;
			erase(--_Before);
			}
		throw;
		}
		}

	void _Incsize(size_type _Count)
		{	
		if (max_size() - _Mysize < _Count)
			throw length_error("list<T> too long");
		_Mysize += _Count;
		}

	static void _Xran()
		{	
		throw out_of_range("invalid list<T> subscript");
		}

	static void _Xinvarg()
		{	
		throw invalid_argument("invalid list<T> argument");
		}

 
	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
		{	
		_Lockit _Lock(3);
		const_iterator **_Pnext = (const_iterator **)&_Cont._Myfirstiter;
		while (*_Pnext != 0)
			if ((*_Pnext)->_Ptr == _Myhead
				|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
				_Pnext = (const_iterator **)&(*_Pnext)->_Mynextiter;
			else
				{	
				(*_Pnext)->_Mycont = 0;
				*_Pnext = (const_iterator *)(*_Pnext)->_Mynextiter;
				}
		}
 #line 1242 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

	_Nodeptr _Myhead;	
	size_type _Mysize;	
	};

	
template <class _Ty, class _Ax>
	class _Move_operation_category<list<_Ty, _Ax> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};

		
template<class _Ty, class _Alloc> inline
	void swap(list<_Ty, _Alloc>& _Left, list<_Ty, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator==(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator!=(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	
	return (lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<=(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>=(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}


}


#pragma pack(pop)
#line 1318 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"

#line 1320 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"
#line 1321 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list"























#line 50 "c:\\qt-3.3.8\\include\\qvaluelist.h"
#line 51 "c:\\qt-3.3.8\\include\\qvaluelist.h"




#pragma warning(disable:4284) 
#line 57 "c:\\qt-3.3.8\\include\\qvaluelist.h"

template <class T>
class QValueListNode
{
public:
    QValueListNode( const T& t ) : data( t ) { }
    QValueListNode() { }

    
    virtual ~QValueListNode() { }
#line 68 "c:\\qt-3.3.8\\include\\qvaluelist.h"

    QValueListNode<T>* next;
    QValueListNode<T>* prev;
    T data;
};

template<class T>
class QValueListIterator
{
 public:
    


    typedef QValueListNode<T>* NodePtr;

    typedef std::bidirectional_iterator_tag  iterator_category;
#line 85 "c:\\qt-3.3.8\\include\\qvaluelist.h"
    typedef T        value_type;
    typedef size_t size_type;

    typedef ptrdiff_t  difference_type;


#line 92 "c:\\qt-3.3.8\\include\\qvaluelist.h"
    typedef T*   pointer;
    typedef T& reference;

    


    NodePtr node;

    


    QValueListIterator() : node( 0 ) {}
    QValueListIterator( NodePtr p ) : node( p ) {}
    QValueListIterator( const QValueListIterator<T>& it ) : node( it.node ) {}

    bool operator==( const QValueListIterator<T>& it ) const { return node == it.node; }
    bool operator!=( const QValueListIterator<T>& it ) const { return node != it.node; }
    const T& operator*() const { return node->data; }
    T& operator*() { return node->data; }
    
    

    QValueListIterator<T>& operator++() {
	node = node->next;
	return *this;
    }

    QValueListIterator<T> operator++(int) {
	QValueListIterator<T> tmp = *this;
	node = node->next;
	return tmp;
    }

    QValueListIterator<T>& operator--() {
	node = node->prev;
	return *this;
    }

    QValueListIterator<T> operator--(int) {
	QValueListIterator<T> tmp = *this;
	node = node->prev;
	return tmp;
    }

    QValueListIterator<T>& operator+=( int j ) {
	while ( j-- )
	    node = node->next;
	return *this;
    }

    QValueListIterator<T>& operator-=( int j ) {
	while ( j-- )
	    node = node->prev;
	return *this;
    }

};

template<class T>
class QValueListConstIterator
{
 public:
    


    typedef QValueListNode<T>* NodePtr;

    typedef std::bidirectional_iterator_tag  iterator_category;
#line 161 "c:\\qt-3.3.8\\include\\qvaluelist.h"
    typedef T        value_type;
    typedef size_t size_type;

    typedef ptrdiff_t  difference_type;


#line 168 "c:\\qt-3.3.8\\include\\qvaluelist.h"
    typedef const T*   pointer;
    typedef const T& reference;

    


    NodePtr node;

    


    QValueListConstIterator() : node( 0 ) {}
    QValueListConstIterator( NodePtr p ) : node( p ) {}
    QValueListConstIterator( const QValueListConstIterator<T>& it ) : node( it.node ) {}
    QValueListConstIterator( const QValueListIterator<T>& it ) : node( it.node ) {}

    bool operator==( const QValueListConstIterator<T>& it ) const { return node == it.node; }
    bool operator!=( const QValueListConstIterator<T>& it ) const { return node != it.node; }
    const T& operator*() const { return node->data; }
    
    

    QValueListConstIterator<T>& operator++() {
	node = node->next;
	return *this;
    }

    QValueListConstIterator<T> operator++(int) {
	QValueListConstIterator<T> tmp = *this;
	node = node->next;
	return tmp;
    }

    QValueListConstIterator<T>& operator--() {
	node = node->prev;
	return *this;
    }

    QValueListConstIterator<T> operator--(int) {
	QValueListConstIterator<T> tmp = *this;
	node = node->prev;
	return tmp;
    }
};

template <class T>
class QValueListPrivate : public QShared
{
public:
    


    typedef QValueListIterator<T> Iterator;
    typedef QValueListConstIterator<T> ConstIterator;
    typedef QValueListNode<T> Node;
    typedef QValueListNode<T>* NodePtr;
    typedef size_t size_type;

    


    QValueListPrivate();
    QValueListPrivate( const QValueListPrivate<T>& _p );

    void derefAndDelete() 
    {
	if ( deref() )
	    delete this;
    }


    
    virtual
#line 242 "c:\\qt-3.3.8\\include\\qvaluelist.h"
    ~QValueListPrivate();

    Iterator insert( Iterator it, const T& x );
    Iterator remove( Iterator it );
    NodePtr find( NodePtr start, const T& x ) const;
    int findIndex( NodePtr start, const T& x ) const;
    uint contains( const T& x ) const;
    uint remove( const T& x );
    NodePtr at( size_type i ) const;
    void clear();

    NodePtr node;
    size_type nodes;
};

template <class T>
inline QValueListPrivate<T>::QValueListPrivate()
{
    node = new Node; node->next = node->prev = node; nodes = 0;
}

template <class T>
inline QValueListPrivate<T>::QValueListPrivate( const QValueListPrivate<T>& _p )
    : QShared()
{
    node = new Node; node->next = node->prev = node; nodes = 0;
    Iterator b( _p.node->next );
    Iterator e( _p.node );
    Iterator i( node );
    while( b != e )
	insert( i, *b++ );
}

template <class T>
inline QValueListPrivate<T>::~QValueListPrivate() {
    NodePtr p = node->next;
    while( p != node ) {
	NodePtr x = p->next;
	delete p;
	p = x;
    }
    delete node;
}

template <class T>
inline typename QValueListPrivate<T>::Iterator QValueListPrivate<T>::insert( typename QValueListPrivate<T>::Iterator it, const T& x )
{
    NodePtr p = new Node( x );
    p->next = it.node;
    p->prev = it.node->prev;
    it.node->prev->next = p;
    it.node->prev = p;
    nodes++;
    return p;
}

template <class T>
inline typename QValueListPrivate<T>::Iterator QValueListPrivate<T>::remove( typename QValueListPrivate<T>::Iterator it )
{
    ((it.node != node) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","it.node != node","c:\\qt-3.3.8\\include\\qvaluelist.h",301));
    NodePtr next = it.node->next;
    NodePtr prev = it.node->prev;
    prev->next = next;
    next->prev = prev;
    delete it.node;
    nodes--;
    return Iterator( next );
}

template <class T>
inline typename QValueListPrivate<T>::NodePtr QValueListPrivate<T>::find( typename QValueListPrivate<T>::NodePtr start, const T& x ) const
{
    ConstIterator first( start );
    ConstIterator last( node );
    while( first != last) {
	if ( *first == x )
	    return first.node;
	++first;
    }
    return last.node;
}

template <class T>
inline int QValueListPrivate<T>::findIndex( typename QValueListPrivate<T>::NodePtr start, const T& x ) const
{
    ConstIterator first( start );
    ConstIterator last( node );
    int pos = 0;
    while( first != last) {
	if ( *first == x )
	    return pos;
	++first;
	++pos;
    }
    return -1;
}

template <class T>
inline uint QValueListPrivate<T>::contains( const T& x ) const
{
    uint result = 0;
    Iterator first = Iterator( node->next );
    Iterator last = Iterator( node );
    while( first != last) {
	if ( *first == x )
	    ++result;
	++first;
    }
    return result;
}

template <class T>
inline uint QValueListPrivate<T>::remove( const T& _x )
{
    const T x = _x;
    uint result = 0;
    Iterator first = Iterator( node->next );
    Iterator last = Iterator( node );
    while( first != last) {
	if ( *first == x ) {
	    first = remove( first );
	    ++result;
	} else
	    ++first;
    }
    return result;
}

template <class T>
inline typename QValueListPrivate<T>::NodePtr QValueListPrivate<T>::at( size_type i ) const
{
    ((i <= nodes) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","i <= nodes","c:\\qt-3.3.8\\include\\qvaluelist.h",373));
    NodePtr p = node->next;
    for( size_type x = 0; x < i; ++x )
	p = p->next;
    return p;
}

template <class T>
inline void QValueListPrivate<T>::clear()
{
    nodes = 0;
    NodePtr p = node->next;
    while( p != node ) {
	NodePtr next = p->next;
	delete p;
	p = next;
    }
    node->next = node->prev = node;
}





#line 398 "c:\\qt-3.3.8\\include\\qvaluelist.h"


#line 401 "c:\\qt-3.3.8\\include\\qvaluelist.h"



#line 405 "c:\\qt-3.3.8\\include\\qvaluelist.h"

template <class T> class QDeepCopy;

template <class T>
class QValueList
{
public:
    


    typedef QValueListIterator<T> iterator;
    typedef QValueListConstIterator<T> const_iterator;
    typedef T value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef size_t size_type;

    typedef ptrdiff_t  difference_type;


#line 428 "c:\\qt-3.3.8\\include\\qvaluelist.h"

    


    QValueList() { sh = new QValueListPrivate<T>; }
    QValueList( const QValueList<T>& l ) { sh = l.sh; sh->ref(); }

    QValueList( const std::list<T>& l )
    {
	sh = new QValueListPrivate<T>;
	qCopy( l.begin(), l.end(), std::back_inserter( *this ) );
    }
#line 441 "c:\\qt-3.3.8\\include\\qvaluelist.h"
    ~QValueList() { sh->derefAndDelete(); }

    QValueList<T>& operator= ( const QValueList<T>& l )
    {
	l.sh->ref();
	sh->derefAndDelete();
	sh = l.sh;
	return *this;
    }

    QValueList<T>& operator= ( const std::list<T>& l )
    {
	detach();
	qCopy( l.begin(), l.end(), std::back_inserter( *this ) );
	return *this;
    }
    bool operator== ( const std::list<T>& l ) const
    {
	if ( size() != l.size() )
	    return FALSE;
	const_iterator it2 = begin();

	typename
#line 465 "c:\\qt-3.3.8\\include\\qvaluelist.h"
	std::list<T>::const_iterator it = l.begin();
	for ( ; it2 != end(); ++it2, ++it )
	if ( !((*it2) == (*it)) )
	    return FALSE;
	return TRUE;
    }
#line 472 "c:\\qt-3.3.8\\include\\qvaluelist.h"
    bool operator== ( const QValueList<T>& l ) const;
    bool operator!= ( const QValueList<T>& l ) const { return !( *this == l ); }
    iterator begin() { detach(); return iterator( sh->node->next ); }
    const_iterator begin() const { return const_iterator( sh->node->next ); }
    const_iterator constBegin() const { return const_iterator( sh->node->next ); }
    iterator end() { detach(); return iterator( sh->node ); }
    const_iterator end() const { return const_iterator( sh->node ); }
    const_iterator constEnd() const { return const_iterator( sh->node ); }
    iterator insert( iterator it, const T& x ) { detach(); return sh->insert( it, x ); }
    uint remove( const T& x ) { detach(); return sh->remove( x ); }
    void clear();

    
    QValueList<T>& operator<< ( const T& x )
    {
	append( x );
	return *this;
    }

    size_type size() const { return sh->nodes; }
    bool empty() const { return sh->nodes == 0; }
    void push_front( const T& x ) { detach(); sh->insert( begin(), x ); }
    void push_back( const T& x ) { detach(); sh->insert( end(), x ); }
    iterator erase( iterator pos ) { detach(); return sh->remove( pos ); }
    iterator erase( iterator first, iterator last );
    reference front() { ; return *begin(); }
    const_reference front() const { ; return *begin(); }
    reference back() { ; return *(--end()); }
    const_reference back() const { ; return *(--end()); }
    void pop_front() { ; erase( begin() ); }
    void pop_back() {
	;
	iterator tmp = end();
	erase( --tmp );
    }
    void insert( iterator pos, size_type n, const T& x );
    
    
    
    






    QValueList<T> operator+ ( const QValueList<T>& l ) const;
    QValueList<T>& operator+= ( const QValueList<T>& l );

    iterator fromLast() { detach(); return iterator( sh->node->prev ); }
    const_iterator fromLast() const { return const_iterator( sh->node->prev ); }

    bool isEmpty() const { return ( sh->nodes == 0 ); }

    iterator append( const T& x ) { detach(); return sh->insert( end(), x ); }
    iterator prepend( const T& x ) { detach(); return sh->insert( begin(), x ); }

    iterator remove( iterator it ) { detach(); return sh->remove( it ); }

    T& first() { ; detach(); return sh->node->next->data; }
    const T& first() const { ; return sh->node->next->data; }
    T& last() { ; detach(); return sh->node->prev->data; }
    const T& last() const { ; return sh->node->prev->data; }

    T& operator[] ( size_type i ) { ; detach(); return sh->at(i)->data; }
    const T& operator[] ( size_type i ) const { ; return sh->at(i)->data; }
    iterator at( size_type i ) { ; detach(); return iterator( sh->at(i) ); }
    const_iterator at( size_type i ) const { ; return const_iterator( sh->at(i) ); }
    iterator find ( const T& x ) { detach(); return iterator( sh->find( sh->node->next, x) ); }
    const_iterator find ( const T& x ) const { return const_iterator( sh->find( sh->node->next, x) ); }
    iterator find ( iterator it, const T& x ) { detach(); return iterator( sh->find( it.node, x ) ); }
    const_iterator find ( const_iterator it, const T& x ) const { return const_iterator( sh->find( it.node, x ) ); }
    int findIndex( const T& x ) const { return sh->findIndex( sh->node->next, x) ; }
    size_type contains( const T& x ) const { return sh->contains( x ); }

    size_type count() const { return sh->nodes; }

    QValueList<T>& operator+= ( const T& x )
    {
	append( x );
	return *this;
    }
    typedef QValueListIterator<T> Iterator;
    typedef QValueListConstIterator<T> ConstIterator;
    typedef T ValueType;

protected:
    


    void detach() { if ( sh->count > 1 ) detachInternal(); }

    


    QValueListPrivate<T>* sh;

private:
    void detachInternal();

    friend class QDeepCopy< QValueList<T> >;
};

template <class T>
inline bool QValueList<T>::operator== ( const QValueList<T>& l ) const
{
    if ( size() != l.size() )
	return FALSE;
    const_iterator it2 = begin();
    const_iterator it = l.begin();
    for( ; it != l.end(); ++it, ++it2 )
	if ( !( *it == *it2 ) )
	    return FALSE;
    return TRUE;
}

template <class T>
inline void QValueList<T>::clear()
{
    if ( sh->count == 1 ) sh->clear(); else { sh->deref(); sh = new QValueListPrivate<T>; }
}

template <class T>
inline typename QValueList<T>::iterator QValueList<T>::erase( typename QValueList<T>::iterator first, typename QValueList<T>::iterator last )
{
    while ( first != last )
	erase( first++ );
    return last;
}


template <class T>
inline void QValueList<T>::insert( typename QValueList<T>::iterator pos, size_type n, const T& x )
{
    for ( ; n > 0; --n )
	insert( pos, x );
}

template <class T>
inline QValueList<T> QValueList<T>::operator+ ( const QValueList<T>& l ) const
{
    QValueList<T> l2( *this );
    for( const_iterator it = l.begin(); it != l.end(); ++it )
	l2.append( *it );
    return l2;
}

template <class T>
inline QValueList<T>& QValueList<T>::operator+= ( const QValueList<T>& l )
{
    QValueList<T> copy = l;
    for( const_iterator it = copy.begin(); it != copy.end(); ++it )
	append( *it );
    return *this;
}

template <class T>
inline void QValueList<T>::detachInternal()
{
    sh->deref(); sh = new QValueListPrivate<T>( *sh );
}


template <class T>
inline QDataStream& operator>>( QDataStream& s, QValueList<T>& l )
{
    l.clear();
    Q_UINT32 c;
    s >> c;
    for( Q_UINT32 i = 0; i < c; ++i )
    {
	T t;
	s >> t;
	l.append( t );
	if ( s.atEnd() )
	    break;
    }
    return s;
}

template <class T>
inline QDataStream& operator<<( QDataStream& s, const QValueList<T>& l )
{
    s << (Q_UINT32)l.size();
    QValueListConstIterator<T> it = l.begin();
    for( ; it != l.end(); ++it )
	s << *it;
    return s;
}
#line 662 "c:\\qt-3.3.8\\include\\qvaluelist.h"



#line 1 "c:\\qt-3.3.8\\include\\qwinexport.h"










































#line 44 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 49 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 54 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 59 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 65 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 70 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 75 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 81 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 87 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 94 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 101 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 106 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 112 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 118 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 124 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 130 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 136 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 141 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 146 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 151 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 156 "c:\\qt-3.3.8\\include\\qwinexport.h"



extern template class __declspec(dllimport) QValueListIterator<bool>;
extern template class __declspec(dllimport) QValueList<bool>;
extern template class __declspec(dllimport) QValueListIterator<int>;
extern template class __declspec(dllimport) QValueList<int>;
#line 164 "c:\\qt-3.3.8\\include\\qwinexport.h"



extern template class __declspec(dllimport) QValueListIterator<QRect>;
extern template class __declspec(dllimport) QValueList<QRect>;
#line 170 "c:\\qt-3.3.8\\include\\qwinexport.h"



extern template class __declspec(dllimport) QValueListIterator<QString>;
extern template class __declspec(dllimport) QValueList<QString>;
#line 176 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 182 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 187 "c:\\qt-3.3.8\\include\\qwinexport.h"








#line 196 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 202 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 207 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 211 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 218 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 222 "c:\\qt-3.3.8\\include\\qwinexport.h"
#line 666 "c:\\qt-3.3.8\\include\\qvaluelist.h"
#line 667 "c:\\qt-3.3.8\\include\\qvaluelist.h"
#line 47 "c:\\qt-3.3.8\\include\\qmap.h"
#line 48 "c:\\qt-3.3.8\\include\\qmap.h"



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map"

#pragma once



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

#pragma once








#pragma pack(push,8)
#pragma warning(push,3)

 #pragma warning(disable:4127)
#line 16 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

  


namespace std {

		
template<class _Traits>
	class _Tree_nod
		: public _Traits	
	{	
protected:
	struct _Node;
	friend struct _Node;

	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;
	typedef typename _Traits::value_type value_type;
	typedef typename allocator_type::template
		rebind<_Node>::other::pointer _Genptr;

	struct _Node
		{	
		_Node(_Genptr _Larg, _Genptr _Parg, _Genptr _Rarg,
			const value_type& _Val, char _Carg)
			: _Left(_Larg), _Parent(_Parg), _Right(_Rarg),
				_Myval(_Val), _Color(_Carg), _Isnil(false)
			{	
			}

		_Genptr _Left;	
		_Genptr _Parent;	
		_Genptr _Right;	
		value_type _Myval;	
		char _Color;	
		char _Isnil;	
		};

	_Tree_nod(const key_compare& _Parg,
		allocator_type _Al)
		: _Traits(_Parg), _Alnod(_Al)
		{	
		}

	typename allocator_type::template rebind<_Node>::other
		_Alnod;	
	};

		
template<class _Traits>
	class _Tree_ptr
		: public _Tree_nod<_Traits>
	{	
 
public:
 

#line 74 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
	typedef typename _Tree_nod<_Traits>::_Node _Node;
	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;
	typedef typename allocator_type::template
		rebind<_Node>::other::pointer _Nodeptr;

	_Tree_ptr(const key_compare& _Parg,
		allocator_type _Al)
		: _Tree_nod<_Traits>(_Parg, _Al), _Alptr(_Al)
		{	
		}

	typename allocator_type::template rebind<_Nodeptr>::other
		_Alptr;	
	};

		
template<class _Traits>
	class _Tree_val
		: public _Tree_ptr<_Traits>
	{	
protected:
	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;

	_Tree_val(const key_compare& _Parg,
		allocator_type _Al)
		: _Tree_ptr<_Traits>(_Parg, _Al), _Alval(_Al)
		{	
		}

	allocator_type _Alval;	
	};

		
template<class _Traits>
	class _Tree
		: public _Tree_val<_Traits>
	{	
public:
	typedef _Tree<_Traits> _Myt;
	typedef _Tree_val<_Traits> _Mybase;
	typedef typename _Traits::key_type key_type;
	typedef typename _Traits::key_compare key_compare;
	typedef typename _Traits::value_compare value_compare;
	typedef typename _Traits::value_type value_type;
	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::_ITptr _ITptr;
	typedef typename _Traits::_IReft _IReft;

protected:

	typedef typename _Tree_nod<_Traits>::_Genptr _Genptr;

	typedef typename _Tree_nod<_Traits>::_Node _Node;

	enum _Redbl
		{	
		_Red, _Black};
	typedef typename allocator_type::template rebind<_Node>::other::pointer _Nodeptr;
	typedef typename allocator_type::template rebind<_Nodeptr>::other::reference _Nodepref;
	typedef typename allocator_type::template rebind<key_type>::other::const_reference _Keyref;
	typedef typename allocator_type::template rebind<char>::other::reference _Charref;
	typedef typename allocator_type::template rebind<value_type>::other::reference _Vref;

	static _Charref _Color(_Nodeptr _Pnode)
		{	
		return ((_Charref)(*_Pnode)._Color);
		}

	static _Charref _Isnil(_Nodeptr _Pnode)
		{	
		return ((_Charref)(*_Pnode)._Isnil);
		}

	static _Keyref _Key(_Nodeptr _Pnode)
		{	
		return (_Mybase::_Kfn(_Myval(_Pnode)));
		}

	static _Nodepref _Left(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)(*_Pnode)._Left);
		}

	static _Nodepref _Parent(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)(*_Pnode)._Parent);
		}

	static _Nodepref _Right(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)(*_Pnode)._Right);
		}

	static _Vref _Myval(_Nodeptr _Pnode)
		{	
		return ((_Vref)(*_Pnode)._Myval);
		}

public:
	typedef typename allocator_type::size_type size_type;
	typedef typename allocator_type::difference_type _Dift;
	typedef _Dift difference_type;
	typedef typename allocator_type::template rebind<value_type>::other::pointer _Tptr;
	typedef typename allocator_type::template rebind<value_type>::other::const_pointer _Ctptr;
	typedef typename allocator_type::template rebind<value_type>::other::reference _Reft;
	typedef _Tptr pointer;
	typedef _Ctptr const_pointer;
	typedef _Reft reference;
	typedef typename allocator_type::template rebind<value_type>::other::const_reference
		const_reference;

		
	class const_iterator;
	friend class const_iterator;

	class const_iterator
		: public _Bidit<value_type, _Dift, _Ctptr, const_reference>
	{	
	public:
		friend class _Tree<_Traits>;
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Dift difference_type;
		typedef _Ctptr pointer;
		typedef const_reference reference;


		typedef _Range_checked_iterator_tag _Checked_iterator_category;
#line 204 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

		const_iterator()
			: _Ptr(0)
			{	
			}

 
 

		const_iterator(_Nodeptr _Pnode, const _Myt *_Plist=0)
			: _Ptr(_Pnode)
			{	
			this->_Adopt(_Plist);
			}

 
















#line 237 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

		const_reference operator*() const
			{	

 
			if (this->_Mycont == 0
				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
				{
				_Debug_message(L"map/set iterator not dereferencable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 245);
				{ (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 246, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 246, 0); };
				}
 


#line 252 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

			return (_Myval(_Ptr));
			}

		_Ctptr operator->() const
			{	
			return (&**this);
			}

		const_iterator& operator++()
			{	
			_Inc();
			return (*this);
			}

		const_iterator operator++(int)
			{	
			const_iterator _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		const_iterator& operator--()
			{	
			_Dec();
			return (*this);
			}

		const_iterator operator--(int)
			{	
			const_iterator _Tmp = *this;
			--*this;
			return (_Tmp);
			}

		bool operator==(const const_iterator& _Right) const
			{	

 
			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
				{
				_Debug_message(L"map/set iterators incompatible", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 293);
				{ (void) ((!!((("Standard C++ Libraries Invalid Argument", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 294, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 294, 0); };
				}
 

#line 299 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

			return (_Ptr == _Right._Ptr);
			}

		bool operator!=(const const_iterator& _Right) const
			{	
			return (!(*this == _Right));
			}

		void _Dec()
			{	

 
			if (this->_Mycont == 0)
				{
				_Debug_message(L"map/set iterator not decrementable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 314);
				{ (void) ((!!((("Standard C++ Libraries Invalid Argument", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 315, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 315, 0); };
				}
 

#line 320 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

			if (_Isnil(_Ptr))
			{
				_Ptr = _Right(_Ptr);	
   				if (_Isnil(_Ptr))

				{
					_Debug_message(L"map/set iterator not decrementable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 327);
					{ (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 328, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 328, 0); };
				}






#line 337 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
			}
			else if (!_Isnil(_Left(_Ptr)))
				_Ptr = _Max(_Left(_Ptr));	
			else
				{	
				_Nodeptr _Pnode;
				while (!_Isnil(_Pnode = _Parent(_Ptr))
					&& _Ptr == _Left(_Pnode))
					_Ptr = _Pnode;	
				if (_Isnil(_Ptr))
 
 					{
					_Debug_message(L"map/set iterator not decrementable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 349);
					{ (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 350, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 350, 0); };
					}
 





#line 359 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
				else
					_Ptr = _Pnode;	
				}
			}

		void _Inc()
			{	

 
			if (this->_Mycont == 0 || _Isnil(_Ptr))
				{
				_Debug_message(L"map/set iterator not incrementable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 370);
				{ (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 371, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 371, 0); };
				}
 






#line 381 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

			else if (!_Isnil(_Right(_Ptr)))
				_Ptr = _Min(_Right(_Ptr));	
			else
				{	
				_Nodeptr _Pnode;
				while (!_Isnil(_Pnode = _Parent(_Ptr))
					&& _Ptr == _Right(_Pnode))
					_Ptr = _Pnode;	
				_Ptr = _Pnode;	
				}
			}

		_Nodeptr _Mynode() const
			{	
			return (_Ptr);
			}

 
    public:
 

#line 404 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
		_Nodeptr _Ptr;	
		};

		
	class iterator;
	friend class iterator;

	class iterator
		: public const_iterator
	{	
	public:
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Dift difference_type;
		typedef _ITptr pointer;
		typedef _IReft reference;

		iterator()
			{	
			}

 
 

		iterator(_Nodeptr _Pnode, const _Myt *_Plist=0)
			: const_iterator(_Pnode, _Plist)
			{	
			}

 














#line 448 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

		reference operator*() const
			{	
			return ((reference)**(const_iterator *)this);
			}

		pointer operator->() const
			{	
			return (&**this);
			}

		iterator& operator++()
			{	
			++(*(const_iterator *)this);
			return (*this);
			}

		iterator operator++(int)
			{	
			iterator _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		iterator& operator--()
			{	
			--(*(const_iterator *)this);
			return (*this);
			}

		iterator operator--(int)
			{	
			iterator _Tmp = *this;
			--*this;
			return (_Tmp);
			}
		};

	typedef std::reverse_iterator<iterator> reverse_iterator;
	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
	typedef pair<iterator, bool> _Pairib;
	typedef pair<iterator, iterator> _Pairii;
	typedef pair<const_iterator, const_iterator> _Paircc;

	explicit _Tree(const key_compare& _Parg,
		const allocator_type& _Al)
		: _Mybase(_Parg, _Al)
		{	
		_Init();
		}

	_Tree(const value_type *_First, const value_type *_Last,
		const key_compare& _Parg, const allocator_type& _Al)
		: _Mybase(_Parg, _Al)
		{	
		_Init();
		try {
		insert(_First, _Last);
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	_Tree(const _Myt& _Right)
		: _Mybase(_Right.key_comp(), _Right.get_allocator())
		{	
		_Init();
		try {
		_Copy(_Right);
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	~_Tree()
		{	
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			erase(begin(), end());
			this->comp = _Right.comp;
			_Copy(_Right);
			}
		return (*this);
		}

	iterator begin()
		{	
		return (iterator(_Lmost(), this));
		}

	const_iterator begin() const
		{	
		return (const_iterator(_Lmost(), this));
		}

	iterator end()
		{	
		return (iterator(_Myhead, this));
		}

	const_iterator end() const
		{	
		return (const_iterator(_Myhead, this));
		}

	reverse_iterator rbegin()
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend()
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const
		{	
		return (const_reverse_iterator(begin()));
		}

	size_type size() const
		{	
		return (_Mysize);
		}

	size_type max_size() const
		{	
		return (this->_Alval.max_size());
		}

	bool empty() const
		{	
		return (size() == 0);
		}

	allocator_type get_allocator() const
		{	
		return (this->_Alval);
		}

	key_compare key_comp() const
		{	
		return (this->comp);
		}

	value_compare value_comp() const
		{	
		return (value_compare(key_comp()));
		}

	_Pairib insert(const value_type& _Val)
		{	
		_Nodeptr _Trynode = _Root();
		_Nodeptr _Wherenode = _Myhead;
		bool _Addleft = true;	
		while (!_Isnil(_Trynode))
			{	
			_Wherenode = _Trynode;
			_Addleft = _Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Trynode), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 619);
#line 620 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);
			}

		if (this->_Multi)
			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
		else
			{	
			iterator _Where = iterator(_Wherenode, this);
			if (!_Addleft)
				;	
			else if (_Where == begin())
				return (_Pairib(_Insert(true, _Wherenode, _Val), true));
			else
				--_Where;	

			if (_Debug_lt_pred(this->comp, _Key(_Where._Mynode()), this->_Kfn(_Val), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 636))
#line 637 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
			else
				return (_Pairib(_Where, false));
			}
		}

	iterator insert(iterator _Where,
		const value_type& _Val)
		{	

 
		if (_Where._Mycont != this)
			_Debug_message(L"map/set insert iterator outside range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 649);
 #line 651 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

		iterator _Next;

		if (size() == 0)
			return (_Insert(true, _Myhead, _Val));	
		else if (this->_Multi)
			{	
			if (_Where == begin())
				{	
				if (!_Debug_lt_pred(this->comp, _Key(_Where._Mynode()), this->_Kfn(_Val), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 661))
#line 662 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (_Where == end())
				{	
				if (!_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Rmost()), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 667))
#line 668 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
					return (_Insert(false, _Rmost(), _Val));
				}
			else if (!_Debug_lt_pred(this->comp, _Key(_Where._Mynode()), this->_Kfn(_Val), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 671)
#line 672 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
				&& !_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode()), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 673))
#line 674 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
				{	
				if (_Isnil(_Right(_Next._Mynode())))
					return (_Insert(false, _Next._Mynode(), _Val));
				else
					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (!_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Where._Mynode()), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 681)
#line 682 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
				&& (++(_Next = _Where) == end()
					|| !_Debug_lt_pred(this->comp, _Key(_Next._Mynode()), this->_Kfn(_Val), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 684)))
#line 685 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
				{	
				if (_Isnil(_Right(_Where._Mynode())))
					return (_Insert(false, _Where._Mynode(), _Val));
				else
					return (_Insert(true, _Next._Mynode(), _Val));
				}
			}
		else
			{	
			if (_Where == begin())
				{	
				if (_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Where._Mynode()), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 697))
#line 698 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (_Where == end())
				{	
				if (_Debug_lt_pred(this->comp, _Key(_Rmost()), this->_Kfn(_Val), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 703))
#line 704 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
					return (_Insert(false, _Rmost(), _Val));
				}
			else if (_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Where._Mynode()), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 707)
#line 708 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
				&& _Debug_lt_pred(this->comp, _Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 709))
#line 710 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
				{	
				if (_Isnil(_Right(_Next._Mynode())))
					return (_Insert(false, _Next._Mynode(), _Val));
				else
					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (_Debug_lt_pred(this->comp, _Key(_Where._Mynode()), this->_Kfn(_Val), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 717)
#line 718 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
				&& (++(_Next = _Where) == end()
					|| _Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Next._Mynode()), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 720)))
#line 721 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
				{	
				if (_Isnil(_Right(_Where._Mynode())))
					return (_Insert(false, _Where._Mynode(), _Val));
				else
					return (_Insert(true, _Next._Mynode(), _Val));
				}
			}

		return (insert(_Val).first);	
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	

 
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 737);
		if (_Debug_get_cont(_First) == this)
			_Debug_message(L"map/set insertion overlaps range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 739);
 #line 741 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

		for (; _First != _Last; ++_First)
			insert(*_First);
		}

	iterator erase(iterator _Where)
		{	

 
		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
			_Debug_message(L"map/set erase iterator outside range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 751);
		_Nodeptr _Erasednode = _Where._Mynode();	
		++_Where;	
		_Orphan_ptr(*this, _Erasednode);

 




#line 762 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

		_Nodeptr _Fixnode;	
		_Nodeptr _Fixnodeparent;	
		_Nodeptr _Pnode = _Erasednode;

		if (_Isnil(_Left(_Pnode)))
			_Fixnode = _Right(_Pnode);	
		else if (_Isnil(_Right(_Pnode)))
			_Fixnode = _Left(_Pnode);	
		else
			{	
			_Pnode = _Where._Mynode();	
			_Fixnode = _Right(_Pnode);	
			}

		if (_Pnode == _Erasednode)
			{	
			_Fixnodeparent = _Parent(_Erasednode);
			if (!_Isnil(_Fixnode))
				_Parent(_Fixnode) = _Fixnodeparent;	

			if (_Root() == _Erasednode)
				_Root() = _Fixnode;	
			else if (_Left(_Fixnodeparent) == _Erasednode)
				_Left(_Fixnodeparent) = _Fixnode;	
			else
				_Right(_Fixnodeparent) = _Fixnode;	

			if (_Lmost() == _Erasednode)
				_Lmost() = _Isnil(_Fixnode)
					? _Fixnodeparent	
					: _Min(_Fixnode);	

			if (_Rmost() == _Erasednode)
				_Rmost() = _Isnil(_Fixnode)
					? _Fixnodeparent	
					: _Max(_Fixnode);	
			}
		else
			{	
			_Parent(_Left(_Erasednode)) = _Pnode;	
			_Left(_Pnode) = _Left(_Erasednode);	

			if (_Pnode == _Right(_Erasednode))
				_Fixnodeparent = _Pnode;	
			else
				{	
				_Fixnodeparent = _Parent(_Pnode);	
				if (!_Isnil(_Fixnode))
					_Parent(_Fixnode) = _Fixnodeparent;	
				_Left(_Fixnodeparent) = _Fixnode;	
				_Right(_Pnode) = _Right(_Erasednode);	
				_Parent(_Right(_Erasednode)) = _Pnode;	
				}

			if (_Root() == _Erasednode)
				_Root() = _Pnode;	
			else if (_Left(_Parent(_Erasednode)) == _Erasednode)
				_Left(_Parent(_Erasednode)) = _Pnode;	
			else
				_Right(_Parent(_Erasednode)) = _Pnode;	

			_Parent(_Pnode) = _Parent(_Erasednode);	
			std::swap(_Color(_Pnode), _Color(_Erasednode));	
			}

		if (_Color(_Erasednode) == _Black)
			{	
			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
				_Fixnodeparent = _Parent(_Fixnode))
				if (_Fixnode == _Left(_Fixnodeparent))
					{	
					_Pnode = _Right(_Fixnodeparent);
					if (_Color(_Pnode) == _Red)
						{	
						_Color(_Pnode) = _Black;
						_Color(_Fixnodeparent) = _Red;
						_Lrotate(_Fixnodeparent);
						_Pnode = _Right(_Fixnodeparent);
						}

					if (_Isnil(_Pnode))
						_Fixnode = _Fixnodeparent;	
					else if (_Color(_Left(_Pnode)) == _Black
						&& _Color(_Right(_Pnode)) == _Black)
						{	
						_Color(_Pnode) = _Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{	
						if (_Color(_Right(_Pnode)) == _Black)
							{	
							_Color(_Left(_Pnode)) = _Black;
							_Color(_Pnode) = _Red;
							_Rrotate(_Pnode);
							_Pnode = _Right(_Fixnodeparent);
							}

						_Color(_Pnode) = _Color(_Fixnodeparent);
						_Color(_Fixnodeparent) = _Black;
						_Color(_Right(_Pnode)) = _Black;
						_Lrotate(_Fixnodeparent);
						break;	
						}
					}
				else
					{	
					_Pnode = _Left(_Fixnodeparent);
					if (_Color(_Pnode) == _Red)
						{	
						_Color(_Pnode) = _Black;
						_Color(_Fixnodeparent) = _Red;
						_Rrotate(_Fixnodeparent);
						_Pnode = _Left(_Fixnodeparent);
						}
					if (_Isnil(_Pnode))
						_Fixnode = _Fixnodeparent;	
					else if (_Color(_Right(_Pnode)) == _Black
						&& _Color(_Left(_Pnode)) == _Black)
						{	
						_Color(_Pnode) = _Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{	
						if (_Color(_Left(_Pnode)) == _Black)
							{	
							_Color(_Right(_Pnode)) = _Black;
							_Color(_Pnode) = _Red;
							_Lrotate(_Pnode);
							_Pnode = _Left(_Fixnodeparent);
							}

						_Color(_Pnode) = _Color(_Fixnodeparent);
						_Color(_Fixnodeparent) = _Black;
						_Color(_Left(_Pnode)) = _Black;
						_Rrotate(_Fixnodeparent);
						break;	
						}
					}

			_Color(_Fixnode) = _Black;	
			}

		this->_Alnod.destroy(_Erasednode);	
		this->_Alnod.deallocate(_Erasednode, 1);

		if (0 < _Mysize)
			--_Mysize;

		return (_Where);	
		}

	iterator erase(iterator _First, iterator _Last)
		{	
		if (_First == begin() && _Last == end())
			{	
			clear();
			return (begin());
			}
		else
			{	
			while (_First != _Last)
				erase(_First++);
			return (_First);
			}
		}

	size_type erase(const key_type& _Keyval)
		{	
		_Pairii _Where = equal_range(_Keyval);
		size_type _Num = 0;
		_Distance(_Where.first, _Where.second, _Num);
		erase(_Where.first, _Where.second);
		return (_Num);
		}

	void erase(const key_type *_First, const key_type *_Last)
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 942);
		while (_First != _Last)
			erase(*_First++);
		}

	void clear()
		{	

 
		this->_Orphan_ptr(*this, 0);
 #line 953 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

		_Erase(_Root());
		_Root() = _Myhead, _Mysize = 0;
		_Lmost() = _Myhead, _Rmost() = _Myhead;
		}

	iterator find(const key_type& _Keyval)
		{	
		iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->comp, _Keyval, _Key(_Where._Mynode()), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 964)
#line 965 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
					? end() : _Where);
		}

	const_iterator find(const key_type& _Keyval) const
		{	
		const_iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->comp, _Keyval, _Key(_Where._Mynode()), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 973)
#line 974 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
					? end() : _Where);
		}

	size_type count(const key_type& _Keyval) const
		{	
		_Paircc _Ans = equal_range(_Keyval);
		size_type _Num = 0;
		_Distance(_Ans.first, _Ans.second, _Num);
		return (_Num);
		}

	iterator lower_bound(const key_type& _Keyval)
		{	
		return (iterator(_Lbound(_Keyval), this));
		}

	const_iterator lower_bound(const key_type& _Keyval) const
		{	
		return (const_iterator(_Lbound(_Keyval), this));
		}

	iterator upper_bound(const key_type& _Keyval)
		{	
		return (iterator(_Ubound(_Keyval), this));
		}

	const_iterator upper_bound(const key_type& _Keyval) const
		{	
		return (const_iterator(_Ubound(_Keyval), this));
		}

	_Pairii equal_range(const key_type& _Keyval)
		{	
		return (_Pairii(lower_bound(_Keyval), upper_bound(_Keyval)));
		}

	_Paircc equal_range(const key_type& _Keyval) const
		{	
		return (_Paircc(lower_bound(_Keyval), upper_bound(_Keyval)));
		}

	void swap(_Myt& _Right)
		{	
		if (get_allocator() == _Right.get_allocator())
			{	

 
			this->_Swap_all(_Right);
 #line 1023 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

			std::swap(this->comp, _Right.comp);
			std::swap(_Myhead, _Right._Myhead);
			std::swap(_Mysize, _Right._Mysize);
			}
		else
			{	
			_Myt _Tmp = *this; *this = _Right, _Right = _Tmp;
			}
		}

protected:
	void _Copy(const _Myt& _Right)
		{	
		_Root() = _Copy(_Right._Root(), _Myhead);
		_Mysize = _Right.size();
		if (!_Isnil(_Root()))
			{	
			_Lmost() = _Min(_Root());
			_Rmost() = _Max(_Root());
			}
		else
			_Lmost() = _Myhead, _Rmost() = _Myhead;	
		}

	_Nodeptr _Copy(_Nodeptr _Rootnode, _Nodeptr _Wherenode)
		{	
		_Nodeptr _Newroot = _Myhead;	

		if (!_Isnil(_Rootnode))
			{	
			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
				_Myval(_Rootnode), _Color(_Rootnode));
			if (_Isnil(_Newroot))
				_Newroot = _Pnode;	

			try {
			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);
			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);
			} catch (...) {
			_Erase(_Newroot);	
			throw;
			}
			}

		return (_Newroot);	
		}

	void _Erase(_Nodeptr _Rootnode)
		{	
		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)
			{	
			_Erase(_Right(_Pnode));
			_Pnode = _Left(_Pnode);
			this->_Alnod.destroy(_Rootnode);	
			this->_Alnod.deallocate(_Rootnode, 1);
			}
		}

	void _Init()
		{	
		_Myhead = _Buynode();
		_Isnil(_Myhead) = true;
		_Root() = _Myhead;
		_Lmost() = _Myhead, _Rmost() = _Myhead;
		_Mysize = 0;
		}

	iterator _Insert(bool _Addleft, _Nodeptr _Wherenode,
		const value_type& _Val)
		{	
		if (max_size() - 1 <= _Mysize)
			throw length_error("map/set<T> too long");
		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
			_Val, _Red);

		++_Mysize;
		if (_Wherenode == _Myhead)
			{	
			_Root() = _Newnode;
			_Lmost() = _Newnode, _Rmost() = _Newnode;
			}
		else if (_Addleft)
			{	
			_Left(_Wherenode) = _Newnode;
			if (_Wherenode == _Lmost())
				_Lmost() = _Newnode;
			}
		else
			{	
			_Right(_Wherenode) = _Newnode;
			if (_Wherenode == _Rmost())
				_Rmost() = _Newnode;
			}

		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )
			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))
				{	
				_Wherenode = _Right(_Parent(_Parent(_Pnode)));
				if (_Color(_Wherenode) == _Red)
					{	
					_Color(_Parent(_Pnode)) = _Black;
					_Color(_Wherenode) = _Black;
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Pnode = _Parent(_Parent(_Pnode));
					}
				else
					{	
					if (_Pnode == _Right(_Parent(_Pnode)))
						{	
						_Pnode = _Parent(_Pnode);
						_Lrotate(_Pnode);
						}
					_Color(_Parent(_Pnode)) = _Black;	
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Rrotate(_Parent(_Parent(_Pnode)));
					}
				}
			else
				{	
				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
				if (_Color(_Wherenode) == _Red)
					{	
					_Color(_Parent(_Pnode)) = _Black;
					_Color(_Wherenode) = _Black;
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Pnode = _Parent(_Parent(_Pnode));
					}
				else
					{	
					if (_Pnode == _Left(_Parent(_Pnode)))
						{	
						_Pnode = _Parent(_Pnode);
						_Rrotate(_Pnode);
						}
					_Color(_Parent(_Pnode)) = _Black;	
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Lrotate(_Parent(_Parent(_Pnode)));
					}
				}

		_Color(_Root()) = _Black;	
		return (iterator(_Newnode, this));
		}

	_Nodeptr _Lbound(const key_type& _Keyval) const
		{	
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Wherenode = _Myhead;	

		while (!_Isnil(_Pnode))
			if (_Debug_lt_pred(this->comp, _Key(_Pnode), _Keyval, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 1174))
				_Pnode = _Right(_Pnode);	
			else
				{	
				_Wherenode = _Pnode;
				_Pnode = _Left(_Pnode);	
				}

		return (_Wherenode);	
		}

	_Nodeptr& _Lmost() const
		{	
		return (_Left(_Myhead));
		}

	void _Lrotate(_Nodeptr _Wherenode)
		{	
		_Nodeptr _Pnode = _Right(_Wherenode);
		_Right(_Wherenode) = _Left(_Pnode);

		if (!_Isnil(_Left(_Pnode)))
			_Parent(_Left(_Pnode)) = _Wherenode;
		_Parent(_Pnode) = _Parent(_Wherenode);

		if (_Wherenode == _Root())
			_Root() = _Pnode;
		else if (_Wherenode == _Left(_Parent(_Wherenode)))
			_Left(_Parent(_Wherenode)) = _Pnode;
		else
			_Right(_Parent(_Wherenode)) = _Pnode;

		_Left(_Pnode) = _Wherenode;
		_Parent(_Wherenode) = _Pnode;
		}

	static _Nodeptr _Max(_Nodeptr _Pnode)
		{	
		while (!_Isnil(_Right(_Pnode)))
			_Pnode = _Right(_Pnode);
		return (_Pnode);
		}

	static _Nodeptr _Min(_Nodeptr _Pnode)
		{	
		while (!_Isnil(_Left(_Pnode)))
			_Pnode = _Left(_Pnode);
		return (_Pnode);
		}

	_Nodeptr& _Rmost() const
		{	
		return (_Right(_Myhead));
		}

	_Nodeptr& _Root() const
		{	
		return (_Parent(_Myhead));
		}

	void _Rrotate(_Nodeptr _Wherenode)
		{	
		_Nodeptr _Pnode = _Left(_Wherenode);
		_Left(_Wherenode) = _Right(_Pnode);

		if (!_Isnil(_Right(_Pnode)))
			_Parent(_Right(_Pnode)) = _Wherenode;
		_Parent(_Pnode) = _Parent(_Wherenode);

		if (_Wherenode == _Root())
			_Root() = _Pnode;
		else if (_Wherenode == _Right(_Parent(_Wherenode)))
			_Right(_Parent(_Wherenode)) = _Pnode;
		else
			_Left(_Parent(_Wherenode)) = _Pnode;

		_Right(_Pnode) = _Wherenode;
		_Parent(_Wherenode) = _Pnode;
		}

	_Nodeptr _Ubound(const key_type& _Keyval) const
		{	
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Wherenode = _Myhead;	

		while (!_Isnil(_Pnode))
			if (_Debug_lt_pred(this->comp, _Keyval, _Key(_Pnode), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree", 1260))
				{	
				_Wherenode = _Pnode;
				_Pnode = _Left(_Pnode);	
				}
			else
				_Pnode = _Right(_Pnode);	

		return (_Wherenode);	
		}

 
	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
		{	
		_Lockit _Lock(3);
		const_iterator **_Pnext = (const_iterator **)&_Cont._Myfirstiter;
		while (*_Pnext != 0)
			if ((*_Pnext)->_Ptr == _Myhead
				|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
				_Pnext = (const_iterator **)&(*_Pnext)->_Mynextiter;
			else
				{	
				(*_Pnext)->_Mycont = 0;
				*_Pnext = (const_iterator *)(*_Pnext)->_Mynextiter;
				}
		}
 #line 1287 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

	_Nodeptr _Buynode()
		{	
		_Nodeptr _Wherenode = this->_Alnod.allocate(1);
		int _Linkcnt = 0;

		try {
		this->_Alptr.construct(&_Left(_Wherenode), 0);
		++_Linkcnt;
		this->_Alptr.construct(&_Parent(_Wherenode), 0);
		++_Linkcnt;
		this->_Alptr.construct(&_Right(_Wherenode), 0);
		} catch (...) {
		if (1 < _Linkcnt)
			this->_Alptr.destroy(&_Parent(_Wherenode));
		if (0 < _Linkcnt)
			this->_Alptr.destroy(&_Left(_Wherenode));
		this->_Alnod.deallocate(_Wherenode, 1);
		throw;
		}
		_Color(_Wherenode) = _Black;
		_Isnil(_Wherenode) = false;
		return (_Wherenode);
		}

	_Nodeptr _Buynode(_Nodeptr _Larg, _Nodeptr _Parg,
		_Nodeptr _Rarg, const value_type& _Val, char _Carg)
		{	
		_Nodeptr _Wherenode = this->_Alnod.allocate(1);
		try {
		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);
		} catch (...) {
		this->_Alnod.deallocate(_Wherenode, 1);
		throw;
		}
		return (_Wherenode);
		}

	void _Tidy()
		{	
		erase(begin(), end());
		this->_Alptr.destroy(&_Left(_Myhead));
		this->_Alptr.destroy(&_Parent(_Myhead));
		this->_Alptr.destroy(&_Right(_Myhead));
		this->_Alnod.deallocate(_Myhead, 1);
		_Myhead = 0, _Mysize = 0;
		}

	static void _Xran()
		{	
		throw out_of_range("invalid map/set<T> iterator");
		}

	static void _Xinvarg()
		{	
		throw invalid_argument("invalid map/set<T> argument");
		}

	_Nodeptr _Myhead;	
	size_type _Mysize;	
	};

	
template <class _Traits>
	class _Move_operation_category<_Tree<_Traits> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};

		
template<class _Traits> inline
	bool operator==(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Traits> inline
	bool operator!=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Traits> inline
	bool operator<(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Traits> inline
	bool operator>(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Traits> inline
	bool operator<=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Traits> inline
	bool operator>=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (!(_Left < _Right));
	}
}


  #pragma warning(default:4127)

#pragma warning(pop)
#pragma pack(pop)
#line 1403 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"

#line 1405 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"
#line 1406 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\xtree"























#line 7 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map"


#pragma pack(push,8)
#pragma warning(push,3)
#line 12 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map"

namespace std {

		
template<class _Kty,	
	class _Ty,	
	class _Pr,	
	class _Alloc,	
	bool _Mfl>	
	class _Tmap_traits
		: public _Container_base
	{	
public:
	typedef _Kty key_type;
	typedef pair<const _Kty, _Ty> value_type;
	typedef _Pr key_compare;
	typedef typename _Alloc::template rebind<value_type>::other
		allocator_type;
	typedef typename allocator_type::template rebind<value_type>::other::pointer _ITptr;
	typedef typename allocator_type::template rebind<value_type>::other::reference _IReft;
	enum
		{	
		_Multi = _Mfl};

	_Tmap_traits()
		: comp()
		{	
		}

	_Tmap_traits(_Pr _Parg)
		: comp(_Parg)
		{	
		}

	class value_compare
		: public binary_function<value_type, value_type, bool>
		{	
		friend class _Tmap_traits<_Kty, _Ty, _Pr, _Alloc, _Mfl>;

	public:
		bool operator()(const value_type& _Left,
			const value_type& _Right) const
			{	
			return (comp(_Left.first, _Right.first));
			}

		value_compare(key_compare _Pred)
			: comp(_Pred)
			{	
			}

	protected:
		key_compare comp;	
		};

	static const _Kty& _Kfn(const value_type& _Val)
		{	
		return (_Val.first);
		}

	_Pr comp;	
	};

		
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<pair<const _Kty, _Ty> > >
	class map
		: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> >
	{	
public:
	typedef map<_Kty, _Ty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> > _Mybase;
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Ty referent_type;	
	typedef _Pr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	map()
		: _Mybase(key_compare(), allocator_type())
		{	
		}

	explicit map(const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		}

	map(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map", 124);
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last,
			const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map", 134);
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map", 144);
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

 














#line 165 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map"

	mapped_type& operator[](const key_type& _Keyval)
		{	
		iterator _Where = this->lower_bound(_Keyval);
		if (_Where == this->end()
			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))
			_Where = this->insert(_Where,
				value_type(_Keyval, mapped_type()));
		return ((*_Where).second);
		}
	};

	
template<class _Kty, class _Ty, class _Pr, class _Alloc>
	class _Move_operation_category<map<_Kty, _Ty, _Pr, _Alloc> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};

template<class _Kty,
	class _Ty,
	class _Pr,
	class _Alloc> inline
	void swap(map<_Kty, _Ty, _Pr, _Alloc>& _Left,
		map<_Kty, _Ty, _Pr, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<pair<const _Kty, _Ty> > >
	class multimap
		: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> >
	{	
public:
	typedef multimap<_Kty, _Ty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> > _Mybase;
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Ty referent_type;	
	typedef _Pr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	multimap()
		: _Mybase(key_compare(), allocator_type())
		{	
		}

	explicit multimap(const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		}
	multimap(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map", 243);
		for (; _First != _Last; ++_First)
			insert(*_First);
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last,
			const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map", 253);
		for (; _First != _Last; ++_First)
			insert(*_First);
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map", 263);
		for (; _First != _Last; ++_First)
			insert(*_First);
		}

	iterator insert(const value_type& _Val)
		{	
		return (_Mybase::insert(_Val).first);
		}

	iterator insert(iterator _Where, const value_type& _Val)
		{	
		return (_Mybase::insert(_Where, _Val));
		}

 














#line 294 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map"

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	

 
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map", 300);
		if (_Debug_get_cont(_First) == this)
			_Debug_message(L"multimap insertion overlaps range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map", 302);
 #line 304 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map"

		for (; _First != _Last; ++_First)
			insert(*_First);
		}
	};

	
template<class _Kty, class _Ty, class _Pr, class _Alloc>
	class _Move_operation_category<multimap<_Kty, _Ty, _Pr, _Alloc> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};

template<class _Kty,
	class _Ty,
	class _Pr,
	class _Alloc> inline
	void swap(multimap<_Kty, _Ty, _Pr, _Alloc>& _Left,
		multimap<_Kty, _Ty, _Pr, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

}


#pragma warning(pop)
#pragma pack(pop)
#line 334 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map"

#line 336 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map"
#line 337 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\map"





#line 52 "c:\\qt-3.3.8\\include\\qmap.h"
#line 53 "c:\\qt-3.3.8\\include\\qmap.h"



struct __declspec(dllimport) QMapNodeBase
{
    enum Color { Red, Black };

    QMapNodeBase* left;
    QMapNodeBase* right;
    QMapNodeBase* parent;

    Color color;

    QMapNodeBase* minimum() {
	QMapNodeBase* x = this;
	while ( x->left )
	    x = x->left;
	return x;
    }

    QMapNodeBase* maximum() {
	QMapNodeBase* x = this;
	while ( x->right )
	    x = x->right;
	return x;
    }
};


template <class K, class T>
struct QMapNode : public QMapNodeBase
{
    QMapNode( const K& _key, const T& _data ) { data = _data; key = _key; }
    QMapNode( const K& _key )	   { key = _key; }
    QMapNode( const QMapNode<K,T>& _n ) { key = _n.key; data = _n.data; }
    QMapNode() { }
    T data;
    K key;
};


template<class K, class T>
class QMapIterator
{
 public:
    


    typedef QMapNode< K, T >* NodePtr;

    typedef std::bidirectional_iterator_tag  iterator_category;
#line 105 "c:\\qt-3.3.8\\include\\qmap.h"
    typedef T          value_type;

    typedef ptrdiff_t  difference_type;


#line 111 "c:\\qt-3.3.8\\include\\qmap.h"
    typedef T*         pointer;
    typedef T&         reference;

    


    QMapNode<K,T>* node;

    


    QMapIterator() : node( 0 ) {}
    QMapIterator( QMapNode<K,T>* p ) : node( p ) {}
    QMapIterator( const QMapIterator<K,T>& it ) : node( it.node ) {}

    bool operator==( const QMapIterator<K,T>& it ) const { return node == it.node; }
    bool operator!=( const QMapIterator<K,T>& it ) const { return node != it.node; }
    T& operator*() { return node->data; }
    const T& operator*() const { return node->data; }
    
    

    const K& key() const { return node->key; }
    T& data() { return node->data; }
    const T& data() const { return node->data; }

private:
    int inc();
    int dec();

public:
    QMapIterator<K,T>& operator++() {
	inc();
	return *this;
    }

    QMapIterator<K,T> operator++(int) {
	QMapIterator<K,T> tmp = *this;
	inc();
	return tmp;
    }

    QMapIterator<K,T>& operator--() {
	dec();
	return *this;
    }

    QMapIterator<K,T> operator--(int) {
	QMapIterator<K,T> tmp = *this;
	dec();
	return tmp;
    }
};

template <class K, class T>
inline int QMapIterator<K,T>::inc()
{
    QMapNodeBase* tmp = node;
    if ( tmp->right ) {
	tmp = tmp->right;
	while ( tmp->left )
	    tmp = tmp->left;
    } else {
	QMapNodeBase* y = tmp->parent;
	while (tmp == y->right) {
	    tmp = y;
	    y = y->parent;
	}
	if (tmp->right != y)
	    tmp = y;
    }
    node = (NodePtr)tmp;
    return 0;
}

template <class K, class T>
inline int QMapIterator<K,T>::dec()
{
    QMapNodeBase* tmp = node;
    if (tmp->color == QMapNodeBase::Red &&
	tmp->parent->parent == tmp ) {
	tmp = tmp->right;
    } else if (tmp->left != 0) {
	QMapNodeBase* y = tmp->left;
	while ( y->right )
	    y = y->right;
	tmp = y;
    } else {
	QMapNodeBase* y = tmp->parent;
	while (tmp == y->left) {
	    tmp = y;
	    y = y->parent;
	}
	tmp = y;
    }
    node = (NodePtr)tmp;
    return 0;
}

template<class K, class T>
class QMapConstIterator
{
 public:
    


    typedef QMapNode< K, T >* NodePtr;

    typedef std::bidirectional_iterator_tag  iterator_category;
#line 221 "c:\\qt-3.3.8\\include\\qmap.h"
    typedef T          value_type;

    typedef ptrdiff_t  difference_type;


#line 227 "c:\\qt-3.3.8\\include\\qmap.h"
    typedef const T*   pointer;
    typedef const T&   reference;


    


    QMapNode<K,T>* node;

    


    QMapConstIterator() : node( 0 ) {}
    QMapConstIterator( QMapNode<K,T>* p ) : node( p ) {}
    QMapConstIterator( const QMapConstIterator<K,T>& it ) : node( it.node ) {}
    QMapConstIterator( const QMapIterator<K,T>& it ) : node( it.node ) {}

    bool operator==( const QMapConstIterator<K,T>& it ) const { return node == it.node; }
    bool operator!=( const QMapConstIterator<K,T>& it ) const { return node != it.node; }
    const T& operator*()  const { return node->data; }
    
    

    const K& key() const { return node->key; }
    const T& data() const { return node->data; }

private:
    int inc();
    int dec();

public:
    QMapConstIterator<K,T>& operator++() {
	inc();
	return *this;
    }

    QMapConstIterator<K,T> operator++(int) {
	QMapConstIterator<K,T> tmp = *this;
	inc();
	return tmp;
    }

    QMapConstIterator<K,T>& operator--() {
	dec();
	return *this;
    }

    QMapConstIterator<K,T> operator--(int) {
	QMapConstIterator<K,T> tmp = *this;
	dec();
	return tmp;
    }
};

template <class K, class T>
inline int QMapConstIterator<K,T>::inc()
{
    QMapNodeBase* tmp = node;
    if ( tmp->right ) {
	tmp = tmp->right;
	while ( tmp->left )
	    tmp = tmp->left;
    } else {
	QMapNodeBase* y = tmp->parent;
	while (tmp == y->right) {
	    tmp = y;
	    y = y->parent;
	}
	if (tmp->right != y)
	    tmp = y;
    }
    node = (NodePtr)tmp;
    return 0;
}

template <class K, class T>
inline int QMapConstIterator<K,T>::dec()
{
    QMapNodeBase* tmp = node;
    if (tmp->color == QMapNodeBase::Red &&
	tmp->parent->parent == tmp ) {
	tmp = tmp->right;
    } else if (tmp->left != 0) {
	QMapNodeBase* y = tmp->left;
	while ( y->right )
	    y = y->right;
	tmp = y;
    } else {
	QMapNodeBase* y = tmp->parent;
	while (tmp == y->left) {
	    tmp = y;
	    y = y->parent;
	}
	tmp = y;
    }
    node = (NodePtr)tmp;
    return 0;
}


class __declspec(dllimport) QMapPrivateBase : public QShared
{
public:
    QMapPrivateBase() {
	node_count = 0;
    }
    QMapPrivateBase( const QMapPrivateBase* _map) {
	node_count = _map->node_count;
    }

    


    void rotateLeft( QMapNodeBase* x, QMapNodeBase*& root);
    void rotateRight( QMapNodeBase* x, QMapNodeBase*& root );
    void rebalance( QMapNodeBase* x, QMapNodeBase*& root );
    QMapNodeBase* removeAndRebalance( QMapNodeBase* z, QMapNodeBase*& root,
				      QMapNodeBase*& leftmost,
				      QMapNodeBase*& rightmost );

    


    int node_count;
};


template <class Key, class T>
class QMapPrivate : public QMapPrivateBase
{
public:
    


    typedef QMapIterator< Key, T > Iterator;
    typedef QMapConstIterator< Key, T > ConstIterator;
    typedef QMapNode< Key, T > Node;
    typedef QMapNode< Key, T >* NodePtr;

    


    QMapPrivate();
    QMapPrivate( const QMapPrivate< Key, T >* _map );
    ~QMapPrivate() { clear(); delete header; }

    NodePtr copy( NodePtr p );
    void clear();
    void clear( NodePtr p );

    Iterator begin()	{ return Iterator( (NodePtr)(header->left ) ); }
    Iterator end()	{ return Iterator( header ); }
    ConstIterator begin() const { return ConstIterator( (NodePtr)(header->left ) ); }
    ConstIterator end() const { return ConstIterator( header ); }

    ConstIterator find(const Key& k) const;

    void remove( Iterator it ) {
	NodePtr del = (NodePtr) removeAndRebalance( it.node, header->parent, header->left, header->right );
	delete del;
	--node_count;
    }























#line 413 "c:\\qt-3.3.8\\include\\qmap.h"

    Iterator insertSingle( const Key& k );
    Iterator insert( QMapNodeBase* x, QMapNodeBase* y, const Key& k );

protected:
    


    const Key& key( QMapNodeBase* b ) const { return ((NodePtr)b)->key; }

    


    NodePtr header;
};


template <class Key, class T>
inline QMapPrivate<Key,T>::QMapPrivate() {
    header = new Node;
    header->color = QMapNodeBase::Red; 
    header->parent = 0;
    header->left = header->right = header;
}
template <class Key, class T>
inline QMapPrivate<Key,T>::QMapPrivate( const QMapPrivate< Key, T >* _map ) : QMapPrivateBase( _map ) {
    header = new Node;
    header->color = QMapNodeBase::Red; 
    if ( _map->header->parent == 0 ) {
	header->parent = 0;
	header->left = header->right = header;
    } else {
	header->parent = copy( (NodePtr)(_map->header->parent) );
	header->parent->parent = header;
	header->left = header->parent->minimum();
	header->right = header->parent->maximum();
    }
}

template <class Key, class T>
inline typename QMapPrivate<Key,T>::NodePtr QMapPrivate<Key,T>::copy( typename QMapPrivate<Key,T>::NodePtr p )
{
    if ( !p )
	return 0;
    NodePtr n = new Node( *p );
    n->color = p->color;
    if ( p->left ) {
	n->left = copy( (NodePtr)(p->left) );
	n->left->parent = n;
    } else {
	n->left = 0;
    }
    if ( p->right ) {
	n->right = copy( (NodePtr)(p->right) );
	n->right->parent = n;
    } else {
	n->right = 0;
    }
    return n;
}

template <class Key, class T>
inline void QMapPrivate<Key,T>::clear()
{
    clear( (NodePtr)(header->parent) );
    header->color = QMapNodeBase::Red;
    header->parent = 0;
    header->left = header->right = header;
    node_count = 0;
}

template <class Key, class T>
inline void QMapPrivate<Key,T>::clear( typename QMapPrivate<Key,T>::NodePtr p )
{
    while ( p != 0 ) {
	clear( (NodePtr)p->right );
	NodePtr y = (NodePtr)p->left;
	delete p;
	p = y;
    }
}

template <class Key, class T>
inline typename QMapPrivate<Key,T>::ConstIterator QMapPrivate<Key,T>::find(const Key& k) const
{
    QMapNodeBase* y = header;        
    QMapNodeBase* x = header->parent; 

    while ( x != 0 ) {
	
	if ( !( key(x) < k ) ) {
	    y = x;
	    x = x->left;
	} else {
	    x = x->right;
	}
    }

    
    
    if ( y == header || k < key(y) )
	return ConstIterator( header );
    return ConstIterator( (NodePtr)y );
}

template <class Key, class T>
inline typename QMapPrivate<Key,T>::Iterator QMapPrivate<Key,T>::insertSingle( const Key& k )
{
    
    QMapNodeBase* y = header;
    QMapNodeBase* x = header->parent;
    bool result = TRUE;
    while ( x != 0 ) {
	result = ( k < key(x) );
	y = x;
	x = result ? x->left : x->right;
    }
    
    Iterator j( (NodePtr)y );
    if ( result ) {
	
	if ( j == begin() ) {
	    return insert(x, y, k );
	} else {
	    
	    --j;
	}
    }
    
    if ( (j.node->key) < k )
	return insert(x, y, k );
    
    return j;
}


template <class Key, class T>
inline typename QMapPrivate<Key,T>::Iterator QMapPrivate<Key,T>::insert( QMapNodeBase* x, QMapNodeBase* y, const Key& k )
{
    NodePtr z = new Node( k );
    if (y == header || x != 0 || k < key(y) ) {
	y->left = z;                
	if ( y == header ) {
	    header->parent = z;
	    header->right = z;
	} else if ( y == header->left )
	    header->left = z;           
    } else {
	y->right = z;
	if ( y == header->right )
	    header->right = z;          
    }
    z->parent = y;
    z->left = 0;
    z->right = 0;
    rebalance( z, header->parent );
    ++node_count;
    return Iterator(z);
}






#line 579 "c:\\qt-3.3.8\\include\\qmap.h"


#line 582 "c:\\qt-3.3.8\\include\\qmap.h"



#line 586 "c:\\qt-3.3.8\\include\\qmap.h"

template <class T> class QDeepCopy;

template<class Key, class T>
class QMap
{
public:
    


    typedef Key key_type;
    typedef T mapped_type;
    typedef QPair<const key_type, mapped_type> value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    typedef ptrdiff_t  difference_type;


#line 608 "c:\\qt-3.3.8\\include\\qmap.h"
    typedef size_t      size_type;
    typedef QMapIterator<Key,T> iterator;
    typedef QMapConstIterator<Key,T> const_iterator;
    typedef QPair<iterator,bool> insert_pair;

    typedef QMapIterator< Key, T > Iterator;
    typedef QMapConstIterator< Key, T > ConstIterator;
    typedef T ValueType;
    typedef QMapPrivate< Key, T > Priv;

    


    QMap()
    {
	sh = new QMapPrivate< Key, T >;
    }
    QMap( const QMap<Key,T>& m )
    {
	sh = m.sh; sh->ref();
    }


    QMap( const std::map<Key,T>& m )
    {
	sh = new QMapPrivate<Key,T>;
	typename std::map<Key,T>::const_iterator it = m.begin();
	for ( ; it != m.end(); ++it ) {
	    value_type p( (*it).first, (*it).second );
	    insert( p );
	}
    }
#line 641 "c:\\qt-3.3.8\\include\\qmap.h"
    ~QMap()
    {
	if ( sh->deref() )
	    delete sh;
    }
    QMap<Key,T>& operator= ( const QMap<Key,T>& m );

    QMap<Key,T>& operator= ( const std::map<Key,T>& m )
    {
	clear();
	typename std::map<Key,T>::const_iterator it = m.begin();
	for ( ; it != m.end(); ++it ) {
	    value_type p( (*it).first, (*it).second );
	    insert( p );
	}
	return *this;
    }
#line 659 "c:\\qt-3.3.8\\include\\qmap.h"

    iterator begin() { detach(); return sh->begin(); }
    iterator end() { detach(); return sh->end(); }
    const_iterator begin() const { return ((const Priv*)sh)->begin(); }
    const_iterator end() const { return ((const Priv*)sh)->end(); }
    const_iterator constBegin() const { return begin(); }
    const_iterator constEnd() const { return end(); }

    iterator replace( const Key& k, const T& v )
    {
	remove( k );
	return insert( k, v );
    }

    size_type size() const
    {
	return sh->node_count;
    }
    bool empty() const
    {
	return sh->node_count == 0;
    }
    QPair<iterator,bool> insert( const value_type& x );

    void erase( iterator it )
    {
	detach();
	sh->remove( it );
    }
    void erase( const key_type& k );
    size_type count( const key_type& k ) const;
    T& operator[] ( const Key& k );
    void clear();

    iterator find ( const Key& k )
    {
	detach();
	return iterator( sh->find( k ).node );
    }
    const_iterator find ( const Key& k ) const {	return sh->find( k ); }

    const T& operator[] ( const Key& k ) const
	{ ; return sh->find( k ).data(); }
    bool contains ( const Key& k ) const
	{ return find( k ) != end(); }
	

    size_type count() const { return sh->node_count; }

    QValueList<Key> keys() const {
	QValueList<Key> r;
	for (const_iterator i=begin(); i!=end(); ++i)
	    r.append(i.key());
	return r;
    }

    QValueList<T> values() const {
	QValueList<T> r;
	for (const_iterator i=begin(); i!=end(); ++i)
	    r.append(*i);
	return r;
    }

    bool isEmpty() const { return sh->node_count == 0; }

    iterator insert( const Key& key, const T& value, bool overwrite = TRUE );
    void remove( iterator it ) { detach(); sh->remove( it ); }
    void remove( const Key& k );






#line 734 "c:\\qt-3.3.8\\include\\qmap.h"

protected:
    


    void detach() {  if ( sh->count > 1 ) detachInternal(); }

    Priv* sh;
private:
    void detachInternal();

    friend class QDeepCopy< QMap<Key,T> >;
};

template<class Key, class T>
inline QMap<Key,T>& QMap<Key,T>::operator= ( const QMap<Key,T>& m )
{
    m.sh->ref();
    if ( sh->deref() )
	delete sh;
    sh = m.sh;
    return *this;
}

template<class Key, class T>
inline typename QMap<Key,T>::insert_pair QMap<Key,T>::insert( const typename QMap<Key,T>::value_type& x )
{
    detach();
    size_type n = size();
    iterator it = sh->insertSingle( x.first );
    bool inserted = FALSE;
    if ( n < size() ) {
	inserted = TRUE;
	it.data() = x.second;
    }
    return QPair<iterator,bool>( it, inserted );
}

template<class Key, class T>
inline void QMap<Key,T>::erase( const Key& k )
{
    detach();
    iterator it( sh->find( k ).node );
    if ( it != end() )
	sh->remove( it );
}

template<class Key, class T>
inline typename QMap<Key,T>::size_type QMap<Key,T>::count( const Key& k ) const
{
    const_iterator it( sh->find( k ).node );
    if ( it != end() ) {
	size_type c = 0;
	while ( it != end() ) {
	    ++it;
	    ++c;
	}
	return c;
    }
    return 0;
}

template<class Key, class T>
inline T& QMap<Key,T>::operator[] ( const Key& k )
{
    detach();
    QMapNode<Key,T>* p = sh->find( k ).node;
    if ( p != sh->end().node )
	return p->data;
    return insert( k, T() ).data();
}

template<class Key, class T>
inline void QMap<Key,T>::clear()
{
    if ( sh->count == 1 )
	sh->clear();
    else {
	sh->deref();
	sh = new QMapPrivate<Key,T>;
    }
}

template<class Key, class T>
inline typename QMap<Key,T>::iterator QMap<Key,T>::insert( const Key& key, const T& value, bool overwrite )
{
    detach();
    size_type n = size();
    iterator it = sh->insertSingle( key );
    if ( overwrite || n < size() )
	it.data() = value;
    return it;
}

template<class Key, class T>
inline void QMap<Key,T>::remove( const Key& k )
{
    detach();
    iterator it( sh->find( k ).node );
    if ( it != end() )
	sh->remove( it );
}

template<class Key, class T>
inline void QMap<Key,T>::detachInternal()
{
    sh->deref(); sh = new QMapPrivate<Key,T>( sh );
}



template<class Key, class T>
inline QDataStream& operator>>( QDataStream& s, QMap<Key,T>& m ) {
    m.clear();
    Q_UINT32 c;
    s >> c;
    for( Q_UINT32 i = 0; i < c; ++i ) {
	Key k; T t;
	s >> k >> t;
	m.insert( k, t );
	if ( s.atEnd() )
	    break;
    }
    return s;
}


template<class Key, class T>
inline QDataStream& operator<<( QDataStream& s, const QMap<Key,T>& m ) {
    s << (Q_UINT32)m.size();
    QMapConstIterator<Key,T> it = m.begin();
    for( ; it != m.end(); ++it )
	s << it.key() << it.data();
    return s;
}
#line 870 "c:\\qt-3.3.8\\include\\qmap.h"


#line 1 "c:\\qt-3.3.8\\include\\qwinexport.h"










































#line 44 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 49 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 54 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 59 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 65 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 70 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 75 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 81 "c:\\qt-3.3.8\\include\\qwinexport.h"



extern template class __declspec(dllimport) QMap<int, int>; 
extern template class __declspec(dllimport) QMap<int, bool>; 
#line 87 "c:\\qt-3.3.8\\include\\qwinexport.h"



extern template class __declspec(dllimport) QMap<QString, QString>;
extern template class __declspec(dllimport) QMap<QString, int>; 
extern template class __declspec(dllimport) QMap<int, QString>; 
#line 94 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 101 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 106 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 112 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 118 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 124 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 130 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 136 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 141 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 146 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 151 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 156 "c:\\qt-3.3.8\\include\\qwinexport.h"







#line 164 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 170 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 176 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 182 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 187 "c:\\qt-3.3.8\\include\\qwinexport.h"








#line 196 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 202 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 207 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 211 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 218 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 222 "c:\\qt-3.3.8\\include\\qwinexport.h"
#line 873 "c:\\qt-3.3.8\\include\\qmap.h"
#line 874 "c:\\qt-3.3.8\\include\\qmap.h"
#line 44 "c:\\qt-3.3.8\\include\\qmime.h"
#line 45 "c:\\qt-3.3.8\\include\\qmime.h"



class QImageDrag;
class QTextDrag;

class __declspec(dllimport) QMimeSource
{
    friend class QClipboardData;

public:
    QMimeSource();
    virtual ~QMimeSource();
    virtual const char* format( int n = 0 ) const = 0;
    virtual bool provides( const char* ) const;
    virtual QByteArray encodedData( const char* ) const = 0;
    int serialNumber() const;

private:
    int ser_no;
    enum { NoCache, Text, Graphics } cacheType;
    union
    {
	struct
	{
	    QString *str;
	    QCString *subtype;
	} txt;
	struct
	{
	    QImage *img;
	    QPixmap *pix;
	} gfx;
    } cache;
    void clearCache();

    
    friend class QImageDrag;
    friend class QTextDrag;

};

inline int QMimeSource::serialNumber() const
{ return ser_no; }

class QStringList;
class QMimeSourceFactoryData;

class __declspec(dllimport) QMimeSourceFactory {
public:
    QMimeSourceFactory();
    virtual ~QMimeSourceFactory();

    static QMimeSourceFactory* defaultFactory();
    static void setDefaultFactory( QMimeSourceFactory* );
    static QMimeSourceFactory* takeDefaultFactory();
    static void addFactory( QMimeSourceFactory *f );
    static void removeFactory( QMimeSourceFactory *f );

    virtual const QMimeSource* data(const QString& abs_name) const;
    virtual QString makeAbsolute(const QString& abs_or_rel_name, const QString& context) const;
    const QMimeSource* data(const QString& abs_or_rel_name, const QString& context) const;

    virtual void setText( const QString& abs_name, const QString& text );
    virtual void setImage( const QString& abs_name, const QImage& im );
    virtual void setPixmap( const QString& abs_name, const QPixmap& pm );
    virtual void setData( const QString& abs_name, QMimeSource* data );
    virtual void setFilePath( const QStringList& );
    virtual QStringList filePath() const;
    void addFilePath( const QString& );
    virtual void setExtensionType( const QString& ext, const char* mimetype );

private:
    QMimeSource *dataInternal(const QString& abs_name, const QMap<QString, QString> &extensions ) const;
    QMimeSourceFactoryData* d;
};




#line 1 "c:\\qt-3.3.8\\include\\qptrlist.h"







































#line 1 "c:\\qt-3.3.8\\include\\qglist.h"









































#line 1 "c:\\qt-3.3.8\\include\\qptrcollection.h"







































#line 1 "c:\\qt-3.3.8\\include\\qglobal.h"





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1111 "c:\\qt-3.3.8\\include\\qglobal.h"


#pragma warning(disable: 4244) 
#pragma warning(disable: 4275) 
#pragma warning(disable: 4514) 
#pragma warning(disable: 4800) 
#pragma warning(disable: 4097) 
#pragma warning(disable: 4706) 
#pragma warning(disable: 4786) 
#pragma warning(disable: 4660) 
#pragma warning(disable: 4355) 
#pragma warning(disable: 4231) 
#pragma warning(disable: 4710) 








#line 1133 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 1134 "c:\\qt-3.3.8\\include\\qglobal.h"


#line 41 "c:\\qt-3.3.8\\include\\qptrcollection.h"
#line 42 "c:\\qt-3.3.8\\include\\qptrcollection.h"


class QGVector;
class QGList;
class QGDict;


class __declspec(dllimport) QPtrCollection			
{
public:
    bool autoDelete()	const	       { return del_item; }
    void setAutoDelete( bool enable )  { del_item = enable; }

    virtual uint  count() const = 0;
    virtual void  clear() = 0;			

    typedef void *Item;				

protected:
    QPtrCollection() { del_item = FALSE; }		
    QPtrCollection(const QPtrCollection &) { del_item = FALSE; }
    virtual ~QPtrCollection() {}

    bool del_item;				

    virtual Item     newItem( Item );		
    virtual void     deleteItem( Item ) = 0;	
};




#line 75 "c:\\qt-3.3.8\\include\\qptrcollection.h"

#line 77 "c:\\qt-3.3.8\\include\\qptrcollection.h"
#line 43 "c:\\qt-3.3.8\\include\\qglist.h"
#line 44 "c:\\qt-3.3.8\\include\\qglist.h"

class __declspec(dllimport) QLNode
{
friend class QGList;
friend class QGListIterator;
friend class QGListStdIterator;
public:
    QPtrCollection::Item getData()	{ return data; }
private:
    QPtrCollection::Item data;
    QLNode *prev;
    QLNode *next;
    QLNode( QPtrCollection::Item d ) { data = d; }
};

class QGListIteratorList; 

class __declspec(dllimport) QGList : public QPtrCollection	
{
friend class QGListIterator;
friend class QGListIteratorList;
friend class QGVector;				
public:
    uint  count() const;			


    QDataStream &read( QDataStream & );		
    QDataStream &write( QDataStream & ) const;	
#line 73 "c:\\qt-3.3.8\\include\\qglist.h"
protected:
    QGList();					
    QGList( const QGList & );			
    virtual ~QGList();

    QGList &operator=( const QGList & );	
    bool operator==( const QGList& ) const;

    void inSort( QPtrCollection::Item );		
    void append( QPtrCollection::Item );		
    bool insertAt( uint index, QPtrCollection::Item ); 
    void relinkNode( QLNode * );		
    bool removeNode( QLNode * );		
    bool remove( QPtrCollection::Item = 0 );	
    bool removeRef( QPtrCollection::Item = 0 );	
    bool removeFirst();				
    bool removeLast();				
    bool removeAt( uint );			
    bool replaceAt( uint, QPtrCollection::Item ); 
    QPtrCollection::Item takeNode( QLNode * );	
    QPtrCollection::Item take();		
    QPtrCollection::Item takeAt( uint index );	
    QPtrCollection::Item takeFirst();		
    QPtrCollection::Item takeLast();		

    void sort();                        	
    void clear();				

    int	 findRef( QPtrCollection::Item, bool = TRUE ); 
    int	 find( QPtrCollection::Item, bool = TRUE ); 

    uint containsRef( QPtrCollection::Item ) const;	
    uint contains( QPtrCollection::Item ) const;	

    QPtrCollection::Item at( uint index );	
    int	  at() const;				
    QLNode *currentNode() const;		

    QPtrCollection::Item get() const;		

    QPtrCollection::Item cfirst() const;	
    QPtrCollection::Item clast()  const;	
    QPtrCollection::Item first();		
    QPtrCollection::Item last();		
    QPtrCollection::Item next();		
    QPtrCollection::Item prev();		

    void  toVector( QGVector * ) const;		

    virtual int compareItems( QPtrCollection::Item, QPtrCollection::Item );


    virtual QDataStream &read( QDataStream &, QPtrCollection::Item & );
    virtual QDataStream &write( QDataStream &, QPtrCollection::Item ) const;
#line 128 "c:\\qt-3.3.8\\include\\qglist.h"

    QLNode* begin() const { return firstNode; }
    QLNode* end() const { return 0; }
    QLNode* erase( QLNode* it );

private:
    void  prepend( QPtrCollection::Item );	

    void heapSortPushDown( QPtrCollection::Item* heap, int first, int last );

    QLNode *firstNode;				
    QLNode *lastNode;				
    QLNode *curNode;				
    int curIndex;				
    uint numNodes;				
    QGListIteratorList *iterators; 		

    QLNode *locate( uint );			
    QLNode *unlink();				
};


inline uint QGList::count() const
{
    return numNodes;
}

inline bool QGList::removeFirst()
{
    first();
    return remove();
}

inline bool QGList::removeLast()
{
    last();
    return remove();
}

inline int QGList::at() const
{
    return curIndex;
}

inline QPtrCollection::Item QGList::at( uint index )
{
    QLNode *n = locate( index );
    return n ? n->data : 0;
}

inline QLNode *QGList::currentNode() const
{
    return curNode;
}

inline QPtrCollection::Item QGList::get() const
{
    return curNode ? curNode->data : 0;
}

inline QPtrCollection::Item QGList::cfirst() const
{
    return firstNode ? firstNode->data : 0;
}

inline QPtrCollection::Item QGList::clast() const
{
    return lastNode ? lastNode->data : 0;
}







__declspec(dllimport) QDataStream &operator>>( QDataStream &, QGList & );
__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QGList & );
#line 207 "c:\\qt-3.3.8\\include\\qglist.h"





class __declspec(dllimport) QGListIterator			
{
friend class QGList;
friend class QGListIteratorList;
protected:
    QGListIterator( const QGList & );
    QGListIterator( const QGListIterator & );
    QGListIterator &operator=( const QGListIterator & );
   ~QGListIterator();

    bool  atFirst() const;			
    bool  atLast()  const;			
    QPtrCollection::Item	  toFirst();				
    QPtrCollection::Item	  toLast();				

    QPtrCollection::Item	  get() const;				
    QPtrCollection::Item	  operator()();				
    QPtrCollection::Item	  operator++();				
    QPtrCollection::Item	  operator+=(uint);			
    QPtrCollection::Item	  operator--();				
    QPtrCollection::Item	  operator-=(uint);			

protected:
    QGList *list;				

private:
    QLNode  *curNode;				
};


inline bool QGListIterator::atFirst() const
{
    return curNode == list->firstNode;
}

inline bool QGListIterator::atLast() const
{
    return curNode == list->lastNode;
}

inline QPtrCollection::Item QGListIterator::get() const
{
    return curNode ? curNode->data : 0;
}

class __declspec(dllimport) QGListStdIterator
{
public:
    inline QGListStdIterator( QLNode* n ) : node( n ){}
    inline operator QLNode* () { return node; }
protected:
    inline QLNode *next() { return node->next; }
    QLNode *node;
};


#line 269 "c:\\qt-3.3.8\\include\\qglist.h"
#line 41 "c:\\qt-3.3.8\\include\\qptrlist.h"
#line 42 "c:\\qt-3.3.8\\include\\qptrlist.h"

template<class type>
class QPtrListStdIterator : public QGListStdIterator
{
public:
    inline QPtrListStdIterator( QLNode* n ): QGListStdIterator(n) {}
    type *operator*() { return node ? (type *)node->getData() : 0; }
    inline QPtrListStdIterator<type> operator++()
    { node = next(); return *this; }
    inline QPtrListStdIterator<type> operator++(int)
    { QLNode* n = node; node = next(); return QPtrListStdIterator<type>( n ); }
    inline bool operator==( const QPtrListStdIterator<type>& it ) const { return node == it.node; }
    inline bool operator!=( const QPtrListStdIterator<type>& it ) const { return node != it.node; }
};


template<class type>
class QPtrList



	: public QGList
#line 65 "c:\\qt-3.3.8\\include\\qptrlist.h"
{
public:

    QPtrList()				{}
    QPtrList( const QPtrList<type> &l ) : QGList(l) {}
    ~QPtrList()				{ clear(); }
    QPtrList<type> &operator=(const QPtrList<type> &l)
			{ return (QPtrList<type>&)QGList::operator=(l); }
    bool operator==( const QPtrList<type> &list ) const
    { return QGList::operator==( list ); }
    bool operator!=( const QPtrList<type> &list ) const
    { return !QGList::operator==( list ); }
    uint  count()   const		{ return QGList::count(); }
    bool  isEmpty() const		{ return QGList::count() == 0; }
    bool  insert( uint i, const type *d){ return QGList::insertAt(i,(QPtrCollection::Item)d); }
    void  inSort( const type *d )	{ QGList::inSort((QPtrCollection::Item)d); }
    void  prepend( const type *d )	{ QGList::insertAt(0,(QPtrCollection::Item)d); }
    void  append( const type *d )	{ QGList::append((QPtrCollection::Item)d); }
    bool  remove( uint i )		{ return QGList::removeAt(i); }
    bool  remove()			{ return QGList::remove((QPtrCollection::Item)0); }
    bool  remove( const type *d )	{ return QGList::remove((QPtrCollection::Item)d); }
    bool  removeRef( const type *d )	{ return QGList::removeRef((QPtrCollection::Item)d); }
    void  removeNode( QLNode *n )	{ QGList::removeNode(n); }
    bool  removeFirst()			{ return QGList::removeFirst(); }
    bool  removeLast()			{ return QGList::removeLast(); }
    type *take( uint i )		{ return (type *)QGList::takeAt(i); }
    type *take()			{ return (type *)QGList::take(); }
    type *takeNode( QLNode *n )		{ return (type *)QGList::takeNode(n); }
    void  clear()			{ QGList::clear(); }
    void  sort()			{ QGList::sort(); }
    int	  find( const type *d )		{ return QGList::find((QPtrCollection::Item)d); }
    int	  findNext( const type *d )	{ return QGList::find((QPtrCollection::Item)d,FALSE); }
    int	  findRef( const type *d )	{ return QGList::findRef((QPtrCollection::Item)d); }
    int	  findNextRef( const type *d ){ return QGList::findRef((QPtrCollection::Item)d,FALSE);}
    uint  contains( const type *d ) const { return QGList::contains((QPtrCollection::Item)d); }
    uint  containsRef( const type *d ) const
					{ return QGList::containsRef((QPtrCollection::Item)d); }
    bool replace( uint i, const type *d ) { return QGList::replaceAt( i, (QPtrCollection::Item)d ); }
    type *at( uint i )			{ return (type *)QGList::at(i); }
    int	  at() const			{ return QGList::at(); }
    type *current()  const		{ return (type *)QGList::get(); }
    QLNode *currentNode()  const	{ return QGList::currentNode(); }
    type *getFirst() const		{ return (type *)QGList::cfirst(); }
    type *getLast()  const		{ return (type *)QGList::clast(); }
    type *first()			{ return (type *)QGList::first(); }
    type *last()			{ return (type *)QGList::last(); }
    type *next()			{ return (type *)QGList::next(); }
    type *prev()			{ return (type *)QGList::prev(); }
    void  toVector( QGVector *vec )const{ QGList::toVector(vec); }


    
    typedef QPtrListStdIterator<type> Iterator;
    typedef QPtrListStdIterator<type> ConstIterator;
    inline Iterator begin() { return QGList::begin(); }
    inline ConstIterator begin() const { return QGList::begin(); }
    inline ConstIterator constBegin() const { return QGList::begin(); }
    inline Iterator end() { return QGList::end(); }
    inline ConstIterator end() const { return QGList::end(); }
    inline ConstIterator constEnd() const { return QGList::end(); }
    inline Iterator erase( Iterator it ) { return QGList::erase( it ); }
    
    typedef Iterator iterator;
    typedef ConstIterator const_iterator;









private:
    void  deleteItem( Item d );
};


template<> inline void QPtrList<void>::deleteItem( QPtrCollection::Item )
{
}
#line 147 "c:\\qt-3.3.8\\include\\qptrlist.h"

template<class type> inline void QPtrList<type>::deleteItem( QPtrCollection::Item d )
{
    if ( del_item ) delete (type *)d;
}

template<class type>
class QPtrListIterator : public QGListIterator
{
public:
    QPtrListIterator(const QPtrList<type> &l) :QGListIterator((QGList &)l) {}
   ~QPtrListIterator()	      {}
    uint  count()   const     { return list->count(); }
    bool  isEmpty() const     { return list->count() == 0; }
    bool  atFirst() const     { return QGListIterator::atFirst(); }
    bool  atLast()  const     { return QGListIterator::atLast(); }
    type *toFirst()	      { return (type *)QGListIterator::toFirst(); }
    type *toLast()	      { return (type *)QGListIterator::toLast(); }
    operator type *() const   { return (type *)QGListIterator::get(); }
    type *operator*()         { return (type *)QGListIterator::get(); }

    
    
    
    
    

    type *current()   const   { return (type *)QGListIterator::get(); }
    type *operator()()	      { return (type *)QGListIterator::operator()();}
    type *operator++()	      { return (type *)QGListIterator::operator++(); }
    type *operator+=(uint j)  { return (type *)QGListIterator::operator+=(j);}
    type *operator--()	      { return (type *)QGListIterator::operator--(); }
    type *operator-=(uint j)  { return (type *)QGListIterator::operator-=(j);}
    QPtrListIterator<type>& operator=(const QPtrListIterator<type>&it)
			      { QGListIterator::operator=(it); return *this; }
};




#line 188 "c:\\qt-3.3.8\\include\\qptrlist.h"


#line 1 "c:\\qt-3.3.8\\include\\qwinexport.h"










































#line 44 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 49 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 54 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 59 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 65 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 70 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 75 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 81 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 87 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 94 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 101 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 106 "c:\\qt-3.3.8\\include\\qwinexport.h"



extern template class __declspec(dllimport) QPtrListIterator<char>;
extern template class __declspec(dllimport) QPtrList<char>;
#line 112 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 118 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 124 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 130 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 136 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 141 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 146 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 151 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 156 "c:\\qt-3.3.8\\include\\qwinexport.h"







#line 164 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 170 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 176 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 182 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 187 "c:\\qt-3.3.8\\include\\qwinexport.h"








#line 196 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 202 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 207 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 211 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 218 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 222 "c:\\qt-3.3.8\\include\\qwinexport.h"
#line 191 "c:\\qt-3.3.8\\include\\qptrlist.h"

#line 193 "c:\\qt-3.3.8\\include\\qptrlist.h"
#line 126 "c:\\qt-3.3.8\\include\\qmime.h"
#line 127 "c:\\qt-3.3.8\\include\\qmime.h"







class __declspec(dllimport) QWindowsMime {
public:
    QWindowsMime();
    virtual ~QWindowsMime();

    static void initialize();

    static QPtrList<QWindowsMime> all();
    static QWindowsMime* convertor( const char* mime, int cf );
    static const char* cfToMime(int cf);

    static int registerMimeType(const char *mime);

    virtual const char* convertorName()=0;
    virtual int countCf()=0;
    virtual int cf(int index)=0;
    virtual bool canConvert( const char* mime, int cf )=0;
    virtual const char* mimeFor(int cf)=0;
    virtual int cfFor(const char* )=0;
    virtual QByteArray convertToMime( QByteArray data, const char* mime, int cf )=0;
    virtual QByteArray convertFromMime( QByteArray data, const char* mime, int cf )=0;
};

#line 158 "c:\\qt-3.3.8\\include\\qmime.h"



































#line 194 "c:\\qt-3.3.8\\include\\qmime.h"

#line 196 "c:\\qt-3.3.8\\include\\qmime.h"

#line 198 "c:\\qt-3.3.8\\include\\qmime.h"
#line 46 "c:\\qt-3.3.8\\include\\qevent.h"
#line 1 "c:\\qt-3.3.8\\include\\qpair.h"









































































































#line 47 "c:\\qt-3.3.8\\include\\qevent.h"
#line 48 "c:\\qt-3.3.8\\include\\qevent.h"

class __declspec(dllimport) QEvent: public Qt		
{
public:
    enum Type {

	






	None = 0,				


	Timer = 1,				
	MouseButtonPress = 2,			
	MouseButtonRelease = 3,			
	MouseButtonDblClick = 4,		
	MouseMove = 5,				
	KeyPress = 6,				
	KeyRelease = 7,				
	FocusIn = 8,				
	FocusOut = 9,				
	Enter = 10,				
	Leave = 11,				
	Paint = 12,				
	Move = 13,				
	Resize = 14,				
	Create = 15,				
	Destroy = 16,				
	Show = 17,				
	Hide = 18,				
	Close = 19,				
	Quit = 20,				
	Reparent = 21,				
	ShowMinimized = 22,		       	
	ShowNormal = 23,	       		
	WindowActivate = 24,	       		
	WindowDeactivate = 25,	       		
	ShowToParent = 26,	       		
	HideToParent = 27,	       		
	ShowMaximized = 28,		       	
	ShowFullScreen = 29,			
	Accel = 30,				
	Wheel = 31,				
	AccelAvailable = 32,			
	CaptionChange = 33,			
	IconChange = 34,			
	ParentFontChange = 35,			
	ApplicationFontChange = 36,		
	ParentPaletteChange = 37,		
	ApplicationPaletteChange = 38,		
	PaletteChange = 39,			
	Clipboard = 40,				
	Speech = 42,				
	SockAct = 50,				
	AccelOverride = 51,			
	DeferredDelete = 52,			
	DragEnter = 60,				
	DragMove = 61,				
	DragLeave = 62,				
	Drop = 63,				
	DragResponse = 64,			
	ChildInserted = 70,			
	ChildRemoved = 71,			
	LayoutHint = 72,			
	ShowWindowRequest = 73,			
	WindowBlocked = 74,			
	WindowUnblocked = 75,			
	ActivateControl = 80,			
	DeactivateControl = 81,			
	ContextMenu = 82,			
	IMStart = 83,				
	IMCompose = 84,				
	IMEnd = 85,				
	Accessibility = 86,			
	TabletMove = 87,			
	LocaleChange = 88,			
	LanguageChange = 89,			
	LayoutDirectionChange = 90,		
	Style = 91,				
	TabletPress = 92,			
	TabletRelease = 93,			
	OkRequest = 94,				
	HelpRequest = 95,			
	WindowStateChange = 96,			
	IconDrag = 97,                          
	User = 1000,				
	MaxUser = 65535				
    };


    QEvent( Type type ) : t(type), posted(FALSE), spont(FALSE) {}
    virtual ~QEvent();
    Type  type() const	{ return t; }
    bool spontaneous() const 	{ return spont; }
protected:
    Type  t;
private:
    uint posted : 1;
    uint spont : 1;


    friend class QApplication;
    friend class QAccelManager;
    friend class QBaseApplication;
    friend class QETWidget;
};


class __declspec(dllimport) QTimerEvent : public QEvent
{
public:
    QTimerEvent( int timerId )
	: QEvent(Timer), id(timerId) {}
    int	  timerId()	const	{ return id; }
protected:
    int	  id;
};


class __declspec(dllimport) QMouseEvent : public QEvent
{
public:
    QMouseEvent( Type type, const QPoint &pos, int button, int state );

    QMouseEvent( Type type, const QPoint &pos, const QPoint&globalPos,
		 int button, int state )
	: QEvent(type), p(pos), g(globalPos), b((ushort)button),s((ushort)state),accpt(TRUE) {};

    const QPoint &pos() const	{ return p; }
    const QPoint &globalPos() const { return g; }
    int	   x()		const	{ return p.x(); }
    int	   y()		const	{ return p.y(); }
    int	   globalX()	const	{ return g.x(); }
    int	   globalY()	const	{ return g.y(); }
    ButtonState button() const	{ return (ButtonState) b; }
    ButtonState state()	const	{ return (ButtonState) s; }
    ButtonState stateAfter() const;
    bool   isAccepted() const	{ return accpt; }
    void   accept()		{ accpt = TRUE; }
    void   ignore()		{ accpt = FALSE; }
protected:
    QPoint p;
    QPoint g;
    ushort b;
    ushort s;
    uint   accpt:1;
};



class __declspec(dllimport) QWheelEvent : public QEvent
{
public:
    QWheelEvent( const QPoint &pos, int delta, int state, Orientation orient = Vertical );
    QWheelEvent( const QPoint &pos, const QPoint& globalPos, int delta, int state, Orientation orient = Vertical  )
	: QEvent(Wheel), p(pos), g(globalPos), d(delta), s((ushort)state),
	  accpt(TRUE), o(orient) {}
    int	   delta()	const	{ return d; }
    const QPoint &pos() const	{ return p; }
    const QPoint &globalPos() const	{ return g; }
    int	   x()		const	{ return p.x(); }
    int	   y()		const	{ return p.y(); }
    int	   globalX()	const	{ return g.x(); }
    int	   globalY()	const	{ return g.y(); }
    ButtonState state()	const	{ return ButtonState(s); }
    Orientation orientation() 	const 	{ return o; }
    bool   isAccepted() const	{ return accpt; }
    void   accept()		{ accpt = TRUE; }
    void   ignore()		{ accpt = FALSE; }
protected:
    QPoint p;
    QPoint g;
    int d;
    ushort s;
    bool   accpt;
    Orientation o;
};
#line 230 "c:\\qt-3.3.8\\include\\qevent.h"

class __declspec(dllimport) QTabletEvent : public QEvent
{
public:
    enum TabletDevice { NoDevice = -1, Puck, Stylus, Eraser };
    QTabletEvent( Type t, const QPoint &pos, const QPoint &globalPos, int device,
		  int pressure, int xTilt, int yTilt, const QPair<int,int> &uId );
    QTabletEvent( const QPoint &pos, const QPoint &globalPos, int device,
		  int pressure, int xTilt, int yTilt, const QPair<int,int> &uId )
	: QEvent( TabletMove ), mPos( pos ), mGPos( globalPos ), mDev( device ),
	  mPress( pressure ), mXT( xTilt ), mYT( yTilt ), mType( uId.first ),
	  mPhy( uId.second ), mbAcc(TRUE)
    {}
    int pressure()	const { return mPress; }
    int xTilt()		const { return mXT; }
    int yTilt()		const { return mYT; }
    const QPoint &pos()	const { return mPos; }
    const QPoint &globalPos() const { return mGPos; }
    int x()		const { return mPos.x(); }
    int y()		const { return mPos.y(); }
    int globalX()	const { return mGPos.x(); }
    int globalY()	const { return mGPos.y(); }
    TabletDevice device() 	const { return TabletDevice(mDev); }
    int isAccepted() const { return mbAcc; }
    void accept() { mbAcc = TRUE; }
    void ignore() { mbAcc = FALSE; }
    QPair<int,int> uniqueId() { return QPair<int,int>( mType, mPhy); }
protected:
    QPoint mPos;
    QPoint mGPos;
    int mDev,
	mPress,
	mXT,
	mYT,
	mType,
	mPhy;
    bool mbAcc;

};

class __declspec(dllimport) QKeyEvent : public QEvent
{
public:
    QKeyEvent( Type type, int key, int ascii, int state,
		const QString& text=QString::null, bool autorep=FALSE, ushort count=1 )
	: QEvent(type), txt(text), k((ushort)key), s((ushort)state),
	    a((uchar)ascii), accpt(TRUE), autor(autorep), c(count)
    {
	if ( key >= Key_Back && key <= Key_MediaLast )
	    accpt = FALSE;
    }
    int	   key()	const	{ return k; }
    int	   ascii()	const	{ return a; }
    ButtonState state()	const	{ return ButtonState(s); }
    ButtonState stateAfter() const;
    bool   isAccepted() const	{ return accpt; }
    QString text()      const   { return txt; }
    bool   isAutoRepeat() const	{ return autor; }
    int   count() const	{ return int(c); }
    void   accept()		{ accpt = TRUE; }
    void   ignore()		{ accpt = FALSE; }

protected:
    QString txt;
    ushort k, s;
    uchar  a;
    uint   accpt:1;
    uint   autor:1;
    ushort c;
};


class __declspec(dllimport) QFocusEvent : public QEvent
{
public:

    QFocusEvent( Type type )
	: QEvent(type) {}

    bool   gotFocus()	const { return type() == FocusIn; }
    bool   lostFocus()	const { return type() == FocusOut; }

    enum Reason { Mouse, Tab, Backtab, ActiveWindow, Popup, Shortcut, Other };
    static Reason reason();
    static void setReason( Reason reason );
    static void resetReason();

private:
    static Reason m_reason;
    static Reason prev_reason;
};


class __declspec(dllimport) QPaintEvent : public QEvent
{
public:
    QPaintEvent( const QRegion& paintRegion, bool erased = TRUE)
	: QEvent(Paint),
	  rec(paintRegion.boundingRect()),
	  reg(paintRegion),
	  erase(erased){}
    QPaintEvent( const QRect &paintRect, bool erased = TRUE )
	: QEvent(Paint),
	  rec(paintRect),
	  reg(paintRect),
	  erase(erased){}
    QPaintEvent( const QRegion &paintRegion, const QRect &paintRect, bool erased = TRUE )
	: QEvent(Paint),
	  rec(paintRect),
	  reg(paintRegion),
	  erase(erased){}

    const QRect &rect() const	  { return rec; }
    const QRegion &region() const { return reg; }
    bool erased() const { return erase; }
protected:
    friend class QApplication;
    friend class QBaseApplication;
    QRect rec;
    QRegion reg;
    bool erase;
};


class __declspec(dllimport) QMoveEvent : public QEvent
{
public:
    QMoveEvent( const QPoint &pos, const QPoint &oldPos )
	: QEvent(Move), p(pos), oldp(oldPos) {}
    const QPoint &pos()	  const { return p; }
    const QPoint &oldPos()const { return oldp;}
protected:
    QPoint p, oldp;
    friend class QApplication;
    friend class QBaseApplication;
};


class __declspec(dllimport) QResizeEvent : public QEvent
{
public:
    QResizeEvent( const QSize &size, const QSize &oldSize )
	: QEvent(Resize), s(size), olds(oldSize) {}
    const QSize &size()	  const { return s; }
    const QSize &oldSize()const { return olds;}
protected:
    QSize s, olds;
    friend class QApplication;
    friend class QBaseApplication;
};


class __declspec(dllimport) QCloseEvent : public QEvent
{
public:
    QCloseEvent()
	: QEvent(Close), accpt(FALSE) {}
    bool   isAccepted() const	{ return accpt; }
    void   accept()		{ accpt = TRUE; }
    void   ignore()		{ accpt = FALSE; }
protected:
    bool   accpt;
};


class __declspec(dllimport) QIconDragEvent : public QEvent
{
public:
    QIconDragEvent() 
	: QEvent(IconDrag), accpt(FALSE) {}

    bool   isAccepted() const	{ return accpt; }
    void   accept()		{ accpt = TRUE; }
    void   ignore()		{ accpt = FALSE; }
protected:
    bool   accpt;
};

class __declspec(dllimport) QShowEvent : public QEvent
{
public:
    QShowEvent()
	: QEvent(Show) {}
};


class __declspec(dllimport) QHideEvent : public QEvent
{
public:
    QHideEvent()
	: QEvent(Hide) {}
};

class __declspec(dllimport) QContextMenuEvent : public QEvent
{
public:
    enum Reason { Mouse, Keyboard, Other };
    QContextMenuEvent( Reason reason, const QPoint &pos, const QPoint &globalPos, int state )
	: QEvent( ContextMenu ), p( pos ), gp( globalPos ), accpt( TRUE ), consum( TRUE ),
	reas( reason ), s((ushort)state) {}
    QContextMenuEvent( Reason reason, const QPoint &pos, int state );

    int	    x() const { return p.x(); }
    int	    y() const { return p.y(); }
    int	    globalX() const { return gp.x(); }
    int	    globalY() const { return gp.y(); }

    const QPoint&   pos() const { return p; }
    const QPoint&   globalPos() const { return gp; }

    ButtonState state()	const	{ return (ButtonState) s; }
    bool    isAccepted() const	{ return accpt; }
    bool    isConsumed() const	{ return consum; }
    void    consume()		{ accpt = FALSE; consum = TRUE; }
    void    accept()		{ accpt = TRUE; consum = TRUE; }
    void    ignore()		{ accpt = FALSE; consum = FALSE; }

    Reason  reason() const { return Reason( reas ); }

protected:
    QPoint  p;
    QPoint  gp;
    bool    accpt;
    bool    consum;
    uint    reas:8;
    ushort s;
};


class __declspec(dllimport) QIMEvent : public QEvent
{
public:
    QIMEvent( Type type, const QString &text, int cursorPosition )
	: QEvent(type), txt(text), cpos(cursorPosition), a(TRUE) {}
    const QString &text() const { return txt; }
    int cursorPos() const { return cpos; }
    bool isAccepted() const { return a; }
    void accept() { a = TRUE; }
    void ignore() { a = FALSE; }
    int selectionLength() const;

private:
    QString txt;
    int cpos;
    bool a;
};

class __declspec(dllimport) QIMComposeEvent : public QIMEvent
{
public:
    QIMComposeEvent( Type type, const QString &text, int cursorPosition,
		     int selLength )
	: QIMEvent( type, text, cursorPosition ), selLen( selLength ) { }

private:
    int selLen;

    friend class QIMEvent;
};

inline int QIMEvent::selectionLength() const
{
    if ( type() != IMCompose ) return 0;
    QIMComposeEvent *that = (QIMComposeEvent *) this;
    return that->selLen;
}








class __declspec(dllimport) QDropEvent : public QEvent, public QMimeSource
{
public:
    QDropEvent( const QPoint& pos, Type typ=Drop )
	: QEvent(typ), p(pos),
	  act(0), accpt(0), accptact(0), resv(0),
	  d(0)
	{}
    const QPoint &pos() const	{ return p; }
    bool isAccepted() const	{ return accpt || accptact; }
    void accept(bool y=TRUE)	{ accpt = y; }
    void ignore()		{ accpt = FALSE; }

    bool isActionAccepted() const { return accptact; }
    void acceptAction(bool y=TRUE) { accptact = y; }
    enum Action { Copy, Link, Move, Private, UserAction=100 };
    void setAction( Action a ) { act = (uint)a; }
    Action action() const { return Action(act); }

    QWidget* source() const;
    const char* format( int n = 0 ) const;
    QByteArray encodedData( const char* ) const;
    bool provides( const char* ) const;

    QByteArray data(const char* f) const { return encodedData(f); }

    void setPoint( const QPoint& np ) { p = np; }

protected:
    QPoint p;
    uint act:8;
    uint accpt:1;
    uint accptact:1;
    uint resv:5;
    void * d;
};



class __declspec(dllimport) QDragMoveEvent : public QDropEvent
{
public:
    QDragMoveEvent( const QPoint& pos, Type typ=DragMove )
	: QDropEvent(pos,typ),
	  rect( pos, QSize( 1, 1 ) ) {}
    QRect answerRect() const { return rect; }
    void accept( bool y=TRUE ) { QDropEvent::accept(y); }
    void accept( const QRect & r) { accpt = TRUE; rect = r; }
    void ignore( const QRect & r) { accpt =FALSE; rect = r; }
    void ignore()		{ QDropEvent::ignore(); }

protected:
    QRect rect;
};


class __declspec(dllimport) QDragEnterEvent : public QDragMoveEvent
{
public:
    QDragEnterEvent( const QPoint& pos ) :
	QDragMoveEvent(pos, DragEnter) { }
};



class __declspec(dllimport) QDragResponseEvent : public QEvent
{
public:
    QDragResponseEvent( bool accepted )
	: QEvent(DragResponse), a(accepted) {}
    bool   dragAccepted() const	{ return a; }
protected:
    bool a;
};


class __declspec(dllimport) QDragLeaveEvent : public QEvent
{
public:
    QDragLeaveEvent()
	: QEvent(DragLeave) {}
};

#line 588 "c:\\qt-3.3.8\\include\\qevent.h"

class __declspec(dllimport) QChildEvent : public QEvent
{
public:
    QChildEvent( Type type, QObject *child )
	: QEvent(type), c(child) {}
    QObject *child() const	{ return c; }
    bool inserted() const { return t == ChildInserted; }
    bool removed() const { return t == ChildRemoved; }
protected:
    QObject *c;
};


class __declspec(dllimport) QCustomEvent : public QEvent
{
public:
    QCustomEvent( int type );
    QCustomEvent( Type type, void *data )
	: QEvent(type), d(data) {};
    void       *data()	const	{ return d; }
    void	setData( void* data )	{ d = data; }
private:
    void       *d;
};

#line 615 "c:\\qt-3.3.8\\include\\qevent.h"
#line 46 "c:\\qt-3.3.8\\include\\qobject.h"
#line 1 "c:\\qt-3.3.8\\include\\qnamespace.h"





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 47 "c:\\qt-3.3.8\\include\\qobject.h"
#line 48 "c:\\qt-3.3.8\\include\\qobject.h"




class QMetaObject;
class QVariant;
class QMetaProperty;
class QPostEventList;
class QSenderObjectList;
class QObjectPrivate;

class QObjectUserData;
#line 61 "c:\\qt-3.3.8\\include\\qobject.h"
struct QUObject;

class __declspec(dllimport) QObject: public Qt
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
    

public:
    QObject( QObject *parent=0, const char *name=0 );
    virtual ~QObject();








    virtual bool event( QEvent * );
    virtual bool eventFilter( QObject *, QEvent * );

    bool	 isA( const char * )	 const;
    bool	 inherits( const char * ) const;

    const char  *name() const;
    const char  *name( const char * defaultName ) const;

    virtual void setName( const char *name );
    bool	 isWidgetType()	  const { return isWidget; }
    bool	 highPriority()	  const { return FALSE; }

    bool	 signalsBlocked()  const { return blockSig; }
    void	 blockSignals( bool b );

    int		 startTimer( int interval );
    void	 killTimer( int id );
    void	 killTimers();

    QObject           *child( const char *objName, const char *inheritsClass = 0, bool recursiveSearch = TRUE ); 
    const QObjectList *children() const { return childObjects; }

    static const QObjectList *objectTrees();

    QObjectList	      *queryList( const char *inheritsClass = 0,
				  const char *objName = 0,
				  bool regexpMatch = TRUE,
				  bool recursiveSearch = TRUE ) const;

    virtual void insertChild( QObject * );
    virtual void removeChild( QObject * );

    void	 installEventFilter( const QObject * );
    void	 removeEventFilter( const QObject * );

    static bool  connect( const QObject *sender, const char *signal,
			  const QObject *receiver, const char *member );
    bool	 connect( const QObject *sender, const char *signal,
			  const char *member ) const;
    static bool  disconnect( const QObject *sender, const char *signal,
			     const QObject *receiver, const char *member );
    bool	 disconnect( const char *signal=0,
			     const QObject *receiver=0, const char *member=0 );
    bool	 disconnect( const QObject *receiver, const char *member=0 );
    static void 	 connectInternal( const QObject *sender, int signal_index,
			  const QObject *receiver, int membcode, int member_index );
    static bool 	 disconnectInternal( const QObject *sender, int signal_index,
			     const QObject *receiver, int membcode, int member_index );

    void	 dumpObjectTree();
    void	 dumpObjectInfo();


    virtual bool setProperty( const char *name, const QVariant& value );
    virtual QVariant property( const char *name ) const;
#line 136 "c:\\qt-3.3.8\\include\\qobject.h"








    static uint registerUserData();
    void setUserData( uint id, QObjectUserData* data);
    QObjectUserData* userData( uint id ) const;
#line 148 "c:\\qt-3.3.8\\include\\qobject.h"

protected:
    void	 destroyed();
    void	 destroyed( QObject* obj );

public:
    QObject	*parent() const { return parentObj; }

public :
    void	deleteLater();

private :
    void	 cleanupEventFilter( QObject* );

protected:
    bool	activate_filters( QEvent * );
    QConnectionList *receivers( const char* signal ) const;
    QConnectionList *receivers( int signal ) const;
    void	activate_signal( int signal );
    void	activate_signal( int signal, int );
    void	activate_signal( int signal, double );
    void	activate_signal( int signal, QString );
    void	activate_signal_bool( int signal, bool );
    void 	activate_signal( QConnectionList *clist, QUObject *o );

    const QObject *sender();

    virtual void timerEvent( QTimerEvent * );
    virtual void childEvent( QChildEvent * );
    virtual void customEvent( QCustomEvent * );

    virtual void connectNotify( const char *signal );
    virtual void disconnectNotify( const char *signal );
    virtual bool checkConnectArgs( const char *signal, const QObject *receiver,
				   const char *member );
    static QCString normalizeSignalSlot( const char *signalSlot );

private:
    uint	isSignal   : 1;
    uint	isWidget   : 1;
    uint	pendTimer  : 1;
    uint	blockSig   : 1;
    uint	wasDeleted : 1;
    uint	isTree : 1;

    const char	*objname;
    QObject	*parentObj;
    QObjectList *childObjects;
    QSignalVec *connections;
    QSenderObjectList *senderObjects;
    QObjectList *eventFilters;
    QPostEventList *postedEvents;
    QObjectPrivate* d;

    static QMetaObject* staticQtMetaObject();

    friend class QApplication;
    friend class QBaseApplication;
    friend class QWidget;
    friend class QSignal;

private:	



#line 214 "c:\\qt-3.3.8\\include\\qobject.h"
};



class __declspec(dllimport) QObjectUserData {
public:
    virtual ~QObjectUserData();
};
#line 223 "c:\\qt-3.3.8\\include\\qobject.h"


inline bool QObject::connect( const QObject *sender, const char *signal,
			      const char *member ) const
{
    return connect( sender, signal, this, member );
}


inline bool QObject::disconnect( const char *signal,
				 const QObject *receiver, const char *member )
{
    return disconnect( this, signal, receiver, member );
}


inline bool QObject::disconnect( const QObject *receiver, const char *member )
{
    return disconnect( this, 0, receiver, member );
}















#line 1 "c:\\qt-3.3.8\\include\\qwinexport.h"










































#line 44 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 49 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 54 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 59 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 65 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 70 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 75 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 81 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 87 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 94 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 101 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 106 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 112 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 118 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 124 "c:\\qt-3.3.8\\include\\qwinexport.h"



extern template class __declspec(dllimport) QPtrListIterator<QObject>;
extern template class __declspec(dllimport) QPtrList<QObject>;
#line 130 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 136 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 141 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 146 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 151 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 156 "c:\\qt-3.3.8\\include\\qwinexport.h"







#line 164 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 170 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 176 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 182 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 187 "c:\\qt-3.3.8\\include\\qwinexport.h"








#line 196 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 202 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 207 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 211 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 218 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 222 "c:\\qt-3.3.8\\include\\qwinexport.h"
#line 259 "c:\\qt-3.3.8\\include\\qobject.h"
#line 260 "c:\\qt-3.3.8\\include\\qobject.h"
#line 44 "c:\\qt-3.3.8\\include\\qwidget.h"
#line 1 "c:\\qt-3.3.8\\include\\qpaintdevice.h"









































#line 1 "c:\\qt-3.3.8\\include\\qwindowdefs.h"


































































































































































































#line 43 "c:\\qt-3.3.8\\include\\qpaintdevice.h"
#line 1 "c:\\qt-3.3.8\\include\\qrect.h"

















































































































































































































































































#line 44 "c:\\qt-3.3.8\\include\\qpaintdevice.h"
#line 45 "c:\\qt-3.3.8\\include\\qpaintdevice.h"




#line 50 "c:\\qt-3.3.8\\include\\qpaintdevice.h"

class QIODevice;
class QString;
class QTextItem;




#line 59 "c:\\qt-3.3.8\\include\\qpaintdevice.h"

union QPDevCmdParam {
    int			 ival;
    int			*ivec;
    QString	        *str;
    const QPoint	*point;
    const QRect		*rect;
    const QPointArray	*ptarr;
    const QPixmap	*pixmap;
    const QImage	*image;
    const QColor	*color;
    const QFont		*font;
    const QPen		*pen;
    const QBrush	*brush;
    const QRegion	*rgn;
    const QWMatrix	*matrix;
    const QTextItem     *textItem;
    QIODevice		*device;
};



class __declspec(dllimport) QPaintDevice				
{
public:
    virtual ~QPaintDevice();

    int		devType() const;
    bool	isExtDev() const;
    bool	paintingActive() const;

    virtual void setResolution( int );
    virtual int resolution() const;

    
    

    virtual HDC		handle() const;







#line 105 "c:\\qt-3.3.8\\include\\qpaintdevice.h"







































#line 145 "c:\\qt-3.3.8\\include\\qpaintdevice.h"






#line 152 "c:\\qt-3.3.8\\include\\qpaintdevice.h"

    enum PDevCmd {
	PdcNOP = 0, 
	PdcDrawPoint = 1, 
	PdcDrawFirst = PdcDrawPoint,
	PdcMoveTo = 2, 
	PdcLineTo = 3, 
	PdcDrawLine = 4, 
	PdcDrawRect = 5, 
	PdcDrawRoundRect = 6, 
	PdcDrawEllipse = 7, 
	PdcDrawArc = 8, 
	PdcDrawPie = 9, 
	PdcDrawChord = 10, 
	PdcDrawLineSegments = 11, 
	PdcDrawPolyline = 12, 
	PdcDrawPolygon = 13, 
	PdcDrawCubicBezier = 14, 
	PdcDrawText = 15, 
	PdcDrawTextFormatted = 16, 
	PdcDrawPixmap = 17, 
	PdcDrawImage = 18, 
	PdcDrawText2 = 19, 
	PdcDrawText2Formatted = 20, 
	PdcDrawTextItem = 21,
	PdcDrawLast = PdcDrawTextItem,

	

	PdcBegin = 30, 
	PdcEnd = 31, 
	PdcSave = 32, 
	PdcRestore = 33, 
	PdcSetdev = 34, 
	PdcSetBkColor = 40, 
	PdcSetBkMode = 41, 
	PdcSetROP = 42, 
	PdcSetBrushOrigin = 43, 
	PdcSetFont = 45, 
	PdcSetPen = 46, 
	PdcSetBrush = 47, 
	PdcSetTabStops = 48, 
	PdcSetTabArray = 49, 
	PdcSetUnit = 50, 
	PdcSetVXform = 51, 
	PdcSetWindow = 52, 
	PdcSetViewport = 53, 
	PdcSetWXform = 54, 
	PdcSetWMatrix = 55, 
	PdcSaveWMatrix = 56,
	PdcRestoreWMatrix = 57,
	PdcSetClip = 60, 
	PdcSetClipRegion = 61, 

	PdcReservedStart = 0, 
	PdcReservedStop = 199 
    };

protected:
    QPaintDevice( uint devflags );


    HDC		hdc;				















#line 231 "c:\\qt-3.3.8\\include\\qpaintdevice.h"

    virtual bool cmd( int, QPainter *, QPDevCmdParam * );
    virtual int	 metric( int ) const;
    virtual int	 fontMet( QFont *, int, const char * = 0, int = 0 ) const;
    virtual int	 fontInf( QFont *, int ) const;

    ushort	devFlags;			
    ushort	painters;			

    friend class QPainter;
    friend class QPaintDeviceMetrics;






#line 249 "c:\\qt-3.3.8\\include\\qpaintdevice.h"
    friend __declspec(dllimport) void bitBlt( QPaintDevice *, int, int,
				 const QPaintDevice *,
				 int, int, int, int, Qt::RasterOp, bool );
#line 253 "c:\\qt-3.3.8\\include\\qpaintdevice.h"



#line 257 "c:\\qt-3.3.8\\include\\qpaintdevice.h"

private:






















#line 282 "c:\\qt-3.3.8\\include\\qpaintdevice.h"

private:	



#line 288 "c:\\qt-3.3.8\\include\\qpaintdevice.h"
};


__declspec(dllimport)
void bitBlt( QPaintDevice *dst, int dx, int dy,
	     const QPaintDevice *src, int sx=0, int sy=0, int sw=-1, int sh=-1,
	     Qt::RasterOp = Qt::CopyROP, bool ignoreMask=FALSE );

__declspec(dllimport)
void bitBlt( QPaintDevice *dst, int dx, int dy,
	     const QImage *src, int sx=0, int sy=0, int sw=-1, int sh=-1,
	     int conversion_flags=0 );















#line 316 "c:\\qt-3.3.8\\include\\qpaintdevice.h"





inline int QPaintDevice::devType() const
{ return devFlags & QInternal::DeviceTypeMask; }

inline bool QPaintDevice::isExtDev() const
{ return (devFlags & QInternal::ExternalDevice) != 0; }

inline bool QPaintDevice::paintingActive() const
{ return painters != 0; }










































































#line 404 "c:\\qt-3.3.8\\include\\qpaintdevice.h"


__declspec(dllimport)
inline void bitBlt( QPaintDevice *dst, const QPoint &dp,
		    const QPaintDevice *src, const QRect &sr =QRect(0,0,-1,-1),
		    Qt::RasterOp rop=Qt::CopyROP, bool ignoreMask=FALSE )
{
    bitBlt( dst, dp.x(), dp.y(), src, sr.x(), sr.y(), sr.width(), sr.height(),
	    rop, ignoreMask );
}




#line 419 "c:\\qt-3.3.8\\include\\qpaintdevice.h"
#line 45 "c:\\qt-3.3.8\\include\\qwidget.h"
#line 1 "c:\\qt-3.3.8\\include\\qpalette.h"









































#line 1 "c:\\qt-3.3.8\\include\\qwindowdefs.h"


































































































































































































#line 43 "c:\\qt-3.3.8\\include\\qpalette.h"
#line 1 "c:\\qt-3.3.8\\include\\qcolor.h"









































#line 1 "c:\\qt-3.3.8\\include\\qwindowdefs.h"


































































































































































































#line 43 "c:\\qt-3.3.8\\include\\qcolor.h"
#line 1 "c:\\qt-3.3.8\\include\\qstringlist.h"









































#line 1 "c:\\qt-3.3.8\\include\\qvaluelist.h"


























































































































































































































































































































































































































































































































































































































































































#line 43 "c:\\qt-3.3.8\\include\\qstringlist.h"
#line 1 "c:\\qt-3.3.8\\include\\qstring.h"

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 44 "c:\\qt-3.3.8\\include\\qstringlist.h"
#line 1 "c:\\qt-3.3.8\\include\\qstrlist.h"









































#line 1 "c:\\qt-3.3.8\\include\\qstring.h"

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 43 "c:\\qt-3.3.8\\include\\qstrlist.h"
#line 1 "c:\\qt-3.3.8\\include\\qptrlist.h"
































































































































































































#line 44 "c:\\qt-3.3.8\\include\\qstrlist.h"
#line 1 "c:\\qt-3.3.8\\include\\qdatastream.h"






























































































































































































#line 45 "c:\\qt-3.3.8\\include\\qstrlist.h"
#line 46 "c:\\qt-3.3.8\\include\\qstrlist.h"





#line 52 "c:\\qt-3.3.8\\include\\qstrlist.h"
typedef QPtrListIterator<char> QStrListIterator;
#line 54 "c:\\qt-3.3.8\\include\\qstrlist.h"

class __declspec(dllimport) QStrList : public QPtrList<char>
{
public:
    QStrList( bool deepCopies=TRUE ) { dc = deepCopies; del_item = deepCopies; }
    QStrList( const QStrList & );
    ~QStrList()			{ clear(); }
    QStrList& operator=( const QStrList & );

private:
    QPtrCollection::Item newItem( QPtrCollection::Item d ) { return dc ? qstrdup( (const char*)d ) : d; }
    void deleteItem( QPtrCollection::Item d ) { if ( del_item ) delete[] (char*)d; }
    int compareItems( QPtrCollection::Item s1, QPtrCollection::Item s2 ) { return qstrcmp((const char*)s1,
							 (const char*)s2); }

    QDataStream &read( QDataStream &s, QPtrCollection::Item &d )
				{ s >> (char *&)d; return s; }
    QDataStream &write( QDataStream &s, QPtrCollection::Item d ) const
				{ return s << (const char *)d; }
#line 74 "c:\\qt-3.3.8\\include\\qstrlist.h"
    bool  dc;
};


class __declspec(dllimport) QStrIList : public QStrList	
{
public:
    QStrIList( bool deepCopies=TRUE ) : QStrList( deepCopies ) {}
    ~QStrIList()			{ clear(); }
private:
    int	  compareItems( QPtrCollection::Item s1, QPtrCollection::Item s2 )
				{ return qstricmp((const char*)s1,
						    (const char*)s2); }
};


inline QStrList & QStrList::operator=( const QStrList &strList )
{
    clear();
    dc = strList.dc;
    del_item = dc;
    QPtrList<char>::operator=( strList );
    return *this;
}

inline QStrList::QStrList( const QStrList &strList )
    : QPtrList<char>( strList )
{
    dc = FALSE;
    operator=( strList );
}

#line 107 "c:\\qt-3.3.8\\include\\qstrlist.h"
#line 45 "c:\\qt-3.3.8\\include\\qstringlist.h"
#line 46 "c:\\qt-3.3.8\\include\\qstringlist.h"



class QRegExp;
template <class T> class QDeepCopy;





#line 57 "c:\\qt-3.3.8\\include\\qstringlist.h"

class __declspec(dllimport) QStringList : public QValueList<QString>
{
public:
    QStringList() { }
    QStringList( const QStringList& l ) : QValueList<QString>(l) { }
    QStringList( const QValueList<QString>& l ) : QValueList<QString>(l) { }
    QStringList( const QString& i ) { append(i); }

    QStringList( const char* i ) { append(i); }
#line 68 "c:\\qt-3.3.8\\include\\qstringlist.h"

    static QStringList fromStrList(const QStrList&);

    void sort();

    static QStringList split( const QString &sep, const QString &str, bool allowEmptyEntries = FALSE );
    static QStringList split( const QChar &sep, const QString &str, bool allowEmptyEntries = FALSE );

    static QStringList split( const QRegExp &sep, const QString &str, bool allowEmptyEntries = FALSE );
#line 78 "c:\\qt-3.3.8\\include\\qstringlist.h"
    QString join( const QString &sep ) const;

    QStringList grep( const QString &str, bool cs = TRUE ) const;

    QStringList grep( const QRegExp &expr ) const;
#line 84 "c:\\qt-3.3.8\\include\\qstringlist.h"

    QStringList& gres( const QString &before, const QString &after,
		       bool cs = TRUE );

    QStringList& gres( const QRegExp &expr, const QString &after );
#line 90 "c:\\qt-3.3.8\\include\\qstringlist.h"

protected:
    void detach() { QValueList<QString>::detach(); }
    friend class QDeepCopy< QStringList >;
};


class QDataStream;
extern __declspec(dllimport) QDataStream &operator>>( QDataStream &, QStringList& );
extern __declspec(dllimport) QDataStream &operator<<( QDataStream &, const QStringList& );
#line 101 "c:\\qt-3.3.8\\include\\qstringlist.h"

#line 103 "c:\\qt-3.3.8\\include\\qstringlist.h"
#line 104 "c:\\qt-3.3.8\\include\\qstringlist.h"
#line 44 "c:\\qt-3.3.8\\include\\qcolor.h"
#line 45 "c:\\qt-3.3.8\\include\\qcolor.h"

const QRgb  RGB_MASK    = 0x00ffffff;		

__declspec(dllimport) inline int qRed( QRgb rgb )		
{ return (int)((rgb >> 16) & 0xff); }

__declspec(dllimport) inline int qGreen( QRgb rgb )		
{ return (int)((rgb >> 8) & 0xff); }

__declspec(dllimport) inline int qBlue( QRgb rgb )		
{ return (int)(rgb & 0xff); }

__declspec(dllimport) inline int qAlpha( QRgb rgb )		
{ return (int)((rgb >> 24) & 0xff); }

__declspec(dllimport) inline QRgb qRgb( int r, int g, int b )
{ return (0xff << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff); }

__declspec(dllimport) inline QRgb qRgba( int r, int g, int b, int a )
{ return ((a & 0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff); }

__declspec(dllimport) inline int qGray( int r, int g, int b )
{ return (r*11+g*16+b*5)/32; }

__declspec(dllimport) inline int qGray( QRgb rgb )		
{ return qGray( qRed(rgb), qGreen(rgb), qBlue(rgb) ); }


class __declspec(dllimport) QColor
{
public:
    enum Spec { Rgb, Hsv };

    QColor();
    QColor( int r, int g, int b );
    QColor( int x, int y, int z, Spec );
    QColor( QRgb rgb, uint pixel=0xffffffff);
    QColor( const QString& name );
    QColor( const char *name );
    QColor( const QColor & );
    QColor &operator=( const QColor & );

    bool   isValid() const;
    bool   isDirty() const;
    QString name() const;
    void   setNamedColor( const QString& name );

    QRgb   rgb()    const;
    void   setRgb( int r, int g, int b );
    void   setRgb( QRgb rgb );
    void   getRgb( int *r, int *g, int *b ) const { rgb( r, g, b ); }
    void   rgb( int *r, int *g, int *b ) const; 

    int	   red()    const;
    int	   green()  const;
    int	   blue()   const;

    void   setHsv( int h, int s, int v );
    void   getHsv( int *h, int *s, int *v ) const { hsv( h, s, v ); }
    void   hsv( int *h, int *s, int *v ) const; 
    void   getHsv( int &h, int &s, int &v ) const { hsv( &h, &s, &v ); } 

    QColor light( int f = 150 ) const;
    QColor dark( int f = 200 )	const;

    bool   operator==( const QColor &c ) const;
    bool   operator!=( const QColor &c ) const;

    uint   alloc();
    uint   pixel()  const;





#line 121 "c:\\qt-3.3.8\\include\\qcolor.h"

    static int  maxColors();
    static int  numBitPlanes();

    static int  enterAllocContext();
    static void leaveAllocContext();
    static int  currentAllocContext();
    static void destroyAllocContext( int );


    static const QRgb* palette( int* numEntries = 0 );
    static int setPaletteEntries( const QRgb* entries, int numEntries,
				  int base = -1 );
    static HPALETTE hPal()  { return hpal; }
    static uint	realizePal( QWidget * );
#line 137 "c:\\qt-3.3.8\\include\\qcolor.h"

    static void initialize();
    static void cleanup();

    static QStringList colorNames();
#line 143 "c:\\qt-3.3.8\\include\\qcolor.h"
    enum { Dirt = 0x44495254, Invalid = 0x49000000 };

private:
    void setSystemNamedColor( const QString& name );
    void setPixel( uint pixel );
    static void initGlobalColors();
    static uint argbToPix32(QRgb);
    static QColor* globalColors();
    static bool color_init;
    static bool globals_init;

    static HPALETTE hpal;
#line 156 "c:\\qt-3.3.8\\include\\qcolor.h"
    static enum ColorModel { d8, d32 } colormodel;
    union {
	QRgb argb;
	struct D8 {
	    QRgb argb;
	    uchar pix;
	    uchar invalid;
	    uchar dirty;
	    uchar direct;
	} d8;
	struct D32 {
	    QRgb argb;
	    uint pix;
	    bool invalid() const { return argb == QColor::Invalid && pix == QColor::Dirt; }
	    bool probablyDirty() const { return pix == QColor::Dirt; }
	} d32;
    } d;
};


inline QColor::QColor()
{ d.d32.argb = Invalid; d.d32.pix = Dirt; }

inline QColor::QColor( int r, int g, int b )
{
    d.d32.argb = Invalid;
    d.d32.pix = Dirt;
    setRgb( r, g, b );
}

inline QRgb QColor::rgb() const
{ return d.argb; }

inline int QColor::red() const
{ return qRed(d.argb); }

inline int QColor::green() const
{ return qGreen(d.argb); }

inline int QColor::blue() const
{ return qBlue(d.argb); }

inline bool QColor::isValid() const
{
    if ( colormodel == d8 )
	return !d.d8.invalid;
    else
	return !d.d32.invalid();
}

inline bool QColor::operator==( const QColor &c ) const
{
    return d.argb == c.d.argb && isValid() == c.isValid();
}

inline bool QColor::operator!=( const QColor &c ) const
{
    return !operator==(c);
}







__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QColor & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QColor & );
#line 225 "c:\\qt-3.3.8\\include\\qcolor.h"

#line 227 "c:\\qt-3.3.8\\include\\qcolor.h"
#line 44 "c:\\qt-3.3.8\\include\\qpalette.h"
#line 1 "c:\\qt-3.3.8\\include\\qshared.h"























































#line 45 "c:\\qt-3.3.8\\include\\qpalette.h"
#line 1 "c:\\qt-3.3.8\\include\\qbrush.h"









































#line 1 "c:\\qt-3.3.8\\include\\qcolor.h"


































































































































































































































#line 43 "c:\\qt-3.3.8\\include\\qbrush.h"
#line 1 "c:\\qt-3.3.8\\include\\qshared.h"























































#line 44 "c:\\qt-3.3.8\\include\\qbrush.h"
#line 45 "c:\\qt-3.3.8\\include\\qbrush.h"


class __declspec(dllimport) QBrush: public Qt
{
friend class QPainter;
public:
    QBrush();
    QBrush( BrushStyle );
    QBrush( const QColor &, BrushStyle=SolidPattern );
    QBrush( const QColor &, const QPixmap & );
    QBrush( const QBrush & );
   ~QBrush();
    QBrush &operator=( const QBrush & );

    BrushStyle	style()	 const		{ return data->style; }
    void	setStyle( BrushStyle );
    const QColor &color()const		{ return data->color; }
    void	setColor( const QColor & );
    QPixmap    *pixmap() const		{ return data->pixmap; }
    void	setPixmap( const QPixmap & );

    bool	operator==( const QBrush &p ) const;
    bool	operator!=( const QBrush &b ) const
					{ return !(operator==(b)); }

private:
    QBrush	copy()	const;
    void	detach();
    void	init( const QColor &, BrushStyle );
    struct QBrushData : public QShared {	
	BrushStyle style;
	QColor	  color;
	QPixmap	 *pixmap;
    } *data;
};







__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QBrush & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QBrush & );
#line 90 "c:\\qt-3.3.8\\include\\qbrush.h"

#line 92 "c:\\qt-3.3.8\\include\\qbrush.h"
#line 46 "c:\\qt-3.3.8\\include\\qpalette.h"
#line 47 "c:\\qt-3.3.8\\include\\qpalette.h"



class QColorGroupPrivate;

class __declspec(dllimport) QColorGroup
{
public:
    QColorGroup();
    QColorGroup( const QColor &foreground, const QColor &button,
		 const QColor &light, const QColor &dark, const QColor &mid,
		 const QColor &text, const QColor &base );
    QColorGroup( const QBrush &foreground, const QBrush &button,
		 const QBrush &light, const QBrush &dark, const QBrush &mid,
		 const QBrush &text, const QBrush &bright_text,
		 const QBrush &base, const QBrush &background);
    QColorGroup( const QColorGroup & );

   ~QColorGroup();

    QColorGroup& operator =(const QColorGroup&);

    
    enum ColorRole { Foreground, Button, Light, Midlight, Dark, Mid,
		     Text, BrightText, ButtonText, Base, Background, Shadow,
		     Highlight, HighlightedText, Link, LinkVisited,
		     NColorRoles };

    const QColor &color( ColorRole ) const;
    const QBrush &brush( ColorRole ) const;
    void setColor( ColorRole, const QColor & );
    void setBrush( ColorRole, const QBrush & );

    const QColor &foreground()	const	{ return br[Foreground].color(); }
    const QColor &button()	const	{ return br[Button].color(); }
    const QColor &light()	const	{ return br[Light].color(); }
    const QColor &dark()	const	{ return br[Dark].color(); }
    const QColor &mid()		const	{ return br[Mid].color(); }
    const QColor &text()	const	{ return br[Text].color(); }
    const QColor &base()	const	{ return br[Base].color(); }
    const QColor &background()	const	{ return br[Background].color(); }

    const QColor &midlight()	const	{ return br[Midlight].color(); }
    const QColor &brightText()	const	{ return br[BrightText].color(); }
    const QColor &buttonText()	const	{ return br[ButtonText].color(); }
    const QColor &shadow()	const	{ return br[Shadow].color(); }
    const QColor &highlight()	const	{ return br[Highlight].color(); }
    const QColor &highlightedText() const{return br[HighlightedText].color(); }
    const QColor &link()        const   { return br[Link].color(); }
    const QColor &linkVisited() const   { return br[LinkVisited].color(); }

    bool	operator==( const QColorGroup &g ) const;
    bool	operator!=( const QColorGroup &g ) const
	{ return !(operator==(g)); }

private:
    QBrush *br;
    QColorGroupPrivate * d;

    friend class QPalette;
};


class __declspec(dllimport) QPalette
{
public:
    QPalette();
    QPalette( const QColor &button );
    QPalette( const QColor &button, const QColor &background );
    QPalette( const QColorGroup &active, const QColorGroup &disabled,
	      const QColorGroup &inactive );
    QPalette( const QPalette & );
    ~QPalette();
    QPalette &operator=( const QPalette & );

    enum ColorGroup { Disabled, Active, Inactive, NColorGroups, Normal=Active };

    const QColor &color( ColorGroup, QColorGroup::ColorRole ) const;
    const QBrush &brush( ColorGroup, QColorGroup::ColorRole ) const;
    void setColor( ColorGroup, QColorGroup::ColorRole, const QColor & );
    void setBrush( ColorGroup, QColorGroup::ColorRole, const QBrush & );

    void setColor( QColorGroup::ColorRole, const QColor & );
    void setBrush( QColorGroup::ColorRole, const QBrush & );

    QPalette	copy() const;

    const QColorGroup &active() const { return data->active; }
    const QColorGroup &disabled() const { return data->disabled; }
    const QColorGroup &inactive() const { return data->inactive; }

    const QColorGroup &normal() const { return active(); }
#line 140 "c:\\qt-3.3.8\\include\\qpalette.h"

    void	setActive( const QColorGroup & );
    void	setDisabled( const QColorGroup & );
    void	setInactive( const QColorGroup & );

    void	setNormal( const QColorGroup & cg ) { setActive(cg); }
#line 147 "c:\\qt-3.3.8\\include\\qpalette.h"

    bool	operator==( const QPalette &p ) const;
    bool	operator!=( const QPalette &p ) const
              { return !(operator==(p)); }
    bool	isCopyOf( const QPalette & );

    int		serialNumber() const	{ return data->ser_no; }
    
    
    static QColorGroup::ColorRole foregroundRoleFromMode( Qt::BackgroundMode mode );
    static QColorGroup::ColorRole backgroundRoleFromMode( Qt::BackgroundMode mode);

private:
    void	detach();
    const QBrush &directBrush( ColorGroup, QColorGroup::ColorRole ) const;
    void directSetBrush( ColorGroup, QColorGroup::ColorRole, const QBrush& );

    struct QPalData : public QShared {
	QColorGroup disabled;
	QColorGroup active;
	int	    ser_no;
	QColorGroup inactive;
    } *data;
};







__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QColorGroup & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QColorGroup & );

__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QPalette & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QPalette & );
#line 184 "c:\\qt-3.3.8\\include\\qpalette.h"

#line 186 "c:\\qt-3.3.8\\include\\qpalette.h"
#line 187 "c:\\qt-3.3.8\\include\\qpalette.h"
#line 46 "c:\\qt-3.3.8\\include\\qwidget.h"
#line 1 "c:\\qt-3.3.8\\include\\qfont.h"









































#line 1 "c:\\qt-3.3.8\\include\\qwindowdefs.h"


































































































































































































#line 43 "c:\\qt-3.3.8\\include\\qfont.h"
#line 1 "c:\\qt-3.3.8\\include\\qstring.h"

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 44 "c:\\qt-3.3.8\\include\\qfont.h"
#line 45 "c:\\qt-3.3.8\\include\\qfont.h"


class QFontPrivate;                                     
class QStringList;
class QTextFormatCollection;

class __declspec(dllimport) QFont
{
public:
    enum StyleHint {
	Helvetica,  SansSerif = Helvetica,
	Times,      Serif = Times,
	Courier,    TypeWriter = Courier,
	OldEnglish, Decorative = OldEnglish,
	System,
	AnyStyle
    };

    enum StyleStrategy {
	PreferDefault    = 0x0001,
	PreferBitmap     = 0x0002,
	PreferDevice     = 0x0004,
	PreferOutline    = 0x0008,
	ForceOutline     = 0x0010,
	PreferMatch      = 0x0020,
	PreferQuality    = 0x0040,
	PreferAntialias  = 0x0080,
	NoAntialias      = 0x0100,
	OpenGLCompatible = 0x0200
    };

    enum Weight {
	Light    = 25,
	Normal   = 50,
	DemiBold = 63,
	Bold     = 75,
	Black	 = 87
    };

    enum Stretch {
	UltraCondensed =  50,
	ExtraCondensed =  62,
	Condensed      =  75,
	SemiCondensed  =  87,
	Unstretched    = 100,
	SemiExpanded   = 112,
	Expanded       = 125,
	ExtraExpanded  = 150,
	UltraExpanded  = 200
    };

    
    QFont();
    




    QFont( const QString &family, int pointSize = -1, int weight = -1,
	   bool italic = FALSE );
#line 106 "c:\\qt-3.3.8\\include\\qfont.h"
    
    QFont( const QFont & );

    ~QFont();

    QString family() const;
    void setFamily( const QString &);

    int pointSize() const;
    float pointSizeFloat() const;
    void setPointSize( int );
    void setPointSizeFloat( float );

    int pixelSize() const;
    void setPixelSize( int );
    void setPixelSizeFloat( float );

    int weight() const;
    void setWeight( int );

    bool bold() const;
    void setBold( bool );

    bool italic() const;
    void setItalic( bool );

    bool underline() const;
    void setUnderline( bool );

    bool overline() const;
    void setOverline( bool );

    bool strikeOut() const;
    void setStrikeOut( bool );

    bool fixedPitch() const;
    void setFixedPitch( bool );

    StyleHint styleHint() const;
    StyleStrategy styleStrategy() const;
    void setStyleHint( StyleHint, StyleStrategy = PreferDefault );
    void setStyleStrategy( StyleStrategy s );

    int stretch() const;
    void setStretch( int );

    
    bool rawMode() const;
    void setRawMode( bool );

    
    bool exactMatch() const;

    QFont &operator=( const QFont & );
    bool operator==( const QFont & ) const;
    bool operator!=( const QFont & ) const;
    bool isCopyOf( const QFont & ) const;



    HFONT handle() const;


#line 170 "c:\\qt-3.3.8\\include\\qfont.h"


    
    void setRawName( const QString & );
    QString rawName() const;

    QString key() const;

    QString toString() const;
    bool fromString(const QString &);


    static QString substitute(const QString &);
    static QStringList substitutes(const QString &);
    static QStringList substitutions();
    static void insertSubstitution(const QString&, const QString &);
    static void insertSubstitutions(const QString&, const QStringList &);
    static void removeSubstitution(const QString &);
#line 189 "c:\\qt-3.3.8\\include\\qfont.h"
    static void initialize();
    static void cleanup();

    static void cacheStatistics();
#line 194 "c:\\qt-3.3.8\\include\\qfont.h"



#line 198 "c:\\qt-3.3.8\\include\\qfont.h"


    
    
    
    enum Script {
	
	Latin,
	Greek,
	Cyrillic,
	Armenian,
	Georgian,
	Runic,
	Ogham,
	SpacingModifiers,
	CombiningMarks,

	
	Hebrew,
	Arabic,
	Syriac,
	Thaana,

	
	Devanagari,
	Bengali,
	Gurmukhi,
	Gujarati,
	Oriya,
	Tamil,
	Telugu,
	Kannada,
	Malayalam,
	Sinhala,
	Thai,
	Lao,
	Tibetan,
	Myanmar,
	Khmer,

	
	Han,
	Hiragana,
	Katakana,
	Hangul,
	Bopomofo,
	Yi,

	
	Ethiopic,
	Cherokee,
	CanadianAboriginal,
	Mongolian,

	
	CurrencySymbols,
	LetterlikeSymbols,
	NumberForms,
	MathematicalOperators,
	TechnicalSymbols,
	GeometricSymbols,
	MiscellaneousSymbols,
	EnclosedAndSquare,
	Braille,

	Unicode,

	
	Tagalog,
	Hanunoo,
	Buhid,
	Tagbanwa,

	KatakanaHalfWidth,

	
	Limbu,
	TaiLe,

	

	NScripts,
	UnknownScript = NScripts,

	NoScript,

	
	
	

	Han_Japanese,
	Han_SimplifiedChinese,
	Han_TraditionalChinese,
	Han_Korean,

	LastPrivateScript
#line 295 "c:\\qt-3.3.8\\include\\qfont.h"
    };

    QString defaultFamily() const;
    QString lastResortFamily() const;
    QString lastResortFont() const;



    static QFont defaultFont();
    static void setDefaultFont( const QFont & );

#line 307 "c:\\qt-3.3.8\\include\\qfont.h"

    QFont resolve( const QFont & ) const;

protected:
    
    bool dirty() const;
    int deciPointSize() const;

private:
    QFont( QFontPrivate *, QPaintDevice *pd );

    void detach();



#line 323 "c:\\qt-3.3.8\\include\\qfont.h"


#line 326 "c:\\qt-3.3.8\\include\\qfont.h"

    friend class QFontMetrics;
    friend class QFontInfo;
    friend class QPainter;
    friend class QPSPrinterFont;
    friend class QApplication;
    friend class QWidget;
    friend class QTextFormatCollection;
    friend class QTextLayout;
    friend class QTextItem;
    friend class QGLContext;


#line 340 "c:\\qt-3.3.8\\include\\qfont.h"

    friend __declspec(dllimport) QDataStream &operator<<( QDataStream &, const QFont & );
    friend __declspec(dllimport) QDataStream &operator>>( QDataStream &, QFont & );
#line 344 "c:\\qt-3.3.8\\include\\qfont.h"

    QFontPrivate *d;
};


inline bool QFont::bold() const
{ return weight() > Normal; }


inline void QFont::setBold( bool enable )
{ setWeight( enable ? Bold : Normal ); }









__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QFont & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QFont & );
#line 367 "c:\\qt-3.3.8\\include\\qfont.h"


#line 370 "c:\\qt-3.3.8\\include\\qfont.h"
#line 47 "c:\\qt-3.3.8\\include\\qwidget.h"
#line 1 "c:\\qt-3.3.8\\include\\qfontmetrics.h"









































#line 1 "c:\\qt-3.3.8\\include\\qfont.h"

















































































































































































































































































































































































#line 43 "c:\\qt-3.3.8\\include\\qfontmetrics.h"
#line 1 "c:\\qt-3.3.8\\include\\qrect.h"

















































































































































































































































































#line 44 "c:\\qt-3.3.8\\include\\qfontmetrics.h"
#line 45 "c:\\qt-3.3.8\\include\\qfontmetrics.h"





class QTextCodec;
class QTextParag;

class __declspec(dllimport) QFontMetrics
{
public:
    QFontMetrics( const QFont & );
    QFontMetrics( const QFont &, QFont::Script );
    QFontMetrics( const QFontMetrics & );
    ~QFontMetrics();

    QFontMetrics &operator=( const QFontMetrics & );

    int		ascent()	const;
    int		descent()	const;
    int		height()	const;
    int		leading()	const;
    int		lineSpacing()	const;
    int		minLeftBearing() const;
    int		minRightBearing() const;
    int		maxWidth()	const;

    bool	inFont(QChar)	const;

    int		leftBearing(QChar) const;
    int		rightBearing(QChar) const;
    int		width( const QString &, int len = -1 ) const;

    int		width( QChar ) const;

    int		width( char c ) const { return width( (QChar) c ); }
#line 82 "c:\\qt-3.3.8\\include\\qfontmetrics.h"

    int 		charWidth( const QString &str, int pos ) const;
    QRect	boundingRect( const QString &, int len = -1 ) const;
    QRect	boundingRect( QChar ) const;
    QRect	boundingRect( int x, int y, int w, int h, int flags,
			      const QString& str, int len=-1, int tabstops=0,
			      int *tabarray=0, QTextParag **intern=0 ) const;
    QSize	size( int flags,
		      const QString& str, int len=-1, int tabstops=0,
		      int *tabarray=0, QTextParag **intern=0 ) const;

    int		underlinePos()	const;
    int         overlinePos()   const;
    int		strikeOutPos()	const;
    int		lineWidth()	const;

private:
    QFontMetrics( const QPainter * );

    friend class QWidget;
    friend class QPainter;
    friend class QTextFormat;


#line 107 "c:\\qt-3.3.8\\include\\qfontmetrics.h"

    QFontPrivate  *d;
    QPainter      *painter;
    int		   fscript;
};


#line 115 "c:\\qt-3.3.8\\include\\qfontmetrics.h"
#line 48 "c:\\qt-3.3.8\\include\\qwidget.h"
#line 1 "c:\\qt-3.3.8\\include\\qfontinfo.h"









































#line 1 "c:\\qt-3.3.8\\include\\qfont.h"

















































































































































































































































































































































































#line 43 "c:\\qt-3.3.8\\include\\qfontinfo.h"
#line 44 "c:\\qt-3.3.8\\include\\qfontinfo.h"


class __declspec(dllimport) QFontInfo
{
public:
    QFontInfo( const QFont & );
    QFontInfo( const QFont &, QFont::Script );
    QFontInfo( const QFontInfo & );
    ~QFontInfo();

    QFontInfo	       &operator=( const QFontInfo & );

    QString   	        family()	const;
    int			pixelSize()	const;
    int			pointSize()	const;
    bool		italic()	const;
    int			weight()	const;
    bool		bold()		const;
    bool		underline()	const;
    bool                overline()      const;
    bool		strikeOut()	const;
    bool		fixedPitch()	const;
    QFont::StyleHint	styleHint()	const;
    bool		rawMode()	const;

    bool		exactMatch()	const;


private:
    QFontInfo( const QPainter * );

    QFontPrivate *d;
    QPainter *painter;
    int fscript;

    friend class QWidget;
    friend class QPainter;
};


inline bool QFontInfo::bold() const
{ return weight() > QFont::Normal; }


#line 89 "c:\\qt-3.3.8\\include\\qfontinfo.h"
#line 49 "c:\\qt-3.3.8\\include\\qwidget.h"
#line 1 "c:\\qt-3.3.8\\include\\qsizepolicy.h"









































#line 1 "c:\\qt-3.3.8\\include\\qglobal.h"





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1111 "c:\\qt-3.3.8\\include\\qglobal.h"


#pragma warning(disable: 4244) 
#pragma warning(disable: 4275) 
#pragma warning(disable: 4514) 
#pragma warning(disable: 4800) 
#pragma warning(disable: 4097) 
#pragma warning(disable: 4706) 
#pragma warning(disable: 4786) 
#pragma warning(disable: 4660) 
#pragma warning(disable: 4355) 
#pragma warning(disable: 4231) 
#pragma warning(disable: 4710) 








#line 1133 "c:\\qt-3.3.8\\include\\qglobal.h"
#line 1134 "c:\\qt-3.3.8\\include\\qglobal.h"


#line 43 "c:\\qt-3.3.8\\include\\qsizepolicy.h"
#line 44 "c:\\qt-3.3.8\\include\\qsizepolicy.h"



class __declspec(dllimport) QSizePolicy
{
private:
    enum SizePolicy_Internal { HSize = 6, HMask = 0x3f, VMask = HMask << HSize,
                               MayGrow = 1, ExpMask = 2, MayShrink = 4 };
public:
    enum SizeType { Fixed = 0,
		    Minimum = MayGrow,
		    Maximum = MayShrink,
		    Preferred = MayGrow | MayShrink,
		    MinimumExpanding = MayGrow | ExpMask,
		    Expanding = MayGrow | MayShrink | ExpMask,
		    Ignored = ExpMask  };

    enum ExpandData { NoDirection = 0,
		      Horizontally = 1,
		      Vertically = 2,

		      Horizontal = Horizontally,
		      Vertical = Vertically,
#line 68 "c:\\qt-3.3.8\\include\\qsizepolicy.h"
		      BothDirections = Horizontally | Vertically };

    QSizePolicy() : data( 0 ) { }

    QSizePolicy( SizeType hor, SizeType ver, bool hfw = FALSE )
	: data( hor | (ver<<HSize) | (hfw ? (Q_UINT32)(1<<2*HSize) : 0) ) { }
    QSizePolicy( SizeType hor, SizeType ver, uchar hors, uchar vers, bool hfw = FALSE );

    SizeType horData() const { return (SizeType)( data & HMask ); }
    SizeType verData() const { return (SizeType)( (data & VMask) >> HSize ); }

    bool mayShrinkHorizontally() const { return horData() & MayShrink || horData() == Ignored; }
    bool mayShrinkVertically() const { return verData() & MayShrink || verData() == Ignored; }
    bool mayGrowHorizontally() const { return horData() & MayGrow || horData() == Ignored; }
    bool mayGrowVertically() const { return verData() & MayGrow || verData() == Ignored; }

    ExpandData expanding() const
    {
	return (ExpandData)( (int)(verData() & ExpMask ? Vertically : 0) |
			     (int)(horData() & ExpMask ? Horizontally : 0) );
    }

    void setHorData( SizeType d ) { data = (Q_UINT32)(data & ~HMask) | d; }
    void setVerData( SizeType d ) { data = (Q_UINT32)(data & ~(HMask << HSize)) |
					   (d << HSize); }

    void setHeightForWidth( bool b ) { data = b ? (Q_UINT32)( data | ( 1 << 2*HSize ) )
					      : (Q_UINT32)( data & ~( 1 << 2*HSize ) );  }
    bool hasHeightForWidth() const { return data & ( 1 << 2*HSize ); }

    bool operator==( const QSizePolicy& s ) const { return data == s.data; }
    bool operator!=( const QSizePolicy& s ) const { return data != s.data; }


    uint horStretch() const { return data >> 24; }
    uint verStretch() const { return (data >> 16) & 0xff; }
    void setHorStretch( uchar sf ) { data = (data&0x00ffffff) | (uint(sf)<<24); }
    void setVerStretch( uchar sf ) { data = (data&0xff00ffff) | (uint(sf)<<16); }
    inline void transpose();

private:
    QSizePolicy( int i ) : data( (Q_UINT32)i ) { }

    Q_UINT32 data;
};

inline QSizePolicy::QSizePolicy( SizeType hor, SizeType ver, uchar hors, uchar vers, bool hfw )
    : data( hor | (ver<<HSize) | (hfw ? (Q_UINT32)(1<<2*HSize) : 0) ) {
    setHorStretch( hors );
    setVerStretch( vers );
}

inline void QSizePolicy::transpose() {
    *this = QSizePolicy( verData(), horData(), verStretch(), horStretch(),
			 hasHeightForWidth() );
}

#line 126 "c:\\qt-3.3.8\\include\\qsizepolicy.h"
#line 50 "c:\\qt-3.3.8\\include\\qwidget.h"
#line 51 "c:\\qt-3.3.8\\include\\qwidget.h"

class QLayout;
struct QWExtra;
struct QTLWExtra;
class QFocusData;
class QCursor;
class QWSRegionManager;
class QStyle;

class __declspec(dllimport) QWidget : public QObject, public QPaintDevice
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
#line 106 "c:\\qt-3.3.8\\include\\qwidget.h"

    
    
    
#line 111 "c:\\qt-3.3.8\\include\\qwidget.h"
    
    
    
    
    
    
    
    
     
    
    
    
    
    
    
    
    
    
    
    
    
    

public:
    explicit QWidget( QWidget* parent=0, const char* name=0, WFlags f=0 );
    ~QWidget();

    WId		 winId() const;
    void	 setName( const char *name );

    

    QStyle     &style() const;
    void        setStyle( QStyle * );
    QStyle*	setStyle( const QString& );
#line 147 "c:\\qt-3.3.8\\include\\qwidget.h"
    

    bool	 isTopLevel()	const;
    bool	 isDialog()	const;
    bool	 isPopup()	const;
    bool	 isDesktop()	const;
    bool	 isModal()	const;

    bool	 isEnabled()	const;
    bool	 isEnabledTo(QWidget*) const;
    bool	 isEnabledToTLW() const;

public :
    virtual void setEnabled( bool );
    void setDisabled( bool );

    

public:
    QRect	 frameGeometry() const;
    const QRect &geometry()	const;
    int		 x()		const;
    int		 y()		const;
    QPoint	 pos()		const;
    QSize	 frameSize()    const;
    QSize	 size()		const;
    int		 width()	const;
    int		 height()	const;
    QRect	 rect()		const;
    QRect	 childrenRect() const;
    QRegion	 childrenRegion() const;

    QSize	 minimumSize()	 const;
    QSize	 maximumSize()	 const;
    int		 minimumWidth()	 const;
    int		 minimumHeight() const;
    int		 maximumWidth()	 const;
    int		 maximumHeight() const;
    void	 setMinimumSize( const QSize & );
    virtual void setMinimumSize( int minw, int minh );
    void	 setMaximumSize( const QSize & );
    virtual void setMaximumSize( int maxw, int maxh );
    void	 setMinimumWidth( int minw );
    void	 setMinimumHeight( int minh );
    void	 setMaximumWidth( int maxw );
    void	 setMaximumHeight( int maxh );

    QSize	 sizeIncrement() const;
    void	 setSizeIncrement( const QSize & );
    virtual void setSizeIncrement( int w, int h );
    QSize	 baseSize() const;
    void	 setBaseSize( const QSize & );
    void	 setBaseSize( int basew, int baseh );

    void	setFixedSize( const QSize & );
    void	setFixedSize( int w, int h );
    void	setFixedWidth( int w );
    void	setFixedHeight( int h );

    

    QPoint	 mapToGlobal( const QPoint & )	 const;
    QPoint	 mapFromGlobal( const QPoint & ) const;
    QPoint	 mapToParent( const QPoint & )	 const;
    QPoint	 mapFromParent( const QPoint & ) const;
    QPoint	 mapTo( QWidget *, const QPoint & ) const;
    QPoint	 mapFrom( QWidget *, const QPoint & ) const;

    QWidget	*topLevelWidget()   const;

    

    BackgroundMode	backgroundMode() const;
    virtual void	setBackgroundMode( BackgroundMode );
    void 		setBackgroundMode( BackgroundMode, BackgroundMode );

    const QColor &	foregroundColor() const;

    const QColor &	eraseColor() const;
    virtual void	setEraseColor( const QColor & );

    const QPixmap *	erasePixmap() const;
    virtual void	setErasePixmap( const QPixmap & );


    const QColorGroup & colorGroup() const;
    const QPalette &	palette()    const;
    bool		ownPalette() const;
    virtual void	setPalette( const QPalette & );
    void		unsetPalette();
#line 238 "c:\\qt-3.3.8\\include\\qwidget.h"

    const QColor &	paletteForegroundColor() const;
    void		setPaletteForegroundColor( const QColor & );

    const QColor &	paletteBackgroundColor() const;
    virtual void	setPaletteBackgroundColor( const QColor & );

    const QPixmap *	paletteBackgroundPixmap() const;
    virtual void 	setPaletteBackgroundPixmap( const QPixmap & );

    const QBrush&	backgroundBrush() const;

    QFont		font() const;
    bool		ownFont() const;
    virtual void	setFont( const QFont & );
    void		unsetFont();
    QFontMetrics	fontMetrics() const;
    QFontInfo	 	fontInfo() const;


    const QCursor      &cursor() const;
    bool		ownCursor() const;
    virtual void	setCursor( const QCursor & );
    virtual void	unsetCursor();
#line 263 "c:\\qt-3.3.8\\include\\qwidget.h"

    QString		caption() const;
    const QPixmap      *icon() const;
    QString		iconText() const;
#line 268 "c:\\qt-3.3.8\\include\\qwidget.h"
    bool		hasMouseTracking() const;
    bool		hasMouse() const;

    virtual void	setMask( const QBitmap & );
    virtual void	setMask( const QRegion & );
    void		clearMask();

    const QColor &	backgroundColor() const; 
    virtual void	setBackgroundColor( const QColor & ); 
    const QPixmap *	backgroundPixmap() const; 
    virtual void	setBackgroundPixmap( const QPixmap & ); 

public :

    virtual void	setCaption( const QString &);
    virtual void	setIcon( const QPixmap & );
    virtual void	setIconText( const QString &);
#line 286 "c:\\qt-3.3.8\\include\\qwidget.h"
    virtual void	setMouseTracking( bool enable );

    

    virtual void	setFocus();
    void		clearFocus();

public:
    enum FocusPolicy {
	NoFocus = 0,
	TabFocus = 0x1,
	ClickFocus = 0x2,
	StrongFocus = TabFocus | ClickFocus | 0x8,
	WheelFocus = StrongFocus | 0x4
    };

    bool		isActiveWindow() const;
    virtual void	setActiveWindow();
    bool		isFocusEnabled() const;

    FocusPolicy		focusPolicy() const;
    virtual void	setFocusPolicy( FocusPolicy );
    bool		hasFocus() const;
    static void		setTabOrder( QWidget *, QWidget * );
    virtual void	setFocusProxy( QWidget * );
    QWidget *		focusProxy() const;

    void setInputMethodEnabled( bool b );
    bool isInputMethodEnabled() const;
    

    void		grabMouse();

    void		grabMouse( const QCursor & );
#line 321 "c:\\qt-3.3.8\\include\\qwidget.h"
    void		releaseMouse();
    void		grabKeyboard();
    void		releaseKeyboard();
    static QWidget *	mouseGrabber();
    static QWidget *	keyboardGrabber();

    

    bool	 	isUpdatesEnabled() const;



#line 334 "c:\\qt-3.3.8\\include\\qwidget.h"
public :
    virtual void	setUpdatesEnabled( bool enable );
    void		update();
    void		update( int x, int y, int w, int h );
    void		update( const QRect& );
    void		repaint();
    void		repaint( bool erase );
    void		repaint( int x, int y, int w, int h, bool erase=TRUE );
    void		repaint( const QRect &, bool erase = TRUE );
    void		repaint( const QRegion &, bool erase = TRUE );

    

    virtual void	show();
    virtual void	hide();
    void		setShown( bool show );
    void		setHidden( bool hide );

    void		iconify() { showMinimized(); }
#line 354 "c:\\qt-3.3.8\\include\\qwidget.h"
    virtual void	showMinimized();
    virtual void	showMaximized();
    void		showFullScreen();
    virtual void	showNormal();
    virtual void	polish();
    void 		constPolish() const;
    bool		close();

    void		raise();
    void		lower();
    void		stackUnder( QWidget* );
    virtual void	move( int x, int y );
    void		move( const QPoint & );
    virtual void	resize( int w, int h );
    void		resize( const QSize & );
    virtual void	setGeometry( int x, int y, int w, int h );
    virtual void	setGeometry( const QRect & ); 

public:
    virtual bool	close( bool alsoDelete );
    bool		isVisible()	const;
    bool		isVisibleTo(QWidget*) const;
    bool		isVisibleToTLW() const; 
    QRect		visibleRect() const; 
    bool 		isHidden() const;
    bool 		isShown() const;
    bool		isMinimized() const;
    bool		isMaximized() const;
    bool		isFullScreen() const;

    uint windowState() const;
    void setWindowState(uint windowState);

    virtual QSize	sizeHint() const;
    virtual QSize	minimumSizeHint() const;
    virtual QSizePolicy	sizePolicy() const;
    virtual void	setSizePolicy( QSizePolicy );
    void 		setSizePolicy( QSizePolicy::SizeType hor, QSizePolicy::SizeType ver, bool hfw = FALSE );
    virtual int heightForWidth(int) const;

    QRegion	clipRegion() const;


public :
    virtual void  	adjustSize();

public:

    QLayout *		layout() const { return lay_out; }
#line 404 "c:\\qt-3.3.8\\include\\qwidget.h"
    void		updateGeometry();
    virtual void 	reparent( QWidget *parent, WFlags, const QPoint &,
				  bool showIt=FALSE );
    void		reparent( QWidget *parent, const QPoint &,
				  bool showIt=FALSE );

    void		recreate( QWidget *parent, WFlags f, const QPoint & p,
				  bool showIt=FALSE ) { reparent(parent,f,p,showIt); }
#line 413 "c:\\qt-3.3.8\\include\\qwidget.h"

    void		erase();
    void		erase( int x, int y, int w, int h );
    void		erase( const QRect & );
    void		erase( const QRegion & );
    void		scroll( int dx, int dy );
    void		scroll( int dx, int dy, const QRect& );

    void		drawText( int x, int y, const QString &);
    void		drawText( const QPoint &, const QString &);

    

    QWidget *		focusWidget() const;
    QRect               microFocusHint() const;

    

    bool		acceptDrops() const;
    virtual void	setAcceptDrops( bool on );

    

    virtual void	setAutoMask(bool);
    bool		autoMask() const;

    enum BackgroundOrigin { WidgetOrigin, ParentOrigin, WindowOrigin, AncestorOrigin };

    virtual void setBackgroundOrigin( BackgroundOrigin );
    BackgroundOrigin backgroundOrigin() const;
    QPoint backgroundOffset() const;

    
    virtual bool customWhatsThis() const;

    QWidget *		parentWidget( bool sameWindow = FALSE ) const;
    WState		testWState( WState s ) const;
    WFlags		testWFlags( WFlags f ) const;
    static QWidget *	find( WId );
    static QWidgetMapper *wmapper();

    QWidget  *childAt( int x, int y, bool includeThis = FALSE ) const;
    QWidget  *childAt( const QPoint &, bool includeThis = FALSE ) const;



#line 460 "c:\\qt-3.3.8\\include\\qwidget.h"






#line 467 "c:\\qt-3.3.8\\include\\qwidget.h"

    void setWindowOpacity(double level);
    double windowOpacity() const;

protected:
    
    bool	 event( QEvent * );
    virtual void mousePressEvent( QMouseEvent * );
    virtual void mouseReleaseEvent( QMouseEvent * );
    virtual void mouseDoubleClickEvent( QMouseEvent * );
    virtual void mouseMoveEvent( QMouseEvent * );

    virtual void wheelEvent( QWheelEvent * );
#line 481 "c:\\qt-3.3.8\\include\\qwidget.h"
    virtual void keyPressEvent( QKeyEvent * );
    virtual void keyReleaseEvent( QKeyEvent * );
    virtual void focusInEvent( QFocusEvent * );
    virtual void focusOutEvent( QFocusEvent * );
    virtual void enterEvent( QEvent * );
    virtual void leaveEvent( QEvent * );
    virtual void paintEvent( QPaintEvent * );
    virtual void moveEvent( QMoveEvent * );
    virtual void resizeEvent( QResizeEvent * );
    virtual void closeEvent( QCloseEvent * );
    virtual void contextMenuEvent( QContextMenuEvent * );
    virtual void imStartEvent( QIMEvent * );
    virtual void imComposeEvent( QIMEvent * );
    virtual void imEndEvent( QIMEvent * );
    virtual void tabletEvent( QTabletEvent * );


    virtual void dragEnterEvent( QDragEnterEvent * );
    virtual void dragMoveEvent( QDragMoveEvent * );
    virtual void dragLeaveEvent( QDragLeaveEvent * );
    virtual void dropEvent( QDropEvent * );
#line 503 "c:\\qt-3.3.8\\include\\qwidget.h"

    virtual void showEvent( QShowEvent * );
    virtual void hideEvent( QHideEvent * );



#line 510 "c:\\qt-3.3.8\\include\\qwidget.h"

    virtual bool winEvent( MSG * );
#line 513 "c:\\qt-3.3.8\\include\\qwidget.h"


#line 516 "c:\\qt-3.3.8\\include\\qwidget.h"




#line 521 "c:\\qt-3.3.8\\include\\qwidget.h"

    virtual void updateMask();

    


    virtual void styleChange( QStyle& );
#line 529 "c:\\qt-3.3.8\\include\\qwidget.h"
    virtual void enabledChange( bool oldEnabled );

    virtual void paletteChange( const QPalette & );
#line 533 "c:\\qt-3.3.8\\include\\qwidget.h"
    virtual void fontChange( const QFont & );
    virtual void windowActivationChange( bool oldActive );

    int		 metric( int )	const;

    void	 resetInputContext();

    virtual void create( WId = 0, bool initializeWindow = TRUE,
			 bool destroyOldWindow = TRUE );
    virtual void destroy( bool destroyWindow = TRUE,
			  bool destroySubWindows = TRUE );
    uint	 getWState() const;
    virtual void setWState( uint );
    void	 clearWState( uint n );
    WFlags	 getWFlags() const;
    virtual void setWFlags( WFlags );
    void	 clearWFlags( WFlags n );

    virtual bool focusNextPrevChild( bool next );

    QWExtra	*extraData();
    QTLWExtra	*topData();
    QFocusData	*focusData();

    virtual void setKeyCompression(bool);
    virtual void setMicroFocusHint(int x, int y, int w, int h, bool text=TRUE, QFont *f = 0);






#line 566 "c:\\qt-3.3.8\\include\\qwidget.h"

private :
    void	 focusProxyDestroyed();

private:
    void	 setFontSys( QFont *f = 0 );





#line 578 "c:\\qt-3.3.8\\include\\qwidget.h"
















#line 595 "c:\\qt-3.3.8\\include\\qwidget.h"


    void 	 setLayout( QLayout *l );
#line 599 "c:\\qt-3.3.8\\include\\qwidget.h"
    void	 setWinId( WId );
    void	 showWindow();
    void	 hideWindow();
    void	 showChildren( bool spontaneous );
    void	 hideChildren( bool spontaneous );
    void	 reparentSys( QWidget *parent, WFlags, const QPoint &,  bool showIt);
    void	 createTLExtra();
    void	 createExtra();
    void	 deleteExtra();
    void	 createSysExtra();
    void	 deleteSysExtra();
    void	 createTLSysExtra();
    void	 deleteTLSysExtra();
    void	 deactivateWidgetCleanup();
    void	 internalSetGeometry( int, int, int, int, bool );
    void	 reparentFocusWidgets( QWidget * );
    QFocusData	*focusData( bool create );
    void         setBackgroundFromMode();
    void         setBackgroundColorDirect( const QColor & );
    void   	 setBackgroundPixmapDirect( const QPixmap & );
    void         setBackgroundModeDirect( BackgroundMode );
    void         setBackgroundEmpty();
    void	 updateFrameStrut() const;


#line 625 "c:\\qt-3.3.8\\include\\qwidget.h"

    WId		 winid;
    uint	 widget_state;
    uint	 widget_flags;
    uint	 focus_policy : 4;
    uint 	 own_font :1;
    uint 	 own_palette :1;
    uint 	 sizehint_forced :1;
    uint 	 is_closing :1;
    uint 	 in_show : 1;
    uint 	 in_show_maximized : 1;
    uint	 fstrut_dirty : 1;
    uint	 im_enabled : 1;
    QRect	 crect;
    QColor	 bg_col;

    QPalette	 pal;
#line 643 "c:\\qt-3.3.8\\include\\qwidget.h"
    QFont	 fnt;

    QLayout 	*lay_out;
#line 647 "c:\\qt-3.3.8\\include\\qwidget.h"
    QWExtra	*extra;





























#line 678 "c:\\qt-3.3.8\\include\\qwidget.h"
    static int instanceCounter;  
    static int maxInstances;     

    static void	 createMapper();
    static void	 destroyMapper();
    static QWidgetList	 *wList();
    static QWidgetList	 *tlwList();
    static QWidgetMapper *mapper;
    friend class QApplication;
    friend class QBaseApplication;
    friend class QPainter;
    friend class QFontMetrics;
    friend class QFontInfo;
    friend class QETWidget;
    friend class QLayout;

private:	



#line 699 "c:\\qt-3.3.8\\include\\qwidget.h"

public: 

    void setPalette( const QPalette &p, bool ) { setPalette( p ); }
#line 704 "c:\\qt-3.3.8\\include\\qwidget.h"
    void setFont( const QFont &f, bool ) { setFont( f ); }
};


inline Qt::WState QWidget::testWState( WState s ) const
{ return (widget_state & s); }

inline Qt::WFlags QWidget::testWFlags( WFlags f ) const
{ return (widget_flags & f); }


inline WId QWidget::winId() const
{ return winid; }

inline bool QWidget::isTopLevel() const
{ return testWFlags(WType_TopLevel); }

inline bool QWidget::isDialog() const
{ return testWFlags(WType_Dialog); }

inline bool QWidget::isPopup() const
{ return testWFlags(WType_Popup); }

inline bool QWidget::isDesktop() const
{ return testWFlags(WType_Desktop); }

inline bool QWidget::isEnabled() const
{ return !testWState(WState_Disabled); }

inline bool QWidget::isModal() const
{ return testWFlags(WShowModal); }

inline bool QWidget::isEnabledToTLW() const
{ return isEnabled(); }

inline const QRect &QWidget::geometry() const
{ return crect; }

inline QSize QWidget::size() const
{ return crect.size(); }

inline int QWidget::width() const
{ return crect.width(); }

inline int QWidget::height() const
{ return crect.height(); }

inline QRect QWidget::rect() const
{ return QRect(0,0,crect.width(),crect.height()); }

inline int QWidget::minimumWidth() const
{ return minimumSize().width(); }

inline int QWidget::minimumHeight() const
{ return minimumSize().height(); }

inline int QWidget::maximumWidth() const
{ return maximumSize().width(); }

inline int QWidget::maximumHeight() const
{ return maximumSize().height(); }

inline void QWidget::setMinimumSize( const QSize &s )
{ setMinimumSize(s.width(),s.height()); }

inline void QWidget::setMaximumSize( const QSize &s )
{ setMaximumSize(s.width(),s.height()); }

inline void QWidget::setSizeIncrement( const QSize &s )
{ setSizeIncrement(s.width(),s.height()); }

inline void QWidget::setBaseSize( const QSize &s )
{ setBaseSize(s.width(),s.height()); }

inline const QColor &QWidget::eraseColor() const
{ return bg_col; }


inline const QPalette &QWidget::palette() const
{ return pal; }
#line 785 "c:\\qt-3.3.8\\include\\qwidget.h"

inline QFont QWidget::font() const
{ return fnt; }

inline QFontMetrics QWidget::fontMetrics() const
{ return QFontMetrics(font()); }

inline QFontInfo QWidget::fontInfo() const
{ return QFontInfo(font()); }

inline bool QWidget::hasMouseTracking() const
{ return testWState(WState_MouseTracking); }

inline bool QWidget::hasMouse() const
{ return testWState(WState_HasMouse); }

inline bool  QWidget::isFocusEnabled() const
{ return (FocusPolicy)focus_policy != NoFocus; }

inline QWidget::FocusPolicy QWidget::focusPolicy() const
{ return (FocusPolicy)focus_policy; }

inline bool QWidget::isUpdatesEnabled() const
{ return !testWState(WState_BlockUpdates); }

inline void QWidget::update( const QRect &r )
{ update( r.x(), r.y(), r.width(), r.height() ); }

inline void QWidget::repaint()
{ repaint( TRUE ); }

inline void QWidget::repaint( const QRect &r, bool erase )
{ repaint( r.x(), r.y(), r.width(), r.height(), erase ); }

inline void QWidget::erase()
{ erase( 0, 0, crect.width(), crect.height() ); }

inline void QWidget::erase( const QRect &r )
{ erase( r.x(), r.y(), r.width(), r.height() ); }

inline bool QWidget::close()
{ return close( FALSE ); }

inline bool QWidget::isVisible() const
{ return testWState(WState_Visible); }

inline bool QWidget::isVisibleToTLW() const 
{ return isVisible(); }

inline bool QWidget::isHidden() const
{ return testWState(WState_ForceHide); }

inline bool QWidget::isShown() const
{ return !testWState(WState_ForceHide); }

inline void QWidget::move( const QPoint &p )
{ move( p.x(), p.y() ); }

inline void QWidget::resize( const QSize &s )
{ resize( s.width(), s.height()); }

inline void QWidget::setGeometry( const QRect &r )
{ setGeometry( r.left(), r.top(), r.width(), r.height() ); }

inline void QWidget::drawText( const QPoint &p, const QString &s )
{ drawText( p.x(), p.y(), s ); }

inline QWidget *QWidget::parentWidget( bool sameWindow ) const
{
    if ( sameWindow )
	return isTopLevel() ? 0 : (QWidget *)QObject::parent();
    return (QWidget *)QObject::parent();
}

inline QWidgetMapper *QWidget::wmapper()
{ return mapper; }

inline uint QWidget::getWState() const
{ return widget_state; }

inline void QWidget::setWState( uint f )
{ widget_state |= f; }

inline void QWidget::clearWState( uint f )
{ widget_state &= ~f; }

inline Qt::WFlags QWidget::getWFlags() const
{ return widget_flags; }

inline void QWidget::setWFlags( WFlags f )
{ widget_flags |= f; }

inline void QWidget::clearWFlags( WFlags f )
{ widget_flags &= ~f; }

inline void QWidget::constPolish() const
{
    if ( !testWState(WState_Polished) ) {
	QWidget* that = (QWidget*) this;
	that->polish();
        that->setWState(WState_Polished); 
    }
}

inline bool QWidget::ownCursor() const
{
    return testWState( WState_OwnCursor );
}
#line 894 "c:\\qt-3.3.8\\include\\qwidget.h"
inline bool QWidget::ownFont() const
{
    return own_font;
}

inline bool QWidget::ownPalette() const
{
    return own_palette;
}
#line 904 "c:\\qt-3.3.8\\include\\qwidget.h"

inline void QWidget::setSizePolicy( QSizePolicy::SizeType hor, QSizePolicy::SizeType ver, bool hfw )
{
    setSizePolicy( QSizePolicy( hor, ver, hfw) );
}

inline bool QWidget::isInputMethodEnabled() const
{
    return (bool)im_enabled;
}





class QFocusData;
class QWSManager;

class QOleDropTarget;
#line 924 "c:\\qt-3.3.8\\include\\qwidget.h"


#line 927 "c:\\qt-3.3.8\\include\\qwidget.h"

struct __declspec(dllimport) QTLWExtra {

    QString  caption;				
    QString  iconText;				
    QPixmap *icon;				
#line 934 "c:\\qt-3.3.8\\include\\qwidget.h"
    QFocusData *focusData;			
    short    incw, inch;			
    
    ulong    fleft, fright, ftop, fbottom;
    uint     unused : 8;                       

    uint     opacity : 8;		       
#line 942 "c:\\qt-3.3.8\\include\\qwidget.h"
    uint     savedFlags;			
    short    basew, baseh;			









#line 954 "c:\\qt-3.3.8\\include\\qwidget.h"




#line 959 "c:\\qt-3.3.8\\include\\qwidget.h"



#line 963 "c:\\qt-3.3.8\\include\\qwidget.h"

    HICON    winIcon;				
#line 966 "c:\\qt-3.3.8\\include\\qwidget.h"
    QRect    normalGeometry;			

    uint style, exstyle;
#line 970 "c:\\qt-3.3.8\\include\\qwidget.h"
};






struct __declspec(dllimport) QWExtra {
    Q_INT16  minw, minh;			
    Q_INT16  maxw, maxh;			
    QPixmap *bg_pix;				
    QWidget *focus_proxy;

    QCursor *curs;
#line 985 "c:\\qt-3.3.8\\include\\qwidget.h"
    QTLWExtra *topextra;			

    QOleDropTarget *dropTarget;			
#line 989 "c:\\qt-3.3.8\\include\\qwidget.h"


#line 992 "c:\\qt-3.3.8\\include\\qwidget.h"










#line 1003 "c:\\qt-3.3.8\\include\\qwidget.h"
    uint bg_origin : 2;



#line 1008 "c:\\qt-3.3.8\\include\\qwidget.h"


#line 1011 "c:\\qt-3.3.8\\include\\qwidget.h"
    char     bg_mode;				
    char     bg_mode_visual;			

    QStyle* style;
#line 1016 "c:\\qt-3.3.8\\include\\qwidget.h"
    QRect micro_focus_hint;			
    QSizePolicy size_policy;
};


#line 1 "c:\\qt-3.3.8\\include\\qwinexport.h"










































#line 44 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 49 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 54 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 59 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 65 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 70 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 75 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 81 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 87 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 94 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 101 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 106 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 112 "c:\\qt-3.3.8\\include\\qwinexport.h"



extern template class __declspec(dllimport) QPtrListIterator<QWidget>;
extern template class __declspec(dllimport) QPtrList<QWidget>;
#line 118 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 124 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 130 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 136 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 141 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 146 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 151 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 156 "c:\\qt-3.3.8\\include\\qwinexport.h"







#line 164 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 170 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 176 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 182 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 187 "c:\\qt-3.3.8\\include\\qwinexport.h"








#line 196 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 202 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 207 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 211 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 218 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 222 "c:\\qt-3.3.8\\include\\qwinexport.h"
#line 1022 "c:\\qt-3.3.8\\include\\qwidget.h"

#line 1024 "c:\\qt-3.3.8\\include\\qwidget.h"

#line 43 "C:\\qt-3.3.8\\include\\qgl.h"
#line 1 "c:\\qt-3.3.8\\include\\qglcolormap.h"









































#line 1 "c:\\qt-3.3.8\\include\\qcolor.h"


































































































































































































































#line 43 "c:\\qt-3.3.8\\include\\qglcolormap.h"
#line 1 "c:\\qt-3.3.8\\include\\qmemarray.h"






















































































































#line 44 "c:\\qt-3.3.8\\include\\qglcolormap.h"
#line 1 "c:\\qt-3.3.8\\include\\qshared.h"























































#line 45 "c:\\qt-3.3.8\\include\\qglcolormap.h"
#line 46 "c:\\qt-3.3.8\\include\\qglcolormap.h"



#line 50 "c:\\qt-3.3.8\\include\\qglcolormap.h"

#line 52 "c:\\qt-3.3.8\\include\\qglcolormap.h"

class QWidget;
class __declspec(dllimport) QGLColormap
{
public:
    QGLColormap();
    QGLColormap( const QGLColormap & );
    ~QGLColormap();
    
    QGLColormap &operator=( const QGLColormap & );
    
    bool   isEmpty() const;
    int    size() const;
    void   detach();

    void   setEntries( int count, const QRgb * colors, int base = 0 );
    void   setEntry( int idx, QRgb color );
    void   setEntry( int idx, const QColor & color );
    QRgb   entryRgb( int idx ) const;
    QColor entryColor( int idx ) const;
    int    find( QRgb color ) const;
    int    findNearest( QRgb color ) const;
    
private:
    class Private : public QShared
    {
    public:
	Private() {
	    cells.resize( 256 ); 
	    cmapHandle = 0;
	}

	~Private() {
	}

	QMemArray<QRgb> cells;
	Qt::HANDLE      cmapHandle;
    };
    
    Private * d;

    friend class QGLWidget;
};

#line 97 "c:\\qt-3.3.8\\include\\qglcolormap.h"
#line 44 "C:\\qt-3.3.8\\include\\qgl.h"
#line 45 "C:\\qt-3.3.8\\include\\qgl.h"



#line 49 "C:\\qt-3.3.8\\include\\qgl.h"

#line 51 "C:\\qt-3.3.8\\include\\qgl.h"




__declspec(dllimport) inline const char *qGLVersion() {
    qObsolete( 0, "qGLVersion", "qVersion" );
    return "4.5";
}
#line 60 "C:\\qt-3.3.8\\include\\qgl.h"


#line 1 "c:\\qt-3.3.8\\include\\qt_windows.h"


























#line 28 "c:\\qt-3.3.8\\include\\qt_windows.h"


#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"


























#line 28 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"





#pragma once
#line 35 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"

















































#line 85 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"




















#line 106 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"



#line 110 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"



#line 114 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"



#line 118 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"



#line 122 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"





#line 128 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"




#line 133 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 134 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"







#line 142 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 143 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"



#pragma warning(disable:4514)

#pragma warning(disable:4103)
#line 150 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"

#pragma warning(push)
#line 153 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#line 157 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\excpt.h"















#pragma once
#line 18 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\excpt.h"




#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 23 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\excpt.h"






#pragma pack(push,8)
#line 31 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\excpt.h"


extern "C" {
#line 35 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\excpt.h"




typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;











struct _EXCEPTION_RECORD;
struct _CONTEXT;

EXCEPTION_DISPOSITION __cdecl _except_handler (
         struct _EXCEPTION_RECORD *_ExceptionRecord,
         void * _EstablisherFrame,
         struct _CONTEXT *_ContextRecord,
         void * _DispatcherContext
    );





























#line 95 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\excpt.h"















unsigned long __cdecl _exception_code(void);
void *        __cdecl _exception_info(void);
int           __cdecl _abnormal_termination(void);

#line 115 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\excpt.h"













}
#line 130 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\excpt.h"


#pragma pack(pop)
#line 134 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\excpt.h"

#line 136 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\excpt.h"
#line 158 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdarg.h"















#pragma once
#line 18 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdarg.h"






#line 25 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdarg.h"








#line 34 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\stdarg.h"
#line 159 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 160 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"















#line 17 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"
#line 18 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"
















extern "C" {
#line 36 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"











typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef char *PSZ;
#line 55 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"













#line 69 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"



#line 73 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"



#line 77 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"



#line 81 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"



#line 85 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"











#line 97 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"






#line 104 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"



#line 108 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"
#line 109 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"


























#line 136 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"





#line 142 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"







#line 150 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"

typedef unsigned long       DWORD;
typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef float               FLOAT;
typedef FLOAT               *PFLOAT;
typedef BOOL            *PBOOL;
typedef BOOL             *LPBOOL;
typedef BYTE            *PBYTE;
typedef BYTE             *LPBYTE;
typedef int             *PINT;
typedef int              *LPINT;
typedef WORD            *PWORD;
typedef WORD             *LPWORD;
typedef long             *LPLONG;
typedef DWORD           *PDWORD;
typedef DWORD            *LPDWORD;
typedef void             *LPVOID;
typedef const void       *LPCVOID;

typedef int                 INT;
typedef unsigned int        UINT;
typedef unsigned int        *PUINT;


#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





















extern "C" {
#line 24 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"




#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\specstrings.h"






























































































































































































































#pragma once
#line 225 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\specstrings.h"







extern "C" {




#line 238 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\specstrings.h"














































































































































































































#line 445 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\specstrings.h"



    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

#line 482 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\specstrings.h"














































































































































































}
#line 658 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\specstrings.h"


#line 29 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"



#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

#line 35 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"








#line 44 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


#line 47 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





#line 53 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


#line 56 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"









#line 66 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"



#line 70 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"














#line 85 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"



#line 89 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"










#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"





























#line 31 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"



#line 35 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"




#line 40 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"
typedef unsigned long POINTER_64_INT;
#line 42 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"

#line 44 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"



#line 48 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"

#line 50 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"



#pragma once
#line 55 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"


extern "C" {
#line 59 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"

typedef signed char         INT8, *PINT8;
typedef signed short        INT16, *PINT16;
typedef signed int          INT32, *PINT32;
typedef signed __int64      INT64, *PINT64;
typedef unsigned char       UINT8, *PUINT8;
typedef unsigned short      UINT16, *PUINT16;
typedef unsigned int        UINT32, *PUINT32;
typedef unsigned __int64    UINT64, *PUINT64;





typedef signed int LONG32, *PLONG32;





typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;







#line 89 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"

















#line 107 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"











#line 119 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"
    typedef __w64 int INT_PTR, *PINT_PTR;
    typedef __w64 unsigned int UINT_PTR, *PUINT_PTR;

    typedef __w64 long LONG_PTR, *PLONG_PTR;
    typedef __w64 unsigned long ULONG_PTR, *PULONG_PTR;

    

#line 128 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"
#line 129 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"





























































































































































































typedef unsigned short UHALF_PTR, *PUHALF_PTR;
typedef short HALF_PTR, *PHALF_PTR;
typedef __w64 long SHANDLE_PTR;
typedef __w64 unsigned long HANDLE_PTR;

















__inline
void * __ptr64
PtrToPtr64(
    const void *p
    )
{
    return((void * __ptr64) (unsigned __int64) (ULONG_PTR)p );
}

__inline
void *
Ptr64ToPtr(
    const void * __ptr64 p
    )
{
    return((void *) (ULONG_PTR) (unsigned __int64) p);
}

__inline
void * __ptr64
HandleToHandle64(
    const void *h
    )
{
    return((void * __ptr64) h );
}

__inline
void *
Handle64ToHandle(
    const void * __ptr64 h
    )
{
    return((void *) (ULONG_PTR) (unsigned __int64) h );
}
#line 375 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"






#line 382 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"























typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;





typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;





typedef __int64 LONG64, *PLONG64;






typedef unsigned __int64 ULONG64, *PULONG64;
typedef unsigned __int64 DWORD64, *PDWORD64;





typedef ULONG_PTR KAFFINITY;
typedef KAFFINITY *PKAFFINITY;


}
#line 438 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"

#line 440 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\basetsd.h"
#line 100 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"






#line 107 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"






#line 114 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#line 115 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"






#line 122 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#line 123 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"






#line 130 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#line 131 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"



#line 135 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"






#line 142 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#line 143 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"






#line 150 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#line 151 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"






#line 158 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#line 159 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"






#line 166 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#line 167 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"




#line 172 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

#line 174 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#line 175 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"






#line 182 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#line 183 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"






#line 190 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#line 191 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"








#line 200 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#line 201 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"














#line 216 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





typedef void *PVOID;
typedef void * __ptr64 PVOID64;







#line 231 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
















#line 248 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"








typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#line 260 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"






typedef wchar_t WCHAR;    



#line 271 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
typedef const WCHAR *LPCWCH, *PCWCH;
typedef  WCHAR *NWPSTR, *LPWSTR, *PWSTR;
typedef  PWSTR *PZPWSTR;
typedef  const PWSTR *PCZPWSTR;
typedef  WCHAR  *LPUWSTR, *PUWSTR;
typedef  const WCHAR *LPCWSTR, *PCWSTR;
typedef  PCWSTR *PZPCWSTR;
typedef  const WCHAR  *LPCUWSTR, *PCUWSTR;




typedef CHAR *PCHAR, *LPCH, *PCH;
typedef const CHAR *LPCCH, *PCCH;

typedef  CHAR *NPSTR, *LPSTR, *PSTR;
typedef  PSTR *PZPSTR;
typedef  const PSTR *PCZPSTR;
typedef  const CHAR *LPCSTR, *PCSTR;
typedef  PCSTR *PZPCSTR;







typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TBYTE , *PTBYTE ;

#line 304 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPUWSTR PUTSTR, LPUTSTR;
typedef LPCUWSTR PCUTSTR, LPCUTSTR;
typedef LPWSTR LP;















#line 327 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"



typedef SHORT *PSHORT;  
typedef LONG *PLONG;    


typedef void *HANDLE;




#line 340 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
typedef HANDLE *PHANDLE;





typedef BYTE   FCHAR;
typedef WORD   FSHORT;
typedef DWORD  FLONG;





typedef LONG HRESULT;

#line 357 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


    


#line 363 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"









#line 373 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"













#line 387 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
















typedef char CCHAR;          
typedef DWORD LCID;         
typedef PDWORD PLCID;       
typedef WORD   LANGID;      






















#line 430 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
typedef struct _FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} FLOAT128;

typedef FLOAT128 *PFLOAT128;









typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;














#line 462 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;



typedef LONGLONG USN;



#line 473 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
typedef union _LARGE_INTEGER {
    struct {
        DWORD LowPart;
        LONG HighPart;
    };
    struct {
        DWORD LowPart;
        LONG HighPart;
    } u;
#line 483 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;



#line 491 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
typedef union _ULARGE_INTEGER {
    struct {
        DWORD LowPart;
        DWORD HighPart;
    };
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } u;
#line 501 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;








typedef struct _LUID {
    DWORD LowPart;
    LONG HighPart;
} LUID, *PLUID;


typedef ULONGLONG  DWORDLONG;
typedef DWORDLONG *PDWORDLONG;






















#line 544 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"











ULONGLONG
__stdcall
Int64ShllMod32 (
    ULONGLONG Value,
    DWORD ShiftCount
    );

LONGLONG
__stdcall
Int64ShraMod32 (
    LONGLONG Value,
    DWORD ShiftCount
    );

ULONGLONG
__stdcall
Int64ShrlMod32 (
    ULONGLONG Value,
    DWORD ShiftCount
    );


#pragma warning(push)
#line 579 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#pragma warning(disable:4035 4793)               

__inline ULONGLONG
__stdcall
Int64ShllMod32 (
    ULONGLONG Value,
    DWORD ShiftCount
    )
{
    __asm    {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    }
}

__inline LONGLONG
__stdcall
Int64ShraMod32 (
    LONGLONG Value,
    DWORD ShiftCount
    )
{
    __asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    }
}

__inline ULONGLONG
__stdcall
Int64ShrlMod32 (
    ULONGLONG Value,
    DWORD ShiftCount
    )
{
    __asm    {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    }
}


#pragma warning(pop)


#line 634 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


































#line 669 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"






extern "C" {
#line 677 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"









































#line 719 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"








unsigned int
__cdecl
_rotl (
     unsigned int Value,
     int Shift
    );

unsigned __int64
__cdecl
_rotl64 (
     unsigned __int64 Value,
     int Shift
    );

unsigned int
__cdecl
_rotr (
     unsigned int Value,
     int Shift
    );

unsigned __int64
__cdecl
_rotr64 (
     unsigned __int64 Value,
     int Shift
    );

#pragma intrinsic(_rotl)
#pragma intrinsic(_rotl64)
#pragma intrinsic(_rotr)
#pragma intrinsic(_rotr64)

#line 761 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


}
#line 765 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





typedef BYTE  BOOLEAN;           
typedef BOOLEAN *PBOOLEAN;       





typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, * PRLIST_ENTRY;






typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;





typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;


#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"




















#line 22 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"
typedef struct _GUID {
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[ 8 ];
} GUID;
#line 29 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"
#line 30 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"




































#line 67 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"








typedef GUID *LPGUID;
#line 77 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"



typedef const GUID *LPCGUID;
#line 82 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"




typedef GUID IID;
typedef IID *LPIID;


typedef GUID CLSID;
typedef CLSID *LPCLSID;


typedef GUID FMTID;
typedef FMTID *LPFMTID;







#line 104 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"







#line 112 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"
#line 113 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"







#line 121 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"
#line 122 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"







#line 130 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"
#line 131 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"







#line 139 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"
#line 140 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"

#line 142 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"








__inline int InlineIsEqualGUID(const GUID & rguid1, const GUID & rguid2)
{
   return (
      ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
      ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
      ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
      ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);
}

__inline int IsEqualGUID(const GUID & rguid1, const GUID & rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}











#line 175 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"

















__inline int operator==(const GUID & guidOne, const GUID & guidOther)
{
    return IsEqualGUID(guidOne,guidOther);
}

__inline int operator!=(const GUID & guidOne, const GUID & guidOther)
{
    return !(guidOne == guidOther);
}
#line 202 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"
#line 203 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"
#line 204 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"
#line 205 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"
#line 206 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\guiddef.h"
#line 809 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"




typedef struct  _OBJECTID {     
    GUID Lineage;
    DWORD Uniquifier;
} OBJECTID;
#line 818 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





































































extern "C++" 
template <typename T, size_t N>
char (*RtlpNumberOf(  T (&)[N] ))[N];









































#line 937 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





#line 943 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"









































#line 985 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"







































































































































































































#line 1185 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"




























































































































































































#line 1374 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
























#line 1399 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


  












































#line 1447 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
  
#line 1449 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"




typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;






















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 2566 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"













#pragma warning(push)
#line 2581 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#pragma warning(disable:4164)   
                                

#pragma function(_enable)
#pragma function(_disable)
#line 2587 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


#pragma warning(pop)


#line 2593 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

#line 2595 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#line 2596 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





extern "C" {
#line 2603 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"














BOOLEAN
_bittest (
     LONG const *Base,
     LONG Offset
    );

BOOLEAN
_bittestandcomplement (
     LONG *Base,
     LONG Offset
    );

BOOLEAN
_bittestandset (
     LONG *Base,
     LONG Offset
    );

BOOLEAN
_bittestandreset (
     LONG *Base,
     LONG Offset
    );

BOOLEAN
_interlockedbittestandset (
     LONG *Base,
     LONG Offset
    );

BOOLEAN
_interlockedbittestandreset (
     LONG *Base,
     LONG Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)
#pragma intrinsic(_interlockedbittestandset)
#pragma intrinsic(_interlockedbittestandreset)








BOOLEAN
_BitScanForward (
     DWORD *Index,
     DWORD Mask
    );

BOOLEAN
_BitScanReverse (
     DWORD *Index,
     DWORD Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)





































#line 2719 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


#pragma warning(push)
#pragma warning(disable:4035 4793)

BOOLEAN
__forceinline
InterlockedBitTestAndComplement (
     LONG *Base,
     LONG Bit
    )
{
    __asm {
           mov eax, Bit
           mov ecx, Base
           lock btc [ecx], eax
           setc al
    };
}
#pragma warning(pop)
#line 2740 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"











BYTE 
__readfsbyte (
     DWORD Offset
    );
 
WORD  
__readfsword (
     DWORD Offset
    );
 
DWORD
__readfsdword (
     DWORD Offset
    );
 
void
__writefsbyte (
     DWORD Offset,
     BYTE  Data
    );
 
void
__writefsword (
     DWORD Offset,
     WORD   Data
    );
 
void
__writefsdword (
     DWORD Offset,
     DWORD Data
    );

#pragma intrinsic(__readfsbyte)
#pragma intrinsic(__readfsword)
#pragma intrinsic(__readfsdword)
#pragma intrinsic(__writefsbyte)
#pragma intrinsic(__writefsword)
#pragma intrinsic(__writefsdword)

#line 2792 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


}
#line 2796 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

#line 2798 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"




#pragma warning( push )
#pragma warning( disable : 4793 )
__forceinline
void
MemoryBarrier (
    void
    )
{
    LONG Barrier;
    __asm {
        xchg Barrier, eax
    }
}
#pragma warning( pop )


#line 2819 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"




















void
__int2c (
    void
    );

#pragma intrinsic(__int2c)







#line 2853 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"




__inline PVOID GetFiberData( void )    { return *(PVOID *) (ULONG_PTR) __readfsdword (0x10);}
__inline PVOID GetCurrentFiber( void ) { return (PVOID) (ULONG_PTR) __readfsdword (0x10);}


















#line 2878 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


#line 2881 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"











































#line 2925 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"



typedef struct _FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[80];
    DWORD   Cr0NpxState;
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;











typedef struct _CONTEXT {

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    DWORD ContextFlags;

    
    
    
    
    

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    
    
    
    

    FLOATING_SAVE_AREA FloatSave;

    
    
    
    

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    
    
    
    

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    
    
    
    

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              
    DWORD   EFlags;             
    DWORD   Esp;
    DWORD   SegSs;

    
    
    
    
    

    BYTE    ExtendedRegisters[512];

} CONTEXT;



typedef CONTEXT *PCONTEXT;



#line 3045 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





typedef struct _LDT_ENTRY {
    WORD    LimitLow;
    WORD    BaseLow;
    union {
        struct {
            BYTE    BaseMid;
            BYTE    Flags1;     
            BYTE    Flags2;     
            BYTE    BaseHi;
        } Bytes;
        struct {
            DWORD   BaseMid : 8;
            DWORD   Type : 5;
            DWORD   Dpl : 2;
            DWORD   Pres : 1;
            DWORD   LimitHi : 4;
            DWORD   Sys : 1;
            DWORD   Reserved_0 : 1;
            DWORD   Default_Big : 1;
            DWORD   Granularity : 1;
            DWORD   BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;

#line 3076 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


























































































































































































#line 3263 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"























































































































#line 3383 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"






















































































































































































































































































































































































































































typedef struct _EXCEPTION_RECORD {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[15];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD32 {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    DWORD ExceptionRecord;
    DWORD ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[15];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    DWORD64 ExceptionRecord;
    DWORD64 ExceptionAddress;
    DWORD NumberParameters;
    DWORD __unusedAlignment;
    DWORD64 ExceptionInformation[15];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;





typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;
typedef PVOID PACCESS_TOKEN;            
typedef PVOID PSECURITY_DESCRIPTOR;     
typedef PVOID PSID;     







































typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;
























































typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;












#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack4.h"























#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack4.h"


#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack4.h"
#line 34 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack4.h"
#line 3979 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    DWORD Attributes;
    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"


#line 36 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"
#line 37 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"
#line 3988 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


































typedef struct _SID_IDENTIFIER_AUTHORITY {
    BYTE  Value[6];
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;
#line 4026 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"




typedef struct _SID {
   BYTE  Revision;
   BYTE  SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;



   DWORD SubAuthority[1];
#line 4039 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
} SID, *PISID;
#line 4041 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





                                                



#line 4051 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


typedef enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer
} SID_NAME_USE, *PSID_NAME_USE;

typedef struct _SID_AND_ATTRIBUTES {
    PSID Sid;
    DWORD Attributes;
    } SID_AND_ATTRIBUTES, * PSID_AND_ATTRIBUTES;

typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[1];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;
























































































































































































typedef enum {

    WinNullSid                                  = 0,
    WinWorldSid                                 = 1,
    WinLocalSid                                 = 2,
    WinCreatorOwnerSid                          = 3,
    WinCreatorGroupSid                          = 4,
    WinCreatorOwnerServerSid                    = 5,
    WinCreatorGroupServerSid                    = 6,
    WinNtAuthoritySid                           = 7,
    WinDialupSid                                = 8,
    WinNetworkSid                               = 9,
    WinBatchSid                                 = 10,
    WinInteractiveSid                           = 11,
    WinServiceSid                               = 12,
    WinAnonymousSid                             = 13,
    WinProxySid                                 = 14,
    WinEnterpriseControllersSid                 = 15,
    WinSelfSid                                  = 16,
    WinAuthenticatedUserSid                     = 17,
    WinRestrictedCodeSid                        = 18,
    WinTerminalServerSid                        = 19,
    WinRemoteLogonIdSid                         = 20,
    WinLogonIdsSid                              = 21,
    WinLocalSystemSid                           = 22,
    WinLocalServiceSid                          = 23,
    WinNetworkServiceSid                        = 24,
    WinBuiltinDomainSid                         = 25,
    WinBuiltinAdministratorsSid                 = 26,
    WinBuiltinUsersSid                          = 27,
    WinBuiltinGuestsSid                         = 28,
    WinBuiltinPowerUsersSid                     = 29,
    WinBuiltinAccountOperatorsSid               = 30,
    WinBuiltinSystemOperatorsSid                = 31,
    WinBuiltinPrintOperatorsSid                 = 32,
    WinBuiltinBackupOperatorsSid                = 33,
    WinBuiltinReplicatorSid                     = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid             = 36,
    WinBuiltinNetworkConfigurationOperatorsSid  = 37,
    WinAccountAdministratorSid                  = 38,
    WinAccountGuestSid                          = 39,
    WinAccountKrbtgtSid                         = 40,
    WinAccountDomainAdminsSid                   = 41,
    WinAccountDomainUsersSid                    = 42,
    WinAccountDomainGuestsSid                   = 43,
    WinAccountComputersSid                      = 44,
    WinAccountControllersSid                    = 45,
    WinAccountCertAdminsSid                     = 46,
    WinAccountSchemaAdminsSid                   = 47,
    WinAccountEnterpriseAdminsSid               = 48,
    WinAccountPolicyAdminsSid                   = 49,
    WinAccountRasAndIasServersSid               = 50,
    WinNTLMAuthenticationSid                    = 51,
    WinDigestAuthenticationSid                  = 52,
    WinSChannelAuthenticationSid                = 53,
    WinThisOrganizationSid                      = 54,
    WinOtherOrganizationSid                     = 55,
    WinBuiltinIncomingForestTrustBuildersSid    = 56,
    WinBuiltinPerfMonitoringUsersSid            = 57,
    WinBuiltinPerfLoggingUsersSid               = 58,
    WinBuiltinAuthorizationAccessSid            = 59,
    WinBuiltinTerminalServerLicenseServersSid   = 60,
    WinBuiltinDCOMUsersSid                      = 61,

} WELL_KNOWN_SID_TYPE;






















































































typedef struct _ACL {
    BYTE  AclRevision;
    BYTE  Sbz1;
    WORD   AclSize;
    WORD   AceCount;
    WORD   Sbz2;
} ACL;
typedef ACL *PACL;





















typedef struct _ACE_HEADER {
    BYTE  AceType;
    BYTE  AceFlags;
    WORD   AceSize;
} ACE_HEADER;
typedef ACE_HEADER *PACE_HEADER;








































































































typedef struct _ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_ALLOWED_ACE;

typedef ACCESS_ALLOWED_ACE *PACCESS_ALLOWED_ACE;

typedef struct _ACCESS_DENIED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_DENIED_ACE;
typedef ACCESS_DENIED_ACE *PACCESS_DENIED_ACE;

typedef struct _SYSTEM_AUDIT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE;

typedef struct _SYSTEM_ALARM_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_ALARM_ACE;
typedef SYSTEM_ALARM_ACE *PSYSTEM_ALARM_ACE;




typedef struct _ACCESS_ALLOWED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_ALLOWED_OBJECT_ACE, *PACCESS_ALLOWED_OBJECT_ACE;

typedef struct _ACCESS_DENIED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_DENIED_OBJECT_ACE, *PACCESS_DENIED_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_AUDIT_OBJECT_ACE, *PSYSTEM_AUDIT_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_ALARM_OBJECT_ACE, *PSYSTEM_ALARM_OBJECT_ACE;






typedef struct _ACCESS_ALLOWED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    
} ACCESS_ALLOWED_CALLBACK_ACE, *PACCESS_ALLOWED_CALLBACK_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    
} ACCESS_DENIED_CALLBACK_ACE, *PACCESS_DENIED_CALLBACK_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    
} SYSTEM_AUDIT_CALLBACK_ACE, *PSYSTEM_AUDIT_CALLBACK_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    
} SYSTEM_ALARM_CALLBACK_ACE, *PSYSTEM_ALARM_CALLBACK_ACE;

typedef struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    
} ACCESS_ALLOWED_CALLBACK_OBJECT_ACE, *PACCESS_ALLOWED_CALLBACK_OBJECT_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    
} ACCESS_DENIED_CALLBACK_OBJECT_ACE, *PACCESS_DENIED_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    
} SYSTEM_AUDIT_CALLBACK_OBJECT_ACE, *PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    
} SYSTEM_ALARM_CALLBACK_OBJECT_ACE, *PSYSTEM_ALARM_CALLBACK_OBJECT_ACE;















typedef enum _ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
} ACL_INFORMATION_CLASS;






typedef struct _ACL_REVISION_INFORMATION {
    DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef ACL_REVISION_INFORMATION *PACL_REVISION_INFORMATION;





typedef struct _ACL_SIZE_INFORMATION {
    DWORD AceCount;
    DWORD AclBytesInUse;
    DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
typedef ACL_SIZE_INFORMATION *PACL_SIZE_INFORMATION;


























typedef WORD   SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;

























































































typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
    BYTE  Revision;
    BYTE  Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD Owner;
    DWORD Group;
    DWORD Sacl;
    DWORD Dacl;
    } SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;

typedef struct _SECURITY_DESCRIPTOR {
   BYTE  Revision;
   BYTE  Sbz1;
   SECURITY_DESCRIPTOR_CONTROL Control;
   PSID Owner;
   PSID Group;
   PACL Sacl;
   PACL Dacl;

   } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;


















































typedef struct _OBJECT_TYPE_LIST {
    WORD   Level;
    WORD   Sbz;
    GUID *ObjectType;
} OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;















typedef enum _AUDIT_EVENT_TYPE {
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess
} AUDIT_EVENT_TYPE, *PAUDIT_EVENT_TYPE;













































typedef struct _PRIVILEGE_SET {
    DWORD PrivilegeCount;
    DWORD Control;
    LUID_AND_ATTRIBUTES Privilege[1];
    } PRIVILEGE_SET, * PPRIVILEGE_SET;
























































typedef enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
    } SECURITY_IMPERSONATION_LEVEL, * PSECURITY_IMPERSONATION_LEVEL;











































#line 5093 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


















typedef enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
    } TOKEN_TYPE;
typedef TOKEN_TYPE *PTOKEN_TYPE;







typedef enum _TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    TokenOrigin,
    MaxTokenInfoClass  
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;






typedef struct _TOKEN_USER {
    SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;

typedef struct _TOKEN_GROUPS {
    DWORD GroupCount;
    SID_AND_ATTRIBUTES Groups[1];
} TOKEN_GROUPS, *PTOKEN_GROUPS;


typedef struct _TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[1];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;


typedef struct _TOKEN_OWNER {
    PSID Owner;
} TOKEN_OWNER, *PTOKEN_OWNER;


typedef struct _TOKEN_PRIMARY_GROUP {
    PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;


typedef struct _TOKEN_DEFAULT_DACL {
    PACL DefaultDacl;
} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;

typedef struct _TOKEN_GROUPS_AND_PRIVILEGES {
    DWORD SidCount;
    DWORD SidLength;
    PSID_AND_ATTRIBUTES Sids;
    DWORD RestrictedSidCount;
    DWORD RestrictedSidLength;
    PSID_AND_ATTRIBUTES RestrictedSids;
    DWORD PrivilegeCount;
    DWORD PrivilegeLength;
    PLUID_AND_ATTRIBUTES Privileges;
    LUID AuthenticationId;
} TOKEN_GROUPS_AND_PRIVILEGES, *PTOKEN_GROUPS_AND_PRIVILEGES;


















typedef struct _TOKEN_AUDIT_POLICY_ELEMENT {
    DWORD Category;
    DWORD PolicyMask;
} TOKEN_AUDIT_POLICY_ELEMENT, *PTOKEN_AUDIT_POLICY_ELEMENT;

typedef struct _TOKEN_AUDIT_POLICY {
    DWORD PolicyCount;
    TOKEN_AUDIT_POLICY_ELEMENT Policy[1];
} TOKEN_AUDIT_POLICY, *PTOKEN_AUDIT_POLICY;









typedef struct _TOKEN_SOURCE {
    CHAR SourceName[8];
    LUID SourceIdentifier;
} TOKEN_SOURCE, *PTOKEN_SOURCE;


typedef struct _TOKEN_STATISTICS {
    LUID TokenId;
    LUID AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD DynamicCharged;
    DWORD DynamicAvailable;
    DWORD GroupCount;
    DWORD PrivilegeCount;
    LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;



typedef struct _TOKEN_CONTROL {
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL, *PTOKEN_CONTROL;

typedef struct _TOKEN_ORIGIN {
    LUID OriginatingLogonSession ;
} TOKEN_ORIGIN, * PTOKEN_ORIGIN ;








typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,
                    * PSECURITY_CONTEXT_TRACKING_MODE;







typedef struct _SECURITY_QUALITY_OF_SERVICE {
    DWORD Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
    } SECURITY_QUALITY_OF_SERVICE, * PSECURITY_QUALITY_OF_SERVICE;






typedef struct _SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;




typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;































#line 5330 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"



#line 5334 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


























typedef struct _JOB_SET_ARRAY {
    HANDLE JobHandle;   
    DWORD MemberLevel;  
    DWORD Flags;        
} JOB_SET_ARRAY, *PJOB_SET_ARRAY;




typedef struct _NT_TIB {
    struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;
    union {
        PVOID FiberData;
        DWORD Version;
    };
    PVOID ArbitraryUserPointer;
    struct _NT_TIB *Self;
} NT_TIB;
typedef NT_TIB *PNT_TIB;




typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;
    union {
        DWORD FiberData;
        DWORD Version;
    };
    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;
    union {
        DWORD64 FiberData;
        DWORD Version;
    };
    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;




#line 5416 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"






typedef struct _QUOTA_LIMITS {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS, *PQUOTA_LIMITS;






typedef struct _QUOTA_LIMITS_EX {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
    SIZE_T Reserved1;
    SIZE_T Reserved2;
    SIZE_T Reserved3;
    SIZE_T Reserved4;
    DWORD  Flags;
    DWORD  Reserved5;
} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;

typedef struct _IO_COUNTERS {
    ULONGLONG  ReadOperationCount;
    ULONGLONG  WriteOperationCount;
    ULONGLONG  OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;


typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    LARGE_INTEGER TotalUserTime;
    LARGE_INTEGER TotalKernelTime;
    LARGE_INTEGER ThisPeriodTotalUserTime;
    LARGE_INTEGER ThisPeriodTotalKernelTime;
    DWORD TotalPageFaultCount;
    DWORD TotalProcesses;
    DWORD ActiveProcesses;
    DWORD TotalTerminatedProcesses;
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
    LARGE_INTEGER PerProcessUserTimeLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD LimitFlags;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    DWORD ActiveProcessLimit;
    ULONG_PTR Affinity;
    DWORD PriorityClass;
    DWORD SchedulingClass;
} JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION;

typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    IO_COUNTERS IoInfo;
    SIZE_T ProcessMemoryLimit;
    SIZE_T JobMemoryLimit;
    SIZE_T PeakProcessMemoryUsed;
    SIZE_T PeakJobMemoryUsed;
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;

typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
    DWORD NumberOfAssignedProcesses;
    DWORD NumberOfProcessIdsInList;
    ULONG_PTR ProcessIdList[1];
} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;

typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
    DWORD UIRestrictionsClass;
} JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS;

typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    DWORD SecurityLimitFlags ;
    HANDLE JobToken ;
    PTOKEN_GROUPS SidsToDisable ;
    PTOKEN_PRIVILEGES PrivilegesToDelete ;
    PTOKEN_GROUPS RestrictedSids ;
} JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION ;

typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    DWORD EndOfJobTimeAction;
} JOBOBJECT_END_OF_JOB_TIME_INFORMATION, *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;

typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    PVOID CompletionKey;
    HANDLE CompletionPort;
} JOBOBJECT_ASSOCIATE_COMPLETION_PORT, *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;

typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    IO_COUNTERS IoInfo;
} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_JOBSET_INFORMATION {
    DWORD MemberLevel;
} JOBOBJECT_JOBSET_INFORMATION, *PJOBOBJECT_JOBSET_INFORMATION;


















































































typedef enum _JOBOBJECTINFOCLASS {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation,
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    JobObjectBasicAndIoAccountingInformation,
    JobObjectExtendedLimitInformation,
    JobObjectJobSetInformation,
    MaxJobObjectInfoClass
    } JOBOBJECTINFOCLASS;
























typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationProcessorCore,
    RelationNumaNode,
    RelationCache
} LOGICAL_PROCESSOR_RELATIONSHIP;



typedef enum _PROCESSOR_CACHE_TYPE {
    CacheUnified,
    CacheInstruction,
    CacheData,
    CacheTrace
} PROCESSOR_CACHE_TYPE;



typedef struct _CACHE_DESCRIPTOR {
    BYTE   Level;
    BYTE   Associativity;
    WORD   LineSize;
    DWORD  Size;
    PROCESSOR_CACHE_TYPE Type;
} CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    ULONG_PTR   ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    union {
        struct {
            BYTE  Flags;
        } ProcessorCore;
        struct {
            DWORD NodeNumber;
        } NumaNode;
        CACHE_DESCRIPTOR Cache;
        ULONGLONG  Reserved[2];
    };
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;






















































typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    SIZE_T RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

typedef struct _MEMORY_BASIC_INFORMATION32 {
    DWORD BaseAddress;
    DWORD AllocationBase;
    DWORD AllocationProtect;
    DWORD RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION32, *PMEMORY_BASIC_INFORMATION32;

typedef struct __declspec(align(16)) _MEMORY_BASIC_INFORMATION64 {
    ULONGLONG BaseAddress;
    ULONGLONG AllocationBase;
    DWORD     AllocationProtect;
    DWORD     __alignment1;
    ULONGLONG RegionSize;
    DWORD     State;
    DWORD     Protect;
    DWORD     Type;
    DWORD     __alignment2;
} MEMORY_BASIC_INFORMATION64, *PMEMORY_BASIC_INFORMATION64;



























































































































































typedef struct _FILE_NOTIFY_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;






typedef union _FILE_SEGMENT_ELEMENT {
    PVOID64 Buffer;
    ULONGLONG Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;









typedef struct _REPARSE_GUID_DATA_BUFFER {
    DWORD  ReparseTag;
    WORD   ReparseDataLength;
    WORD   Reserved;
    GUID   ReparseGuid;
    struct {
        BYTE   DataBuffer[1];
    } GenericReparseBuffer;
} REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER;













































































typedef enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking     = 1,
    PowerSystemSleeping1   = 2,
    PowerSystemSleeping2   = 3,
    PowerSystemSleeping3   = 4,
    PowerSystemHibernate   = 5,
    PowerSystemShutdown    = 6,
    PowerSystemMaximum     = 7
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;



typedef enum {
    PowerActionNone = 0,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject
} POWER_ACTION, *PPOWER_ACTION;

typedef enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;







typedef DWORD EXECUTION_STATE;

typedef enum {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
} LATENCY_TIME;

















typedef struct CM_Power_Data_s {
    DWORD               PD_Size;
    DEVICE_POWER_STATE  PD_MostRecentPowerState;
    DWORD               PD_Capabilities;
    DWORD               PD_D1Latency;
    DWORD               PD_D2Latency;
    DWORD               PD_D3Latency;
    DEVICE_POWER_STATE  PD_PowerStateMapping[7];
    SYSTEM_POWER_STATE  PD_DeepestSystemWake;
} CM_POWER_DATA, *PCM_POWER_DATA;



typedef enum {
    SystemPowerPolicyAc,
    SystemPowerPolicyDc,
    VerifySystemPolicyAc,
    VerifySystemPolicyDc,
    SystemPowerCapabilities,
    SystemBatteryState,
    SystemPowerStateHandler,
    ProcessorStateHandler,
    SystemPowerPolicyCurrent,
    AdministratorPowerPolicy,
    SystemReserveHiberFile,
    ProcessorInformation,
    SystemPowerInformation,
    ProcessorStateHandler2,
    LastWakeTime,                                   
    LastSleepTime,                                  
    SystemExecutionState,
    SystemPowerStateNotifyHandler,
    ProcessorPowerPolicyAc,
    ProcessorPowerPolicyDc,
    VerifyProcessorPowerPolicyAc,
    VerifyProcessorPowerPolicyDc,
    ProcessorPowerPolicyCurrent,
    SystemPowerStateLogging,
    SystemPowerLoggingEntry
} POWER_INFORMATION_LEVEL;







typedef struct {
    DWORD       Granularity;
    DWORD       Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;






typedef struct {
    POWER_ACTION    Action;
    DWORD           Flags;
    DWORD           EventCode;
} POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY;



















typedef struct {
    BOOLEAN                 Enable;
    BYTE                    Spare[3];
    DWORD                   BatteryLevel;
    POWER_ACTION_POLICY     PowerPolicy;
    SYSTEM_POWER_STATE      MinSystemState;
} SYSTEM_POWER_LEVEL, *PSYSTEM_POWER_LEVEL;
















typedef struct _SYSTEM_POWER_POLICY {
    DWORD                   Revision;       

    
    POWER_ACTION_POLICY     PowerButton;
    POWER_ACTION_POLICY     SleepButton;
    POWER_ACTION_POLICY     LidClose;
    SYSTEM_POWER_STATE      LidOpenWake;
    DWORD                   Reserved;

    
    POWER_ACTION_POLICY     Idle;
    DWORD                   IdleTimeout;
    BYTE                    IdleSensitivity;

    
    
    BYTE                    DynamicThrottle;

    BYTE                    Spare2[2];

    
    SYSTEM_POWER_STATE      MinSleep;
    SYSTEM_POWER_STATE      MaxSleep;
    SYSTEM_POWER_STATE      ReducedLatencySleep;
    DWORD                   WinLogonFlags;

    
    DWORD                   Spare3;
    DWORD                   DozeS4Timeout;

    
    DWORD                   BroadcastCapacityResolution;
    SYSTEM_POWER_LEVEL      DischargePolicy[4];

    
    DWORD                   VideoTimeout;
    BOOLEAN                 VideoDimDisplay;
    DWORD                   VideoReserved[3];

    
    DWORD                   SpindownTimeout;

    
    BOOLEAN                 OptimizeForPower;
    BYTE                    FanThrottleTolerance;
    BYTE                    ForcedThrottle;
    BYTE                    MinThrottle;
    POWER_ACTION_POLICY     OverThrottled;

} SYSTEM_POWER_POLICY, *PSYSTEM_POWER_POLICY;


typedef struct _PROCESSOR_POWER_POLICY_INFO {

    
    DWORD                   TimeCheck;                      
    DWORD                   DemoteLimit;                    
    DWORD                   PromoteLimit;                   

    
    BYTE                    DemotePercent;
    BYTE                    PromotePercent;
    BYTE                    Spare[2];

    
    DWORD                   AllowDemotion:1;
    DWORD                   AllowPromotion:1;
    DWORD                   Reserved:30;

} PROCESSOR_POWER_POLICY_INFO, *PPROCESSOR_POWER_POLICY_INFO;


typedef struct _PROCESSOR_POWER_POLICY {
    DWORD                       Revision;       

    
    BYTE                        DynamicThrottle;
    BYTE                        Spare[3];

    
    DWORD                       DisableCStates:1;
    DWORD                       Reserved:31;

    
    
    
    DWORD                       PolicyCount;
    PROCESSOR_POWER_POLICY_INFO Policy[3];

} PROCESSOR_POWER_POLICY, *PPROCESSOR_POWER_POLICY;


typedef struct _ADMINISTRATOR_POWER_POLICY {

    
    SYSTEM_POWER_STATE      MinSleep;
    SYSTEM_POWER_STATE      MaxSleep;

    
    DWORD                   MinVideoTimeout;
    DWORD                   MaxVideoTimeout;

    
    DWORD                   MinSpindownTimeout;
    DWORD                   MaxSpindownTimeout;
} ADMINISTRATOR_POWER_POLICY, *PADMINISTRATOR_POWER_POLICY;


typedef struct {
    
    BOOLEAN             PowerButtonPresent;
    BOOLEAN             SleepButtonPresent;
    BOOLEAN             LidPresent;
    BOOLEAN             SystemS1;
    BOOLEAN             SystemS2;
    BOOLEAN             SystemS3;
    BOOLEAN             SystemS4;           
    BOOLEAN             SystemS5;           
    BOOLEAN             HiberFilePresent;
    BOOLEAN             FullWake;
    BOOLEAN             VideoDimPresent;
    BOOLEAN             ApmPresent;
    BOOLEAN             UpsPresent;

    
    BOOLEAN             ThermalControl;
    BOOLEAN             ProcessorThrottle;
    BYTE                ProcessorMinThrottle;
    BYTE                ProcessorMaxThrottle;
    BYTE                spare2[4];

    
    BOOLEAN             DiskSpinDown;
    BYTE                spare3[8];

    
    BOOLEAN             SystemBatteriesPresent;
    BOOLEAN             BatteriesAreShortTerm;
    BATTERY_REPORTING_SCALE BatteryScale[3];

    
    SYSTEM_POWER_STATE  AcOnLineWake;
    SYSTEM_POWER_STATE  SoftLidWake;
    SYSTEM_POWER_STATE  RtcWake;
    SYSTEM_POWER_STATE  MinDeviceWakeState; 
    SYSTEM_POWER_STATE  DefaultLowLatencyWake;
} SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES;

typedef struct {
    BOOLEAN             AcOnLine;
    BOOLEAN             BatteryPresent;
    BOOLEAN             Charging;
    BOOLEAN             Discharging;
    BOOLEAN             Spare1[4];

    DWORD               MaxCapacity;
    DWORD               RemainingCapacity;
    DWORD               Rate;
    DWORD               EstimatedTime;

    DWORD               DefaultAlert1;
    DWORD               DefaultAlert2;
} SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE;










#line 1 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack4.h"























#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack4.h"


#line 33 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack4.h"
#line 34 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack4.h"
#line 6379 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"







#line 1 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack2.h"


#line 33 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack2.h"
#line 34 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack2.h"
#line 6387 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"









#line 6397 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

typedef struct _IMAGE_DOS_HEADER {      
    WORD   e_magic;                     
    WORD   e_cblp;                      
    WORD   e_cp;                        
    WORD   e_crlc;                      
    WORD   e_cparhdr;                   
    WORD   e_minalloc;                  
    WORD   e_maxalloc;                  
    WORD   e_ss;                        
    WORD   e_sp;                        
    WORD   e_csum;                      
    WORD   e_ip;                        
    WORD   e_cs;                        
    WORD   e_lfarlc;                    
    WORD   e_ovno;                      
    WORD   e_res[4];                    
    WORD   e_oemid;                     
    WORD   e_oeminfo;                   
    WORD   e_res2[10];                  
    LONG   e_lfanew;                    
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {      
    WORD   ne_magic;                    
    CHAR   ne_ver;                      
    CHAR   ne_rev;                      
    WORD   ne_enttab;                   
    WORD   ne_cbenttab;                 
    LONG   ne_crc;                      
    WORD   ne_flags;                    
    WORD   ne_autodata;                 
    WORD   ne_heap;                     
    WORD   ne_stack;                    
    LONG   ne_csip;                     
    LONG   ne_sssp;                     
    WORD   ne_cseg;                     
    WORD   ne_cmod;                     
    WORD   ne_cbnrestab;                
    WORD   ne_segtab;                   
    WORD   ne_rsrctab;                  
    WORD   ne_restab;                   
    WORD   ne_modtab;                   
    WORD   ne_imptab;                   
    LONG   ne_nrestab;                  
    WORD   ne_cmovent;                  
    WORD   ne_align;                    
    WORD   ne_cres;                     
    BYTE   ne_exetyp;                   
    BYTE   ne_flagsothers;              
    WORD   ne_pretthunks;               
    WORD   ne_psegrefbytes;             
    WORD   ne_swaparea;                 
    WORD   ne_expver;                   
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

typedef struct _IMAGE_VXD_HEADER {      
    WORD   e32_magic;                   
    BYTE   e32_border;                  
    BYTE   e32_worder;                  
    DWORD  e32_level;                   
    WORD   e32_cpu;                     
    WORD   e32_os;                      
    DWORD  e32_ver;                     
    DWORD  e32_mflags;                  
    DWORD  e32_mpages;                  
    DWORD  e32_startobj;                
    DWORD  e32_eip;                     
    DWORD  e32_stackobj;                
    DWORD  e32_esp;                     
    DWORD  e32_pagesize;                
    DWORD  e32_lastpagesize;            
    DWORD  e32_fixupsize;               
    DWORD  e32_fixupsum;                
    DWORD  e32_ldrsize;                 
    DWORD  e32_ldrsum;                  
    DWORD  e32_objtab;                  
    DWORD  e32_objcnt;                  
    DWORD  e32_objmap;                  
    DWORD  e32_itermap;                 
    DWORD  e32_rsrctab;                 
    DWORD  e32_rsrccnt;                 
    DWORD  e32_restab;                  
    DWORD  e32_enttab;                  
    DWORD  e32_dirtab;                  
    DWORD  e32_dircnt;                  
    DWORD  e32_fpagetab;                
    DWORD  e32_frectab;                 
    DWORD  e32_impmod;                  
    DWORD  e32_impmodcnt;               
    DWORD  e32_impproc;                 
    DWORD  e32_pagesum;                 
    DWORD  e32_datapage;                
    DWORD  e32_preload;                 
    DWORD  e32_nrestab;                 
    DWORD  e32_cbnrestab;               
    DWORD  e32_nressum;                 
    DWORD  e32_autodata;                
    DWORD  e32_debuginfo;               
    DWORD  e32_debuglen;                
    DWORD  e32_instpreload;             
    DWORD  e32_instdemand;              
    DWORD  e32_heapsize;                
    BYTE   e32_res3[12];                
    DWORD  e32_winresoff;
    DWORD  e32_winreslen;
    WORD   e32_devid;                   
    WORD   e32_ddkver;                  
  } IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER;


#line 1 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"


#line 36 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"
#line 37 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"
#line 6509 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#line 6510 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;






















































typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;







typedef struct _IMAGE_OPTIONAL_HEADER {
    
    
    

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    
    
    

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    WORD   Magic;
    BYTE   MajorLinkerVersion;
    BYTE   MinorLinkerVersion;
    DWORD  SizeOfCode;
    DWORD  SizeOfInitializedData;
    DWORD  SizeOfUninitializedData;
    DWORD  AddressOfEntryPoint;
    DWORD  BaseOfCode;
    DWORD  BaseOfData;
    DWORD  BaseOfBss;
    DWORD  GprMask;
    DWORD  CprMask[4];
    DWORD  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;
















typedef IMAGE_OPTIONAL_HEADER32             IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER32            PIMAGE_OPTIONAL_HEADER;


#line 6701 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;





typedef IMAGE_NT_HEADERS32                  IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS32                 PIMAGE_NT_HEADERS;
#line 6726 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"






























































typedef struct ANON_OBJECT_HEADER {
    WORD    Sig1;            
    WORD    Sig2;            
    WORD    Version;         
    WORD    Machine;
    DWORD   TimeDateStamp;
    CLSID   ClassID;         
    DWORD   SizeOfData;      
} ANON_OBJECT_HEADER;







typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[8];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

































































#line 1 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack2.h"


#line 33 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack2.h"
#line 34 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack2.h"
#line 6885 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#line 6886 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





typedef struct _IMAGE_SYMBOL {
    union {
        BYTE    ShortName[8];
        struct {
            DWORD   Short;     
            DWORD   Long;      
        } Name;
        DWORD   LongName[2];    
    } N;
    DWORD   Value;
    SHORT   SectionNumber;
    WORD    Type;
    BYTE    StorageClass;
    BYTE    NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL  *PIMAGE_SYMBOL;


































































































#line 7006 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"




#line 7011 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





#line 7017 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"




#line 7022 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"



#line 7026 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


#line 7029 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





typedef union _IMAGE_AUX_SYMBOL {
    struct {
        DWORD    TagIndex;                      
        union {
            struct {
                WORD    Linenumber;             
                WORD    Size;                   
            } LnSz;
           DWORD    TotalSize;
        } Misc;
        union {
            struct {                            
                DWORD    PointerToLinenumber;
                DWORD    PointerToNextFunction;
            } Function;
            struct {                            
                WORD     Dimension[4];
            } Array;
        } FcnAry;
        WORD    TvIndex;                        
    } Sym;
    struct {
        BYTE    Name[18];
    } File;
    struct {
        DWORD   Length;                         
        WORD    NumberOfRelocations;            
        WORD    NumberOfLinenumbers;            
        DWORD   CheckSum;                       
        SHORT   Number;                         
        BYTE    Selection;                      
    } Section;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL  *PIMAGE_AUX_SYMBOL;



typedef enum IMAGE_AUX_SYMBOL_TYPE {
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1,
} IMAGE_AUX_SYMBOL_TYPE;

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"


#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"
#line 34 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"
#line 7076 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

typedef struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
    BYTE  bAuxType;                  
    BYTE  bReserved;                 
    DWORD SymbolTableIndex;
    BYTE  rgbReserved[12];           
} IMAGE_AUX_SYMBOL_TOKEN_DEF;

typedef IMAGE_AUX_SYMBOL_TOKEN_DEF  *PIMAGE_AUX_SYMBOL_TOKEN_DEF;

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"


#line 36 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"
#line 37 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"
#line 7087 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





















typedef struct _IMAGE_RELOCATION {
    union {
        DWORD   VirtualAddress;
        DWORD   RelocCount;             
    };
    DWORD   SymbolTableIndex;
    WORD    Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION  *PIMAGE_RELOCATION;


























































































































































































































































































































































typedef struct _IMAGE_LINENUMBER {
    union {
        DWORD   SymbolTableIndex;               
        DWORD   VirtualAddress;                 
    } Type;
    WORD    Linenumber;                         
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER  *PIMAGE_LINENUMBER;




#line 1 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"


#line 36 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"
#line 37 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"
#line 7476 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#line 7477 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;

} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION  * PIMAGE_BASE_RELOCATION;





























typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    BYTE     Name[16];                          
    BYTE     Date[12];                          
    BYTE     UserID[6];                         
    BYTE     GroupID[6];                        
    BYTE     Mode[8];                           
    BYTE     Size[10];                          
    BYTE     EndHeader[2];                      
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;











typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     
    DWORD   AddressOfNames;         
    DWORD   AddressOfNameOrdinals;  
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;





typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD    Hint;
    BYTE    Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

#line 1 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack8.h"























#pragma warning(disable:4103)

#pragma pack(push,8)


#line 30 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack8.h"


#line 33 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack8.h"
#line 34 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\pshpack8.h"
#line 7561 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString;  
        ULONGLONG Function;         
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;    
    } u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;

#line 1 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"


#line 36 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"
#line 37 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"
#line 7573 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

typedef struct _IMAGE_THUNK_DATA32 {
    union {
        DWORD ForwarderString;      
        DWORD Function;             
        DWORD Ordinal;
        DWORD AddressOfData;        
    } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;












typedef void
(__stdcall *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved
    );

typedef struct _IMAGE_TLS_DIRECTORY64 {
    ULONGLONG   StartAddressOfRawData;
    ULONGLONG   EndAddressOfRawData;
    ULONGLONG   AddressOfIndex;         
    ULONGLONG   AddressOfCallBacks;     
    DWORD   SizeOfZeroFill;
    DWORD   Characteristics;
} IMAGE_TLS_DIRECTORY64;
typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;

typedef struct _IMAGE_TLS_DIRECTORY32 {
    DWORD   StartAddressOfRawData;
    DWORD   EndAddressOfRawData;
    DWORD   AddressOfIndex;             
    DWORD   AddressOfCallBacks;         
    DWORD   SizeOfZeroFill;
    DWORD   Characteristics;
} IMAGE_TLS_DIRECTORY32;
typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;












typedef IMAGE_THUNK_DATA32              IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA32             PIMAGE_THUNK_DATA;

typedef IMAGE_TLS_DIRECTORY32           IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY32          PIMAGE_TLS_DIRECTORY;
#line 7639 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            
        DWORD   OriginalFirstThunk;         
    };
    DWORD   TimeDateStamp;                  
                                            
                                            
                                            

    DWORD   ForwarderChain;                 
    DWORD   Name;
    DWORD   FirstThunk;                     
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR  *PIMAGE_IMPORT_DESCRIPTOR;





typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    NumberOfModuleForwarderRefs;

} IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_BOUND_FORWARDER_REF {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    Reserved;
} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;



















typedef struct _IMAGE_RESOURCE_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    WORD    NumberOfNamedEntries;
    WORD    NumberOfIdEntries;

} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;


















typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        };
        DWORD   Name;
        WORD    Id;
    };
    union {
        DWORD   OffsetToData;
        struct {
            DWORD   OffsetToDirectory:31;
            DWORD   DataIsDirectory:1;
        };
    };
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;










typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD    Length;
    CHAR    NameString[ 1 ];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;


typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    WORD    Length;
    WCHAR   NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;











typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    DWORD   OffsetToData;
    DWORD   Size;
    DWORD   CodePage;
    DWORD   Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;





typedef struct {
    DWORD   Size;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   GlobalFlagsClear;
    DWORD   GlobalFlagsSet;
    DWORD   CriticalSectionDefaultTimeout;
    DWORD   DeCommitFreeBlockThreshold;
    DWORD   DeCommitTotalFreeThreshold;
    DWORD   LockPrefixTable;            
    DWORD   MaximumAllocationSize;
    DWORD   VirtualMemoryThreshold;
    DWORD   ProcessHeapFlags;
    DWORD   ProcessAffinityMask;
    WORD    CSDVersion;
    WORD    Reserved1;
    DWORD   EditList;                   
    DWORD   SecurityCookie;             
    DWORD   SEHandlerTable;             
    DWORD   SEHandlerCount;
} IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

typedef struct {
    DWORD      Size;
    DWORD      TimeDateStamp;
    WORD       MajorVersion;
    WORD       MinorVersion;
    DWORD      GlobalFlagsClear;
    DWORD      GlobalFlagsSet;
    DWORD      CriticalSectionDefaultTimeout;
    ULONGLONG  DeCommitFreeBlockThreshold;
    ULONGLONG  DeCommitTotalFreeThreshold;
    ULONGLONG  LockPrefixTable;         
    ULONGLONG  MaximumAllocationSize;
    ULONGLONG  VirtualMemoryThreshold;
    ULONGLONG  ProcessAffinityMask;
    DWORD      ProcessHeapFlags;
    WORD       CSDVersion;
    WORD       Reserved1;
    ULONGLONG  EditList;                
    ULONGLONG  SecurityCookie;          
    ULONGLONG  SEHandlerTable;          
    ULONGLONG  SEHandlerCount;
} IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64;





typedef IMAGE_LOAD_CONFIG_DIRECTORY32     IMAGE_LOAD_CONFIG_DIRECTORY;
typedef PIMAGE_LOAD_CONFIG_DIRECTORY32    PIMAGE_LOAD_CONFIG_DIRECTORY;
#line 7830 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"










typedef struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    DWORD FuncStart;
    DWORD PrologLen : 8;
    DWORD FuncLen : 22;
    DWORD ThirtyTwoBit : 1;
    DWORD ExceptionFlag : 1;
} IMAGE_CE_RUNTIME_FUNCTION_ENTRY, * PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    ULONGLONG BeginAddress;
    ULONGLONG EndAddress;
    ULONGLONG ExceptionHandler;
    ULONGLONG HandlerData;
    ULONGLONG PrologEndAddress;
} IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD ExceptionHandler;
    DWORD HandlerData;
    DWORD PrologEndAddress;
} IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD UnwindInfoAddress;
} _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;

typedef  _IMAGE_RUNTIME_FUNCTION_ENTRY  IMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY;








#line 7881 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"




#line 7886 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

typedef  _IMAGE_RUNTIME_FUNCTION_ENTRY  IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;

#line 7891 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





typedef struct _IMAGE_DEBUG_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Type;
    DWORD   SizeOfData;
    DWORD   AddressOfRawData;
    DWORD   PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;















typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
    DWORD   NumberOfSymbols;
    DWORD   LvaToFirstSymbol;
    DWORD   NumberOfLinenumbers;
    DWORD   LvaToFirstLinenumber;
    DWORD   RvaToFirstByteOfCode;
    DWORD   RvaToLastByteOfCode;
    DWORD   RvaToFirstByteOfData;
    DWORD   RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;






typedef struct _FPO_DATA {
    DWORD       ulOffStart;             
    DWORD       cbProcSize;             
    DWORD       cdwLocals;              
    WORD        cdwParams;              
    WORD        cbProlog : 8;           
    WORD        cbRegs   : 3;           
    WORD        fHasSEH  : 1;           
    WORD        fUseBP   : 1;           
    WORD        reserved : 1;           
    WORD        cbFrame  : 2;           
} FPO_DATA, *PFPO_DATA;





typedef struct _IMAGE_DEBUG_MISC {
    DWORD       DataType;               
    DWORD       Length;                 
                                        
    BOOLEAN     Unicode;                
    BYTE        Reserved[ 3 ];
    BYTE        Data[ 1 ];              
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;








typedef struct _IMAGE_FUNCTION_ENTRY {
    DWORD   StartingAddress;
    DWORD   EndingAddress;
    DWORD   EndOfPrologue;
} IMAGE_FUNCTION_ENTRY, *PIMAGE_FUNCTION_ENTRY;

typedef struct _IMAGE_FUNCTION_ENTRY64 {
    ULONGLONG   StartingAddress;
    ULONGLONG   EndingAddress;
    union {
        ULONGLONG   EndOfPrologue;
        ULONGLONG   UnwindInfoAddress;
    };
} IMAGE_FUNCTION_ENTRY64, *PIMAGE_FUNCTION_ENTRY64;





















typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
    WORD        Signature;
    WORD        Flags;
    WORD        Machine;
    WORD        Characteristics;
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       ImageBase;
    DWORD       SizeOfImage;
    DWORD       NumberOfSections;
    DWORD       ExportedNamesSize;
    DWORD       DebugDirectorySize;
    DWORD       SectionAlignment;
    DWORD       Reserved[2];
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;

typedef struct _NON_PAGED_DEBUG_INFO {
    WORD        Signature;
    WORD        Flags;
    DWORD       Size;
    WORD        Machine;
    WORD        Characteristics;
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       SizeOfImage;
    ULONGLONG   ImageBase;
    
    
} NON_PAGED_DEBUG_INFO, *PNON_PAGED_DEBUG_INFO;







#line 8042 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"



                                                









typedef struct _ImageArchitectureHeader {
    unsigned int AmaskValue: 1;                 
                                                
    int :7;                                     
    unsigned int AmaskShift: 8;                 
    int :16;                                    
    DWORD FirstEntryRVA;                        
} IMAGE_ARCHITECTURE_HEADER, *PIMAGE_ARCHITECTURE_HEADER;

typedef struct _ImageArchitectureEntry {
    DWORD FixupInstRVA;                         
    DWORD NewInst;                              
} IMAGE_ARCHITECTURE_ENTRY, *PIMAGE_ARCHITECTURE_ENTRY;

#line 1 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"


#line 36 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"
#line 37 "c:\\program files\\microsoft visual studio 8\\vc\\platformsdk\\include\\poppack.h"
#line 8070 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"








typedef struct IMPORT_OBJECT_HEADER {
    WORD    Sig1;                       
    WORD    Sig2;                       
    WORD    Version;
    WORD    Machine;
    DWORD   TimeDateStamp;              
    DWORD   SizeOfData;                 

    union {
        WORD    Ordinal;                
        WORD    Hint;
    };

    WORD    Type : 2;                   
    WORD    NameType : 3;               
    WORD    Reserved : 11;              
} IMPORT_OBJECT_HEADER;

typedef enum IMPORT_OBJECT_TYPE
{
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
} IMPORT_OBJECT_TYPE;

typedef enum IMPORT_OBJECT_NAME_TYPE
{
    IMPORT_OBJECT_ORDINAL = 0,          
    IMPORT_OBJECT_NAME = 1,             
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,   
    IMPORT_OBJECT_NAME_UNDECORATE = 3,  
                                        
} IMPORT_OBJECT_NAME_TYPE;





typedef enum ReplacesCorHdrNumericDefines
{

    COMIMAGE_FLAGS_ILONLY               =0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED        =0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY           =0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED     =0x00000008,
    COMIMAGE_FLAGS_TRACKDEBUGDATA       =0x00010000,


    COR_VERSION_MAJOR_V2                =2,
    COR_VERSION_MAJOR                   =COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR                   =0,
    COR_DELETED_NAME_LENGTH             =8,
    COR_VTABLEGAP_NAME_LENGTH           =8,


    NATIVE_TYPE_MAX_CB                  =1,   
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=0xFF,


    IMAGE_COR_MIH_METHODRVA             =0x01,
    IMAGE_COR_MIH_EHRVA                 =0x02,    
    IMAGE_COR_MIH_BASICBLOCK            =0x08,


    COR_VTABLE_32BIT                    =0x01,          
    COR_VTABLE_64BIT                    =0x02,          
    COR_VTABLE_FROM_UNMANAGED           =0x04,          
    COR_VTABLE_CALL_MOST_DERIVED        =0x10,          


    IMAGE_COR_EATJ_THUNK_SIZE           =32,            


    
    MAX_CLASS_NAME                      =1024,
    MAX_PACKAGE_NAME                    =1024,
} ReplacesCorHdrNumericDefines;


typedef struct IMAGE_COR20_HEADER
{
    
    DWORD                   cb;              
    WORD                    MajorRuntimeVersion;
    WORD                    MinorRuntimeVersion;
    
    
    IMAGE_DATA_DIRECTORY    MetaData;        
    DWORD                   Flags;           
    DWORD                   EntryPointToken;
    
    
    IMAGE_DATA_DIRECTORY    Resources;
    IMAGE_DATA_DIRECTORY    StrongNameSignature;

    
    IMAGE_DATA_DIRECTORY    CodeManagerTable;
    IMAGE_DATA_DIRECTORY    VTableFixups;
    IMAGE_DATA_DIRECTORY    ExportAddressTableJumps;

    
    IMAGE_DATA_DIRECTORY    ManagedNativeHeader;
    
} IMAGE_COR20_HEADER, *PIMAGE_COR20_HEADER;

#line 8184 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"














#line 8199 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
























#line 8224 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





#line 8230 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"










#line 8241 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SINGLE_LIST_ENTRY Next;
        WORD   Depth;
        WORD   Sequence;
    };
} SLIST_HEADER, *PSLIST_HEADER;

#line 8252 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

#line 8254 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


__declspec(dllimport)
void
__stdcall
RtlInitializeSListHead (
     PSLIST_HEADER ListHead
    );

__declspec(dllimport)
PSINGLE_LIST_ENTRY
__stdcall
RtlFirstEntrySList (
     const SLIST_HEADER *ListHead
    );

__declspec(dllimport)
PSINGLE_LIST_ENTRY
__stdcall
RtlInterlockedPopEntrySList (
     PSLIST_HEADER ListHead
    );

__declspec(dllimport)
PSINGLE_LIST_ENTRY
__stdcall
RtlInterlockedPushEntrySList (
     PSLIST_HEADER ListHead,
     PSINGLE_LIST_ENTRY ListEntry
    );

__declspec(dllimport)
PSINGLE_LIST_ENTRY
__stdcall
RtlInterlockedFlushSList (
     PSLIST_HEADER ListHead
    );

__declspec(dllimport)
WORD  
__stdcall
RtlQueryDepthSList (
     PSLIST_HEADER ListHead
    );

















__declspec(dllimport)
void
__stdcall
RtlCaptureContext (
     PCONTEXT ContextRecord
    );





















































#line 8375 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

__declspec(dllimport)
SIZE_T
__stdcall
RtlCompareMemory (
    const void *Source1,
    const void *Source2,
    SIZE_T Length
    );











__forceinline
PVOID
RtlSecureZeroMemory(
     PVOID ptr,
     SIZE_T cnt
    )
{
    volatile char *vptr = (volatile char *)ptr;





#line 8409 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

    while (cnt) {
        *vptr = 0;
        vptr++;
        cnt--;
    }

#line 8417 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

    return ptr;
}

#line 8422 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


typedef struct _MESSAGE_RESOURCE_ENTRY {
    WORD   Length;
    WORD   Flags;
    BYTE  Text[ 1 ];
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;



typedef struct _MESSAGE_RESOURCE_BLOCK {
    DWORD LowId;
    DWORD HighId;
    DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;

typedef struct _MESSAGE_RESOURCE_DATA {
    DWORD NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[ 1 ];
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;

typedef struct _OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

typedef struct _OSVERSIONINFOW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;

typedef OSVERSIONINFOW OSVERSIONINFO;
typedef POSVERSIONINFOW POSVERSIONINFO;
typedef LPOSVERSIONINFOW LPOSVERSIONINFO;




#line 8469 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

typedef struct _OSVERSIONINFOEXA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     
    WORD   wServicePackMajor;
    WORD   wServicePackMinor;
    WORD   wSuiteMask;
    BYTE  wProductType;
    BYTE  wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     
    WORD   wServicePackMajor;
    WORD   wServicePackMinor;
    WORD   wSuiteMask;
    BYTE  wProductType;
    BYTE  wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;

typedef OSVERSIONINFOEXW OSVERSIONINFOEX;
typedef POSVERSIONINFOEXW POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXW LPOSVERSIONINFOEX;




#line 8505 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


























































__declspec(dllimport)
ULONGLONG
__stdcall
VerSetConditionMask(
          ULONGLONG   ConditionMask,
          DWORD   TypeMask,
          BYTE    Condition
        );


typedef struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD   Type;
    WORD   CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Spare[ 2 ];
} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG, RTL_RESOURCE_DEBUG, *PRTL_RESOURCE_DEBUG;




typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;

    
    
    
    

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;        
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;        
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

typedef void (__stdcall * RTL_VERIFIER_DLL_LOAD_CALLBACK) (
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved
    );

typedef void (__stdcall * RTL_VERIFIER_DLL_UNLOAD_CALLBACK) (
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved
    );

typedef void (__stdcall * RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK) (
    PVOID AllocationBase,
    SIZE_T AllocationSize
    );

typedef struct _RTL_VERIFIER_THUNK_DESCRIPTOR {

    PCHAR ThunkName;
    PVOID ThunkOldAddress;
    PVOID ThunkNewAddress;

} RTL_VERIFIER_THUNK_DESCRIPTOR, *PRTL_VERIFIER_THUNK_DESCRIPTOR;

typedef struct _RTL_VERIFIER_DLL_DESCRIPTOR {

    PWCHAR DllName;
    DWORD DllFlags;
    PVOID DllAddress;
    PRTL_VERIFIER_THUNK_DESCRIPTOR DllThunks;

} RTL_VERIFIER_DLL_DESCRIPTOR, *PRTL_VERIFIER_DLL_DESCRIPTOR;

typedef struct _RTL_VERIFIER_PROVIDER_DESCRIPTOR {

    
    
    

    DWORD Length;        
    PRTL_VERIFIER_DLL_DESCRIPTOR ProviderDlls;
    RTL_VERIFIER_DLL_LOAD_CALLBACK ProviderDllLoadCallback;
    RTL_VERIFIER_DLL_UNLOAD_CALLBACK ProviderDllUnloadCallback;
    
    
    
    
        
    PWSTR VerifierImage;
    DWORD VerifierFlags;
    DWORD VerifierDebug;
    
    PVOID RtlpGetStackTraceAddress;
    PVOID RtlpDebugPageHeapCreate;
    PVOID RtlpDebugPageHeapDestroy;

    
    
    
    
    RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK ProviderNtdllHeapFreeCallback;

} RTL_VERIFIER_PROVIDER_DESCRIPTOR, *PRTL_VERIFIER_PROVIDER_DESCRIPTOR;


























































































































void
__stdcall
RtlApplicationVerifierStop (
         ULONG_PTR Code,
         PSTR Message,
         ULONG_PTR Param1,
         PSTR Description1,
         ULONG_PTR Param2,
         PSTR Description2,
         ULONG_PTR Param3,
         PSTR Description3,
         ULONG_PTR Param4,
         PSTR Description4
    );

typedef LONG (__stdcall *PVECTORED_EXCEPTION_HANDLER)(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );








typedef enum _HEAP_INFORMATION_CLASS {

    HeapCompatibilityInformation

} HEAP_INFORMATION_CLASS;

__declspec(dllimport)
DWORD   
__stdcall
RtlSetHeapInformation (
     PVOID HeapHandle,
     HEAP_INFORMATION_CLASS HeapInformationClass,
     PVOID HeapInformation ,
     SIZE_T HeapInformationLength 
    );

__declspec(dllimport)
DWORD   
__stdcall
RtlQueryHeapInformation (
     PVOID HeapHandle,
     HEAP_INFORMATION_CLASS HeapInformationClass,
     PVOID HeapInformation ,
     SIZE_T HeapInformationLength ,
     PSIZE_T ReturnLength 
    );





DWORD
__stdcall
RtlMultipleAllocateHeap (
     PVOID HeapHandle,
     DWORD Flags,
     SIZE_T Size,
     DWORD Count,
     PVOID * Array
    );

DWORD
__stdcall
RtlMultipleFreeHeap (
     PVOID HeapHandle,
     DWORD Flags,
     DWORD Count,
     PVOID * Array
    );
    











typedef void (__stdcall * WAITORTIMERCALLBACKFUNC) (PVOID, BOOLEAN );   
typedef void (__stdcall * WORKERCALLBACKFUNC) (PVOID );                 
typedef void (__stdcall * APC_CALLBACK_FUNCTION) (DWORD   , PVOID, PVOID); 
typedef
void
(__stdcall *PFLS_CALLBACK_FUNCTION) (
     PVOID lpFlsData
    );



typedef enum _ACTIVATION_CONTEXT_INFO_CLASS {
    ActivationContextBasicInformation                       = 1,
    ActivationContextDetailedInformation                    = 2,
    AssemblyDetailedInformationInActivationContext          = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext  = 4,
    MaxActivationContextInfoClass,

    
    
    
    AssemblyDetailedInformationInActivationContxt           = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt   = 4
} ACTIVATION_CONTEXT_INFO_CLASS;




typedef struct _ACTIVATION_CONTEXT_QUERY_INDEX {
    DWORD ulAssemblyIndex; 
    DWORD ulFileIndexInAssembly; 
} ACTIVATION_CONTEXT_QUERY_INDEX, * PACTIVATION_CONTEXT_QUERY_INDEX;

typedef const struct _ACTIVATION_CONTEXT_QUERY_INDEX * PCACTIVATION_CONTEXT_QUERY_INDEX;







typedef struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulFilenameLength;
    DWORD ulPathLength; 

    PCWSTR lpFileName;
    PCWSTR lpFilePath;   
} ASSEMBLY_FILE_DETAILED_INFORMATION, *PASSEMBLY_FILE_DETAILED_INFORMATION;
typedef const ASSEMBLY_FILE_DETAILED_INFORMATION *PCASSEMBLY_FILE_DETAILED_INFORMATION;










typedef struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulEncodedAssemblyIdentityLength;      
    DWORD ulManifestPathType;                   
    DWORD ulManifestPathLength;                 
    LARGE_INTEGER liManifestLastWriteTime;      
    DWORD ulPolicyPathType;                     
    DWORD ulPolicyPathLength;                   
    LARGE_INTEGER liPolicyLastWriteTime;        
    DWORD ulMetadataSatelliteRosterIndex;
    
    DWORD ulManifestVersionMajor;               
    DWORD ulManifestVersionMinor;               
    DWORD ulPolicyVersionMajor;                 
    DWORD ulPolicyVersionMinor;                 
    DWORD ulAssemblyDirectoryNameLength;        

    PCWSTR lpAssemblyEncodedAssemblyIdentity;
    PCWSTR lpAssemblyManifestPath;
    PCWSTR lpAssemblyPolicyPath;
    PCWSTR lpAssemblyDirectoryName;

    DWORD  ulFileCount;
} ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION, * PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION * PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION ;

typedef struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
    DWORD dwFlags;
    DWORD ulFormatVersion;
    DWORD ulAssemblyCount;
    DWORD ulRootManifestPathType;
    DWORD ulRootManifestPathChars;
    DWORD ulRootConfigurationPathType;
    DWORD ulRootConfigurationPathChars;
    DWORD ulAppDirPathType;
    DWORD ulAppDirPathChars;
    PCWSTR lpRootManifestPath;
    PCWSTR lpRootConfigurationPath;
    PCWSTR lpAppDirPath;
} ACTIVATION_CONTEXT_DETAILED_INFORMATION, *PACTIVATION_CONTEXT_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION *PCACTIVATION_CONTEXT_DETAILED_INFORMATION;













































typedef struct _EVENTLOGRECORD {
    DWORD  Length;        
    DWORD  Reserved;      
    DWORD  RecordNumber;  
    DWORD  TimeGenerated; 
    DWORD  TimeWritten;   
    DWORD  EventID;
    WORD   EventType;
    WORD   NumStrings;
    WORD   EventCategory;
    WORD   ReservedFlags; 
    DWORD  ClosingRecordNumber; 
    DWORD  StringOffset;  
    DWORD  UserSidLength;
    DWORD  UserSidOffset;
    DWORD  DataLength;
    DWORD  DataOffset;    
    
    
    
    
    
    
    
    
    
    
    
} EVENTLOGRECORD, *PEVENTLOGRECORD;






#pragma warning(push)
#line 9061 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"
#pragma warning(disable : 4200)
typedef struct _EVENTSFORLOGFILE{
	DWORD			ulSize;
    WCHAR   		szLogicalLogFile[256];        
    DWORD			ulNumRecords;
	EVENTLOGRECORD 	pEventLogRecords[];
}EVENTSFORLOGFILE, *PEVENTSFORLOGFILE;

typedef struct _PACKEDEVENTINFO{
    DWORD               ulSize;  
    DWORD               ulNumEventsForLogFile; 
    DWORD 				ulOffsets[];           
}PACKEDEVENTINFO, *PPACKEDEVENTINFO;


#pragma warning(pop)


#line 9080 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"





















































                                                    


                                                    


                                                    


                                                    
                                                    































































                                            






























































typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType               = 0x00000001,
    FileSystemType           = 0x00000002,
    Win32ServiceOwnProcess   = 0x00000010,
    Win32ServiceShareProcess = 0x00000020,
    AdapterType              = 0x00000004,
    RecognizerType           = 0x00000008
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad    = 0x00000000,
    SystemLoad  = 0x00000001,
    AutoLoad    = 0x00000002,
    DemandLoad  = 0x00000003,
    DisableLoad = 0x00000004
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError   = 0x00000000,
    NormalError   = 0x00000001,
    SevereError   = 0x00000002,
    CriticalError = 0x00000003
} SERVICE_ERROR_TYPE;










typedef struct _TAPE_ERASE {
    DWORD Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;












typedef struct _TAPE_PREPARE {
    DWORD Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;










typedef struct _TAPE_WRITE_MARKS {
    DWORD Type;
    DWORD Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;









typedef struct _TAPE_GET_POSITION {
    DWORD Type;
    DWORD Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;
















typedef struct _TAPE_SET_POSITION {
    DWORD Method;
    DWORD Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;























































































typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD DefaultBlockSize;
    DWORD MaximumBlockSize;
    DWORD MinimumBlockSize;
    DWORD MaximumPartitionCount;
    DWORD FeaturesLow;
    DWORD FeaturesHigh;
    DWORD EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;





typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;





typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    DWORD BlockSize;
    DWORD PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;





typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    DWORD BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;









typedef struct _TAPE_CREATE_PARTITION {
    DWORD Method;
    DWORD Count;
    DWORD Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;











typedef struct _TAPE_WMI_OPERATIONS {
   DWORD Method;
   DWORD DataBufferSize;
   PVOID DataBuffer;
} TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;




typedef enum _TAPE_DRIVE_PROBLEM_TYPE {
   TapeDriveProblemNone, TapeDriveReadWriteWarning,
   TapeDriveReadWriteError, TapeDriveReadWarning,
   TapeDriveWriteWarning, TapeDriveReadError,
   TapeDriveWriteError, TapeDriveHardwareError,
   TapeDriveUnsupportedMedia, TapeDriveScsiConnectionError,
   TapeDriveTimetoClean, TapeDriveCleanDriveNow,
   TapeDriveMediaLifeExpired, TapeDriveSnappedTape
} TAPE_DRIVE_PROBLEM_TYPE;




































#line 9586 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"








__inline struct _TEB * NtCurrentTeb( void ) { return (struct _TEB *) (ULONG_PTR) __readfsdword (0x18); }

















#line 9613 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

#line 9615 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"











#line 9627 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


}
#line 9631 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"

#line 9633 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnt.h"


#line 177 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"
#line 178 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"




typedef UINT_PTR            WPARAM;
typedef LONG_PTR            LPARAM;
typedef LONG_PTR            LRESULT;





#line 191 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"



#line 195 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"

#line 197 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"










struct HWND__ { int unused; }; typedef struct HWND__ *HWND;
struct HHOOK__ { int unused; }; typedef struct HHOOK__ *HHOOK;



#line 213 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"

typedef WORD                ATOM;

typedef HANDLE          *SPHANDLE;
typedef HANDLE           *LPHANDLE;
typedef HANDLE              HGLOBAL;
typedef HANDLE              HLOCAL;
typedef HANDLE              GLOBALHANDLE;
typedef HANDLE              LOCALHANDLE;






typedef int ( __stdcall *FARPROC)();
typedef int ( __stdcall *NEARPROC)();
typedef int (__stdcall *PROC)();
#line 232 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"




#line 237 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"



typedef void * HGDIOBJ;


#line 244 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"
#line 245 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"

struct HKEY__ { int unused; }; typedef struct HKEY__ *HKEY;
typedef HKEY *PHKEY;


struct HACCEL__ { int unused; }; typedef struct HACCEL__ *HACCEL;
#line 252 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"

struct HBITMAP__ { int unused; }; typedef struct HBITMAP__ *HBITMAP;
struct HBRUSH__ { int unused; }; typedef struct HBRUSH__ *HBRUSH;
#line 256 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"

struct HCOLORSPACE__ { int unused; }; typedef struct HCOLORSPACE__ *HCOLORSPACE;
#line 259 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"

struct HDC__ { int unused; }; typedef struct HDC__ *HDC;
#line 262 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"
struct HGLRC__ { int unused; }; typedef struct HGLRC__ *HGLRC;          
struct HDESK__ { int unused; }; typedef struct HDESK__ *HDESK;
struct HENHMETAFILE__ { int unused; }; typedef struct HENHMETAFILE__ *HENHMETAFILE;

struct HFONT__ { int unused; }; typedef struct HFONT__ *HFONT;
#line 268 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"
struct HICON__ { int unused; }; typedef struct HICON__ *HICON;

struct HMENU__ { int unused; }; typedef struct HMENU__ *HMENU;
#line 272 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"
struct HMETAFILE__ { int unused; }; typedef struct HMETAFILE__ *HMETAFILE;
struct HINSTANCE__ { int unused; }; typedef struct HINSTANCE__ *HINSTANCE;
typedef HINSTANCE HMODULE;      

struct HPALETTE__ { int unused; }; typedef struct HPALETTE__ *HPALETTE;
struct HPEN__ { int unused; }; typedef struct HPEN__ *HPEN;
#line 279 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"
struct HRGN__ { int unused; }; typedef struct HRGN__ *HRGN;
struct HRSRC__ { int unused; }; typedef struct HRSRC__ *HRSRC;
struct HSTR__ { int unused; }; typedef struct HSTR__ *HSTR;
struct HTASK__ { int unused; }; typedef struct HTASK__ *HTASK;
struct HWINSTA__ { int unused; }; typedef struct HWINSTA__ *HWINSTA;
struct HKL__ { int unused; }; typedef struct HKL__ *HKL;



struct HMONITOR__ { int unused; }; typedef struct HMONITOR__ *HMONITOR;
struct HWINEVENTHOOK__ { int unused; }; typedef struct HWINEVENTHOOK__ *HWINEVENTHOOK;
#line 291 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"
struct HUMPD__ { int unused; }; typedef struct HUMPD__ *HUMPD;
#line 293 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"


typedef int HFILE;
typedef HICON HCURSOR;      



#line 301 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"

typedef DWORD   COLORREF;
typedef DWORD   *LPCOLORREF;



typedef struct tagRECT
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECT, *PRECT,  *NPRECT,  *LPRECT;

typedef const RECT * LPCRECT;

typedef struct _RECTL       
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECTL, *PRECTL, *LPRECTL;

typedef const RECTL * LPCRECTL;

typedef struct tagPOINT
{
    LONG  x;
    LONG  y;
} POINT, *PPOINT,  *NPPOINT,  *LPPOINT;

typedef struct _POINTL      
{
    LONG  x;
    LONG  y;
} POINTL, *PPOINTL;

typedef struct tagSIZE
{
    LONG        cx;
    LONG        cy;
} SIZE, *PSIZE, *LPSIZE;

typedef SIZE               SIZEL;
typedef SIZE               *PSIZEL, *LPSIZEL;

typedef struct tagPOINTS
{

    SHORT   x;
    SHORT   y;



#line 357 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"
} POINTS, *PPOINTS, *LPPOINTS;





typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;



































}
#line 404 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"

#line 406 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windef.h"

#line 162 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"












#pragma once
#line 15 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"













#line 29 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"





#line 35 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"





#line 41 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


extern "C" {
#line 45 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"















































































































#line 157 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"









#line 167 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


























































typedef struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union {
        struct {
            DWORD Offset;
            DWORD OffsetHigh;
        };

        PVOID Pointer;
    };

    HANDLE  hEvent;
} OVERLAPPED, *LPOVERLAPPED;

typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;

typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;



















typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;


typedef DWORD (__stdcall *PTHREAD_START_ROUTINE)(
    LPVOID lpThreadParameter
    );
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;


typedef void (__stdcall *PFIBER_START_ROUTINE)(
    LPVOID lpFiberParameter
    );
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;
#line 294 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

typedef RTL_CRITICAL_SECTION_DEBUG CRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;

__declspec(dllimport)
      
PVOID
__stdcall
EncodePointer (
           PVOID Ptr
    );

__declspec(dllimport)
      
PVOID
__stdcall
DecodePointer (
           PVOID Ptr
    );

__declspec(dllimport)
      
PVOID
__stdcall
EncodeSystemPointer (
           PVOID Ptr
    );

__declspec(dllimport)
      
PVOID
__stdcall
DecodeSystemPointer (
           PVOID Ptr
    );


typedef PLDT_ENTRY LPLDT_ENTRY;


#line 340 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"









































































































typedef struct _COMMPROP {
    WORD wPacketLength;
    WORD wPacketVersion;
    DWORD dwServiceMask;
    DWORD dwReserved1;
    DWORD dwMaxTxQueue;
    DWORD dwMaxRxQueue;
    DWORD dwMaxBaud;
    DWORD dwProvSubType;
    DWORD dwProvCapabilities;
    DWORD dwSettableParams;
    DWORD dwSettableBaud;
    WORD wSettableData;
    WORD wSettableStopParity;
    DWORD dwCurrentTxQueue;
    DWORD dwCurrentRxQueue;
    DWORD dwProvSpec1;
    DWORD dwProvSpec2;
    WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;







typedef struct _COMSTAT {
    DWORD fCtsHold : 1;
    DWORD fDsrHold : 1;
    DWORD fRlsdHold : 1;
    DWORD fXoffHold : 1;
    DWORD fXoffSent : 1;
    DWORD fEof : 1;
    DWORD fTxim : 1;
    DWORD fReserved : 25;
    DWORD cbInQue;
    DWORD cbOutQue;
} COMSTAT, *LPCOMSTAT;
















typedef struct _DCB {
    DWORD DCBlength;      
    DWORD BaudRate;       
    DWORD fBinary: 1;     
    DWORD fParity: 1;     
    DWORD fOutxCtsFlow:1; 
    DWORD fOutxDsrFlow:1; 
    DWORD fDtrControl:2;  
    DWORD fDsrSensitivity:1; 
    DWORD fTXContinueOnXoff: 1; 
    DWORD fOutX: 1;       
    DWORD fInX: 1;        
    DWORD fErrorChar: 1;  
    DWORD fNull: 1;       
    DWORD fRtsControl:2;  
    DWORD fAbortOnError:1; 
    DWORD fDummy2:17;     
    WORD wReserved;       
    WORD XonLim;          
    WORD XoffLim;         
    BYTE ByteSize;        
    BYTE Parity;          
    BYTE StopBits;        
    char XonChar;         
    char XoffChar;        
    char ErrorChar;       
    char EofChar;         
    char EvtChar;         
    WORD wReserved1;      
} DCB, *LPDCB;

typedef struct _COMMTIMEOUTS {
    DWORD ReadIntervalTimeout;          
    DWORD ReadTotalTimeoutMultiplier;   
    DWORD ReadTotalTimeoutConstant;     
    DWORD WriteTotalTimeoutMultiplier;  
    DWORD WriteTotalTimeoutConstant;    
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;

typedef struct _COMMCONFIG {
    DWORD dwSize;               
    WORD wVersion;              
    WORD wReserved;             
    DCB dcb;                    
    DWORD dwProviderSubType;    

    DWORD dwProviderOffset;     

    DWORD dwProviderSize;       
    WCHAR wcProviderData[1];    
} COMMCONFIG,*LPCOMMCONFIG;

typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId;          
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        };
    };
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD_PTR dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;




































typedef struct _MEMORYSTATUS {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    SIZE_T dwTotalPhys;
    SIZE_T dwAvailPhys;
    SIZE_T dwTotalPageFile;
    SIZE_T dwAvailPageFile;
    SIZE_T dwTotalVirtual;
    SIZE_T dwAvailVirtual;
} MEMORYSTATUS, *LPMEMORYSTATUS;
























































































typedef struct _EXCEPTION_DEBUG_INFO {
    EXCEPTION_RECORD ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;

typedef struct _CREATE_THREAD_DEBUG_INFO {
    HANDLE hThread;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;

typedef struct _CREATE_PROCESS_DEBUG_INFO {
    HANDLE hFile;
    HANDLE hProcess;
    HANDLE hThread;
    LPVOID lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
    LPVOID lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;

typedef struct _EXIT_THREAD_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;

typedef struct _EXIT_PROCESS_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;

typedef struct _LOAD_DLL_DEBUG_INFO {
    HANDLE hFile;
    LPVOID lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;

typedef struct _UNLOAD_DLL_DEBUG_INFO {
    LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;

typedef struct _OUTPUT_DEBUG_STRING_INFO {
    LPSTR lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;

typedef struct _RIP_INFO {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO, *LPRIP_INFO;


typedef struct _DEBUG_EVENT {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union {
        EXCEPTION_DEBUG_INFO Exception;
        CREATE_THREAD_DEBUG_INFO CreateThread;
        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO ExitThread;
        EXIT_PROCESS_DEBUG_INFO ExitProcess;
        LOAD_DLL_DEBUG_INFO LoadDll;
        UNLOAD_DLL_DEBUG_INFO UnloadDll;
        OUTPUT_DEBUG_STRING_INFO DebugString;
        RIP_INFO RipInfo;
    } u;
} DEBUG_EVENT, *LPDEBUG_EVENT;


typedef PCONTEXT LPCONTEXT;
typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD;
typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;
#line 783 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"














#line 798 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"











































































































































































































typedef struct _OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[128];
} OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT;



















































































































































































































































































































































































































































#line 1445 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"




























































































































#line 1570 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
LONG
__stdcall
InterlockedIncrement (
         LONG volatile *lpAddend
    );

__declspec(dllimport)
LONG
__stdcall
InterlockedDecrement (
         LONG volatile *lpAddend
    );

__declspec(dllimport)
LONG
__stdcall
InterlockedExchange (
         LONG volatile *Target,
            LONG Value
    );




__declspec(dllimport)
LONG
__stdcall
InterlockedExchangeAdd (
         LONG volatile *Addend,
            LONG Value
    );

__declspec(dllimport)
LONG
__stdcall
InterlockedCompareExchange (
         LONG volatile *Destination,
            LONG Exchange,
            LONG Comperand
    );












#line 1625 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

































































































































#line 1755 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

#line 1757 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"







__forceinline
PVOID

__cdecl
#line 1769 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
__InlineInterlockedCompareExchangePointer (
          PVOID volatile *Destination,
           PVOID ExChange,
           PVOID Comperand
    )
{
    return((PVOID)(LONG_PTR)InterlockedCompareExchange((LONG volatile *)Destination, (LONG)(LONG_PTR)ExChange, (LONG)(LONG_PTR)Comperand));
}








#line 1786 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"














#line 1801 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"



__declspec(dllimport)
void
__stdcall
InitializeSListHead (
         PSLIST_HEADER ListHead
    );

__declspec(dllimport)
PSINGLE_LIST_ENTRY
__stdcall
InterlockedPopEntrySList (
         PSLIST_HEADER ListHead
    );

__declspec(dllimport)
PSINGLE_LIST_ENTRY
__stdcall
InterlockedPushEntrySList (
         PSLIST_HEADER ListHead,
         PSINGLE_LIST_ENTRY ListEntry
    );

__declspec(dllimport)
PSINGLE_LIST_ENTRY
__stdcall
InterlockedFlushSList (
         PSLIST_HEADER ListHead
    );

__declspec(dllimport)
USHORT
__stdcall
QueryDepthSList (
         PSLIST_HEADER ListHead
    );

#line 1841 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

#line 1843 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

#line 1845 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FreeResource(
         HGLOBAL hResData
    );

__declspec(dllimport)
LPVOID
__stdcall
LockResource(
         HGLOBAL hResData
    );






int



#line 1870 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
__stdcall
#line 1872 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


#line 1875 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
WinMain (
         HINSTANCE hInstance,
           HINSTANCE hPrevInstance,
           LPSTR lpCmdLine,
         int nShowCmd
    );

__declspec(dllimport)
BOOL
__stdcall
FreeLibrary (
         HMODULE hLibModule
    );


__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
FreeLibraryAndExitThread (
         HMODULE hLibModule,
         DWORD dwExitCode
    );

__declspec(dllimport)
BOOL
__stdcall
DisableThreadLibraryCalls (
         HMODULE hLibModule
    );

__declspec(dllimport)
FARPROC
__stdcall
GetProcAddress (
         HMODULE hModule,
         LPCSTR lpProcName
    );

__declspec(dllimport)
DWORD
__stdcall
GetVersion (
    void
    );

__declspec(dllimport)
    
HGLOBAL
__stdcall
GlobalAlloc (
         UINT uFlags,
         SIZE_T dwBytes
    );

__declspec(dllimport)
    
HGLOBAL
__stdcall
GlobalReAlloc (
         HGLOBAL hMem,
         SIZE_T dwBytes,
         UINT uFlags
    );

__declspec(dllimport)
SIZE_T
__stdcall
GlobalSize (
         HGLOBAL hMem
    );

__declspec(dllimport)
UINT
__stdcall
GlobalFlags (
         HGLOBAL hMem
    );

__declspec(dllimport)
    
LPVOID
__stdcall
GlobalLock ( 
         HGLOBAL hMem
    );

__declspec(dllimport)
    
HGLOBAL
__stdcall
GlobalHandle (
         LPCVOID pMem
    );

__declspec(dllimport)
BOOL
__stdcall
GlobalUnlock(
         HGLOBAL hMem
    );

__declspec(dllimport)
    
HGLOBAL
__stdcall
GlobalFree(
     HGLOBAL hMem
    );

__declspec(dllimport)
SIZE_T
__stdcall
GlobalCompact(
         DWORD dwMinFree
    );

__declspec(dllimport)
void
__stdcall
GlobalFix(
         HGLOBAL hMem
    );

__declspec(dllimport)
void
__stdcall
GlobalUnfix(
         HGLOBAL hMem
    );

__declspec(dllimport)
    
LPVOID
__stdcall
GlobalWire(
         HGLOBAL hMem
    );

__declspec(dllimport)
BOOL
__stdcall
GlobalUnWire(
         HGLOBAL hMem
    );

__declspec(dllimport)
void
__stdcall
GlobalMemoryStatus(
         LPMEMORYSTATUS lpBuffer
    );

typedef struct _MEMORYSTATUSEX {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORDLONG ullTotalPhys;
    DWORDLONG ullAvailPhys;
    DWORDLONG ullTotalPageFile;
    DWORDLONG ullAvailPageFile;
    DWORDLONG ullTotalVirtual;
    DWORDLONG ullAvailVirtual;
    DWORDLONG ullAvailExtendedVirtual;
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;

__declspec(dllimport)
BOOL
__stdcall
GlobalMemoryStatusEx(
         LPMEMORYSTATUSEX lpBuffer
    );

__declspec(dllimport)
    
HLOCAL
__stdcall
LocalAlloc(
         UINT uFlags,
         SIZE_T uBytes
    );

__declspec(dllimport)
    
HLOCAL
__stdcall
LocalReAlloc(
         HLOCAL hMem,
         SIZE_T uBytes,
         UINT uFlags
    );

__declspec(dllimport)
    
LPVOID
__stdcall
LocalLock(
         HLOCAL hMem
    );

__declspec(dllimport)
    
HLOCAL
__stdcall
LocalHandle(
         LPCVOID pMem
    );

__declspec(dllimport)
BOOL
__stdcall
LocalUnlock(
         HLOCAL hMem
    );

__declspec(dllimport)
SIZE_T
__stdcall
LocalSize(
         HLOCAL hMem
    );

__declspec(dllimport)
UINT
__stdcall
LocalFlags(
         HLOCAL hMem
    );

__declspec(dllimport)
HLOCAL
__stdcall
LocalFree(
     HLOCAL hMem
    );

__declspec(dllimport)
SIZE_T
__stdcall
LocalShrink(
         HLOCAL hMem,
         UINT cbNewSize
    );

__declspec(dllimport)
SIZE_T
__stdcall
LocalCompact(
         UINT uMinFree
    );

__declspec(dllimport)
BOOL
__stdcall
FlushInstructionCache(
         HANDLE hProcess,
             LPCVOID lpBaseAddress,
         SIZE_T dwSize
    );

__declspec(dllimport)
 
LPVOID
__stdcall
VirtualAlloc(
           LPVOID lpAddress,
             SIZE_T dwSize,
             DWORD flAllocationType,
             DWORD flProtect
    );

__declspec(dllimport)
BOOL
__stdcall
VirtualFree(
         LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD dwFreeType
    );

__declspec(dllimport)
BOOL
__stdcall
VirtualProtect(
          LPVOID lpAddress,
          SIZE_T dwSize,
          DWORD flNewProtect,
         PDWORD lpflOldProtect
    );

__declspec(dllimport)
SIZE_T
__stdcall
VirtualQuery(
           LPCVOID lpAddress,
           PMEMORY_BASIC_INFORMATION lpBuffer,
             SIZE_T dwLength
    );

__declspec(dllimport)
 
LPVOID
__stdcall
VirtualAllocEx(
             HANDLE hProcess,
           LPVOID lpAddress,
             SIZE_T dwSize,
             DWORD flAllocationType,
             DWORD flProtect
    );

__declspec(dllimport)
UINT
__stdcall
GetWriteWatch(
         DWORD dwFlags,
         PVOID lpBaseAddress,
         SIZE_T dwRegionSize,
           PVOID *lpAddresses,
         ULONG_PTR *lpdwCount,
         PULONG lpdwGranularity
    );

__declspec(dllimport)
UINT
__stdcall
ResetWriteWatch(
         LPVOID lpBaseAddress,
         SIZE_T dwRegionSize
    );

__declspec(dllimport)
SIZE_T
__stdcall
GetLargePageMinimum(
    void
    );

__declspec(dllimport)
UINT
__stdcall
EnumSystemFirmwareTables(
         DWORD FirmwareTableProviderSignature,
             PVOID pFirmwareTableEnumBuffer,
         DWORD BufferSize
    );
    
__declspec(dllimport)
UINT
__stdcall
GetSystemFirmwareTable(
         DWORD FirmwareTableProviderSignature,
         DWORD FirmwareTableID,
             PVOID pFirmwareTableBuffer,
         DWORD BufferSize
    );

__declspec(dllimport)
BOOL
__stdcall
VirtualFreeEx(
         HANDLE hProcess,
         LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD  dwFreeType
    );

__declspec(dllimport)
BOOL
__stdcall
VirtualProtectEx(
          HANDLE hProcess,
          LPVOID lpAddress,
          SIZE_T dwSize,
          DWORD flNewProtect,
         PDWORD lpflOldProtect
    );

__declspec(dllimport)
SIZE_T
__stdcall
VirtualQueryEx(
             HANDLE hProcess,
           LPCVOID lpAddress,
           PMEMORY_BASIC_INFORMATION lpBuffer,
             SIZE_T dwLength
    );

__declspec(dllimport)
    
HANDLE
__stdcall
HeapCreate(
         DWORD flOptions,
         SIZE_T dwInitialSize,
         SIZE_T dwMaximumSize
    );

__declspec(dllimport)
BOOL
__stdcall
HeapDestroy(
         HANDLE hHeap
    );


__declspec(dllimport)
 
LPVOID
__stdcall
HeapAlloc(
         HANDLE hHeap,
         DWORD dwFlags,
         SIZE_T dwBytes
    );

__declspec(dllimport)
 
LPVOID
__stdcall
HeapReAlloc(
         HANDLE hHeap,
            DWORD dwFlags,
     LPVOID lpMem,
            SIZE_T dwBytes
    );

__declspec(dllimport)
BOOL
__stdcall
HeapFree(
         HANDLE hHeap,
            DWORD dwFlags,
     LPVOID lpMem
    );

__declspec(dllimport)
SIZE_T
__stdcall
HeapSize(
         HANDLE hHeap,
         DWORD dwFlags,
         LPCVOID lpMem
    );

__declspec(dllimport)
BOOL
__stdcall
HeapValidate(
             HANDLE hHeap,
             DWORD dwFlags,
           LPCVOID lpMem
    );

__declspec(dllimport)
SIZE_T
__stdcall
HeapCompact(
         HANDLE hHeap,
         DWORD dwFlags
    );

__declspec(dllimport)
    
HANDLE
__stdcall
GetProcessHeap( void );

__declspec(dllimport)
DWORD
__stdcall
GetProcessHeaps(
         DWORD NumberOfHeaps,
           PHANDLE ProcessHeaps
    );

typedef struct _PROCESS_HEAP_ENTRY {
    PVOID lpData;
    DWORD cbData;
    BYTE cbOverhead;
    BYTE iRegionIndex;
    WORD wFlags;
    union {
        struct {
            HANDLE hMem;
            DWORD dwReserved[ 3 ];
        } Block;
        struct {
            DWORD dwCommittedSize;
            DWORD dwUnCommittedSize;
            LPVOID lpFirstBlock;
            LPVOID lpLastBlock;
        } Region;
    };
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY;







__declspec(dllimport)
BOOL
__stdcall
HeapLock(
         HANDLE hHeap
    );

__declspec(dllimport)
BOOL
__stdcall
HeapUnlock(
         HANDLE hHeap
    );


__declspec(dllimport)
BOOL
__stdcall
HeapWalk(
            HANDLE hHeap,
         LPPROCESS_HEAP_ENTRY lpEntry
    );

__declspec(dllimport)
BOOL
__stdcall
HeapSetInformation (
         HANDLE HeapHandle, 
         HEAP_INFORMATION_CLASS HeapInformationClass,
             PVOID HeapInformation,
         SIZE_T HeapInformationLength
    );

__declspec(dllimport)
BOOL
__stdcall
HeapQueryInformation (
              HANDLE HeapHandle, 
              HEAP_INFORMATION_CLASS HeapInformationClass,
             PVOID HeapInformation,
              SIZE_T HeapInformationLength,
           PSIZE_T ReturnLength
    );













#line 2433 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

#line 2435 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetBinaryTypeA(
          LPCSTR lpApplicationName,
         LPDWORD  lpBinaryType
    );
__declspec(dllimport)
BOOL
__stdcall
GetBinaryTypeW(
          LPCWSTR lpApplicationName,
         LPDWORD  lpBinaryType
    );




#line 2455 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetShortPathNameA(
         LPCSTR lpszLongPath,
           LPSTR  lpszShortPath,
         DWORD cchBuffer
    );
__declspec(dllimport)
DWORD
__stdcall
GetShortPathNameW(
         LPCWSTR lpszLongPath,
           LPWSTR  lpszShortPath,
         DWORD cchBuffer
    );




#line 2477 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetLongPathNameA(
         LPCSTR lpszShortPath,
           LPSTR  lpszLongPath,
         DWORD cchBuffer
    );
__declspec(dllimport)
DWORD
__stdcall
GetLongPathNameW(
         LPCWSTR lpszShortPath,
           LPWSTR  lpszLongPath,
         DWORD cchBuffer
    );




#line 2499 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetProcessAffinityMask(
          HANDLE hProcess,
         PDWORD_PTR lpProcessAffinityMask,
         PDWORD_PTR lpSystemAffinityMask
    );

__declspec(dllimport)
BOOL
__stdcall
SetProcessAffinityMask(
         HANDLE hProcess,
         DWORD_PTR dwProcessAffinityMask
    );











#line 2528 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetProcessTimes(
          HANDLE hProcess,
         LPFILETIME lpCreationTime,
         LPFILETIME lpExitTime,
         LPFILETIME lpKernelTime,
         LPFILETIME lpUserTime
    );

__declspec(dllimport)
BOOL
__stdcall
GetProcessIoCounters(
          HANDLE hProcess,
         PIO_COUNTERS lpIoCounters
    );

__declspec(dllimport)
BOOL
__stdcall
GetProcessWorkingSetSize(
          HANDLE hProcess,
         PSIZE_T lpMinimumWorkingSetSize,
         PSIZE_T lpMaximumWorkingSetSize
    );

__declspec(dllimport)
BOOL
__stdcall
GetProcessWorkingSetSizeEx(
          HANDLE hProcess,
         PSIZE_T lpMinimumWorkingSetSize,
         PSIZE_T lpMaximumWorkingSetSize,
         PDWORD Flags
    );

__declspec(dllimport)
BOOL
__stdcall
SetProcessWorkingSetSize(
         HANDLE hProcess,
         SIZE_T dwMinimumWorkingSetSize,
         SIZE_T dwMaximumWorkingSetSize
    );

__declspec(dllimport)
BOOL
__stdcall
SetProcessWorkingSetSizeEx(
         HANDLE hProcess,
         SIZE_T dwMinimumWorkingSetSize,
         SIZE_T dwMaximumWorkingSetSize,
         DWORD Flags
    );

__declspec(dllimport)
    
HANDLE
__stdcall
OpenProcess(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         DWORD dwProcessId
    );

__declspec(dllimport)
    
HANDLE
__stdcall
GetCurrentProcess(
    void
    );

__declspec(dllimport)
DWORD
__stdcall
GetCurrentProcessId(
    void
    );

__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
ExitProcess(
         UINT uExitCode
    );

__declspec(dllimport)
BOOL
__stdcall
TerminateProcess(
         HANDLE hProcess,
         UINT uExitCode
    );

__declspec(dllimport)
BOOL
__stdcall
GetExitCodeProcess(
          HANDLE hProcess,
         LPDWORD lpExitCode
    );

__declspec(dllimport)
void
__stdcall
FatalExit(
         int ExitCode
    );

__declspec(dllimport)
    

LPCH
__stdcall
GetEnvironmentStrings(
    void
    );

__declspec(dllimport)
    

LPWCH
__stdcall
GetEnvironmentStringsW(
    void
    );





#line 2665 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentStringsA(
          LPCH NewEnvironment
    );
__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentStringsW(
          LPWCH NewEnvironment
    );




#line 2683 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FreeEnvironmentStringsA(
          LPCH
    );
__declspec(dllimport)
BOOL
__stdcall
FreeEnvironmentStringsW(
          LPWCH
    );




#line 2701 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
void
__stdcall
RaiseException(
         DWORD dwExceptionCode,
         DWORD dwExceptionFlags,
         DWORD nNumberOfArguments,
             const ULONG_PTR *lpArguments
    );


__declspec(dllimport)
LONG
__stdcall
UnhandledExceptionFilter(
         struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef LONG (__stdcall *PTOP_LEVEL_EXCEPTION_FILTER)(
         struct _EXCEPTION_POINTERS *ExceptionInfo
    );
typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;

__declspec(dllimport)
LPTOP_LEVEL_EXCEPTION_FILTER
__stdcall
SetUnhandledExceptionFilter(
         LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    );









__declspec(dllimport)
    
LPVOID
__stdcall
CreateFiber(
             SIZE_T dwStackSize,
             LPFIBER_START_ROUTINE lpStartAddress,
           LPVOID lpParameter
    );

__declspec(dllimport)
    
LPVOID
__stdcall
CreateFiberEx(
             SIZE_T dwStackCommitSize,
             SIZE_T dwStackReserveSize,
             DWORD dwFlags,
             LPFIBER_START_ROUTINE lpStartAddress,
           LPVOID lpParameter
    );

__declspec(dllimport)
void
__stdcall
DeleteFiber(
         LPVOID lpFiber
    );

__declspec(dllimport)
    
LPVOID
__stdcall
ConvertThreadToFiber(
           LPVOID lpParameter
    );

__declspec(dllimport)
    
LPVOID
__stdcall
ConvertThreadToFiberEx(
           LPVOID lpParameter,
             DWORD dwFlags
    );

__declspec(dllimport)
BOOL
__stdcall
ConvertFiberToThread(
    void
    );

__declspec(dllimport)
void
__stdcall
SwitchToFiber(
         LPVOID lpFiber
    );

__declspec(dllimport)
BOOL
__stdcall
SwitchToThread(
    void
    );

#line 2808 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HANDLE
__stdcall
CreateThread(
            LPSECURITY_ATTRIBUTES lpThreadAttributes,
              SIZE_T dwStackSize,
              LPTHREAD_START_ROUTINE lpStartAddress,
            LPVOID lpParameter,
              DWORD dwCreationFlags,
           LPDWORD lpThreadId
    );

__declspec(dllimport)
    
HANDLE
__stdcall
CreateRemoteThread(
              HANDLE hProcess,
            LPSECURITY_ATTRIBUTES lpThreadAttributes,
              SIZE_T dwStackSize,
              LPTHREAD_START_ROUTINE lpStartAddress,
            LPVOID lpParameter,
              DWORD dwCreationFlags,
           LPDWORD lpThreadId
    );

__declspec(dllimport)
    
HANDLE
__stdcall
GetCurrentThread(
    void
    );

__declspec(dllimport)
DWORD
__stdcall
GetCurrentThreadId(
    void
    );

__declspec(dllimport)
BOOL
__stdcall
SetThreadStackGuarantee (
         PULONG StackSizeInBytes
    );

__declspec(dllimport)
DWORD
__stdcall
GetProcessIdOfThread(
         HANDLE Thread
    );

__declspec(dllimport)
DWORD
__stdcall
GetThreadId(
         HANDLE Thread
    );

__declspec(dllimport)
DWORD
__stdcall
GetProcessId(
         HANDLE Process
    );

__declspec(dllimport)
DWORD
__stdcall
GetCurrentProcessorNumber(
    void
    );

__declspec(dllimport)
DWORD_PTR
__stdcall
SetThreadAffinityMask(
         HANDLE hThread,
         DWORD_PTR dwThreadAffinityMask
    );


__declspec(dllimport)
DWORD
__stdcall
SetThreadIdealProcessor(
         HANDLE hThread,
         DWORD dwIdealProcessor
    );
#line 2903 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetProcessPriorityBoost(
         HANDLE hProcess,
         BOOL bDisablePriorityBoost
    );

__declspec(dllimport)
BOOL
__stdcall
GetProcessPriorityBoost(
          HANDLE hProcess,
         PBOOL  pDisablePriorityBoost
    );

__declspec(dllimport)
BOOL
__stdcall
RequestWakeupLatency(
         LATENCY_TIME latency
    );

__declspec(dllimport)
BOOL
__stdcall
IsSystemResumeAutomatic(
    void
    );

__declspec(dllimport)
    
HANDLE
__stdcall
OpenThread(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         DWORD dwThreadId
    );

__declspec(dllimport)
BOOL
__stdcall
SetThreadPriority(
         HANDLE hThread,
         int nPriority
    );

__declspec(dllimport)
BOOL
__stdcall
SetThreadPriorityBoost(
         HANDLE hThread,
         BOOL bDisablePriorityBoost
    );

__declspec(dllimport)
BOOL
__stdcall
GetThreadPriorityBoost(
          HANDLE hThread,
         PBOOL pDisablePriorityBoost
    );

__declspec(dllimport)
int
__stdcall
GetThreadPriority(
         HANDLE hThread
    );

__declspec(dllimport)
BOOL
__stdcall
GetThreadTimes(
          HANDLE hThread,
         LPFILETIME lpCreationTime,
         LPFILETIME lpExitTime,
         LPFILETIME lpKernelTime,
         LPFILETIME lpUserTime
    );











#line 2997 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
ExitThread(
         DWORD dwExitCode
    );

__declspec(dllimport)
BOOL
__stdcall
TerminateThread(
         HANDLE hThread,
         DWORD dwExitCode
    );

__declspec(dllimport)
BOOL
__stdcall
GetExitCodeThread(
          HANDLE hThread,
         LPDWORD lpExitCode
    );

__declspec(dllimport)
BOOL
__stdcall
GetThreadSelectorEntry(
          HANDLE hThread,
          DWORD dwSelector,
         LPLDT_ENTRY lpSelectorEntry
    );

__declspec(dllimport)
EXECUTION_STATE
__stdcall
SetThreadExecutionState(
         EXECUTION_STATE esFlags
    );

__declspec(dllimport)
DWORD
__stdcall
GetLastError(
    void
    );

__declspec(dllimport)
void
__stdcall
SetLastError(
         DWORD dwErrCode
    );

















#line 3069 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
#line 3070 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
GetOverlappedResult(
          HANDLE hFile,
          LPOVERLAPPED lpOverlapped,
         LPDWORD lpNumberOfBytesTransferred,
          BOOL bWait
    );

__declspec(dllimport)
    
HANDLE
__stdcall
CreateIoCompletionPort(
             HANDLE FileHandle,
           HANDLE ExistingCompletionPort,
             ULONG_PTR CompletionKey,
             DWORD NumberOfConcurrentThreads
    );

__declspec(dllimport)
BOOL
__stdcall
GetQueuedCompletionStatus(
          HANDLE CompletionPort,
         LPDWORD lpNumberOfBytesTransferred,
         PULONG_PTR lpCompletionKey,
         LPOVERLAPPED *lpOverlapped,
          DWORD dwMilliseconds
    );

__declspec(dllimport)
BOOL
__stdcall
PostQueuedCompletionStatus(
             HANDLE CompletionPort,
             DWORD dwNumberOfBytesTransferred,
             ULONG_PTR dwCompletionKey,
           LPOVERLAPPED lpOverlapped
    );






__declspec(dllimport)
UINT
__stdcall
SetErrorMode(
         UINT uMode
    );

__declspec(dllimport)
BOOL
__stdcall
ReadProcessMemory(
              HANDLE hProcess,
              LPCVOID lpBaseAddress,
           LPVOID lpBuffer,
              SIZE_T nSize,
           SIZE_T * lpNumberOfBytesRead
    );

__declspec(dllimport)
BOOL
__stdcall
WriteProcessMemory(
              HANDLE hProcess,
              LPVOID lpBaseAddress,
           LPCVOID lpBuffer,
              SIZE_T nSize,
           SIZE_T * lpNumberOfBytesWritten
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadContext(
            HANDLE hThread,
         LPCONTEXT lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
SetThreadContext(
         HANDLE hThread,
         const CONTEXT *lpContext
    );
#line 3166 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
SuspendThread(
         HANDLE hThread
    );

__declspec(dllimport)
DWORD
__stdcall
ResumeThread(
         HANDLE hThread
    );




typedef
void
(__stdcall *PAPCFUNC)(
         ULONG_PTR dwParam
    );

__declspec(dllimport)
DWORD
__stdcall
QueueUserAPC(
         PAPCFUNC pfnAPC,
         HANDLE hThread,
         ULONG_PTR dwData
    );

#line 3200 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
IsDebuggerPresent(
    void
    );
#line 3209 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"











#line 3221 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
void
__stdcall
DebugBreak(
    void
    );

__declspec(dllimport)
BOOL
__stdcall
WaitForDebugEvent(
         LPDEBUG_EVENT lpDebugEvent,
         DWORD dwMilliseconds
    );

__declspec(dllimport)
BOOL
__stdcall
ContinueDebugEvent(
         DWORD dwProcessId,
         DWORD dwThreadId,
         DWORD dwContinueStatus
    );

__declspec(dllimport)
BOOL
__stdcall
DebugActiveProcess(
         DWORD dwProcessId
    );

__declspec(dllimport)
BOOL
__stdcall
DebugActiveProcessStop(
         DWORD dwProcessId
    );

__declspec(dllimport)
BOOL
__stdcall
DebugSetProcessKillOnExit(
         BOOL KillOnExit
    );

__declspec(dllimport)
BOOL
__stdcall
DebugBreakProcess (
         HANDLE Process
    );

__declspec(dllimport)
void
__stdcall
InitializeCriticalSection(
         LPCRITICAL_SECTION lpCriticalSection
    );

__declspec(dllimport)
void
__stdcall
EnterCriticalSection(
         LPCRITICAL_SECTION lpCriticalSection
    );

__declspec(dllimport)
void
__stdcall
LeaveCriticalSection(
         LPCRITICAL_SECTION lpCriticalSection
    );


__declspec(dllimport)
BOOL
__stdcall
InitializeCriticalSectionAndSpinCount(
         LPCRITICAL_SECTION lpCriticalSection,
          DWORD dwSpinCount
    );

__declspec(dllimport)
DWORD
__stdcall
SetCriticalSectionSpinCount(
         LPCRITICAL_SECTION lpCriticalSection,
            DWORD dwSpinCount
    );
#line 3312 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
TryEnterCriticalSection(
         LPCRITICAL_SECTION lpCriticalSection
    );
#line 3321 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
void
__stdcall
DeleteCriticalSection(
         LPCRITICAL_SECTION lpCriticalSection
    );

__declspec(dllimport)
BOOL
__stdcall
SetEvent(
         HANDLE hEvent
    );

__declspec(dllimport)
BOOL
__stdcall
ResetEvent(
         HANDLE hEvent
    );

__declspec(dllimport)
BOOL
__stdcall
PulseEvent(
         HANDLE hEvent
    );

__declspec(dllimport)
BOOL
__stdcall
ReleaseSemaphore(
              HANDLE hSemaphore,
              LONG lReleaseCount,
           LPLONG lpPreviousCount
    );

__declspec(dllimport)
BOOL
__stdcall
ReleaseMutex(
         HANDLE hMutex
    );

__declspec(dllimport)
DWORD
__stdcall
WaitForSingleObject(
         HANDLE hHandle,
         DWORD dwMilliseconds
    );

__declspec(dllimport)
DWORD
__stdcall
WaitForMultipleObjects(
         DWORD nCount,
           const HANDLE *lpHandles,
         BOOL bWaitAll,
         DWORD dwMilliseconds
    );

__declspec(dllimport)
void
__stdcall
Sleep(
         DWORD dwMilliseconds
    );

__declspec(dllimport)
    
HGLOBAL
__stdcall
LoadResource(
           HMODULE hModule,
         HRSRC hResInfo
    );

__declspec(dllimport)
DWORD
__stdcall
SizeofResource(
           HMODULE hModule,
         HRSRC hResInfo
    );


__declspec(dllimport)
    
ATOM
__stdcall
GlobalDeleteAtom(
         ATOM nAtom
    );

__declspec(dllimport)
BOOL
__stdcall
InitAtomTable(
         DWORD nSize
    );

__declspec(dllimport)
    
ATOM
__stdcall
DeleteAtom(
         ATOM nAtom
    );

__declspec(dllimport)
UINT
__stdcall
SetHandleCount(
         UINT uNumber
    );

__declspec(dllimport)
DWORD
__stdcall
GetLogicalDrives(
    void
    );

__declspec(dllimport)
BOOL
__stdcall
LockFile(
         HANDLE hFile,
         DWORD dwFileOffsetLow,
         DWORD dwFileOffsetHigh,
         DWORD nNumberOfBytesToLockLow,
         DWORD nNumberOfBytesToLockHigh
    );

__declspec(dllimport)
BOOL
__stdcall
UnlockFile(
         HANDLE hFile,
         DWORD dwFileOffsetLow,
         DWORD dwFileOffsetHigh,
         DWORD nNumberOfBytesToUnlockLow,
         DWORD nNumberOfBytesToUnlockHigh
    );

__declspec(dllimport)
BOOL
__stdcall
LockFileEx(
               HANDLE hFile,
               DWORD dwFlags,
      DWORD dwReserved,
               DWORD nNumberOfBytesToLockLow,
               DWORD nNumberOfBytesToLockHigh,
            LPOVERLAPPED lpOverlapped
    );




__declspec(dllimport)
BOOL
__stdcall
UnlockFileEx(
               HANDLE hFile,
      DWORD dwReserved,
               DWORD nNumberOfBytesToUnlockLow,
               DWORD nNumberOfBytesToUnlockHigh,
            LPOVERLAPPED lpOverlapped
    );

typedef struct _BY_HANDLE_FILE_INFORMATION {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD dwVolumeSerialNumber;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD nNumberOfLinks;
    DWORD nFileIndexHigh;
    DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;

__declspec(dllimport)
BOOL
__stdcall
GetFileInformationByHandle(
          HANDLE hFile,
         LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    );

__declspec(dllimport)
DWORD
__stdcall
GetFileType(
         HANDLE hFile
    );

__declspec(dllimport)
DWORD
__stdcall
GetFileSize(
              HANDLE hFile,
           LPDWORD lpFileSizeHigh
    );

__declspec(dllimport)
BOOL
__stdcall
GetFileSizeEx(
          HANDLE hFile,
         PLARGE_INTEGER lpFileSize
    );


__declspec(dllimport)
    
HANDLE
__stdcall
GetStdHandle(
         DWORD nStdHandle
    );

__declspec(dllimport)
BOOL
__stdcall
SetStdHandle(
         DWORD nStdHandle,
         HANDLE hHandle
    );

__declspec(dllimport)
BOOL
__stdcall
WriteFile(
                HANDLE hFile,
           LPCVOID lpBuffer,
                DWORD nNumberOfBytesToWrite,
             LPDWORD lpNumberOfBytesWritten,
           LPOVERLAPPED lpOverlapped
    );

__declspec(dllimport)
BOOL
__stdcall
ReadFile(
                HANDLE hFile,
           LPVOID lpBuffer,
                DWORD nNumberOfBytesToRead,
             LPDWORD lpNumberOfBytesRead,
           LPOVERLAPPED lpOverlapped
    );

__declspec(dllimport)
BOOL
__stdcall
FlushFileBuffers(
         HANDLE hFile
    );

__declspec(dllimport)
BOOL
__stdcall
DeviceIoControl(
                HANDLE hDevice,
                DWORD dwIoControlCode,
             LPVOID lpInBuffer,
                DWORD nInBufferSize,
             LPVOID lpOutBuffer,
                DWORD nOutBufferSize,
             LPDWORD lpBytesReturned,
           LPOVERLAPPED lpOverlapped
    );

__declspec(dllimport)
BOOL
__stdcall
RequestDeviceWakeup(
         HANDLE hDevice
    );

__declspec(dllimport)
BOOL
__stdcall
CancelDeviceWakeupRequest(
         HANDLE hDevice
    );

__declspec(dllimport)
BOOL
__stdcall
GetDevicePowerState(
          HANDLE hDevice,
         BOOL *pfOn
    );

__declspec(dllimport)
BOOL
__stdcall
SetMessageWaitingIndicator(
         HANDLE hMsgIndicator,
         ULONG ulMsgCount
    );

__declspec(dllimport)
BOOL
__stdcall
SetEndOfFile(
         HANDLE hFile
    );

__declspec(dllimport)
DWORD
__stdcall
SetFilePointer(
             HANDLE hFile,
             LONG lDistanceToMove,
           PLONG lpDistanceToMoveHigh,
             DWORD dwMoveMethod
    );

__declspec(dllimport)
BOOL
__stdcall
SetFilePointerEx(
              HANDLE hFile,
              LARGE_INTEGER liDistanceToMove,
           PLARGE_INTEGER lpNewFilePointer,
              DWORD dwMoveMethod
    );

__declspec(dllimport)
BOOL
__stdcall
FindClose(
         HANDLE hFindFile
    );

__declspec(dllimport)
BOOL
__stdcall
GetFileTime(
              HANDLE hFile,
           LPFILETIME lpCreationTime,
           LPFILETIME lpLastAccessTime,
           LPFILETIME lpLastWriteTime
    );

__declspec(dllimport)
BOOL
__stdcall
SetFileTime(
             HANDLE hFile,
           const FILETIME *lpCreationTime,
           const FILETIME *lpLastAccessTime,
           const FILETIME *lpLastWriteTime
    );

__declspec(dllimport)
BOOL
__stdcall
SetFileValidData(
         HANDLE hFile,
         LONGLONG ValidDataLength
    );

__declspec(dllimport)
BOOL
__stdcall
SetFileShortNameA(
         HANDLE hFile,
         LPCSTR lpShortName
    );
__declspec(dllimport)
BOOL
__stdcall
SetFileShortNameW(
         HANDLE hFile,
         LPCWSTR lpShortName
    );




#line 3709 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CloseHandle(
         HANDLE hObject
    );

__declspec(dllimport)
BOOL
__stdcall
DuplicateHandle(
                HANDLE hSourceProcessHandle,
                HANDLE hSourceHandle,
                HANDLE hTargetProcessHandle,
                  LPHANDLE lpTargetHandle,
                DWORD dwDesiredAccess,
                BOOL bInheritHandle,
                DWORD dwOptions
    );

__declspec(dllimport)
BOOL
__stdcall
GetHandleInformation(
          HANDLE hObject,
         LPDWORD lpdwFlags
    );

__declspec(dllimport)
BOOL
__stdcall
SetHandleInformation(
         HANDLE hObject,
         DWORD dwMask,
         DWORD dwFlags
    );






__declspec(dllimport)
DWORD
__stdcall
LoadModule(
         LPCSTR lpModuleName,
         LPVOID lpParameterBlock
    );

__declspec(dllimport)
UINT
__stdcall
WinExec(
         LPCSTR lpCmdLine,
         UINT uCmdShow
    );

__declspec(dllimport)
BOOL
__stdcall
ClearCommBreak(
         HANDLE hFile
    );

__declspec(dllimport)
BOOL
__stdcall
ClearCommError(
              HANDLE hFile,
           LPDWORD lpErrors,
           LPCOMSTAT lpStat
    );

__declspec(dllimport)
BOOL
__stdcall
SetupComm(
         HANDLE hFile,
         DWORD dwInQueue,
         DWORD dwOutQueue
    );

__declspec(dllimport)
BOOL
__stdcall
EscapeCommFunction(
         HANDLE hFile,
         DWORD dwFunc
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommConfig(
              HANDLE hCommDev,
           LPCOMMCONFIG lpCC,
           LPDWORD lpdwSize
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommMask(
          HANDLE hFile,
         LPDWORD lpEvtMask
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommProperties(
          HANDLE hFile,
         LPCOMMPROP lpCommProp
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommModemStatus(
          HANDLE hFile,
         LPDWORD lpModemStat
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommState(
          HANDLE hFile,
         LPDCB lpDCB
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommTimeouts(
          HANDLE hFile,
         LPCOMMTIMEOUTS lpCommTimeouts
    );

__declspec(dllimport)
BOOL
__stdcall
PurgeComm(
         HANDLE hFile,
         DWORD dwFlags
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommBreak(
         HANDLE hFile
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommConfig(
         HANDLE hCommDev,
           LPCOMMCONFIG lpCC,
         DWORD dwSize
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommMask(
         HANDLE hFile,
         DWORD dwEvtMask
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommState(
         HANDLE hFile,
         LPDCB lpDCB
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommTimeouts(
         HANDLE hFile,
         LPCOMMTIMEOUTS lpCommTimeouts
    );

__declspec(dllimport)
BOOL
__stdcall
TransmitCommChar(
         HANDLE hFile,
         char cChar
    );

__declspec(dllimport)
BOOL
__stdcall
WaitCommEvent(
                HANDLE hFile,
             LPDWORD lpEvtMask,
           LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
DWORD
__stdcall
SetTapePosition(
         HANDLE hDevice,
         DWORD dwPositionMethod,
         DWORD dwPartition,
         DWORD dwOffsetLow,
         DWORD dwOffsetHigh,
         BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapePosition(
          HANDLE hDevice,
          DWORD dwPositionType,
         LPDWORD lpdwPartition,
         LPDWORD lpdwOffsetLow,
         LPDWORD lpdwOffsetHigh
    );

__declspec(dllimport)
DWORD
__stdcall
PrepareTape(
         HANDLE hDevice,
         DWORD dwOperation,
         BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
EraseTape(
         HANDLE hDevice,
         DWORD dwEraseType,
         BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
CreateTapePartition(
         HANDLE hDevice,
         DWORD dwPartitionMethod,
         DWORD dwCount,
         DWORD dwSize
    );

__declspec(dllimport)
DWORD
__stdcall
WriteTapemark(
         HANDLE hDevice,
         DWORD dwTapemarkType,
         DWORD dwTapemarkCount,
         BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapeStatus(
         HANDLE hDevice
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapeParameters(
            HANDLE hDevice,
            DWORD dwOperation,
         LPDWORD lpdwSize,
         LPVOID lpTapeInformation
    );




__declspec(dllimport)
DWORD
__stdcall
SetTapeParameters(
         HANDLE hDevice,
         DWORD dwOperation,
         LPVOID lpTapeInformation
    );




__declspec(dllimport)
BOOL
__stdcall
Beep(
         DWORD dwFreq,
         DWORD dwDuration
    );

__declspec(dllimport)
int
__stdcall
MulDiv(
         int nNumber,
         int nNumerator,
         int nDenominator
    );

__declspec(dllimport)
void
__stdcall
GetSystemTime(
         LPSYSTEMTIME lpSystemTime
    );

__declspec(dllimport)
void
__stdcall
GetSystemTimeAsFileTime(
         LPFILETIME lpSystemTimeAsFileTime
    );

__declspec(dllimport)
BOOL
__stdcall
SetSystemTime(
         const SYSTEMTIME *lpSystemTime
    );

__declspec(dllimport)
void
__stdcall
GetLocalTime(
         LPSYSTEMTIME lpSystemTime
    );

__declspec(dllimport)
BOOL
__stdcall
SetLocalTime(
         const SYSTEMTIME *lpSystemTime
    );

__declspec(dllimport)
void
__stdcall
GetSystemInfo(
         LPSYSTEM_INFO lpSystemInfo
    );





















#line 4089 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"



















#line 4109 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"








#line 4118 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
IsProcessorFeaturePresent(
         DWORD ProcessorFeature
    );

typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;

__declspec(dllimport)
BOOL
__stdcall
SystemTimeToTzSpecificLocalTime(
           LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
             LPSYSTEMTIME lpUniversalTime,
            LPSYSTEMTIME lpLocalTime
    );

__declspec(dllimport)
BOOL
__stdcall
TzSpecificLocalTimeToSystemTime(
           LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
             LPSYSTEMTIME lpLocalTime,
            LPSYSTEMTIME lpUniversalTime
    );

__declspec(dllimport)
DWORD
__stdcall
GetTimeZoneInformation(
         LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    );

__declspec(dllimport)
BOOL
__stdcall
SetTimeZoneInformation(
         const TIME_ZONE_INFORMATION *lpTimeZoneInformation
    );






__declspec(dllimport)
BOOL
__stdcall
SystemTimeToFileTime(
          const SYSTEMTIME *lpSystemTime,
         LPFILETIME lpFileTime
    );

__declspec(dllimport)
BOOL
__stdcall
FileTimeToLocalFileTime(
          const FILETIME *lpFileTime,
         LPFILETIME lpLocalFileTime
    );

__declspec(dllimport)
BOOL
__stdcall
LocalFileTimeToFileTime(
          const FILETIME *lpLocalFileTime,
         LPFILETIME lpFileTime
    );

__declspec(dllimport)
BOOL
__stdcall
FileTimeToSystemTime(
          const FILETIME *lpFileTime,
         LPSYSTEMTIME lpSystemTime
    );

__declspec(dllimport)
LONG
__stdcall
CompareFileTime(
         const FILETIME *lpFileTime1,
         const FILETIME *lpFileTime2
    );

__declspec(dllimport)
BOOL
__stdcall
FileTimeToDosDateTime(
          const FILETIME *lpFileTime,
         LPWORD lpFatDate,
         LPWORD lpFatTime
    );

__declspec(dllimport)
BOOL
__stdcall
DosDateTimeToFileTime(
          WORD wFatDate,
          WORD wFatTime,
         LPFILETIME lpFileTime
    );

__declspec(dllimport)
DWORD
__stdcall
GetTickCount(
    void
    );

__declspec(dllimport)
BOOL
__stdcall
SetSystemTimeAdjustment(
         DWORD dwTimeAdjustment,
         BOOL  bTimeAdjustmentDisabled
    );

__declspec(dllimport)
BOOL
__stdcall
GetSystemTimeAdjustment(
         PDWORD lpTimeAdjustment,
         PDWORD lpTimeIncrement,
         PBOOL  lpTimeAdjustmentDisabled
    );


__declspec(dllimport)
DWORD
__stdcall
FormatMessageA(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );
__declspec(dllimport)
DWORD
__stdcall
FormatMessageW(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );




#line 4285 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
    




























#line 4315 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
#line 4316 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"










__declspec(dllimport)
BOOL
__stdcall
CreatePipe(
           PHANDLE hReadPipe,
           PHANDLE hWritePipe,
           LPSECURITY_ATTRIBUTES lpPipeAttributes,
             DWORD nSize
    );

__declspec(dllimport)
BOOL
__stdcall
ConnectNamedPipe(
                HANDLE hNamedPipe,
           LPOVERLAPPED lpOverlapped
    );

__declspec(dllimport)
BOOL
__stdcall
DisconnectNamedPipe(
         HANDLE hNamedPipe
    );

__declspec(dllimport)
BOOL
__stdcall
SetNamedPipeHandleState(
             HANDLE hNamedPipe,
           LPDWORD lpMode,
           LPDWORD lpMaxCollectionCount,
           LPDWORD lpCollectDataTimeout
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeInfo(
              HANDLE hNamedPipe,
           LPDWORD lpFlags,
           LPDWORD lpOutBufferSize,
           LPDWORD lpInBufferSize,
           LPDWORD lpMaxInstances
    );

__declspec(dllimport)
BOOL
__stdcall
PeekNamedPipe(
              HANDLE hNamedPipe,
             LPVOID lpBuffer,
              DWORD nBufferSize,
           LPDWORD lpBytesRead,
           LPDWORD lpTotalBytesAvail,
           LPDWORD lpBytesLeftThisMessage
    );

__declspec(dllimport)
BOOL
__stdcall
TransactNamedPipe(
                HANDLE hNamedPipe,
             LPVOID lpInBuffer,
                DWORD nInBufferSize,
             LPVOID lpOutBuffer,
                DWORD nOutBufferSize,
               LPDWORD lpBytesRead,
           LPOVERLAPPED lpOverlapped
    );

__declspec(dllimport)
    
HANDLE
__stdcall
CreateMailslotA(
             LPCSTR lpName,
             DWORD nMaxMessageSize,
             DWORD lReadTimeout,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
    
HANDLE
__stdcall
CreateMailslotW(
             LPCWSTR lpName,
             DWORD nMaxMessageSize,
             DWORD lReadTimeout,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 4422 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetMailslotInfo(
              HANDLE hMailslot,
           LPDWORD lpMaxMessageSize,
           LPDWORD lpNextSize,
           LPDWORD lpMessageCount,
           LPDWORD lpReadTimeout
    );

__declspec(dllimport)
BOOL
__stdcall
SetMailslotInfo(
         HANDLE hMailslot,
         DWORD lReadTimeout
    );

__declspec(dllimport)
    
LPVOID
__stdcall
MapViewOfFile(
         HANDLE hFileMappingObject,
         DWORD dwDesiredAccess,
         DWORD dwFileOffsetHigh,
         DWORD dwFileOffsetLow,
         SIZE_T dwNumberOfBytesToMap
    );

__declspec(dllimport)
BOOL
__stdcall
FlushViewOfFile(
         LPCVOID lpBaseAddress,
         SIZE_T dwNumberOfBytesToFlush
    );

__declspec(dllimport)
BOOL
__stdcall
UnmapViewOfFile(
         LPCVOID lpBaseAddress
    );





__declspec(dllimport)
BOOL
__stdcall
EncryptFileA(
         LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
EncryptFileW(
         LPCWSTR lpFileName
    );




#line 4490 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
DecryptFileA(
               LPCSTR lpFileName,
      DWORD dwReserved
    );
__declspec(dllimport)
BOOL
__stdcall
DecryptFileW(
               LPCWSTR lpFileName,
      DWORD dwReserved
    );




#line 4510 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
















__declspec(dllimport)
BOOL
__stdcall
FileEncryptionStatusA(
          LPCSTR lpFileName,
         LPDWORD  lpStatus
    );
__declspec(dllimport)
BOOL
__stdcall
FileEncryptionStatusW(
          LPCWSTR lpFileName,
         LPDWORD  lpStatus
    );




#line 4545 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"







typedef
DWORD
(__stdcall *PFE_EXPORT_FUNC)(
           PBYTE pbData,
           PVOID pvCallbackContext,
             ULONG ulLength
    );

typedef
DWORD
(__stdcall *PFE_IMPORT_FUNC)(
           PBYTE pbData,
           PVOID pvCallbackContext,
          PULONG ulLength
    );











__declspec(dllimport)
DWORD
__stdcall
OpenEncryptedFileRawA(
                LPCSTR lpFileName,
                ULONG    ulFlags,
                  PVOID   *pvContext
    );
__declspec(dllimport)
DWORD
__stdcall
OpenEncryptedFileRawW(
                LPCWSTR lpFileName,
                ULONG    ulFlags,
                  PVOID   *pvContext
    );




#line 4599 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
ReadEncryptedFileRaw(
             PFE_EXPORT_FUNC pfExportCallback,
           PVOID           pvCallbackContext,
             PVOID           pvContext
    );

__declspec(dllimport)
DWORD
__stdcall
WriteEncryptedFileRaw(
             PFE_IMPORT_FUNC pfImportCallback,
           PVOID           pvCallbackContext,
             PVOID           pvContext
    );

__declspec(dllimport)
void
__stdcall
CloseEncryptedFileRaw(
         PVOID           pvContext
    );





__declspec(dllimport)
int
__stdcall
lstrcmpA(
         LPCSTR lpString1,
         LPCSTR lpString2
    );
__declspec(dllimport)
int
__stdcall
lstrcmpW(
         LPCWSTR lpString1,
         LPCWSTR lpString2
    );




#line 4648 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
int
__stdcall
lstrcmpiA(
         LPCSTR lpString1,
         LPCSTR lpString2
    );
__declspec(dllimport)
int
__stdcall
lstrcmpiW(
         LPCWSTR lpString1,
         LPCWSTR lpString2
    );




#line 4668 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
LPSTR
__stdcall
lstrcpynA(
         LPSTR lpString1,
         LPCSTR lpString2,
         int iMaxLength
    );
__declspec(dllimport)
    
LPWSTR
__stdcall
lstrcpynW(
         LPWSTR lpString1,
         LPCWSTR lpString2,
         int iMaxLength
    );




#line 4692 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
LPSTR
__stdcall
lstrcpyA(
         LPSTR lpString1,
          LPCSTR lpString2
    );
__declspec(dllimport)
    
LPWSTR
__stdcall
lstrcpyW(
         LPWSTR lpString1,
          LPCWSTR lpString2
    );




#line 4714 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
LPSTR
__stdcall
lstrcatA(
         LPSTR lpString1,
            LPCSTR lpString2
    );
__declspec(dllimport)
    
LPWSTR
__stdcall
lstrcatW(
         LPWSTR lpString1,
            LPCWSTR lpString2
    );




#line 4736 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
int
__stdcall
lstrlenA(
         LPCSTR lpString
    );
__declspec(dllimport)
int
__stdcall
lstrlenW(
         LPCWSTR lpString
    );




#line 4754 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HFILE
__stdcall
OpenFile(
            LPCSTR lpFileName,
         LPOFSTRUCT lpReOpenBuff,
            UINT uStyle
    );

__declspec(dllimport)
    
HFILE
__stdcall
_lopen(
         LPCSTR lpPathName,
         int iReadWrite
    );

__declspec(dllimport)
    
HFILE
__stdcall
_lcreat(
         LPCSTR lpPathName,
         int  iAttribute
    );

__declspec(dllimport)
UINT
__stdcall
_lread(
         HFILE hFile,
           LPVOID lpBuffer,
         UINT uBytes
    );

__declspec(dllimport)
UINT
__stdcall
_lwrite(
         HFILE hFile,
           LPCCH lpBuffer,
         UINT uBytes
    );

__declspec(dllimport)
long
__stdcall
_hread(
         HFILE hFile,
           LPVOID lpBuffer,
         long lBytes
    );

__declspec(dllimport)
long
__stdcall
_hwrite(
         HFILE hFile,
           LPCCH lpBuffer,
         long lBytes
    );

__declspec(dllimport)
HFILE
__stdcall
_lclose(
         HFILE hFile
    );

__declspec(dllimport)
LONG
__stdcall
_llseek(
         HFILE hFile,
         LONG lOffset,
         int iOrigin
    );

__declspec(dllimport)
BOOL
__stdcall
IsTextUnicode(
           const void* lpv,
                int iSize,
           LPINT lpiResult
    );



__declspec(dllimport)
DWORD
__stdcall
FlsAlloc(
           PFLS_CALLBACK_FUNCTION lpCallback
    );

__declspec(dllimport)
PVOID
__stdcall
FlsGetValue(
         DWORD dwFlsIndex
    );

__declspec(dllimport)
BOOL
__stdcall
FlsSetValue(
             DWORD dwFlsIndex,
           PVOID lpFlsData
    );

__declspec(dllimport)
BOOL
__stdcall
FlsFree(
         DWORD dwFlsIndex
    );



__declspec(dllimport)
DWORD
__stdcall
TlsAlloc(
    void
    );

__declspec(dllimport)
LPVOID
__stdcall
TlsGetValue(
         DWORD dwTlsIndex
    );

__declspec(dllimport)
BOOL
__stdcall
TlsSetValue(
             DWORD dwTlsIndex,
           LPVOID lpTlsValue
    );

__declspec(dllimport)
BOOL
__stdcall
TlsFree(
         DWORD dwTlsIndex
    );

typedef
void
(__stdcall *LPOVERLAPPED_COMPLETION_ROUTINE)(
            DWORD dwErrorCode,
            DWORD dwNumberOfBytesTransfered,
         LPOVERLAPPED lpOverlapped
    );

__declspec(dllimport)
DWORD
__stdcall
SleepEx(
         DWORD dwMilliseconds,
         BOOL bAlertable
    );

__declspec(dllimport)
DWORD
__stdcall
WaitForSingleObjectEx(
         HANDLE hHandle,
         DWORD dwMilliseconds,
         BOOL bAlertable
    );

__declspec(dllimport)
DWORD
__stdcall
WaitForMultipleObjectsEx(
         DWORD nCount,
           const HANDLE *lpHandles,
         BOOL bWaitAll,
         DWORD dwMilliseconds,
         BOOL bAlertable
    );


__declspec(dllimport)
DWORD
__stdcall
SignalObjectAndWait(
         HANDLE hObjectToSignal,
         HANDLE hObjectToWaitOn,
         DWORD dwMilliseconds,
         BOOL bAlertable
    );
#line 4953 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ReadFileEx(
             HANDLE hFile,
         LPVOID lpBuffer,
             DWORD nNumberOfBytesToRead,
          LPOVERLAPPED lpOverlapped,
           LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

__declspec(dllimport)
BOOL
__stdcall
WriteFileEx(
             HANDLE hFile,
           LPCVOID lpBuffer,
             DWORD nNumberOfBytesToWrite,
          LPOVERLAPPED lpOverlapped,
           LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

__declspec(dllimport)
BOOL
__stdcall
BackupRead(
            HANDLE hFile,
           LPBYTE lpBuffer,
            DWORD nNumberOfBytesToRead,
           LPDWORD lpNumberOfBytesRead,
            BOOL bAbort,
            BOOL bProcessSecurity,
         LPVOID *lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
BackupSeek(
            HANDLE hFile,
            DWORD  dwLowBytesToSeek,
            DWORD  dwHighBytesToSeek,
           LPDWORD lpdwLowByteSeeked,
           LPDWORD lpdwHighByteSeeked,
         LPVOID *lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
BackupWrite(
            HANDLE hFile,
           LPBYTE lpBuffer,
            DWORD nNumberOfBytesToWrite,
           LPDWORD lpNumberOfBytesWritten,
            BOOL bAbort,
            BOOL bProcessSecurity,
         LPVOID *lpContext
    );




typedef struct _WIN32_STREAM_ID {
        DWORD          dwStreamId ;
        DWORD          dwStreamAttributes ;
        LARGE_INTEGER  Size ;
        DWORD          dwStreamNameSize ;
        WCHAR          cStreamName[ 1 ] ;
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID ;



























__declspec(dllimport)
BOOL
__stdcall
ReadFileScatter(
               HANDLE hFile,
               FILE_SEGMENT_ELEMENT aSegmentArray[],
               DWORD nNumberOfBytesToRead,
      LPDWORD lpReserved,
            LPOVERLAPPED lpOverlapped
    );

__declspec(dllimport)
BOOL
__stdcall
WriteFileGather(
               HANDLE hFile,
               FILE_SEGMENT_ELEMENT aSegmentArray[],
               DWORD nNumberOfBytesToWrite,
      LPDWORD lpReserved,
            LPOVERLAPPED lpOverlapped
    );


















#line 5091 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

typedef struct _STARTUPINFOA {
    DWORD   cb;
    LPSTR   lpReserved;
    LPSTR   lpDesktop;
    LPSTR   lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
    DWORD   cb;
    LPWSTR  lpReserved;
    LPWSTR  lpDesktop;
    LPWSTR  lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;

typedef STARTUPINFOW STARTUPINFO;
typedef LPSTARTUPINFOW LPSTARTUPINFO;



#line 5139 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"



typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR   cFileName[ 260 ];
    CHAR   cAlternateFileName[ 14 ];





} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    WCHAR  cFileName[ 260 ];
    WCHAR  cAlternateFileName[ 14 ];





} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;

typedef WIN32_FIND_DATAW WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAW PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAW LPWIN32_FIND_DATA;




#line 5185 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;

__declspec(dllimport)
    
HANDLE
__stdcall
CreateMutexA(
           LPSECURITY_ATTRIBUTES lpMutexAttributes,
             BOOL bInitialOwner,
           LPCSTR lpName
    );
__declspec(dllimport)
    
HANDLE
__stdcall
CreateMutexW(
           LPSECURITY_ATTRIBUTES lpMutexAttributes,
             BOOL bInitialOwner,
           LPCWSTR lpName
    );




#line 5218 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HANDLE
__stdcall
OpenMutexA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpName
    );
__declspec(dllimport)
    
HANDLE
__stdcall
OpenMutexW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpName
    );




#line 5242 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HANDLE
__stdcall
CreateEventA(
           LPSECURITY_ATTRIBUTES lpEventAttributes,
             BOOL bManualReset,
             BOOL bInitialState,
           LPCSTR lpName
    );
__declspec(dllimport)
    
HANDLE
__stdcall
CreateEventW(
           LPSECURITY_ATTRIBUTES lpEventAttributes,
             BOOL bManualReset,
             BOOL bInitialState,
           LPCWSTR lpName
    );




#line 5268 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HANDLE
__stdcall
OpenEventA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpName
    );
__declspec(dllimport)
    
HANDLE
__stdcall
OpenEventW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpName
    );




#line 5292 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HANDLE
__stdcall
CreateSemaphoreA(
           LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
             LONG lInitialCount,
             LONG lMaximumCount,
           LPCSTR lpName
    );
__declspec(dllimport)
    
HANDLE
__stdcall
CreateSemaphoreW(
           LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
             LONG lInitialCount,
             LONG lMaximumCount,
           LPCWSTR lpName
    );




#line 5318 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HANDLE
__stdcall
OpenSemaphoreA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpName
    );
__declspec(dllimport)
    
HANDLE
__stdcall
OpenSemaphoreW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpName
    );




#line 5342 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


typedef
void
(__stdcall *PTIMERAPCROUTINE)(
           LPVOID lpArgToCompletionRoutine,
             DWORD dwTimerLowValue,
             DWORD dwTimerHighValue
    );

__declspec(dllimport)
    
HANDLE
__stdcall
CreateWaitableTimerA(
           LPSECURITY_ATTRIBUTES lpTimerAttributes,
             BOOL bManualReset,
           LPCSTR lpTimerName
    );
__declspec(dllimport)
    
HANDLE
__stdcall
CreateWaitableTimerW(
           LPSECURITY_ATTRIBUTES lpTimerAttributes,
             BOOL bManualReset,
           LPCWSTR lpTimerName
    );




#line 5375 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HANDLE
__stdcall
OpenWaitableTimerA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpTimerName
    );
__declspec(dllimport)
    
HANDLE
__stdcall
OpenWaitableTimerW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpTimerName
    );




#line 5399 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetWaitableTimer(
             HANDLE hTimer,
             const LARGE_INTEGER *lpDueTime,
             LONG lPeriod,
           PTIMERAPCROUTINE pfnCompletionRoutine,
           LPVOID lpArgToCompletionRoutine,
             BOOL fResume
    );

__declspec(dllimport)
BOOL
__stdcall
CancelWaitableTimer(
         HANDLE hTimer
    );
#line 5419 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HANDLE
__stdcall
CreateFileMappingA(
             HANDLE hFile,
           LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
             DWORD flProtect,
             DWORD dwMaximumSizeHigh,
             DWORD dwMaximumSizeLow,
           LPCSTR lpName
    );
__declspec(dllimport)
    
HANDLE
__stdcall
CreateFileMappingW(
             HANDLE hFile,
           LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
             DWORD flProtect,
             DWORD dwMaximumSizeHigh,
             DWORD dwMaximumSizeLow,
           LPCWSTR lpName
    );




#line 5449 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HANDLE
__stdcall
OpenFileMappingA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpName
    );
__declspec(dllimport)
    
HANDLE
__stdcall
OpenFileMappingW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpName
    );




#line 5473 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetLogicalDriveStringsA(
         DWORD nBufferLength,
             LPSTR lpBuffer
    );
__declspec(dllimport)
DWORD
__stdcall
GetLogicalDriveStringsW(
         DWORD nBufferLength,
             LPWSTR lpBuffer
    );




#line 5493 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
























#line 5518 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
    
HMODULE
__stdcall
LoadLibraryA(
         LPCSTR lpLibFileName
    );
__declspec(dllimport)
    
HMODULE
__stdcall
LoadLibraryW(
         LPCWSTR lpLibFileName
    );




#line 5539 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HMODULE
__stdcall
LoadLibraryExA(
               LPCSTR lpLibFileName,
      HANDLE hFile,
               DWORD dwFlags
    );
__declspec(dllimport)
    
HMODULE
__stdcall
LoadLibraryExW(
               LPCWSTR lpLibFileName,
      HANDLE hFile,
               DWORD dwFlags
    );




#line 5563 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"







__declspec(dllimport)
DWORD
__stdcall
GetModuleFileNameA(
           HMODULE hModule,
           LPCH lpFilename,
             DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetModuleFileNameW(
           HMODULE hModule,
           LPWCH lpFilename,
             DWORD nSize
    );




#line 5591 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HMODULE
__stdcall
GetModuleHandleA(
           LPCSTR lpModuleName
    );
__declspec(dllimport)
    
HMODULE
__stdcall
GetModuleHandleW(
           LPCWSTR lpModuleName
    );




#line 5611 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"




















































#line 5664 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
#line 5665 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"





















#line 5687 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CreateProcessA(
              LPCSTR lpApplicationName,
           LPSTR lpCommandLine,
              LPSECURITY_ATTRIBUTES lpProcessAttributes,
              LPSECURITY_ATTRIBUTES lpThreadAttributes,
                BOOL bInheritHandles,
                DWORD dwCreationFlags,
              LPVOID lpEnvironment,
              LPCSTR lpCurrentDirectory,
                LPSTARTUPINFOA lpStartupInfo,
               LPPROCESS_INFORMATION lpProcessInformation
    );
__declspec(dllimport)
BOOL
__stdcall
CreateProcessW(
              LPCWSTR lpApplicationName,
           LPWSTR lpCommandLine,
              LPSECURITY_ATTRIBUTES lpProcessAttributes,
              LPSECURITY_ATTRIBUTES lpThreadAttributes,
                BOOL bInheritHandles,
                DWORD dwCreationFlags,
              LPVOID lpEnvironment,
              LPCWSTR lpCurrentDirectory,
                LPSTARTUPINFOW lpStartupInfo,
               LPPROCESS_INFORMATION lpProcessInformation
    );




#line 5723 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
SetProcessShutdownParameters(
         DWORD dwLevel,
         DWORD dwFlags
    );

__declspec(dllimport)
BOOL
__stdcall
GetProcessShutdownParameters(
         LPDWORD lpdwLevel,
         LPDWORD lpdwFlags
    );

__declspec(dllimport)
DWORD
__stdcall
GetProcessVersion(
         DWORD ProcessId
    );

__declspec(dllimport)
void
__stdcall
FatalAppExitA(
         UINT uAction,
         LPCSTR lpMessageText
    );
__declspec(dllimport)
void
__stdcall
FatalAppExitW(
         UINT uAction,
         LPCWSTR lpMessageText
    );




#line 5768 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
void
__stdcall
GetStartupInfoA(
         LPSTARTUPINFOA lpStartupInfo
    );
__declspec(dllimport)
void
__stdcall
GetStartupInfoW(
         LPSTARTUPINFOW lpStartupInfo
    );




#line 5786 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
LPSTR
__stdcall
GetCommandLineA(
    void
    );
__declspec(dllimport)
    
LPWSTR
__stdcall
GetCommandLineW(
    void
    );




#line 5806 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetEnvironmentVariableA(
         LPCSTR lpName,
             LPSTR lpBuffer,
         DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetEnvironmentVariableW(
         LPCWSTR lpName,
             LPWSTR lpBuffer,
         DWORD nSize
    );




#line 5828 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentVariableA(
             LPCSTR lpName,
           LPCSTR lpValue
    );
__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentVariableW(
             LPCWSTR lpName,
           LPCWSTR lpValue
    );




#line 5848 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
    


















#line 5868 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
ExpandEnvironmentStringsA(
         LPCSTR lpSrc,
             LPSTR lpDst,
         DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
ExpandEnvironmentStringsW(
         LPCWSTR lpSrc,
             LPWSTR lpDst,
         DWORD nSize
    );




#line 5890 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableA(
         LPCSTR lpName,
         LPCSTR lpGuid,
             PVOID pBuffer,
         DWORD    nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableW(
         LPCWSTR lpName,
         LPCWSTR lpGuid,
             PVOID pBuffer,
         DWORD    nSize
    );




#line 5914 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableA(
         LPCSTR lpName,
         LPCSTR lpGuid,
             PVOID pValue,
         DWORD    nSize
    );
__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableW(
         LPCWSTR lpName,
         LPCWSTR lpGuid,
             PVOID pValue,
         DWORD    nSize
    );




#line 5938 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
void
__stdcall
OutputDebugStringA(
         LPCSTR lpOutputString
    );
__declspec(dllimport)
void
__stdcall
OutputDebugStringW(
         LPCWSTR lpOutputString
    );




#line 5957 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HRSRC
__stdcall
FindResourceA(
           HMODULE hModule,
             LPCSTR lpName,
             LPCSTR lpType
    );
__declspec(dllimport)
    
HRSRC
__stdcall
FindResourceW(
           HMODULE hModule,
             LPCWSTR lpName,
             LPCWSTR lpType
    );




#line 5981 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HRSRC
__stdcall
FindResourceExA(
           HMODULE hModule,
             LPCSTR lpType,
             LPCSTR lpName,
             WORD    wLanguage
    );
__declspec(dllimport)
    
HRSRC
__stdcall
FindResourceExW(
           HMODULE hModule,
             LPCWSTR lpType,
             LPCWSTR lpName,
             WORD    wLanguage
    );




#line 6007 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


typedef BOOL (__stdcall* ENUMRESTYPEPROCA)(       HMODULE hModule,      LPSTR lpType,
     LONG_PTR lParam);
typedef BOOL (__stdcall* ENUMRESTYPEPROCW)(       HMODULE hModule,      LPWSTR lpType,
     LONG_PTR lParam);




#line 6018 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
typedef BOOL (__stdcall* ENUMRESNAMEPROCA)(       HMODULE hModule,      LPCSTR lpType,
     LPSTR lpName,      LONG_PTR lParam);
typedef BOOL (__stdcall* ENUMRESNAMEPROCW)(       HMODULE hModule,      LPCWSTR lpType,
     LPWSTR lpName,      LONG_PTR lParam);




#line 6027 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
typedef BOOL (__stdcall* ENUMRESLANGPROCA)(       HMODULE hModule,      LPCSTR lpType,
     LPCSTR lpName,      WORD  wLanguage,      LONG_PTR lParam);
typedef BOOL (__stdcall* ENUMRESLANGPROCW)(       HMODULE hModule,      LPCWSTR lpType,
     LPCWSTR lpName,      WORD  wLanguage,      LONG_PTR lParam);




#line 6036 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"






















#line 6059 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesA(
           HMODULE hModule,
             ENUMRESTYPEPROCA lpEnumFunc,
             LONG_PTR lParam
    );
__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesW(
           HMODULE hModule,
             ENUMRESTYPEPROCW lpEnumFunc,
             LONG_PTR lParam
    );




#line 6081 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesA(
           HMODULE hModule,
             LPCSTR lpType,
             ENUMRESNAMEPROCA lpEnumFunc,
             LONG_PTR lParam
    );
__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesW(
           HMODULE hModule,
             LPCWSTR lpType,
             ENUMRESNAMEPROCW lpEnumFunc,
             LONG_PTR lParam
    );




#line 6105 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesA(
           HMODULE hModule,
             LPCSTR lpType,
             LPCSTR lpName,
             ENUMRESLANGPROCA lpEnumFunc,
             LONG_PTR lParam
    );
__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesW(
           HMODULE hModule,
             LPCWSTR lpType,
             LPCWSTR lpName,
             ENUMRESLANGPROCW lpEnumFunc,
             LONG_PTR lParam
    );




#line 6131 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HANDLE
__stdcall
BeginUpdateResourceA(
         LPCSTR pFileName,
         BOOL bDeleteExistingResources
    );
__declspec(dllimport)
    
HANDLE
__stdcall
BeginUpdateResourceW(
         LPCWSTR pFileName,
         BOOL bDeleteExistingResources
    );




#line 6153 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
UpdateResourceA(
         HANDLE hUpdate,
         LPCSTR lpType,
         LPCSTR lpName,
         WORD wLanguage,
             LPVOID lpData,
         DWORD cb
    );
__declspec(dllimport)
BOOL
__stdcall
UpdateResourceW(
         HANDLE hUpdate,
         LPCWSTR lpType,
         LPCWSTR lpName,
         WORD wLanguage,
             LPVOID lpData,
         DWORD cb
    );




#line 6181 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EndUpdateResourceA(
         HANDLE hUpdate,
         BOOL   fDiscard
    );
__declspec(dllimport)
BOOL
__stdcall
EndUpdateResourceW(
         HANDLE hUpdate,
         BOOL   fDiscard
    );




#line 6201 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
ATOM
__stdcall
GlobalAddAtomA(
           LPCSTR lpString
    );
__declspec(dllimport)
    
ATOM
__stdcall
GlobalAddAtomW(
           LPCWSTR lpString
    );




#line 6221 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
ATOM
__stdcall
GlobalFindAtomA(
           LPCSTR lpString
    );
__declspec(dllimport)
    
ATOM
__stdcall
GlobalFindAtomW(
           LPCWSTR lpString
    );




#line 6241 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GlobalGetAtomNameA(
         ATOM nAtom,
           LPSTR lpBuffer,
         int nSize
    );
__declspec(dllimport)
UINT
__stdcall
GlobalGetAtomNameW(
         ATOM nAtom,
           LPWSTR lpBuffer,
         int nSize
    );




#line 6263 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
ATOM
__stdcall
AddAtomA(
           LPCSTR lpString
    );
__declspec(dllimport)
    
ATOM
__stdcall
AddAtomW(
           LPCWSTR lpString
    );




#line 6283 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
ATOM
__stdcall
FindAtomA(
           LPCSTR lpString
    );
__declspec(dllimport)
    
ATOM
__stdcall
FindAtomW(
           LPCWSTR lpString
    );




#line 6303 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GetAtomNameA(
         ATOM nAtom,
           LPSTR lpBuffer,
         int nSize
    );
__declspec(dllimport)
UINT
__stdcall
GetAtomNameW(
         ATOM nAtom,
           LPWSTR lpBuffer,
         int nSize
    );




#line 6325 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GetProfileIntA(
         LPCSTR lpAppName,
         LPCSTR lpKeyName,
         INT nDefault
    );
__declspec(dllimport)
UINT
__stdcall
GetProfileIntW(
         LPCWSTR lpAppName,
         LPCWSTR lpKeyName,
         INT nDefault
    );




#line 6347 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetProfileStringA(
           LPCSTR lpAppName,
           LPCSTR lpKeyName,
           LPCSTR lpDefault,
             LPSTR lpReturnedString,
             DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetProfileStringW(
           LPCWSTR lpAppName,
           LPCWSTR lpKeyName,
           LPCWSTR lpDefault,
             LPWSTR lpReturnedString,
             DWORD nSize
    );




#line 6373 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WriteProfileStringA(
           LPCSTR lpAppName,
           LPCSTR lpKeyName,
           LPCSTR lpString
    );
__declspec(dllimport)
BOOL
__stdcall
WriteProfileStringW(
           LPCWSTR lpAppName,
           LPCWSTR lpKeyName,
           LPCWSTR lpString
    );




#line 6395 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetProfileSectionA(
         LPCSTR lpAppName,
             LPSTR lpReturnedString,
         DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetProfileSectionW(
         LPCWSTR lpAppName,
             LPWSTR lpReturnedString,
         DWORD nSize
    );




#line 6417 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WriteProfileSectionA(
         LPCSTR lpAppName,
         LPCSTR lpString
    );
__declspec(dllimport)
BOOL
__stdcall
WriteProfileSectionW(
         LPCWSTR lpAppName,
         LPCWSTR lpString
    );




#line 6437 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GetPrivateProfileIntA(
             LPCSTR lpAppName,
             LPCSTR lpKeyName,
             INT nDefault,
           LPCSTR lpFileName
    );
__declspec(dllimport)
UINT
__stdcall
GetPrivateProfileIntW(
             LPCWSTR lpAppName,
             LPCWSTR lpKeyName,
             INT nDefault,
           LPCWSTR lpFileName
    );




#line 6461 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileStringA(
           LPCSTR lpAppName,
           LPCSTR lpKeyName,
           LPCSTR lpDefault,
             LPSTR lpReturnedString,
             DWORD nSize,
           LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileStringW(
           LPCWSTR lpAppName,
           LPCWSTR lpKeyName,
           LPCWSTR lpDefault,
             LPWSTR lpReturnedString,
             DWORD nSize,
           LPCWSTR lpFileName
    );




#line 6489 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStringA(
           LPCSTR lpAppName,
           LPCSTR lpKeyName,
           LPCSTR lpString,
           LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStringW(
           LPCWSTR lpAppName,
           LPCWSTR lpKeyName,
           LPCWSTR lpString,
           LPCWSTR lpFileName
    );




#line 6513 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionA(
             LPCSTR lpAppName,
             LPSTR lpReturnedString,
             DWORD nSize,
           LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionW(
             LPCWSTR lpAppName,
             LPWSTR lpReturnedString,
             DWORD nSize,
           LPCWSTR lpFileName
    );




#line 6537 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileSectionA(
             LPCSTR lpAppName,
             LPCSTR lpString,
           LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileSectionW(
             LPCWSTR lpAppName,
             LPCWSTR lpString,
           LPCWSTR lpFileName
    );




#line 6559 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionNamesA(
             LPSTR lpszReturnBuffer,
             DWORD nSize,
           LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionNamesW(
             LPWSTR lpszReturnBuffer,
             DWORD nSize,
           LPCWSTR lpFileName
    );




#line 6582 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetPrivateProfileStructA(
             LPCSTR lpszSection,
             LPCSTR lpszKey,
           LPVOID   lpStruct,
             UINT     uSizeStruct,
           LPCSTR szFile
    );
__declspec(dllimport)
BOOL
__stdcall
GetPrivateProfileStructW(
             LPCWSTR lpszSection,
             LPCWSTR lpszKey,
           LPVOID   lpStruct,
             UINT     uSizeStruct,
           LPCWSTR szFile
    );




#line 6608 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStructA(
             LPCSTR lpszSection,
             LPCSTR lpszKey,
             LPVOID lpStruct,
             UINT     uSizeStruct,
           LPCSTR szFile
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStructW(
             LPCWSTR lpszSection,
             LPCWSTR lpszKey,
             LPVOID lpStruct,
             UINT     uSizeStruct,
           LPCWSTR szFile
    );




#line 6634 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
UINT
__stdcall
GetDriveTypeA(
           LPCSTR lpRootPathName
    );
__declspec(dllimport)
UINT
__stdcall
GetDriveTypeW(
           LPCWSTR lpRootPathName
    );




#line 6653 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GetSystemDirectoryA(
             LPSTR lpBuffer,
         UINT uSize
    );
__declspec(dllimport)
UINT
__stdcall
GetSystemDirectoryW(
             LPWSTR lpBuffer,
         UINT uSize
    );




#line 6673 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetTempPathA(
         DWORD nBufferLength,
           LPSTR lpBuffer
    );
__declspec(dllimport)
DWORD
__stdcall
GetTempPathW(
         DWORD nBufferLength,
           LPWSTR lpBuffer
    );




#line 6693 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GetTempFileNameA(
         LPCSTR lpPathName,
         LPCSTR lpPrefixString,
         UINT uUnique,
         LPSTR lpTempFileName
    );
__declspec(dllimport)
UINT
__stdcall
GetTempFileNameW(
         LPCWSTR lpPathName,
         LPCWSTR lpPrefixString,
         UINT uUnique,
         LPWSTR lpTempFileName
    );




#line 6717 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
    






















#line 6741 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GetWindowsDirectoryA(
             LPSTR lpBuffer,
         UINT uSize
    );
__declspec(dllimport)
UINT
__stdcall
GetWindowsDirectoryW(
             LPWSTR lpBuffer,
         UINT uSize
    );




#line 6761 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GetSystemWindowsDirectoryA(
             LPSTR lpBuffer,
         UINT uSize
    );
__declspec(dllimport)
UINT
__stdcall
GetSystemWindowsDirectoryW(
             LPWSTR lpBuffer,
         UINT uSize
    );




#line 6781 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"










































































#line 6856 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
#line 6857 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetCurrentDirectoryA(
         LPCSTR lpPathName
    );
__declspec(dllimport)
BOOL
__stdcall
SetCurrentDirectoryW(
         LPCWSTR lpPathName
    );




#line 6875 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
    
















#line 6893 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetCurrentDirectoryA(
         DWORD nBufferLength,
             LPSTR lpBuffer
    );
__declspec(dllimport)
DWORD
__stdcall
GetCurrentDirectoryW(
         DWORD nBufferLength,
             LPWSTR lpBuffer
    );




#line 6913 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"









































#line 6955 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceA(
            LPCSTR lpRootPathName,
           LPDWORD lpSectorsPerCluster,
           LPDWORD lpBytesPerSector,
           LPDWORD lpNumberOfFreeClusters,
           LPDWORD lpTotalNumberOfClusters
    );
__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceW(
            LPCWSTR lpRootPathName,
           LPDWORD lpSectorsPerCluster,
           LPDWORD lpBytesPerSector,
           LPDWORD lpNumberOfFreeClusters,
           LPDWORD lpTotalNumberOfClusters
    );




#line 6981 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceExA(
            LPCSTR lpDirectoryName,
           PULARGE_INTEGER lpFreeBytesAvailableToCaller,
           PULARGE_INTEGER lpTotalNumberOfBytes,
           PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );
__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceExW(
            LPCWSTR lpDirectoryName,
           PULARGE_INTEGER lpFreeBytesAvailableToCaller,
           PULARGE_INTEGER lpTotalNumberOfBytes,
           PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );




#line 7005 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryA(
             LPCSTR lpPathName,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryW(
             LPCWSTR lpPathName,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 7025 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"



















#line 7045 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryExA(
             LPCSTR lpTemplateDirectory,
             LPCSTR lpNewDirectory,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryExW(
             LPCWSTR lpTemplateDirectory,
             LPCWSTR lpNewDirectory,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 7067 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryA(
         LPCSTR lpPathName
    );
__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryW(
         LPCWSTR lpPathName
    );




#line 7085 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetFullPathNameA(
                    LPCSTR lpFileName,
                    DWORD nBufferLength,
             LPSTR lpBuffer,
                    LPSTR *lpFilePart
    );
__declspec(dllimport)
DWORD
__stdcall
GetFullPathNameW(
                    LPCWSTR lpFileName,
                    DWORD nBufferLength,
             LPWSTR lpBuffer,
                    LPWSTR *lpFilePart
    );




#line 7109 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"







__declspec(dllimport)
BOOL
__stdcall
DefineDosDeviceA(
             DWORD dwFlags,
             LPCSTR lpDeviceName,
           LPCSTR lpTargetPath
    );
__declspec(dllimport)
BOOL
__stdcall
DefineDosDeviceW(
             DWORD dwFlags,
             LPCWSTR lpDeviceName,
           LPCWSTR lpTargetPath
    );




#line 7137 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
QueryDosDeviceA(
           LPCSTR lpDeviceName,
             LPSTR lpTargetPath,
             DWORD ucchMax
    );
__declspec(dllimport)
DWORD
__stdcall
QueryDosDeviceW(
           LPCWSTR lpDeviceName,
             LPWSTR lpTargetPath,
             DWORD ucchMax
    );




#line 7159 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"



__declspec(dllimport)
    
HANDLE
__stdcall
CreateFileA(
             LPCSTR lpFileName,
             DWORD dwDesiredAccess,
             DWORD dwShareMode,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes,
             DWORD dwCreationDisposition,
             DWORD dwFlagsAndAttributes,
           HANDLE hTemplateFile
    );
__declspec(dllimport)
    
HANDLE
__stdcall
CreateFileW(
             LPCWSTR lpFileName,
             DWORD dwDesiredAccess,
             DWORD dwShareMode,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes,
             DWORD dwCreationDisposition,
             DWORD dwFlagsAndAttributes,
           HANDLE hTemplateFile
    );




#line 7193 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"














#line 7208 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesA(
         LPCSTR lpFileName,
         DWORD dwFileAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesW(
         LPCWSTR lpFileName,
         DWORD dwFileAttributes
    );




#line 7228 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetFileAttributesA(
         LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetFileAttributesW(
         LPCWSTR lpFileName
    );




#line 7246 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

typedef enum _GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel
} GET_FILEEX_INFO_LEVELS;

__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesExA(
          LPCSTR lpFileName,
          GET_FILEEX_INFO_LEVELS fInfoLevelId,
         LPVOID lpFileInformation
    );
__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesExW(
          LPCWSTR lpFileName,
          GET_FILEEX_INFO_LEVELS fInfoLevelId,
         LPVOID lpFileInformation
    );




#line 7273 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeA(
          LPCSTR lpFileName,
         LPDWORD  lpFileSizeHigh
    );
__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeW(
          LPCWSTR lpFileName,
         LPDWORD  lpFileSizeHigh
    );




#line 7293 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
DeleteFileA(
         LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
DeleteFileW(
         LPCWSTR lpFileName
    );




#line 7311 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

















#line 7329 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"






























#line 7360 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


typedef enum _FINDEX_INFO_LEVELS {
    FindExInfoStandard,
    FindExInfoMaxInfoLevel
} FINDEX_INFO_LEVELS;

typedef enum _FINDEX_SEARCH_OPS {
    FindExSearchNameMatch,
    FindExSearchLimitToDirectories,
    FindExSearchLimitToDevices,
    FindExSearchMaxSearchOp
} FINDEX_SEARCH_OPS;



__declspec(dllimport)
    
HANDLE
__stdcall
FindFirstFileExA(
               LPCSTR lpFileName,
               FINDEX_INFO_LEVELS fInfoLevelId,
              LPVOID lpFindFileData,
               FINDEX_SEARCH_OPS fSearchOp,
      LPVOID lpSearchFilter,
               DWORD dwAdditionalFlags
    );
__declspec(dllimport)
    
HANDLE
__stdcall
FindFirstFileExW(
               LPCWSTR lpFileName,
               FINDEX_INFO_LEVELS fInfoLevelId,
              LPVOID lpFindFileData,
               FINDEX_SEARCH_OPS fSearchOp,
      LPVOID lpSearchFilter,
               DWORD dwAdditionalFlags
    );




#line 7405 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
#line 7406 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HANDLE
__stdcall
FindFirstFileA(
          LPCSTR lpFileName,
         LPWIN32_FIND_DATAA lpFindFileData
    );
__declspec(dllimport)
    
HANDLE
__stdcall
FindFirstFileW(
          LPCWSTR lpFileName,
         LPWIN32_FIND_DATAW lpFindFileData
    );




#line 7428 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindNextFileA(
          HANDLE hFindFile,
         LPWIN32_FIND_DATAA lpFindFileData
    );
__declspec(dllimport)
BOOL
__stdcall
FindNextFileW(
          HANDLE hFindFile,
         LPWIN32_FIND_DATAW lpFindFileData
    );




#line 7448 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
DWORD
__stdcall
SearchPathA(
            LPCSTR lpPath,
              LPCSTR lpFileName,
            LPCSTR lpExtension,
              DWORD nBufferLength,
             LPSTR lpBuffer,
           LPSTR *lpFilePart
    );
__declspec(dllimport)
DWORD
__stdcall
SearchPathW(
            LPCWSTR lpPath,
              LPCWSTR lpFileName,
            LPCWSTR lpExtension,
              DWORD nBufferLength,
             LPWSTR lpBuffer,
           LPWSTR *lpFilePart
    );




#line 7477 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CopyFileA(
         LPCSTR lpExistingFileName,
         LPCSTR lpNewFileName,
         BOOL bFailIfExists
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileW(
         LPCWSTR lpExistingFileName,
         LPCWSTR lpNewFileName,
         BOOL bFailIfExists
    );




#line 7499 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
    




















#line 7521 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


typedef
DWORD
(__stdcall *LPPROGRESS_ROUTINE)(
             LARGE_INTEGER TotalFileSize,
             LARGE_INTEGER TotalBytesTransferred,
             LARGE_INTEGER StreamSize,
             LARGE_INTEGER StreamBytesTransferred,
             DWORD dwStreamNumber,
             DWORD dwCallbackReason,
             HANDLE hSourceFile,
             HANDLE hDestinationFile,
           LPVOID lpData
    );

__declspec(dllimport)
BOOL
__stdcall
CopyFileExA(
             LPCSTR lpExistingFileName,
             LPCSTR lpNewFileName,
           LPPROGRESS_ROUTINE lpProgressRoutine,
           LPVOID lpData,
           LPBOOL pbCancel,
             DWORD dwCopyFlags
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileExW(
             LPCWSTR lpExistingFileName,
             LPCWSTR lpNewFileName,
           LPPROGRESS_ROUTINE lpProgressRoutine,
           LPVOID lpData,
           LPBOOL pbCancel,
             DWORD dwCopyFlags
    );




#line 7564 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
#line 7565 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
MoveFileA(
         LPCSTR lpExistingFileName,
         LPCSTR lpNewFileName
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileW(
         LPCWSTR lpExistingFileName,
         LPCWSTR lpNewFileName
    );




#line 7585 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"



















#line 7605 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
MoveFileExA(
         LPCSTR lpExistingFileName,
         LPCSTR lpNewFileName,
         DWORD dwFlags
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileExW(
         LPCWSTR lpExistingFileName,
         LPCWSTR lpNewFileName,
         DWORD dwFlags
    );




#line 7627 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
MoveFileWithProgressA(
             LPCSTR lpExistingFileName,
             LPCSTR lpNewFileName,
           LPPROGRESS_ROUTINE lpProgressRoutine,
           LPVOID lpData,
             DWORD dwFlags
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileWithProgressW(
             LPCWSTR lpExistingFileName,
             LPCWSTR lpNewFileName,
           LPPROGRESS_ROUTINE lpProgressRoutine,
           LPVOID lpData,
             DWORD dwFlags
    );




#line 7654 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
#line 7655 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"








#line 7664 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"




__declspec(dllimport)
BOOL
__stdcall
ReplaceFileA(
               LPCSTR  lpReplacedFileName,
               LPCSTR  lpReplacementFileName,
             LPCSTR  lpBackupFileName,
               DWORD   dwReplaceFlags,
      LPVOID  lpExclude,
      LPVOID  lpReserved
    );
__declspec(dllimport)
BOOL
__stdcall
ReplaceFileW(
               LPCWSTR lpReplacedFileName,
               LPCWSTR lpReplacementFileName,
             LPCWSTR lpBackupFileName,
               DWORD   dwReplaceFlags,
      LPVOID  lpExclude,
      LPVOID  lpReserved
    );




#line 7695 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
#line 7696 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"







__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkA(
               LPCSTR lpFileName,
               LPCSTR lpExistingFileName,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkW(
               LPCWSTR lpFileName,
               LPCWSTR lpExistingFileName,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 7724 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

#line 7726 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"







































#line 7766 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"



__declspec(dllimport)
    
HANDLE
__stdcall
CreateNamedPipeA(
             LPCSTR lpName,
             DWORD dwOpenMode,
             DWORD dwPipeMode,
             DWORD nMaxInstances,
             DWORD nOutBufferSize,
             DWORD nInBufferSize,
             DWORD nDefaultTimeOut,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
    
HANDLE
__stdcall
CreateNamedPipeW(
             LPCWSTR lpName,
             DWORD dwOpenMode,
             DWORD dwPipeMode,
             DWORD nMaxInstances,
             DWORD nOutBufferSize,
             DWORD nInBufferSize,
             DWORD nDefaultTimeOut,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 7802 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeHandleStateA(
              HANDLE hNamedPipe,
           LPDWORD lpState,
           LPDWORD lpCurInstances,
           LPDWORD lpMaxCollectionCount,
           LPDWORD lpCollectDataTimeout,
           LPSTR lpUserName,
              DWORD nMaxUserNameSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeHandleStateW(
              HANDLE hNamedPipe,
           LPDWORD lpState,
           LPDWORD lpCurInstances,
           LPDWORD lpMaxCollectionCount,
           LPDWORD lpCollectDataTimeout,
           LPWSTR lpUserName,
              DWORD nMaxUserNameSize
    );




#line 7832 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CallNamedPipeA(
          LPCSTR lpNamedPipeName,
             LPVOID lpInBuffer,
          DWORD nInBufferSize,
             LPVOID lpOutBuffer,
          DWORD nOutBufferSize,
         LPDWORD lpBytesRead,
          DWORD nTimeOut
    );
__declspec(dllimport)
BOOL
__stdcall
CallNamedPipeW(
          LPCWSTR lpNamedPipeName,
             LPVOID lpInBuffer,
          DWORD nInBufferSize,
             LPVOID lpOutBuffer,
          DWORD nOutBufferSize,
         LPDWORD lpBytesRead,
          DWORD nTimeOut
    );




#line 7862 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WaitNamedPipeA(
         LPCSTR lpNamedPipeName,
         DWORD nTimeOut
    );
__declspec(dllimport)
BOOL
__stdcall
WaitNamedPipeW(
         LPCWSTR lpNamedPipeName,
         DWORD nTimeOut
    );




#line 7882 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetVolumeLabelA(
           LPCSTR lpRootPathName,
           LPCSTR lpVolumeName
    );
__declspec(dllimport)
BOOL
__stdcall
SetVolumeLabelW(
           LPCWSTR lpRootPathName,
           LPCWSTR lpVolumeName
    );




#line 7902 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
void
__stdcall
SetFileApisToOEM( void );

__declspec(dllimport)
void
__stdcall
SetFileApisToANSI( void );

__declspec(dllimport)
BOOL
__stdcall
AreFileApisANSI( void );

__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationA(
            LPCSTR lpRootPathName,
           LPSTR lpVolumeNameBuffer,
              DWORD nVolumeNameSize,
           LPDWORD lpVolumeSerialNumber,
           LPDWORD lpMaximumComponentLength,
           LPDWORD lpFileSystemFlags,
           LPSTR lpFileSystemNameBuffer,
              DWORD nFileSystemNameSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationW(
            LPCWSTR lpRootPathName,
           LPWSTR lpVolumeNameBuffer,
              DWORD nVolumeNameSize,
           LPDWORD lpVolumeSerialNumber,
           LPDWORD lpMaximumComponentLength,
           LPDWORD lpFileSystemFlags,
           LPWSTR lpFileSystemNameBuffer,
              DWORD nFileSystemNameSize
    );




#line 7949 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CancelIo(
         HANDLE hFile
    );





__declspec(dllimport)
BOOL
__stdcall
ClearEventLogA (
             HANDLE hEventLog,
           LPCSTR lpBackupFileName
    );
__declspec(dllimport)
BOOL
__stdcall
ClearEventLogW (
             HANDLE hEventLog,
           LPCWSTR lpBackupFileName
    );




#line 7980 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
BackupEventLogA (
         HANDLE hEventLog,
         LPCSTR lpBackupFileName
    );
__declspec(dllimport)
BOOL
__stdcall
BackupEventLogW (
         HANDLE hEventLog,
         LPCWSTR lpBackupFileName
    );




#line 8000 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CloseEventLog (
         HANDLE hEventLog
    );

__declspec(dllimport)
BOOL
__stdcall
DeregisterEventSource (
         HANDLE hEventLog
    );

__declspec(dllimport)
BOOL
__stdcall
NotifyChangeEventLog(
         HANDLE  hEventLog,
         HANDLE  hEvent
    );

__declspec(dllimport)
BOOL
__stdcall
GetNumberOfEventLogRecords (
          HANDLE hEventLog,
         PDWORD NumberOfRecords
    );

__declspec(dllimport)
BOOL
__stdcall
GetOldestEventLogRecord (
          HANDLE hEventLog,
         PDWORD OldestRecord
    );

__declspec(dllimport)
    
HANDLE
__stdcall
OpenEventLogA (
           LPCSTR lpUNCServerName,
             LPCSTR lpSourceName
    );
__declspec(dllimport)
    
HANDLE
__stdcall
OpenEventLogW (
           LPCWSTR lpUNCServerName,
             LPCWSTR lpSourceName
    );




#line 8060 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HANDLE
__stdcall
RegisterEventSourceA (
           LPCSTR lpUNCServerName,
             LPCSTR lpSourceName
    );
__declspec(dllimport)
    
HANDLE
__stdcall
RegisterEventSourceW (
           LPCWSTR lpUNCServerName,
             LPCWSTR lpSourceName
    );




#line 8082 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HANDLE
__stdcall
OpenBackupEventLogA (
           LPCSTR lpUNCServerName,
             LPCSTR lpFileName
    );
__declspec(dllimport)
    
HANDLE
__stdcall
OpenBackupEventLogW (
           LPCWSTR lpUNCServerName,
             LPCWSTR lpFileName
    );




#line 8104 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ReadEventLogA (
          HANDLE     hEventLog,
          DWORD      dwReadFlags,
          DWORD      dwRecordOffset,
           LPVOID     lpBuffer,
          DWORD      nNumberOfBytesToRead,
         DWORD      *pnBytesRead,
         DWORD      *pnMinNumberOfBytesNeeded
    );
__declspec(dllimport)
BOOL
__stdcall
ReadEventLogW (
          HANDLE     hEventLog,
          DWORD      dwReadFlags,
          DWORD      dwRecordOffset,
           LPVOID     lpBuffer,
          DWORD      nNumberOfBytesToRead,
         DWORD      *pnBytesRead,
         DWORD      *pnMinNumberOfBytesNeeded
    );




#line 8134 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ReportEventA (
             HANDLE     hEventLog,
             WORD       wType,
             WORD       wCategory,
             DWORD      dwEventID,
           PSID       lpUserSid,
             WORD       wNumStrings,
             DWORD      dwDataSize,
           LPCSTR   *lpStrings,
             LPVOID lpRawData
    );
__declspec(dllimport)
BOOL
__stdcall
ReportEventW (
             HANDLE     hEventLog,
             WORD       wType,
             WORD       wCategory,
             DWORD      dwEventID,
           PSID       lpUserSid,
             WORD       wNumStrings,
             DWORD      dwDataSize,
           LPCWSTR   *lpStrings,
             LPVOID lpRawData
    );




#line 8168 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"




typedef struct _EVENTLOG_FULL_INFORMATION
{
    DWORD    dwFull;
}
EVENTLOG_FULL_INFORMATION, *LPEVENTLOG_FULL_INFORMATION;

__declspec(dllimport)
BOOL
__stdcall
GetEventLogInformation (
          HANDLE     hEventLog,
          DWORD      dwInfoLevel,
           LPVOID lpBuffer,
          DWORD      cbBufSize,
         LPDWORD    pcbBytesNeeded
    );







__declspec(dllimport)
BOOL
__stdcall
DuplicateToken(
                HANDLE ExistingTokenHandle,
                SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
                  PHANDLE DuplicateTokenHandle
    );

__declspec(dllimport)
BOOL
__stdcall
GetKernelObjectSecurity (
          HANDLE Handle,
          SECURITY_INFORMATION RequestedInformation,
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
          DWORD nLength,
         LPDWORD lpnLengthNeeded
    );

__declspec(dllimport)
BOOL
__stdcall
ImpersonateNamedPipeClient(
         HANDLE hNamedPipe
    );

__declspec(dllimport)
BOOL
__stdcall
ImpersonateSelf(
         SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );


__declspec(dllimport)
BOOL
__stdcall
RevertToSelf (
    void
    );

__declspec(dllimport)
BOOL
__stdcall
SetThreadToken (
           PHANDLE Thread,
           HANDLE Token
    );

__declspec(dllimport)
BOOL
__stdcall
AccessCheck (
            PSECURITY_DESCRIPTOR pSecurityDescriptor,
            HANDLE ClientToken,
            DWORD DesiredAccess,
            PGENERIC_MAPPING GenericMapping,
           PPRIVILEGE_SET PrivilegeSet,
         LPDWORD PrivilegeSetLength,
           LPDWORD GrantedAccess,
           LPBOOL AccessStatus
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckByType (
             PSECURITY_DESCRIPTOR pSecurityDescriptor,
           PSID PrincipalSelfSid,
             HANDLE ClientToken,
             DWORD DesiredAccess,
             POBJECT_TYPE_LIST ObjectTypeList,
             DWORD ObjectTypeListLength,
             PGENERIC_MAPPING GenericMapping,
           PPRIVILEGE_SET PrivilegeSet,
          LPDWORD PrivilegeSetLength,
            LPDWORD GrantedAccess,
            LPBOOL AccessStatus
    );

__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultList (
             PSECURITY_DESCRIPTOR pSecurityDescriptor,
           PSID PrincipalSelfSid,
             HANDLE ClientToken,
             DWORD DesiredAccess,
             POBJECT_TYPE_LIST ObjectTypeList,
             DWORD ObjectTypeListLength,
             PGENERIC_MAPPING GenericMapping,
           PPRIVILEGE_SET PrivilegeSet,
          LPDWORD PrivilegeSetLength,
            LPDWORD GrantedAccessList,
            LPDWORD AccessStatusList
    );
#line 8294 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
OpenProcessToken (
                HANDLE ProcessHandle,
                DWORD DesiredAccess,
                  PHANDLE TokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
OpenThreadToken (
                HANDLE ThreadHandle,
                DWORD DesiredAccess,
                BOOL OpenAsSelf,
                  PHANDLE TokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
GetTokenInformation (
              HANDLE TokenHandle,
              TOKEN_INFORMATION_CLASS TokenInformationClass,
             LPVOID TokenInformation,
              DWORD TokenInformationLength,
           PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
SetTokenInformation (
         HANDLE TokenHandle,
         TOKEN_INFORMATION_CLASS TokenInformationClass,
           LPVOID TokenInformation,
         DWORD TokenInformationLength
    );


__declspec(dllimport)
BOOL
__stdcall
AdjustTokenPrivileges (
              HANDLE TokenHandle,
              BOOL DisableAllPrivileges,
            PTOKEN_PRIVILEGES NewState,
              DWORD BufferLength,
             PTOKEN_PRIVILEGES PreviousState,
           PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
AdjustTokenGroups (
              HANDLE TokenHandle,
              BOOL ResetToDefault,
            PTOKEN_GROUPS NewState,
              DWORD BufferLength,
             PTOKEN_GROUPS PreviousState,
           PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
PrivilegeCheck (
            HANDLE ClientToken,
         PPRIVILEGE_SET RequiredPrivileges,
           LPBOOL pfResult
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckAndAuditAlarmA (
             LPCSTR SubsystemName,
             LPVOID HandleId,
             LPSTR ObjectTypeName,
           LPSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
             DWORD DesiredAccess,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
            LPDWORD GrantedAccess,
            LPBOOL AccessStatus,
            LPBOOL pfGenerateOnClose
    );
__declspec(dllimport)
BOOL
__stdcall
AccessCheckAndAuditAlarmW (
             LPCWSTR SubsystemName,
             LPVOID HandleId,
             LPWSTR ObjectTypeName,
           LPWSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
             DWORD DesiredAccess,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
            LPDWORD GrantedAccess,
            LPBOOL AccessStatus,
            LPBOOL pfGenerateOnClose
    );




#line 8413 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeAndAuditAlarmA (
             LPCSTR SubsystemName,
             LPVOID HandleId,
             LPCSTR ObjectTypeName,
           LPCSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
           PSID PrincipalSelfSid,
             DWORD DesiredAccess,
             AUDIT_EVENT_TYPE AuditType,
             DWORD Flags,
             POBJECT_TYPE_LIST ObjectTypeList,
             DWORD ObjectTypeListLength,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
            LPDWORD GrantedAccess,
            LPBOOL AccessStatus,
            LPBOOL pfGenerateOnClose
    );
__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeAndAuditAlarmW (
             LPCWSTR SubsystemName,
             LPVOID HandleId,
             LPCWSTR ObjectTypeName,
           LPCWSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
           PSID PrincipalSelfSid,
             DWORD DesiredAccess,
             AUDIT_EVENT_TYPE AuditType,
             DWORD Flags,
             POBJECT_TYPE_LIST ObjectTypeList,
             DWORD ObjectTypeListLength,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
            LPDWORD GrantedAccess,
            LPBOOL AccessStatus,
            LPBOOL pfGenerateOnClose
    );




#line 8463 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmA (
             LPCSTR SubsystemName,
             LPVOID HandleId,
             LPCSTR ObjectTypeName,
           LPCSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
           PSID PrincipalSelfSid,
             DWORD DesiredAccess,
             AUDIT_EVENT_TYPE AuditType,
             DWORD Flags,
             POBJECT_TYPE_LIST ObjectTypeList,
             DWORD ObjectTypeListLength,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
            LPDWORD GrantedAccess,
            LPDWORD AccessStatusList,
            LPBOOL pfGenerateOnClose
    );
__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmW (
             LPCWSTR SubsystemName,
             LPVOID HandleId,
             LPCWSTR ObjectTypeName,
           LPCWSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
           PSID PrincipalSelfSid,
             DWORD DesiredAccess,
             AUDIT_EVENT_TYPE AuditType,
             DWORD Flags,
             POBJECT_TYPE_LIST ObjectTypeList,
             DWORD ObjectTypeListLength,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
            LPDWORD GrantedAccess,
            LPDWORD AccessStatusList,
            LPBOOL pfGenerateOnClose
    );




#line 8511 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmByHandleA (
             LPCSTR SubsystemName,
             LPVOID HandleId,
             HANDLE ClientToken,
             LPCSTR ObjectTypeName,
           LPCSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
           PSID PrincipalSelfSid,
             DWORD DesiredAccess,
             AUDIT_EVENT_TYPE AuditType,
             DWORD Flags,
             POBJECT_TYPE_LIST ObjectTypeList,
             DWORD ObjectTypeListLength,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
            LPDWORD GrantedAccess,
            LPDWORD AccessStatusList,
            LPBOOL pfGenerateOnClose
    );
__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmByHandleW (
             LPCWSTR SubsystemName,
             LPVOID HandleId,
             HANDLE ClientToken,
             LPCWSTR ObjectTypeName,
           LPCWSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
           PSID PrincipalSelfSid,
             DWORD DesiredAccess,
             AUDIT_EVENT_TYPE AuditType,
             DWORD Flags,
             POBJECT_TYPE_LIST ObjectTypeList,
             DWORD ObjectTypeListLength,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
            LPDWORD GrantedAccess,
            LPDWORD AccessStatusList,
            LPBOOL pfGenerateOnClose
    );




#line 8561 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

#line 8563 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ObjectOpenAuditAlarmA (
             LPCSTR SubsystemName,
             LPVOID HandleId,
             LPSTR ObjectTypeName,
           LPSTR ObjectName,
             PSECURITY_DESCRIPTOR pSecurityDescriptor,
             HANDLE ClientToken,
             DWORD DesiredAccess,
             DWORD GrantedAccess,
           PPRIVILEGE_SET Privileges,
             BOOL ObjectCreation,
             BOOL AccessGranted,
            LPBOOL GenerateOnClose
    );
__declspec(dllimport)
BOOL
__stdcall
ObjectOpenAuditAlarmW (
             LPCWSTR SubsystemName,
             LPVOID HandleId,
             LPWSTR ObjectTypeName,
           LPWSTR ObjectName,
             PSECURITY_DESCRIPTOR pSecurityDescriptor,
             HANDLE ClientToken,
             DWORD DesiredAccess,
             DWORD GrantedAccess,
           PPRIVILEGE_SET Privileges,
             BOOL ObjectCreation,
             BOOL AccessGranted,
            LPBOOL GenerateOnClose
    );




#line 8603 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
ObjectPrivilegeAuditAlarmA (
         LPCSTR SubsystemName,
         LPVOID HandleId,
         HANDLE ClientToken,
         DWORD DesiredAccess,
         PPRIVILEGE_SET Privileges,
         BOOL AccessGranted
    );
__declspec(dllimport)
BOOL
__stdcall
ObjectPrivilegeAuditAlarmW (
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         HANDLE ClientToken,
         DWORD DesiredAccess,
         PPRIVILEGE_SET Privileges,
         BOOL AccessGranted
    );




#line 8632 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
ObjectCloseAuditAlarmA (
         LPCSTR SubsystemName,
         LPVOID HandleId,
         BOOL GenerateOnClose
    );
__declspec(dllimport)
BOOL
__stdcall
ObjectCloseAuditAlarmW (
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         BOOL GenerateOnClose
    );




#line 8655 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
ObjectDeleteAuditAlarmA (
         LPCSTR SubsystemName,
         LPVOID HandleId,
         BOOL GenerateOnClose
    );
__declspec(dllimport)
BOOL
__stdcall
ObjectDeleteAuditAlarmW (
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         BOOL GenerateOnClose
    );




#line 8678 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
PrivilegedServiceAuditAlarmA (
         LPCSTR SubsystemName,
         LPCSTR ServiceName,
         HANDLE ClientToken,
         PPRIVILEGE_SET Privileges,
         BOOL AccessGranted
    );
__declspec(dllimport)
BOOL
__stdcall
PrivilegedServiceAuditAlarmW (
         LPCWSTR SubsystemName,
         LPCWSTR ServiceName,
         HANDLE ClientToken,
         PPRIVILEGE_SET Privileges,
         BOOL AccessGranted
    );




#line 8705 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"










































#line 8748 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
IsValidSid (
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
EqualSid (
         PSID pSid1,
         PSID pSid2
    );


__declspec(dllimport)
BOOL
__stdcall
EqualPrefixSid (
         PSID pSid1,
         PSID pSid2
    );


__declspec(dllimport)
DWORD
__stdcall
GetSidLengthRequired (
         UCHAR nSubAuthorityCount
    );


__declspec(dllimport)
BOOL
__stdcall
AllocateAndInitializeSid (
                PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
                BYTE nSubAuthorityCount,
                DWORD nSubAuthority0,
                DWORD nSubAuthority1,
                DWORD nSubAuthority2,
                DWORD nSubAuthority3,
                DWORD nSubAuthority4,
                DWORD nSubAuthority5,
                DWORD nSubAuthority6,
                DWORD nSubAuthority7,
                  PSID *pSid
    );

__declspec(dllimport)
PVOID
__stdcall
FreeSid(
         PSID pSid
    );

__declspec(dllimport)
BOOL
__stdcall
InitializeSid (
         PSID Sid,
          PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
          BYTE nSubAuthorityCount
    );


__declspec(dllimport)
    
PSID_IDENTIFIER_AUTHORITY
__stdcall
GetSidIdentifierAuthority (
         PSID pSid
    );


__declspec(dllimport)
    
PDWORD
__stdcall
GetSidSubAuthority (
         PSID pSid,
         DWORD nSubAuthority
    );


__declspec(dllimport)
    
PUCHAR
__stdcall
GetSidSubAuthorityCount (
         PSID pSid
    );


__declspec(dllimport)
DWORD
__stdcall
GetLengthSid (
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
CopySid (
         DWORD nDestinationSidLength,
         PSID pDestinationSid,
         PSID pSourceSid
    );


__declspec(dllimport)
BOOL
__stdcall
AreAllAccessesGranted (
         DWORD GrantedAccess,
         DWORD DesiredAccess
    );


__declspec(dllimport)
BOOL
__stdcall
AreAnyAccessesGranted (
         DWORD GrantedAccess,
         DWORD DesiredAccess
    );


__declspec(dllimport)
void
__stdcall
MapGenericMask (
         PDWORD AccessMask,
            PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
IsValidAcl (
         PACL pAcl
    );


__declspec(dllimport)
BOOL
__stdcall
InitializeAcl (
         PACL pAcl,
         DWORD nAclLength,
         DWORD dwAclRevision
    );


__declspec(dllimport)
BOOL
__stdcall
GetAclInformation (
         PACL pAcl,
         LPVOID pAclInformation,
         DWORD nAclInformationLength,
         ACL_INFORMATION_CLASS dwAclInformationClass
    );


__declspec(dllimport)
BOOL
__stdcall
SetAclInformation (
         PACL pAcl,
           LPVOID pAclInformation,
            DWORD nAclInformationLength,
            ACL_INFORMATION_CLASS dwAclInformationClass
    );


__declspec(dllimport)
BOOL
__stdcall
AddAce (
         PACL pAcl,
            DWORD dwAceRevision,
            DWORD dwStartingAceIndex,
           LPVOID pAceList,
            DWORD nAceListLength
    );


__declspec(dllimport)
BOOL
__stdcall
DeleteAce (
         PACL pAcl,
            DWORD dwAceIndex
    );


__declspec(dllimport)
BOOL
__stdcall
GetAce (
                PACL pAcl,
                DWORD dwAceIndex,
                  LPVOID *pAce
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedAce (
         PACL pAcl,
            DWORD dwAceRevision,
            DWORD AccessMask,
            PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedAceEx (
         PACL pAcl,
            DWORD dwAceRevision,
            DWORD AceFlags,
            DWORD AccessMask,
            PSID pSid
    );
#line 8983 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedAce (
         PACL pAcl,
            DWORD dwAceRevision,
            DWORD AccessMask,
            PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedAceEx (
         PACL pAcl,
            DWORD dwAceRevision,
            DWORD AceFlags,
            DWORD AccessMask,
            PSID pSid
    );
#line 9007 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessAce(
         PACL pAcl,
            DWORD dwAceRevision,
            DWORD dwAccessMask,
            PSID pSid,
            BOOL bAuditSuccess,
            BOOL bAuditFailure
    );


__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessAceEx(
         PACL pAcl,
            DWORD dwAceRevision,
            DWORD AceFlags,
            DWORD dwAccessMask,
            PSID pSid,
            BOOL bAuditSuccess,
            BOOL bAuditFailure
    );

__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedObjectAce (
          PACL pAcl,
             DWORD dwAceRevision,
             DWORD AceFlags,
             DWORD AccessMask,
           GUID *ObjectTypeGuid,
           GUID *InheritedObjectTypeGuid,
             PSID pSid
    );

__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedObjectAce (
          PACL pAcl,
             DWORD dwAceRevision,
             DWORD AceFlags,
             DWORD AccessMask,
           GUID *ObjectTypeGuid,
           GUID *InheritedObjectTypeGuid,
             PSID pSid
    );

__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessObjectAce (
          PACL pAcl,
             DWORD dwAceRevision,
             DWORD AceFlags,
             DWORD AccessMask,
           GUID *ObjectTypeGuid,
           GUID *InheritedObjectTypeGuid,
             PSID pSid,
             BOOL bAuditSuccess,
             BOOL bAuditFailure
    );
#line 9075 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindFirstFreeAce (
                PACL pAcl,
                  LPVOID *pAce
    );


__declspec(dllimport)
BOOL
__stdcall
InitializeSecurityDescriptor (
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
          DWORD dwRevision
    );


__declspec(dllimport)
BOOL
__stdcall
IsValidSecurityDescriptor (
         PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


__declspec(dllimport)
DWORD
__stdcall
GetSecurityDescriptorLength (
         PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorControl (
          PSECURITY_DESCRIPTOR pSecurityDescriptor,
         PSECURITY_DESCRIPTOR_CONTROL pControl,
         LPDWORD lpdwRevision
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorControl (
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
         SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
         SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    );
#line 9129 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorDacl (
          PSECURITY_DESCRIPTOR pSecurityDescriptor,
             BOOL bDaclPresent,
           PACL pDacl,
             BOOL bDaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorDacl (
                PSECURITY_DESCRIPTOR pSecurityDescriptor,
               LPBOOL lpbDaclPresent,
                  PACL *pDacl,
               LPBOOL lpbDaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorSacl (
          PSECURITY_DESCRIPTOR pSecurityDescriptor,
             BOOL bSaclPresent,
           PACL pSacl,
             BOOL bSaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorSacl (
                PSECURITY_DESCRIPTOR pSecurityDescriptor,
               LPBOOL lpbSaclPresent,
                  PACL *pSacl,
               LPBOOL lpbSaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorOwner (
          PSECURITY_DESCRIPTOR pSecurityDescriptor,
           PSID pOwner,
             BOOL bOwnerDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorOwner (
                PSECURITY_DESCRIPTOR pSecurityDescriptor,
                  PSID *pOwner,
               LPBOOL lpbOwnerDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorGroup (
          PSECURITY_DESCRIPTOR pSecurityDescriptor,
           PSID pGroup,
             BOOL bGroupDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorGroup (
                PSECURITY_DESCRIPTOR pSecurityDescriptor,
                  PSID *pGroup,
               LPBOOL lpbGroupDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
SetSecurityDescriptorRMControl(
          PSECURITY_DESCRIPTOR SecurityDescriptor,
           PUCHAR RMControl
    );

__declspec(dllimport)
DWORD
__stdcall
GetSecurityDescriptorRMControl(
          PSECURITY_DESCRIPTOR SecurityDescriptor,
         PUCHAR RMControl
    );

__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurity (
              PSECURITY_DESCRIPTOR ParentDescriptor,
              PSECURITY_DESCRIPTOR CreatorDescriptor,
                  PSECURITY_DESCRIPTOR * NewDescriptor,
                BOOL IsDirectoryObject,
              HANDLE Token,
                PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
ConvertToAutoInheritPrivateObjectSecurity(
              PSECURITY_DESCRIPTOR ParentDescriptor,
                PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
                  PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
              GUID *ObjectType,
                BOOLEAN IsDirectoryObject,
                PGENERIC_MAPPING GenericMapping
    );

__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurityEx (
              PSECURITY_DESCRIPTOR ParentDescriptor,
              PSECURITY_DESCRIPTOR CreatorDescriptor,
                  PSECURITY_DESCRIPTOR * NewDescriptor,
              GUID *ObjectType,
                BOOL IsContainerObject,
                ULONG AutoInheritFlags,
              HANDLE Token,
                PGENERIC_MAPPING GenericMapping
    );

__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurityWithMultipleInheritance (
              PSECURITY_DESCRIPTOR ParentDescriptor,
              PSECURITY_DESCRIPTOR CreatorDescriptor,
                  PSECURITY_DESCRIPTOR * NewDescriptor,
             GUID **ObjectTypes,
                ULONG GuidCount,
                BOOL IsContainerObject,
                ULONG AutoInheritFlags,
              HANDLE Token,
                PGENERIC_MAPPING GenericMapping
    );
#line 9284 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetPrivateObjectSecurity (
                  SECURITY_INFORMATION SecurityInformation,
                  PSECURITY_DESCRIPTOR ModificationDescriptor,
             PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
                  PGENERIC_MAPPING GenericMapping,
                HANDLE Token
    );


__declspec(dllimport)
BOOL
__stdcall
SetPrivateObjectSecurityEx (
                  SECURITY_INFORMATION SecurityInformation,
                  PSECURITY_DESCRIPTOR ModificationDescriptor,
             PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
                  ULONG AutoInheritFlags,
                  PGENERIC_MAPPING GenericMapping,
                HANDLE Token
    );
#line 9309 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetPrivateObjectSecurity (
          PSECURITY_DESCRIPTOR ObjectDescriptor,
          SECURITY_INFORMATION SecurityInformation,
             PSECURITY_DESCRIPTOR ResultantDescriptor,
          DWORD DescriptorLength,
         PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
DestroyPrivateObjectSecurity (
     PSECURITY_DESCRIPTOR * ObjectDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
MakeSelfRelativeSD (
            PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
             PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
         LPDWORD lpdwBufferLength
    );


__declspec(dllimport)
BOOL
__stdcall
MakeAbsoluteSD (
            PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
             PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
         LPDWORD lpdwAbsoluteSecurityDescriptorSize,
             PACL pDacl,
         LPDWORD lpdwDaclSize,
             PACL pSacl,
         LPDWORD lpdwSaclSize,
             PSID pOwner,
         LPDWORD lpdwOwnerSize,
             PSID pPrimaryGroup,
         LPDWORD lpdwPrimaryGroupSize
    );


__declspec(dllimport)
BOOL
__stdcall
MakeAbsoluteSD2 (
               PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
         LPDWORD lpdwBufferSize
    );

__declspec(dllimport)
BOOL
__stdcall
SetFileSecurityA (
         LPCSTR lpFileName,
         SECURITY_INFORMATION SecurityInformation,
         PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
__declspec(dllimport)
BOOL
__stdcall
SetFileSecurityW (
         LPCWSTR lpFileName,
         SECURITY_INFORMATION SecurityInformation,
         PSECURITY_DESCRIPTOR pSecurityDescriptor
    );




#line 9387 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
GetFileSecurityA (
          LPCSTR lpFileName,
          SECURITY_INFORMATION RequestedInformation,
             PSECURITY_DESCRIPTOR pSecurityDescriptor,
          DWORD nLength,
         LPDWORD lpnLengthNeeded
    );
__declspec(dllimport)
BOOL
__stdcall
GetFileSecurityW (
          LPCWSTR lpFileName,
          SECURITY_INFORMATION RequestedInformation,
             PSECURITY_DESCRIPTOR pSecurityDescriptor,
          DWORD nLength,
         LPDWORD lpnLengthNeeded
    );




#line 9414 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
SetKernelObjectSecurity (
         HANDLE Handle,
         SECURITY_INFORMATION SecurityInformation,
         PSECURITY_DESCRIPTOR SecurityDescriptor
    );

__declspec(dllimport)
    
HANDLE
__stdcall
FindFirstChangeNotificationA(
         LPCSTR lpPathName,
         BOOL bWatchSubtree,
         DWORD dwNotifyFilter
    );
__declspec(dllimport)
    
HANDLE
__stdcall
FindFirstChangeNotificationW(
         LPCWSTR lpPathName,
         BOOL bWatchSubtree,
         DWORD dwNotifyFilter
    );




#line 9448 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindNextChangeNotification(
         HANDLE hChangeHandle
    );

__declspec(dllimport)
BOOL
__stdcall
FindCloseChangeNotification(
         HANDLE hChangeHandle
    );


__declspec(dllimport)
BOOL
__stdcall
ReadDirectoryChangesW(
             HANDLE hDirectory,
           LPVOID lpBuffer,
             DWORD nBufferLength,
             BOOL bWatchSubtree,
             DWORD dwNotifyFilter,
            LPDWORD lpBytesReturned,
          LPOVERLAPPED lpOverlapped,
           LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#line 9478 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
VirtualLock(
         LPVOID lpAddress,
         SIZE_T dwSize
    );

__declspec(dllimport)
BOOL
__stdcall
VirtualUnlock(
         LPVOID lpAddress,
         SIZE_T dwSize
    );

__declspec(dllimport)
    
LPVOID
__stdcall
MapViewOfFileEx(
             HANDLE hFileMappingObject,
             DWORD dwDesiredAccess,
             DWORD dwFileOffsetHigh,
             DWORD dwFileOffsetLow,
             SIZE_T dwNumberOfBytesToMap,
           LPVOID lpBaseAddress
    );

__declspec(dllimport)
BOOL
__stdcall
SetPriorityClass(
         HANDLE hProcess,
         DWORD dwPriorityClass
    );

__declspec(dllimport)
DWORD
__stdcall
GetPriorityClass(
         HANDLE hProcess
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadReadPtr(
           const void *lp,
             UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadWritePtr(
           LPVOID lp,
             UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadHugeReadPtr(
           const void *lp,
             UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadHugeWritePtr(
           LPVOID lp,
             UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadCodePtr(
           FARPROC lpfn
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadStringPtrA(
           LPCSTR lpsz,
             UINT_PTR ucchMax
    );
__declspec(dllimport)
BOOL
__stdcall
IsBadStringPtrW(
           LPCWSTR lpsz,
             UINT_PTR ucchMax
    );




#line 9581 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
LookupAccountSidA(
           LPCSTR lpSystemName,
         PSID Sid,
             LPSTR Name,
          LPDWORD cchName,
             LPSTR ReferencedDomainName,
         LPDWORD cchReferencedDomainName,
         PSID_NAME_USE peUse
    );
__declspec(dllimport)
BOOL
__stdcall
LookupAccountSidW(
           LPCWSTR lpSystemName,
         PSID Sid,
             LPWSTR Name,
          LPDWORD cchName,
             LPWSTR ReferencedDomainName,
         LPDWORD cchReferencedDomainName,
         PSID_NAME_USE peUse
    );




#line 9611 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
LookupAccountNameA(
           LPCSTR lpSystemName,
             LPCSTR lpAccountName,
             PSID Sid,
          LPDWORD cbSid,
             LPSTR ReferencedDomainName,
          LPDWORD cchReferencedDomainName,
            PSID_NAME_USE peUse
    );
__declspec(dllimport)
BOOL
__stdcall
LookupAccountNameW(
           LPCWSTR lpSystemName,
             LPCWSTR lpAccountName,
             PSID Sid,
          LPDWORD cbSid,
             LPWSTR ReferencedDomainName,
          LPDWORD cchReferencedDomainName,
            PSID_NAME_USE peUse
    );




#line 9641 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeValueA(
           LPCSTR lpSystemName,
             LPCSTR lpName,
            PLUID   lpLuid
    );
__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeValueW(
           LPCWSTR lpSystemName,
             LPCWSTR lpName,
            PLUID   lpLuid
    );




#line 9663 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeNameA(
           LPCSTR lpSystemName,
             PLUID   lpLuid,
             LPSTR lpName,
          LPDWORD cchName
    );
__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeNameW(
           LPCWSTR lpSystemName,
             PLUID   lpLuid,
             LPWSTR lpName,
          LPDWORD cchName
    );




#line 9687 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeDisplayNameA(
           LPCSTR lpSystemName,
             LPCSTR lpName,
             LPSTR lpDisplayName,
          LPDWORD cchDisplayName,
            LPDWORD lpLanguageId
    );
__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeDisplayNameW(
           LPCWSTR lpSystemName,
             LPCWSTR lpName,
             LPWSTR lpDisplayName,
          LPDWORD cchDisplayName,
            LPDWORD lpLanguageId
    );




#line 9713 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
AllocateLocallyUniqueId(
         PLUID Luid
    );

__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBA(
          LPCSTR lpDef,
         LPDCB lpDCB
    );
__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBW(
          LPCWSTR lpDef,
         LPDCB lpDCB
    );




#line 9740 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBAndTimeoutsA(
          LPCSTR lpDef,
         LPDCB lpDCB,
         LPCOMMTIMEOUTS lpCommTimeouts
    );
__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBAndTimeoutsW(
          LPCWSTR lpDef,
         LPDCB lpDCB,
         LPCOMMTIMEOUTS lpCommTimeouts
    );




#line 9762 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CommConfigDialogA(
             LPCSTR lpszName,
           HWND hWnd,
          LPCOMMCONFIG lpCC
    );
__declspec(dllimport)
BOOL
__stdcall
CommConfigDialogW(
             LPCWSTR lpszName,
           HWND hWnd,
          LPCOMMCONFIG lpCC
    );




#line 9784 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetDefaultCommConfigA(
            LPCSTR lpszName,
           LPCOMMCONFIG lpCC,
         LPDWORD lpdwSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetDefaultCommConfigW(
            LPCWSTR lpszName,
           LPCOMMCONFIG lpCC,
         LPDWORD lpdwSize
    );




#line 9806 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetDefaultCommConfigA(
         LPCSTR lpszName,
           LPCOMMCONFIG lpCC,
         DWORD dwSize
    );
__declspec(dllimport)
BOOL
__stdcall
SetDefaultCommConfigW(
         LPCWSTR lpszName,
           LPCOMMCONFIG lpCC,
         DWORD dwSize
    );




#line 9828 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"





#line 9834 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetComputerNameA (
           LPSTR lpBuffer,
         LPDWORD nSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetComputerNameW (
           LPWSTR lpBuffer,
         LPDWORD nSize
    );




#line 9854 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetComputerNameA (
         LPCSTR lpComputerName
    );
__declspec(dllimport)
BOOL
__stdcall
SetComputerNameW (
         LPCWSTR lpComputerName
    );




#line 9872 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"




typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;

__declspec(dllimport)
BOOL
__stdcall
GetComputerNameExA (
            COMPUTER_NAME_FORMAT NameType,
             LPSTR lpBuffer,
         LPDWORD nSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetComputerNameExW (
            COMPUTER_NAME_FORMAT NameType,
             LPWSTR lpBuffer,
         LPDWORD nSize
    );




#line 9909 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetComputerNameExA (
         COMPUTER_NAME_FORMAT NameType,
         LPCSTR lpBuffer
    );
__declspec(dllimport)
BOOL
__stdcall
SetComputerNameExW (
         COMPUTER_NAME_FORMAT NameType,
         LPCWSTR lpBuffer
    );




#line 9929 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
DnsHostnameToComputerNameA (
            LPCSTR Hostname,
             LPSTR ComputerName,
         LPDWORD nSize
    );
__declspec(dllimport)
BOOL
__stdcall
DnsHostnameToComputerNameW (
            LPCWSTR Hostname,
             LPWSTR ComputerName,
         LPDWORD nSize
    );




#line 9952 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

#line 9954 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetUserNameA (
           LPSTR lpBuffer,
         LPDWORD pcbBuffer
    );
__declspec(dllimport)
BOOL
__stdcall
GetUserNameW (
           LPWSTR lpBuffer,
         LPDWORD pcbBuffer
    );




#line 9974 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"













#line 9988 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"





#line 9994 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


#line 9997 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
LogonUserA (
                LPCSTR lpszUsername,
              LPCSTR lpszDomain,
                LPCSTR lpszPassword,
                DWORD dwLogonType,
                DWORD dwLogonProvider,
                  PHANDLE phToken
    );
__declspec(dllimport)
BOOL
__stdcall
LogonUserW (
                LPCWSTR lpszUsername,
              LPCWSTR lpszDomain,
                LPCWSTR lpszPassword,
                DWORD dwLogonType,
                DWORD dwLogonProvider,
                  PHANDLE phToken
    );




#line 10027 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
LogonUserExA (
                    LPCSTR lpszUsername,
                  LPCSTR lpszDomain,
                    LPCSTR lpszPassword,
                    DWORD dwLogonType,
                    DWORD dwLogonProvider,
                    PHANDLE phToken,
                    PSID  *ppLogonSid,
                       PVOID *ppProfileBuffer,
                 LPDWORD pdwProfileLength,
                 PQUOTA_LIMITS pQuotaLimits
    );
__declspec(dllimport)
BOOL
__stdcall
LogonUserExW (
                    LPCWSTR lpszUsername,
                  LPCWSTR lpszDomain,
                    LPCWSTR lpszPassword,
                    DWORD dwLogonType,
                    DWORD dwLogonProvider,
                    PHANDLE phToken,
                    PSID  *ppLogonSid,
                       PVOID *ppProfileBuffer,
                 LPDWORD pdwProfileLength,
                 PQUOTA_LIMITS pQuotaLimits
    );




#line 10063 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ImpersonateLoggedOnUser(
         HANDLE  hToken
    );

__declspec(dllimport)
BOOL
__stdcall
CreateProcessAsUserA (
              HANDLE hToken,
              LPCSTR lpApplicationName,
           LPSTR lpCommandLine,
              LPSECURITY_ATTRIBUTES lpProcessAttributes,
              LPSECURITY_ATTRIBUTES lpThreadAttributes,
                BOOL bInheritHandles,
                DWORD dwCreationFlags,
              LPVOID lpEnvironment,
              LPCSTR lpCurrentDirectory,
                LPSTARTUPINFOA lpStartupInfo,
               LPPROCESS_INFORMATION lpProcessInformation
    );
__declspec(dllimport)
BOOL
__stdcall
CreateProcessAsUserW (
              HANDLE hToken,
              LPCWSTR lpApplicationName,
           LPWSTR lpCommandLine,
              LPSECURITY_ATTRIBUTES lpProcessAttributes,
              LPSECURITY_ATTRIBUTES lpThreadAttributes,
                BOOL bInheritHandles,
                DWORD dwCreationFlags,
              LPVOID lpEnvironment,
              LPCWSTR lpCurrentDirectory,
                LPSTARTUPINFOW lpStartupInfo,
               LPPROCESS_INFORMATION lpProcessInformation
    );




#line 10108 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"











__declspec(dllimport)
BOOL
__stdcall
CreateProcessWithLogonW(
                LPCWSTR lpUsername,
              LPCWSTR lpDomain,
                LPCWSTR lpPassword,
                DWORD dwLogonFlags,
              LPCWSTR lpApplicationName,
           LPWSTR lpCommandLine,
                DWORD dwCreationFlags,
              LPVOID lpEnvironment,
              LPCWSTR lpCurrentDirectory,
                LPSTARTUPINFOW lpStartupInfo,
               LPPROCESS_INFORMATION lpProcessInformation
      );

__declspec(dllimport)
BOOL
__stdcall
CreateProcessWithTokenW(
                HANDLE hToken,
                DWORD dwLogonFlags,
              LPCWSTR lpApplicationName,
           LPWSTR lpCommandLine,
                DWORD dwCreationFlags,
              LPVOID lpEnvironment,
              LPCWSTR lpCurrentDirectory,
                LPSTARTUPINFOW lpStartupInfo,
               LPPROCESS_INFORMATION lpProcessInformation
      );

#line 10152 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ImpersonateAnonymousToken(
         HANDLE ThreadHandle
    );

__declspec(dllimport)
BOOL
__stdcall
DuplicateTokenEx(
                HANDLE hExistingToken,
                DWORD dwDesiredAccess,
              LPSECURITY_ATTRIBUTES lpTokenAttributes,
                SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
                TOKEN_TYPE TokenType,
                  PHANDLE phNewToken);

__declspec(dllimport)
BOOL
__stdcall
CreateRestrictedToken(
                HANDLE ExistingTokenHandle,
                DWORD Flags,
                DWORD DisableSidCount,
             PSID_AND_ATTRIBUTES SidsToDisable,
                DWORD DeletePrivilegeCount,
             PLUID_AND_ATTRIBUTES PrivilegesToDelete,
                DWORD RestrictedSidCount,
             PSID_AND_ATTRIBUTES SidsToRestrict,
                  PHANDLE NewTokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
IsTokenRestricted(
         HANDLE TokenHandle
    );

__declspec(dllimport)
BOOL
__stdcall
IsTokenUntrusted(
         HANDLE TokenHandle
    );

__declspec(dllimport)
BOOL
__stdcall
CheckTokenMembership(
           HANDLE TokenHandle,
             PSID SidToCheck,
            PBOOL IsMember
    );







typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK ;

__declspec(dllimport)
BOOL
__stdcall
RegisterWaitForSingleObject(
                  PHANDLE phNewWaitObject,
                HANDLE hObject,
                WAITORTIMERCALLBACK Callback,
              PVOID Context,
                ULONG dwMilliseconds,
                ULONG dwFlags
    );

__declspec(dllimport)
    
HANDLE
__stdcall
RegisterWaitForSingleObjectEx(
             HANDLE hObject,
             WAITORTIMERCALLBACK Callback,
           PVOID Context,
             ULONG dwMilliseconds,
             ULONG dwFlags
    );

__declspec(dllimport)

BOOL
__stdcall
UnregisterWait(
         HANDLE WaitHandle
    );

__declspec(dllimport)

BOOL
__stdcall
UnregisterWaitEx(
             HANDLE WaitHandle,
           HANDLE CompletionEvent
    );

__declspec(dllimport)
BOOL
__stdcall
QueueUserWorkItem(
             LPTHREAD_START_ROUTINE Function,
           PVOID Context,
             ULONG Flags
    );

__declspec(dllimport)
BOOL
__stdcall
BindIoCompletionCallback (
         HANDLE FileHandle,
         LPOVERLAPPED_COMPLETION_ROUTINE Function,
         ULONG Flags
    );

__declspec(dllimport)
    
HANDLE
__stdcall
CreateTimerQueue(
    void
    );

__declspec(dllimport)
BOOL
__stdcall
CreateTimerQueueTimer(
                  PHANDLE phNewTimer,
              HANDLE TimerQueue,
                WAITORTIMERCALLBACK Callback,
              PVOID Parameter,
                DWORD DueTime,
                DWORD Period,
                ULONG Flags
    ) ;

__declspec(dllimport)

BOOL
__stdcall
ChangeTimerQueueTimer(
           HANDLE TimerQueue,
          HANDLE Timer,
             ULONG DueTime,
             ULONG Period
    );

__declspec(dllimport)

BOOL
__stdcall
DeleteTimerQueueTimer(
           HANDLE TimerQueue,
             HANDLE Timer,
           HANDLE CompletionEvent
    );

__declspec(dllimport)

BOOL
__stdcall
DeleteTimerQueueEx(
             HANDLE TimerQueue,
           HANDLE CompletionEvent
    );

__declspec(dllimport)
    
HANDLE
__stdcall
SetTimerQueueTimer(
           HANDLE TimerQueue,
             WAITORTIMERCALLBACK Callback,
           PVOID Parameter,
             DWORD DueTime,
             DWORD Period,
             BOOL PreferIo
    );

__declspec(dllimport)

BOOL
__stdcall
CancelTimerQueueTimer(
           HANDLE TimerQueue,
             HANDLE Timer
    );

__declspec(dllimport)

BOOL
__stdcall
DeleteTimerQueue(
         HANDLE TimerQueue
    );

#line 10359 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
















typedef struct tagHW_PROFILE_INFOA {
    DWORD  dwDockInfo;
    CHAR   szHwProfileGuid[39];
    CHAR   szHwProfileName[80];
} HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA;
typedef struct tagHW_PROFILE_INFOW {
    DWORD  dwDockInfo;
    WCHAR  szHwProfileGuid[39];
    WCHAR  szHwProfileName[80];
} HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW;

typedef HW_PROFILE_INFOW HW_PROFILE_INFO;
typedef LPHW_PROFILE_INFOW LPHW_PROFILE_INFO;



#line 10392 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
GetCurrentHwProfileA (
         LPHW_PROFILE_INFOA  lpHwProfileInfo
    );
__declspec(dllimport)
BOOL
__stdcall
GetCurrentHwProfileW (
         LPHW_PROFILE_INFOW  lpHwProfileInfo
    );




#line 10411 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
#line 10412 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"





__declspec(dllimport)
BOOL
__stdcall
QueryPerformanceCounter(
         LARGE_INTEGER *lpPerformanceCount
    );

__declspec(dllimport)
BOOL
__stdcall
QueryPerformanceFrequency(
         LARGE_INTEGER *lpFrequency
    );



__declspec(dllimport)
BOOL
__stdcall
GetVersionExA(
         LPOSVERSIONINFOA lpVersionInformation
    );
__declspec(dllimport)
BOOL
__stdcall
GetVersionExW(
         LPOSVERSIONINFOW lpVersionInformation
    );




#line 10450 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
VerifyVersionInfoA(
         LPOSVERSIONINFOEXA lpVersionInformation,
            DWORD dwTypeMask,
            DWORDLONG dwlConditionMask
    );
__declspec(dllimport)
BOOL
__stdcall
VerifyVersionInfoW(
         LPOSVERSIONINFOEXW lpVersionInformation,
            DWORD dwTypeMask,
            DWORDLONG dwlConditionMask
    );




#line 10474 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"





#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winerror.h"












#pragma once
#line 15 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winerror.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 15300 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winerror.h"



















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 17176 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winerror.h"







































#line 17216 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winerror.h"


























































































































































































#line 17403 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winerror.h"






















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 
 
 
 
 






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 27381 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winerror.h"

#line 10480 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"





























typedef struct _SYSTEM_POWER_STATUS {
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE Reserved1;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
}   SYSTEM_POWER_STATUS, *LPSYSTEM_POWER_STATUS;

BOOL
__stdcall
GetSystemPowerStatus(
         LPSYSTEM_POWER_STATUS lpSystemPowerStatus
    );

BOOL
__stdcall
SetSystemPowerState(
         BOOL fSuspend,
         BOOL fForce
    );

#line 10532 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"






__declspec(dllimport)
BOOL
__stdcall
AllocateUserPhysicalPages(
            HANDLE hProcess,
         PULONG_PTR NumberOfPages,
           PULONG_PTR PageArray
    );

__declspec(dllimport)
BOOL
__stdcall
FreeUserPhysicalPages(
            HANDLE hProcess,
         PULONG_PTR NumberOfPages,
           PULONG_PTR PageArray
    );

__declspec(dllimport)
BOOL
__stdcall
MapUserPhysicalPages(
         PVOID VirtualAddress,
         ULONG_PTR NumberOfPages,
             PULONG_PTR PageArray
    );

__declspec(dllimport)
BOOL
__stdcall
MapUserPhysicalPagesScatter(
           PVOID *VirtualAddresses,
         ULONG_PTR NumberOfPages,
             PULONG_PTR PageArray
    );

__declspec(dllimport)
    
HANDLE
__stdcall
CreateJobObjectA(
           LPSECURITY_ATTRIBUTES lpJobAttributes,
           LPCSTR lpName
    );
__declspec(dllimport)
    
HANDLE
__stdcall
CreateJobObjectW(
           LPSECURITY_ATTRIBUTES lpJobAttributes,
           LPCWSTR lpName
    );




#line 10595 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
    
HANDLE
__stdcall
OpenJobObjectA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpName
    );
__declspec(dllimport)
    
HANDLE
__stdcall
OpenJobObjectW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpName
    );




#line 10619 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
AssignProcessToJobObject(
         HANDLE hJob,
         HANDLE hProcess
    );

__declspec(dllimport)
BOOL
__stdcall
TerminateJobObject(
         HANDLE hJob,
         UINT uExitCode
    );

__declspec(dllimport)
BOOL
__stdcall
QueryInformationJobObject(
            HANDLE hJob,
              JOBOBJECTINFOCLASS JobObjectInformationClass,
           LPVOID lpJobObjectInformation,
              DWORD cbJobObjectInformationLength,
           LPDWORD lpReturnLength
    );

__declspec(dllimport)
BOOL
__stdcall
SetInformationJobObject(
         HANDLE hJob,
         JOBOBJECTINFOCLASS JobObjectInformationClass,
           LPVOID lpJobObjectInformation,
         DWORD cbJobObjectInformationLength
    );

__declspec(dllimport)
BOOL
__stdcall
IsProcessInJob (
             HANDLE ProcessHandle,
           HANDLE JobHandle,
            PBOOL Result
    );


__declspec(dllimport)
BOOL
__stdcall
CreateJobSet (
         ULONG NumJob,
           PJOB_SET_ARRAY UserJobSet,
         ULONG Flags);

__declspec(dllimport)
    
PVOID
__stdcall
AddVectoredExceptionHandler (
         ULONG First,
         PVECTORED_EXCEPTION_HANDLER Handler
    );

__declspec(dllimport)
ULONG
__stdcall
RemoveVectoredExceptionHandler (
         PVOID Handle
    );

__declspec(dllimport)
    
PVOID
__stdcall
AddVectoredContinueHandler (
         ULONG First,
         PVECTORED_EXCEPTION_HANDLER Handler
    );

__declspec(dllimport)
ULONG
__stdcall
RemoveVectoredContinueHandler (
         PVOID Handle
    );





__declspec(dllimport)
    
HANDLE
__stdcall
FindFirstVolumeA(
         LPSTR lpszVolumeName,
         DWORD cchBufferLength
    );
__declspec(dllimport)
    
HANDLE
__stdcall
FindFirstVolumeW(
         LPWSTR lpszVolumeName,
         DWORD cchBufferLength
    );




#line 10732 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeA(
         HANDLE hFindVolume,
         LPSTR lpszVolumeName,
            DWORD cchBufferLength
    );
__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeW(
         HANDLE hFindVolume,
         LPWSTR lpszVolumeName,
            DWORD cchBufferLength
    );




#line 10754 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindVolumeClose(
         HANDLE hFindVolume
    );

__declspec(dllimport)
    
HANDLE
__stdcall
FindFirstVolumeMountPointA(
         LPCSTR lpszRootPathName,
         LPSTR lpszVolumeMountPoint,
         DWORD cchBufferLength
    );
__declspec(dllimport)
    
HANDLE
__stdcall
FindFirstVolumeMountPointW(
         LPCWSTR lpszRootPathName,
         LPWSTR lpszVolumeMountPoint,
         DWORD cchBufferLength
    );




#line 10785 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeMountPointA(
         HANDLE hFindVolumeMountPoint,
         LPSTR lpszVolumeMountPoint,
         DWORD cchBufferLength
    );
__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeMountPointW(
         HANDLE hFindVolumeMountPoint,
         LPWSTR lpszVolumeMountPoint,
         DWORD cchBufferLength
    );




#line 10807 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindVolumeMountPointClose(
         HANDLE hFindVolumeMountPoint
    );

__declspec(dllimport)
BOOL
__stdcall
SetVolumeMountPointA(
         LPCSTR lpszVolumeMountPoint,
         LPCSTR lpszVolumeName
    );
__declspec(dllimport)
BOOL
__stdcall
SetVolumeMountPointW(
         LPCWSTR lpszVolumeMountPoint,
         LPCWSTR lpszVolumeName
    );




#line 10834 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
DeleteVolumeMountPointA(
         LPCSTR lpszVolumeMountPoint
    );
__declspec(dllimport)
BOOL
__stdcall
DeleteVolumeMountPointW(
         LPCWSTR lpszVolumeMountPoint
    );




#line 10852 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetVolumeNameForVolumeMountPointA(
         LPCSTR lpszVolumeMountPoint,
         LPSTR lpszVolumeName,
         DWORD cchBufferLength
    );
__declspec(dllimport)
BOOL
__stdcall
GetVolumeNameForVolumeMountPointW(
         LPCWSTR lpszVolumeMountPoint,
         LPWSTR lpszVolumeName,
         DWORD cchBufferLength
    );




#line 10874 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNameA(
         LPCSTR lpszFileName,
         LPSTR lpszVolumePathName,
         DWORD cchBufferLength
    );
__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNameW(
         LPCWSTR lpszFileName,
         LPWSTR lpszVolumePathName,
         DWORD cchBufferLength
    );




#line 10896 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNamesForVolumeNameA(
          LPCSTR lpszVolumeName,
              LPCH lpszVolumePathNames,
          DWORD cchBufferLength,
         PDWORD lpcchReturnLength
    );
__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNamesForVolumeNameW(
          LPCWSTR lpszVolumeName,
              LPWCH lpszVolumePathNames,
          DWORD cchBufferLength,
         PDWORD lpcchReturnLength
    );




#line 10920 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

#line 10922 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"












typedef struct tagACTCTXA {
    ULONG       cbSize;
    DWORD       dwFlags;
    LPCSTR      lpSource;
    USHORT      wProcessorArchitecture;
    LANGID      wLangId;
    LPCSTR      lpAssemblyDirectory;
    LPCSTR      lpResourceName;
    LPCSTR      lpApplicationName;
    HMODULE     hModule;
} ACTCTXA, *PACTCTXA;
typedef struct tagACTCTXW {
    ULONG       cbSize;
    DWORD       dwFlags;
    LPCWSTR     lpSource;
    USHORT      wProcessorArchitecture;
    LANGID      wLangId;
    LPCWSTR     lpAssemblyDirectory;
    LPCWSTR     lpResourceName;
    LPCWSTR     lpApplicationName;
    HMODULE     hModule;
} ACTCTXW, *PACTCTXW;

typedef ACTCTXW ACTCTX;
typedef PACTCTXW PACTCTX;



#line 10963 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

typedef const ACTCTXA *PCACTCTXA;
typedef const ACTCTXW *PCACTCTXW;

typedef ACTCTXW ACTCTX;
typedef PCACTCTXW PCACTCTX;



#line 10973 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

#line 10975 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"




__declspec(dllimport)
    
HANDLE
__stdcall
CreateActCtxA(
         PCACTCTXA pActCtx
    );
__declspec(dllimport)
    
HANDLE
__stdcall
CreateActCtxW(
         PCACTCTXW pActCtx
    );




#line 10998 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
void
__stdcall
AddRefActCtx(
         HANDLE hActCtx
    );


__declspec(dllimport)
void
__stdcall
ReleaseActCtx(
         HANDLE hActCtx
    );

__declspec(dllimport)
BOOL
__stdcall
ZombifyActCtx(
         HANDLE hActCtx
    );


__declspec(dllimport)
BOOL
__stdcall
ActivateActCtx(
         HANDLE hActCtx,
           ULONG_PTR *lpCookie
    );




__declspec(dllimport)
BOOL
__stdcall
DeactivateActCtx(
         DWORD dwFlags,
         ULONG_PTR ulCookie
    );

__declspec(dllimport)
BOOL
__stdcall
GetCurrentActCtx(
                  HANDLE *lphActCtx);

#line 11048 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"



typedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
} ACTCTX_SECTION_KEYED_DATA_2600, *PACTCTX_SECTION_KEYED_DATA_2600;
typedef const ACTCTX_SECTION_KEYED_DATA_2600 * PCACTCTX_SECTION_KEYED_DATA_2600;

typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
    PVOID lpInformation;
    PVOID lpSectionBase;
    ULONG ulSectionLength;
    PVOID lpSectionGlobalDataBase;
    ULONG ulSectionGlobalDataLength;
} ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;

typedef struct tagACTCTX_SECTION_KEYED_DATA {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;

    ULONG ulFlags;
    ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
} ACTCTX_SECTION_KEYED_DATA, *PACTCTX_SECTION_KEYED_DATA;
typedef const ACTCTX_SECTION_KEYED_DATA * PCACTCTX_SECTION_KEYED_DATA;





#line 11096 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"




__declspec(dllimport)
BOOL
__stdcall
FindActCtxSectionStringA(
               DWORD dwFlags,
      const GUID *lpExtensionGuid,
               ULONG ulSectionId,
               LPCSTR lpStringToFind,
              PACTCTX_SECTION_KEYED_DATA ReturnedData
    );
__declspec(dllimport)
BOOL
__stdcall
FindActCtxSectionStringW(
               DWORD dwFlags,
      const GUID *lpExtensionGuid,
               ULONG ulSectionId,
               LPCWSTR lpStringToFind,
              PACTCTX_SECTION_KEYED_DATA ReturnedData
    );




#line 11125 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindActCtxSectionGuid(
               DWORD dwFlags,
      const GUID *lpExtensionGuid,
               ULONG ulSectionId,
             const GUID *lpGuidToFind,
              PACTCTX_SECTION_KEYED_DATA ReturnedData
    );

#line 11138 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"






typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
    HANDLE  hActCtx;
    DWORD   dwFlags;
} ACTIVATION_CONTEXT_BASIC_INFORMATION, *PACTIVATION_CONTEXT_BASIC_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION *PCACTIVATION_CONTEXT_BASIC_INFORMATION;



#line 11154 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
#line 11155 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"






#line 11162 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"




























__declspec(dllimport)
BOOL
__stdcall
QueryActCtxW(
              DWORD dwFlags,
              HANDLE hActCtx,
            PVOID pvSubInstance,
              ULONG ulInfoClass,
             PVOID pvBuffer,
              SIZE_T cbBuffer,
           SIZE_T *pcbWrittenOrRequired
    );

typedef BOOL (__stdcall * PQUERYACTCTXW_FUNC)(
              DWORD dwFlags,
              HANDLE hActCtx,
            PVOID pvSubInstance,
              ULONG ulInfoClass,
             PVOID pvBuffer,
              SIZE_T cbBuffer,
           SIZE_T *pcbWrittenOrRequired
    );

#line 11214 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
ProcessIdToSessionId(
          DWORD dwProcessId,
         DWORD *pSessionId
    );
















#line 11240 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetLogicalProcessorInformation(
           PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer,
         PDWORD ReturnedLength
    );





__declspec(dllimport)
BOOL
__stdcall
GetNumaHighestNodeNumber(
         PULONG HighestNodeNumber
    );

__declspec(dllimport)
BOOL
__stdcall
GetNumaProcessorNode(
          UCHAR Processor,
         PUCHAR NodeNumber
    );

__declspec(dllimport)
BOOL
__stdcall
GetNumaNodeProcessorMask(
          UCHAR Node,
         PULONGLONG ProcessorMask
    );

__declspec(dllimport)
BOOL
__stdcall
GetNumaAvailableMemoryNode(
          UCHAR Node,
         PULONGLONG AvailableBytes
    );






#line 11290 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"
#line 11291 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


}
#line 11295 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"



#line 11299 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winbase.h"


#line 163 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"























#line 25 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"









#line 35 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


extern "C" {
#line 39 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
















































#line 88 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"




#line 93 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

































#line 127 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"













#line 141 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

















#line 159 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
















#line 176 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


#line 179 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"














































































#line 258 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"









typedef struct _DRAWPATRECT {
        POINT ptPosition;
        POINT ptSize;
        WORD wStyle;
        WORD wPattern;
} DRAWPATRECT, *PDRAWPATRECT;
#line 274 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

#line 276 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"







































































































typedef struct _PSINJECTDATA {

    DWORD   DataBytes;      
    WORD    InjectionPoint; 
    WORD    PageNumber;     

    

} PSINJECTDATA, *PPSINJECTDATA;

































































typedef struct _PSFEATURE_OUTPUT {

    BOOL bPageIndependent;
    BOOL bSetPageDevice;

} PSFEATURE_OUTPUT, *PPSFEATURE_OUTPUT;





typedef struct _PSFEATURE_CUSTPAPER {

    LONG lOrientation;
    LONG lWidth;
    LONG lHeight;
    LONG lWidthOffset;
    LONG lHeightOffset;

} PSFEATURE_CUSTPAPER, *PPSFEATURE_CUSTPAPER;
















































typedef struct  tagXFORM
  {
    FLOAT   eM11;
    FLOAT   eM12;
    FLOAT   eM21;
    FLOAT   eM22;
    FLOAT   eDx;
    FLOAT   eDy;
  } XFORM, *PXFORM,  *LPXFORM;


typedef struct tagBITMAP
  {
    LONG        bmType;
    LONG        bmWidth;
    LONG        bmHeight;
    LONG        bmWidthBytes;
    WORD        bmPlanes;
    WORD        bmBitsPixel;
    LPVOID      bmBits;
  } BITMAP, *PBITMAP,  *NPBITMAP,  *LPBITMAP;

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack1.h"























#pragma warning(disable:4103)

#pragma pack(push,1)


#line 30 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack1.h"


#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack1.h"
#line 34 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack1.h"
#line 544 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
typedef struct tagRGBTRIPLE {
        BYTE    rgbtBlue;
        BYTE    rgbtGreen;
        BYTE    rgbtRed;
} RGBTRIPLE;
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"


#line 36 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"
#line 37 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"
#line 550 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

typedef struct tagRGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD * LPRGBQUAD;


















typedef LONG   LCSCSTYPE;


typedef LONG    LCSGAMUTMATCH;


























typedef long            FXPT16DOT16,  *LPFXPT16DOT16;
typedef long            FXPT2DOT30,  *LPFXPT2DOT30;




typedef struct tagCIEXYZ
{
        FXPT2DOT30 ciexyzX;
        FXPT2DOT30 ciexyzY;
        FXPT2DOT30 ciexyzZ;
} CIEXYZ;
typedef CIEXYZ   *LPCIEXYZ;

typedef struct tagICEXYZTRIPLE
{
        CIEXYZ  ciexyzRed;
        CIEXYZ  ciexyzGreen;
        CIEXYZ  ciexyzBlue;
} CIEXYZTRIPLE;
typedef CIEXYZTRIPLE     *LPCIEXYZTRIPLE;






typedef struct tagLOGCOLORSPACEA {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    CHAR   lcsFilename[260];
} LOGCOLORSPACEA, *LPLOGCOLORSPACEA;
typedef struct tagLOGCOLORSPACEW {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    WCHAR  lcsFilename[260];
} LOGCOLORSPACEW, *LPLOGCOLORSPACEW;

typedef LOGCOLORSPACEW LOGCOLORSPACE;
typedef LPLOGCOLORSPACEW LPLOGCOLORSPACE;



#line 664 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

#line 666 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


typedef struct tagBITMAPCOREHEADER {
        DWORD   bcSize;                 
        WORD    bcWidth;
        WORD    bcHeight;
        WORD    bcPlanes;
        WORD    bcBitCount;
} BITMAPCOREHEADER,  *LPBITMAPCOREHEADER, *PBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} BITMAPINFOHEADER,  *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;


typedef struct {
        DWORD        bV4Size;
        LONG         bV4Width;
        LONG         bV4Height;
        WORD         bV4Planes;
        WORD         bV4BitCount;
        DWORD        bV4V4Compression;
        DWORD        bV4SizeImage;
        LONG         bV4XPelsPerMeter;
        LONG         bV4YPelsPerMeter;
        DWORD        bV4ClrUsed;
        DWORD        bV4ClrImportant;
        DWORD        bV4RedMask;
        DWORD        bV4GreenMask;
        DWORD        bV4BlueMask;
        DWORD        bV4AlphaMask;
        DWORD        bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD        bV4GammaRed;
        DWORD        bV4GammaGreen;
        DWORD        bV4GammaBlue;
} BITMAPV4HEADER,  *LPBITMAPV4HEADER, *PBITMAPV4HEADER;
#line 714 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


typedef struct {
        DWORD        bV5Size;
        LONG         bV5Width;
        LONG         bV5Height;
        WORD         bV5Planes;
        WORD         bV5BitCount;
        DWORD        bV5Compression;
        DWORD        bV5SizeImage;
        LONG         bV5XPelsPerMeter;
        LONG         bV5YPelsPerMeter;
        DWORD        bV5ClrUsed;
        DWORD        bV5ClrImportant;
        DWORD        bV5RedMask;
        DWORD        bV5GreenMask;
        DWORD        bV5BlueMask;
        DWORD        bV5AlphaMask;
        DWORD        bV5CSType;
        CIEXYZTRIPLE bV5Endpoints;
        DWORD        bV5GammaRed;
        DWORD        bV5GammaGreen;
        DWORD        bV5GammaBlue;
        DWORD        bV5Intent;
        DWORD        bV5ProfileData;
        DWORD        bV5ProfileSize;
        DWORD        bV5Reserved;
} BITMAPV5HEADER,  *LPBITMAPV5HEADER, *PBITMAPV5HEADER;




#line 747 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"









#line 757 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

typedef struct tagBITMAPINFO {
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[1];
} BITMAPINFO,  *LPBITMAPINFO, *PBITMAPINFO;

typedef struct tagBITMAPCOREINFO {
    BITMAPCOREHEADER    bmciHeader;
    RGBTRIPLE           bmciColors[1];
} BITMAPCOREINFO,  *LPBITMAPCOREINFO, *PBITMAPCOREINFO;

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"


#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"
#line 34 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"
#line 769 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
typedef struct tagBITMAPFILEHEADER {
        WORD    bfType;
        DWORD   bfSize;
        WORD    bfReserved1;
        WORD    bfReserved2;
        DWORD   bfOffBits;
} BITMAPFILEHEADER,  *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"


#line 36 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"
#line 37 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"
#line 777 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"





typedef struct tagFONTSIGNATURE
{
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE, *LPFONTSIGNATURE;

typedef struct tagCHARSETINFO
{
    UINT ciCharset;
    UINT ciACP;
    FONTSIGNATURE fs;
} CHARSETINFO, *PCHARSETINFO,  *NPCHARSETINFO,  *LPCHARSETINFO;






typedef struct tagLOCALESIGNATURE
{
    DWORD lsUsb[4];
    DWORD lsCsbDefault[2];
    DWORD lsCsbSupported[2];
} LOCALESIGNATURE, *PLOCALESIGNATURE, *LPLOCALESIGNATURE;


#line 809 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
#line 810 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"




typedef struct tagHANDLETABLE
  {
    HGDIOBJ     objectHandle[1];
  } HANDLETABLE, *PHANDLETABLE,  *LPHANDLETABLE;

typedef struct tagMETARECORD
  {
    DWORD       rdSize;
    WORD        rdFunction;
    WORD        rdParm[1];
  } METARECORD;
typedef struct tagMETARECORD  *PMETARECORD;
typedef struct tagMETARECORD   *LPMETARECORD;

typedef struct tagMETAFILEPICT
  {
    LONG        mm;
    LONG        xExt;
    LONG        yExt;
    HMETAFILE   hMF;
  } METAFILEPICT,  *LPMETAFILEPICT;

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"


#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"
#line 34 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"
#line 837 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
typedef struct tagMETAHEADER
{
    WORD        mtType;
    WORD        mtHeaderSize;
    WORD        mtVersion;
    DWORD       mtSize;
    WORD        mtNoObjects;
    DWORD       mtMaxRecord;
    WORD        mtNoParameters;
} METAHEADER;
typedef struct tagMETAHEADER  *PMETAHEADER;
typedef struct tagMETAHEADER   *LPMETAHEADER;

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"


#line 36 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"
#line 37 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"
#line 851 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


typedef struct tagENHMETARECORD
{
    DWORD   iType;              
    DWORD   nSize;              
    DWORD   dParm[1];           
} ENHMETARECORD, *PENHMETARECORD, *LPENHMETARECORD;

typedef struct tagENHMETAHEADER
{
    DWORD   iType;              
    DWORD   nSize;              
                                
    RECTL   rclBounds;          
    RECTL   rclFrame;           
    DWORD   dSignature;         
    DWORD   nVersion;           
    DWORD   nBytes;             
    DWORD   nRecords;           
    WORD    nHandles;           
                                
    WORD    sReserved;          
    DWORD   nDescription;       
                                
    DWORD   offDescription;     
                                
    DWORD   nPalEntries;        
    SIZEL   szlDevice;          
    SIZEL   szlMillimeters;     

    DWORD   cbPixelFormat;      
                                
    DWORD   offPixelFormat;     
                                
    DWORD   bOpenGL;            
                                
#line 889 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

    SIZEL   szlMicrometers;     
#line 892 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

} ENHMETAHEADER, *PENHMETAHEADER, *LPENHMETAHEADER;

#line 896 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"













    typedef WCHAR BCHAR;


#line 913 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"



typedef struct tagTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
} TEXTMETRICA, *PTEXTMETRICA,  *NPTEXTMETRICA,  *LPTEXTMETRICA;
typedef struct tagTEXTMETRICW
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
} TEXTMETRICW, *PTEXTMETRICW,  *NPTEXTMETRICW,  *LPTEXTMETRICW;

typedef TEXTMETRICW TEXTMETRIC;
typedef PTEXTMETRICW PTEXTMETRIC;
typedef NPTEXTMETRICW NPTEXTMETRIC;
typedef LPTEXTMETRICW LPTEXTMETRIC;





#line 973 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
#line 974 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"















#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack4.h"























#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack4.h"


#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack4.h"
#line 34 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack4.h"
#line 990 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
typedef struct tagNEWTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICA, *PNEWTEXTMETRICA,  *NPNEWTEXTMETRICA,  *LPNEWTEXTMETRICA;
typedef struct tagNEWTEXTMETRICW
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICW, *PNEWTEXTMETRICW,  *NPNEWTEXTMETRICW,  *LPNEWTEXTMETRICW;

typedef NEWTEXTMETRICW NEWTEXTMETRIC;
typedef PNEWTEXTMETRICW PNEWTEXTMETRIC;
typedef NPNEWTEXTMETRICW NPNEWTEXTMETRIC;
typedef LPNEWTEXTMETRICW LPNEWTEXTMETRIC;





#line 1055 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"


#line 36 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"
#line 37 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"
#line 1056 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


typedef struct tagNEWTEXTMETRICEXA
{
    NEWTEXTMETRICA  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXA;
typedef struct tagNEWTEXTMETRICEXW
{
    NEWTEXTMETRICW  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXW;

typedef NEWTEXTMETRICEXW NEWTEXTMETRICEX;


#line 1073 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
#line 1074 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

#line 1076 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"



typedef struct tagPELARRAY
  {
    LONG        paXCount;
    LONG        paYCount;
    LONG        paXExt;
    LONG        paYExt;
    BYTE        paRGBs;
  } PELARRAY, *PPELARRAY,  *NPPELARRAY,  *LPPELARRAY;


typedef struct tagLOGBRUSH
  {
    UINT        lbStyle;
    COLORREF    lbColor;
    ULONG_PTR    lbHatch;    
  } LOGBRUSH, *PLOGBRUSH,  *NPLOGBRUSH,  *LPLOGBRUSH;

typedef struct tagLOGBRUSH32
  {
    UINT        lbStyle;
    COLORREF    lbColor;
    ULONG       lbHatch;
  } LOGBRUSH32, *PLOGBRUSH32,  *NPLOGBRUSH32,  *LPLOGBRUSH32;

typedef LOGBRUSH            PATTERN;
typedef PATTERN             *PPATTERN;
typedef PATTERN         *NPPATTERN;
typedef PATTERN          *LPPATTERN;


typedef struct tagLOGPEN
  {
    UINT        lopnStyle;
    POINT       lopnWidth;
    COLORREF    lopnColor;
  } LOGPEN, *PLOGPEN,  *NPLOGPEN,  *LPLOGPEN;

typedef struct tagEXTLOGPEN {
    DWORD       elpPenStyle;
    DWORD       elpWidth;
    UINT        elpBrushStyle;
    COLORREF    elpColor;
    ULONG_PTR    elpHatch;     
    DWORD       elpNumEntries;
    DWORD       elpStyleEntry[1];
} EXTLOGPEN, *PEXTLOGPEN,  *NPEXTLOGPEN,  *LPEXTLOGPEN;



typedef struct tagPALETTEENTRY {
    BYTE        peRed;
    BYTE        peGreen;
    BYTE        peBlue;
    BYTE        peFlags;
} PALETTEENTRY, *PPALETTEENTRY,  *LPPALETTEENTRY;
#line 1135 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"




typedef struct tagLOGPALETTE {
    WORD        palVersion;
    WORD        palNumEntries;
    PALETTEENTRY        palPalEntry[1];
} LOGPALETTE, *PLOGPALETTE,  *NPLOGPALETTE,  *LPLOGPALETTE;
#line 1145 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"





typedef struct tagLOGFONTA
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    CHAR      lfFaceName[32];
} LOGFONTA, *PLOGFONTA,  *NPLOGFONTA,  *LPLOGFONTA;
typedef struct tagLOGFONTW
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    WCHAR     lfFaceName[32];
} LOGFONTW, *PLOGFONTW,  *NPLOGFONTW,  *LPLOGFONTW;

typedef LOGFONTW LOGFONT;
typedef PLOGFONTW PLOGFONT;
typedef NPLOGFONTW NPLOGFONT;
typedef LPLOGFONTW LPLOGFONT;





#line 1195 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"




typedef struct tagENUMLOGFONTA
{
    LOGFONTA elfLogFont;
    BYTE     elfFullName[64];
    BYTE     elfStyle[32];
} ENUMLOGFONTA, * LPENUMLOGFONTA;

typedef struct tagENUMLOGFONTW
{
    LOGFONTW elfLogFont;
    WCHAR    elfFullName[64];
    WCHAR    elfStyle[32];
} ENUMLOGFONTW, * LPENUMLOGFONTW;

typedef ENUMLOGFONTW ENUMLOGFONT;
typedef LPENUMLOGFONTW LPENUMLOGFONT;



#line 1219 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


typedef struct tagENUMLOGFONTEXA
{
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[64];
    BYTE        elfStyle[32];
    BYTE        elfScript[32];
} ENUMLOGFONTEXA,  *LPENUMLOGFONTEXA;
typedef struct tagENUMLOGFONTEXW
{
    LOGFONTW    elfLogFont;
    WCHAR       elfFullName[64];
    WCHAR       elfStyle[32];
    WCHAR       elfScript[32];
} ENUMLOGFONTEXW,  *LPENUMLOGFONTEXW;

typedef ENUMLOGFONTEXW ENUMLOGFONTEX;
typedef LPENUMLOGFONTEXW LPENUMLOGFONTEX;



#line 1242 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
#line 1243 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"




























#line 1272 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"



#line 1276 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"



#line 1280 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"






#line 1287 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"








































#line 1328 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"




                                    

                                    

                                    



































typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, * LPPANOSE;

















































































































typedef struct tagEXTLOGFONTA {
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[64];
    BYTE        elfStyle[32];
    DWORD       elfVersion;     
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[4];
    DWORD       elfCulture;     
    PANOSE      elfPanose;
} EXTLOGFONTA, *PEXTLOGFONTA,  *NPEXTLOGFONTA,  *LPEXTLOGFONTA;
typedef struct tagEXTLOGFONTW {
    LOGFONTW    elfLogFont;
    WCHAR       elfFullName[64];
    WCHAR       elfStyle[32];
    DWORD       elfVersion;     
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[4];
    DWORD       elfCulture;     
    PANOSE      elfPanose;
} EXTLOGFONTW, *PEXTLOGFONTW,  *NPEXTLOGFONTW,  *LPEXTLOGFONTW;

typedef EXTLOGFONTW EXTLOGFONT;
typedef PEXTLOGFONTW PEXTLOGFONT;
typedef NPEXTLOGFONTW NPEXTLOGFONT;
typedef LPEXTLOGFONTW LPEXTLOGFONT;





#line 1533 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
















































































#line 1614 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"




#line 1619 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"







#line 1627 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

































































































                             

                             

                             





#line 1735 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"










































































#line 1810 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"





































#line 1848 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"



























typedef struct _devicemodeA {
    BYTE   dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {
      
      struct {
        short dmOrientation;
        short dmPaperSize;
        short dmPaperLength;
        short dmPaperWidth;
        short dmScale;
        short dmCopies;
        short dmDefaultSource;
        short dmPrintQuality;
      };
      
      struct {
        POINTL dmPosition;
        DWORD  dmDisplayOrientation;
        DWORD  dmDisplayFixedOutput; 
      };
    };
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    BYTE   dmFormName[32];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    union {
        DWORD  dmDisplayFlags;
        DWORD  dmNup;
    };
    DWORD  dmDisplayFrequency;

    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;

    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
#line 1927 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
#line 1928 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
} DEVMODEA, *PDEVMODEA, *NPDEVMODEA, *LPDEVMODEA;
typedef struct _devicemodeW {
    WCHAR  dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {
      
      struct {
        short dmOrientation;
        short dmPaperSize;
        short dmPaperLength;
        short dmPaperWidth;
        short dmScale;
        short dmCopies;
        short dmDefaultSource;
        short dmPrintQuality;
      };
      
      struct {
        POINTL dmPosition;
        DWORD  dmDisplayOrientation;
        DWORD  dmDisplayFixedOutput; 
      };
    };
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    WCHAR  dmFormName[32];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    union {
        DWORD  dmDisplayFlags;
        DWORD  dmNup;
    };
    DWORD  dmDisplayFrequency;

    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;

    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
#line 1981 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
#line 1982 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
} DEVMODEW, *PDEVMODEW, *NPDEVMODEW, *LPDEVMODEW;

typedef DEVMODEW DEVMODE;
typedef PDEVMODEW PDEVMODE;
typedef NPDEVMODEW NPDEVMODE;
typedef LPDEVMODEW LPDEVMODE;





#line 1994 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"








#line 2003 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"










#line 2014 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


#line 2017 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"






















#line 2040 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


#line 2043 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"












































































#line 2120 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"




















































#line 2173 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"







#line 2181 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"












































#line 2226 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
















#line 2243 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

















































#line 2293 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

typedef struct _DISPLAY_DEVICEA {
    DWORD  cb;
    CHAR   DeviceName[32];
    CHAR   DeviceString[128];
    DWORD  StateFlags;
    CHAR   DeviceID[128];
    CHAR   DeviceKey[128];
} DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;
typedef struct _DISPLAY_DEVICEW {
    DWORD  cb;
    WCHAR  DeviceName[32];
    WCHAR  DeviceString[128];
    DWORD  StateFlags;
    WCHAR  DeviceID[128];
    WCHAR  DeviceKey[128];
} DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;

typedef DISPLAY_DEVICEW DISPLAY_DEVICE;
typedef PDISPLAY_DEVICEW PDISPLAY_DEVICE;
typedef LPDISPLAY_DEVICEW LPDISPLAY_DEVICE;




#line 2319 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"




















typedef struct _RGNDATAHEADER {
    DWORD   dwSize;
    DWORD   iType;
    DWORD   nCount;
    DWORD   nRgnSize;
    RECT    rcBound;
} RGNDATAHEADER, *PRGNDATAHEADER;

typedef struct _RGNDATA {
    RGNDATAHEADER   rdh;
    char            Buffer[1];
} RGNDATA, *PRGNDATA,  *NPRGNDATA,  *LPRGNDATA;





typedef struct _ABC {
    int     abcA;
    UINT    abcB;
    int     abcC;
} ABC, *PABC,  *NPABC,  *LPABC;

typedef struct _ABCFLOAT {
    FLOAT   abcfA;
    FLOAT   abcfB;
    FLOAT   abcfC;
} ABCFLOAT, *PABCFLOAT,  *NPABCFLOAT,  *LPABCFLOAT;






typedef struct _OUTLINETEXTMETRICA {
    UINT    otmSize;
    TEXTMETRICA otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRICA, *POUTLINETEXTMETRICA,  *NPOUTLINETEXTMETRICA,  *LPOUTLINETEXTMETRICA;
typedef struct _OUTLINETEXTMETRICW {
    UINT    otmSize;
    TEXTMETRICW otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRICW, *POUTLINETEXTMETRICW,  *NPOUTLINETEXTMETRICW,  *LPOUTLINETEXTMETRICW;

typedef OUTLINETEXTMETRICW OUTLINETEXTMETRIC;
typedef POUTLINETEXTMETRICW POUTLINETEXTMETRIC;
typedef NPOUTLINETEXTMETRICW NPOUTLINETEXTMETRIC;
typedef LPOUTLINETEXTMETRICW LPOUTLINETEXTMETRIC;





#line 2452 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"





#line 2458 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


typedef struct tagPOLYTEXTA
{
    int       x;
    int       y;
    UINT      n;
    LPCSTR    lpstr;
    UINT      uiFlags;
    RECT      rcl;
    int      *pdx;
} POLYTEXTA, *PPOLYTEXTA,  *NPPOLYTEXTA,  *LPPOLYTEXTA;
typedef struct tagPOLYTEXTW
{
    int       x;
    int       y;
    UINT      n;
    LPCWSTR   lpstr;
    UINT      uiFlags;
    RECT      rcl;
    int      *pdx;
} POLYTEXTW, *PPOLYTEXTW,  *NPPOLYTEXTW,  *LPPOLYTEXTW;

typedef POLYTEXTW POLYTEXT;
typedef PPOLYTEXTW PPOLYTEXT;
typedef NPPOLYTEXTW NPPOLYTEXT;
typedef LPPOLYTEXTW LPPOLYTEXT;





#line 2491 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

typedef struct _FIXED {

    WORD    fract;
    short   value;



#line 2500 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
} FIXED;


typedef struct _MAT2 {
     FIXED  eM11;
     FIXED  eM12;
     FIXED  eM21;
     FIXED  eM22;
} MAT2,  *LPMAT2;



typedef struct _GLYPHMETRICS {
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    short   gmCellIncX;
    short   gmCellIncY;
} GLYPHMETRICS,  *LPGLYPHMETRICS;













#line 2533 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"



#line 2537 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"







typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, * LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    WORD    wType;
    WORD    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, * LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, * LPTTPOLYGONHEADER;













































typedef struct tagGCP_RESULTSA
    {
    DWORD   lStructSize;
    LPSTR     lpOutString;
    UINT  *lpOrder;
    int   *lpDx;
    int   *lpCaretPos;
    LPSTR   lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
    } GCP_RESULTSA, * LPGCP_RESULTSA;
typedef struct tagGCP_RESULTSW
    {
    DWORD   lStructSize;
    LPWSTR    lpOutString;
    UINT  *lpOrder;
    int   *lpDx;
    int   *lpCaretPos;
    LPSTR   lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
    } GCP_RESULTSW, * LPGCP_RESULTSW;

typedef GCP_RESULTSW GCP_RESULTS;
typedef LPGCP_RESULTSW LPGCP_RESULTS;



#line 2639 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
#line 2640 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

typedef struct _RASTERIZER_STATUS {
    short   nSize;
    short   wFlags;
    short   nLanguageID;
} RASTERIZER_STATUS,  *LPRASTERIZER_STATUS;






typedef struct tagPIXELFORMATDESCRIPTOR
{
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;
    BYTE  iPixelType;
    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAccumBits;
    BYTE  cAccumRedBits;
    BYTE  cAccumGreenBits;
    BYTE  cAccumBlueBits;
    BYTE  cAccumAlphaBits;
    BYTE  cDepthBits;
    BYTE  cStencilBits;
    BYTE  cAuxBuffers;
    BYTE  iLayerType;
    BYTE  bReserved;
    DWORD dwLayerMask;
    DWORD dwVisibleMask;
    DWORD dwDamageMask;
} PIXELFORMATDESCRIPTOR, *PPIXELFORMATDESCRIPTOR,  *LPPIXELFORMATDESCRIPTOR;

































typedef int (__stdcall* OLDFONTENUMPROCA)(const LOGFONTA *, const TEXTMETRICA *, DWORD, LPARAM);
typedef int (__stdcall* OLDFONTENUMPROCW)(const LOGFONTW *, const TEXTMETRICW *, DWORD, LPARAM);




#line 2721 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"








#line 2730 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

typedef OLDFONTENUMPROCA    FONTENUMPROCA;
typedef OLDFONTENUMPROCW    FONTENUMPROCW;

typedef FONTENUMPROCW FONTENUMPROC;


#line 2738 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

typedef int (__stdcall* GOBJENUMPROC)(LPVOID, LPARAM);
typedef void (__stdcall* LINEDDAPROC)(int, int, LPARAM);











#line 2753 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"



__declspec(dllimport) int __stdcall AddFontResourceA(     LPCSTR);
__declspec(dllimport) int __stdcall AddFontResourceW(     LPCWSTR);




#line 2763 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) BOOL	__stdcall AnimatePalette(      HPALETTE hPal,      UINT iStartIndex,     	UINT cEntries,        const PALETTEENTRY * ppe);
__declspec(dllimport) BOOL	__stdcall Arc(      HDC hdc,      int x1,      int y1,      int x2,      int y2,      int x3,      int y3,      int x4,      int y4);
__declspec(dllimport) BOOL	__stdcall BitBlt(      HDC hdc,      int x,      int y,      int cx,      int cy,        HDC hdcSrc,      int x1,      int y1,      DWORD rop);
__declspec(dllimport) BOOL  __stdcall CancelDC(      HDC hdc);
__declspec(dllimport) BOOL  __stdcall Chord(      HDC hdc,      int x1,      int y1,      int x2,      int y2,      int x3,      int y3,      int x4,      int y4);
__declspec(dllimport) int   __stdcall ChoosePixelFormat(      HDC hdc,      const PIXELFORMATDESCRIPTOR *ppfd);
__declspec(dllimport) HMETAFILE  __stdcall CloseMetaFile(      HDC hdc);
__declspec(dllimport) int     __stdcall CombineRgn(        HRGN hrgnDst,        HRGN hrgnSrc1,        HRGN hrgnSrc2,      int iMode);
__declspec(dllimport) HMETAFILE __stdcall CopyMetaFileA(      HMETAFILE,        LPCSTR);
__declspec(dllimport) HMETAFILE __stdcall CopyMetaFileW(      HMETAFILE,        LPCWSTR);




#line 2779 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) HBITMAP __stdcall CreateBitmap(      int nWidth,      int nHeight,      UINT nPlanes,      UINT nBitCount,        const void *lpBits);
__declspec(dllimport) HBITMAP __stdcall CreateBitmapIndirect(      const BITMAP *pbm);
__declspec(dllimport) HBRUSH  __stdcall CreateBrushIndirect(      const LOGBRUSH *plbrush);
__declspec(dllimport) HBITMAP __stdcall CreateCompatibleBitmap(      HDC hdc,      int cx,      int cy);
__declspec(dllimport) HBITMAP __stdcall CreateDiscardableBitmap(      HDC hdc,      int cx,      int cy);
__declspec(dllimport) HDC     __stdcall CreateCompatibleDC(        HDC hdc);
__declspec(dllimport) HDC     __stdcall CreateDCA(        LPCSTR pwszDriver,        LPCSTR pwszDevice,        LPCSTR pszPort,        const DEVMODEA * pdm);
__declspec(dllimport) HDC     __stdcall CreateDCW(        LPCWSTR pwszDriver,        LPCWSTR pwszDevice,        LPCWSTR pszPort,        const DEVMODEW * pdm);




#line 2792 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) HBITMAP __stdcall CreateDIBitmap(      HDC hdc,        const BITMAPINFOHEADER *pbmih,      DWORD flInit,        const void *pjBits,        const BITMAPINFO *pbmi,      UINT iUsage);
__declspec(dllimport) HBRUSH  __stdcall CreateDIBPatternBrush(      HGLOBAL h,      UINT iUsage);
__declspec(dllimport) HBRUSH  __stdcall CreateDIBPatternBrushPt(      const void *lpPackedDIB,      UINT iUsage);
__declspec(dllimport) HRGN    __stdcall CreateEllipticRgn(      int x1,      int y1,      int x2,      int y2);
__declspec(dllimport) HRGN    __stdcall CreateEllipticRgnIndirect(      const RECT *lprect);
__declspec(dllimport) HFONT   __stdcall CreateFontIndirectA(      const LOGFONTA *lplf);
__declspec(dllimport) HFONT   __stdcall CreateFontIndirectW(      const LOGFONTW *lplf);




#line 2804 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) HFONT   __stdcall CreateFontA(      int cHeight,      int cWidth,      int cEscapement,      int cOrientation,      int cWeight,      DWORD bItalic,
                                  DWORD bUnderline,      DWORD bStrikeOut,      DWORD iCharSet,      DWORD iOutPrecision,      DWORD iClipPrecision,
                                  DWORD iQuality,      DWORD iPitchAndFamily,        LPCSTR pszFaceName);
__declspec(dllimport) HFONT   __stdcall CreateFontW(      int cHeight,      int cWidth,      int cEscapement,      int cOrientation,      int cWeight,      DWORD bItalic,
                                  DWORD bUnderline,      DWORD bStrikeOut,      DWORD iCharSet,      DWORD iOutPrecision,      DWORD iClipPrecision,
                                  DWORD iQuality,      DWORD iPitchAndFamily,        LPCWSTR pszFaceName);




#line 2815 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) HBRUSH  __stdcall CreateHatchBrush(      int iHatch,      COLORREF color);
__declspec(dllimport) HDC     __stdcall CreateICA(        LPCSTR pszDriver,        LPCSTR pszDevice,        LPCSTR pszPort,        const DEVMODEA * pdm);
__declspec(dllimport) HDC     __stdcall CreateICW(        LPCWSTR pszDriver,        LPCWSTR pszDevice,        LPCWSTR pszPort,        const DEVMODEW * pdm);




#line 2824 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) HDC     __stdcall CreateMetaFileA(        LPCSTR pszFile);
__declspec(dllimport) HDC     __stdcall CreateMetaFileW(        LPCWSTR pszFile);




#line 2831 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) HPALETTE __stdcall CreatePalette(      const LOGPALETTE * plpal);
__declspec(dllimport) HPEN    __stdcall CreatePen(      int iStyle,      int cWidth,      COLORREF color);
__declspec(dllimport) HPEN    __stdcall CreatePenIndirect(      const LOGPEN *plpen);
__declspec(dllimport) HRGN    __stdcall CreatePolyPolygonRgn(       const POINT *pptl,
                                                     const INT  *pc,
                                                     int cPoly,
                                                     int iMode);
__declspec(dllimport) HBRUSH  __stdcall CreatePatternBrush(      HBITMAP hbm);
__declspec(dllimport) HRGN    __stdcall CreateRectRgn(      int x1,      int y1,      int x2,      int y2);
__declspec(dllimport) HRGN    __stdcall CreateRectRgnIndirect(      const RECT *lprect);
__declspec(dllimport) HRGN    __stdcall CreateRoundRectRgn(      int x1,      int y1,      int x2,      int y2,      int w,      int h);
__declspec(dllimport) BOOL    __stdcall CreateScalableFontResourceA(      DWORD fdwHidden,      LPCSTR lpszFont,      LPCSTR lpszFile,        LPCSTR lpszPath);
__declspec(dllimport) BOOL    __stdcall CreateScalableFontResourceW(      DWORD fdwHidden,      LPCWSTR lpszFont,      LPCWSTR lpszFile,        LPCWSTR lpszPath);




#line 2849 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) HBRUSH  __stdcall CreateSolidBrush(      COLORREF color);

__declspec(dllimport) BOOL __stdcall DeleteDC(      HDC hdc);
__declspec(dllimport) BOOL __stdcall DeleteMetaFile(      HMETAFILE hmf);
__declspec(dllimport) BOOL __stdcall DeleteObject(      HGDIOBJ ho);
__declspec(dllimport) int  __stdcall DescribePixelFormat(       HDC hdc, 
                                                 int iPixelFormat, 
                                                 UINT nBytes,
                                                   LPPIXELFORMATDESCRIPTOR ppfd);





typedef UINT   (__stdcall* LPFNDEVMODE)(HWND, HMODULE, LPDEVMODE, LPSTR, LPSTR, LPDEVMODE, LPSTR, UINT);

typedef DWORD  (__stdcall* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE);






































#line 2905 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

















#line 2923 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

















#line 2941 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport)
int
__stdcall
DeviceCapabilitiesA(
         LPCSTR pDevice,
           LPCSTR pPort,
         WORD fwCapability,
           LPSTR pOutput,
           const DEVMODEA * pDevMode
    );
__declspec(dllimport)
int
__stdcall
DeviceCapabilitiesW(
         LPCWSTR pDevice,
           LPCWSTR pPort,
         WORD fwCapability,
           LPWSTR pOutput,
           const DEVMODEW * pDevMode
    );




#line 2967 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) int  __stdcall DrawEscape(        HDC    hdc,         
                                         int    iEscape,     
                                         int    cjIn,        
                                             LPCSTR lpIn);
__declspec(dllimport) BOOL __stdcall Ellipse(      HDC hdc,      int left,      int top,       int right,      int bottom);


__declspec(dllimport) int  __stdcall EnumFontFamiliesExA(      HDC hdc,      LPLOGFONTA lpLogfont,      FONTENUMPROCA lpProc,      LPARAM lParam,      DWORD dwFlags);
__declspec(dllimport) int  __stdcall EnumFontFamiliesExW(      HDC hdc,      LPLOGFONTW lpLogfont,      FONTENUMPROCW lpProc,      LPARAM lParam,      DWORD dwFlags);




#line 2982 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
#line 2983 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) int  __stdcall EnumFontFamiliesA(      HDC hdc,        LPCSTR lpLogfont,      FONTENUMPROCA lpProc,      LPARAM lParam);
__declspec(dllimport) int  __stdcall EnumFontFamiliesW(      HDC hdc,        LPCWSTR lpLogfont,      FONTENUMPROCW lpProc,      LPARAM lParam);




#line 2991 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) int  __stdcall EnumFontsA(      HDC hdc,        LPCSTR lpLogfont,       FONTENUMPROCA lpProc,      LPARAM lParam);
__declspec(dllimport) int  __stdcall EnumFontsW(      HDC hdc,        LPCWSTR lpLogfont,       FONTENUMPROCW lpProc,      LPARAM lParam);




#line 2998 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


__declspec(dllimport) int  __stdcall EnumObjects(      HDC hdc,      int nType,      GOBJENUMPROC lpFunc,      LPARAM lParam);


#line 3004 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


__declspec(dllimport) BOOL __stdcall EqualRgn(      HRGN hrgn1,      HRGN hrgn2);
__declspec(dllimport) int  __stdcall Escape(        HDC hdc,           
                                     int iEscape,       
                                     int cjIn,          
                                         LPCSTR pvIn,
                                       LPVOID pvOut);
__declspec(dllimport) int  __stdcall ExtEscape(         HDC hdc,         
                                         int iEscape,     
                                         int cjInput,     
                                             LPCSTR lpInData,  
                                         int cjOutput,   
                                           LPSTR lpOutData);
__declspec(dllimport) int  __stdcall ExcludeClipRect(      HDC hdc,      int left,      int top,      int right,      int bottom);
__declspec(dllimport) HRGN __stdcall ExtCreateRegion(        const XFORM * lpx,      DWORD nCount,        const RGNDATA * lpData);
__declspec(dllimport) BOOL __stdcall ExtFloodFill(      HDC hdc,      int x,      int y,      COLORREF color,      UINT type);
__declspec(dllimport) BOOL __stdcall FillRgn(      HDC hdc,      HRGN hrgn,      HBRUSH hbr);
__declspec(dllimport) BOOL __stdcall FloodFill(      HDC hdc,      int x,      int y,      COLORREF color);
__declspec(dllimport) BOOL __stdcall FrameRgn(      HDC hdc,      HRGN hrgn,      HBRUSH hbr,      int w,      int h);
__declspec(dllimport) int  __stdcall GetROP2(      HDC hdc);
__declspec(dllimport) BOOL __stdcall GetAspectRatioFilterEx(      HDC hdc,      LPSIZE lpsize);
__declspec(dllimport) COLORREF __stdcall GetBkColor(      HDC hdc);


__declspec(dllimport) COLORREF __stdcall GetDCBrushColor(      HDC hdc);
__declspec(dllimport) COLORREF __stdcall GetDCPenColor(      HDC hdc);
#line 3032 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport)
int
__stdcall
GetBkMode(
         HDC hdc
    );

__declspec(dllimport)
LONG
__stdcall
GetBitmapBits(
         HBITMAP hbit,
         LONG cb,
         LPVOID lpvBits
    );

__declspec(dllimport) BOOL  __stdcall GetBitmapDimensionEx(      HBITMAP hbit,      LPSIZE lpsize);
__declspec(dllimport) UINT  __stdcall GetBoundsRect(      HDC hdc,      LPRECT lprect,      UINT flags);

__declspec(dllimport) BOOL  __stdcall GetBrushOrgEx(      HDC hdc,      LPPOINT lppt);

__declspec(dllimport) BOOL  __stdcall GetCharWidthA(      HDC hdc,      UINT iFirst,      UINT iLast,      LPINT lpBuffer);
__declspec(dllimport) BOOL  __stdcall GetCharWidthW(      HDC hdc,      UINT iFirst,      UINT iLast,      LPINT lpBuffer);




#line 3061 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall GetCharWidth32A(      HDC hdc,      UINT iFirst,      UINT iLast,       LPINT lpBuffer);
__declspec(dllimport) BOOL  __stdcall GetCharWidth32W(      HDC hdc,      UINT iFirst,      UINT iLast,       LPINT lpBuffer);




#line 3068 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall GetCharWidthFloatA(      HDC hdc,      UINT iFirst,      UINT iLast,      PFLOAT lpBuffer);
__declspec(dllimport) BOOL  __stdcall GetCharWidthFloatW(      HDC hdc,      UINT iFirst,      UINT iLast,      PFLOAT lpBuffer);




#line 3075 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsA(      HDC hdc, 
                                                 UINT wFirst, 
                                                 UINT wLast, 
                                                 LPABC lpABC);
__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsW(      HDC hdc, 
                                                 UINT wFirst, 
                                                 UINT wLast, 
                                                 LPABC lpABC);




#line 3089 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsFloatA(      HDC hdc,      UINT iFirst,      UINT iLast,      LPABCFLOAT lpABC);
__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsFloatW(      HDC hdc,      UINT iFirst,      UINT iLast,      LPABCFLOAT lpABC);




#line 3097 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) int   __stdcall GetClipBox(      HDC hdc,       LPRECT lprect);
__declspec(dllimport) int	__stdcall GetClipRgn(      HDC hdc,      HRGN hrgn);
__declspec(dllimport) int	__stdcall GetMetaRgn(      HDC hdc,      HRGN hrgn);
__declspec(dllimport) HGDIOBJ __stdcall GetCurrentObject(      HDC hdc,      UINT type);
__declspec(dllimport) BOOL  __stdcall GetCurrentPositionEx(      HDC hdc,       LPPOINT lppt);
__declspec(dllimport) int   __stdcall GetDeviceCaps(        HDC hdc,      int index);
__declspec(dllimport) int   __stdcall GetDIBits(      HDC hdc,      HBITMAP hbm,      UINT start,      UINT cLines,         LPVOID lpvBits,      LPBITMAPINFO lpbmi,      UINT usage);

__declspec(dllimport) DWORD __stdcall GetFontData (         HDC     hdc,
                                             DWORD   dwTable,
                                             DWORD   dwOffset,
                                                 PVOID pvBuffer,
                                             DWORD   cjBuffer
                                        );

__declspec(dllimport) DWORD __stdcall GetGlyphOutlineA(         HDC hdc,
                                                 UINT uChar,
                                                 UINT fuFormat,
                                                 LPGLYPHMETRICS lpgm,
                                                 DWORD cjBuffer,
                                                   LPVOID pvBuffer,
                                                 const MAT2 *lpmat2
                                        );
__declspec(dllimport) DWORD __stdcall GetGlyphOutlineW(         HDC hdc,
                                                 UINT uChar,
                                                 UINT fuFormat,
                                                 LPGLYPHMETRICS lpgm,
                                                 DWORD cjBuffer,
                                                   LPVOID pvBuffer,
                                                 const MAT2 *lpmat2
                                        );




#line 3133 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) int   __stdcall GetGraphicsMode(      HDC hdc);
__declspec(dllimport) int   __stdcall GetMapMode(      HDC hdc);
__declspec(dllimport) UINT  __stdcall GetMetaFileBitsEx(     HMETAFILE hMF,      UINT cbBuffer,        LPVOID lpData);
__declspec(dllimport) HMETAFILE   __stdcall GetMetaFileA(      LPCSTR lpName);
__declspec(dllimport) HMETAFILE   __stdcall GetMetaFileW(      LPCWSTR lpName);




#line 3144 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) COLORREF __stdcall GetNearestColor(      HDC hdc,      COLORREF color);
__declspec(dllimport) UINT  __stdcall GetNearestPaletteIndex(      HPALETTE h,      COLORREF color);
__declspec(dllimport) DWORD __stdcall GetObjectType(      HGDIOBJ h);



__declspec(dllimport) UINT __stdcall GetOutlineTextMetricsA(      HDC hdc, 
                                                     UINT cjCopy, 
                                                       LPOUTLINETEXTMETRICA potm);
__declspec(dllimport) UINT __stdcall GetOutlineTextMetricsW(      HDC hdc, 
                                                     UINT cjCopy, 
                                                       LPOUTLINETEXTMETRICW potm);




#line 3161 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

#line 3163 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) UINT	__stdcall GetPaletteEntries(        HPALETTE hpal,
                                                 UINT iStart,
                                                 UINT cEntries,
                                                 LPPALETTEENTRY pPalEntries);
__declspec(dllimport) COLORREF __stdcall GetPixel(      HDC hdc,      int x,      int y);
__declspec(dllimport) int   __stdcall GetPixelFormat(      HDC hdc);
__declspec(dllimport) int   __stdcall GetPolyFillMode(      HDC hdc);
__declspec(dllimport) BOOL  __stdcall GetRasterizerCaps(        LPRASTERIZER_STATUS lpraststat, 
                                                 UINT cjBytes);

__declspec(dllimport) int   __stdcall GetRandomRgn (     HDC hdc,      HRGN hrgn,      INT i);
__declspec(dllimport) DWORD __stdcall GetRegionData(        HRGN hrgn,
                                             DWORD nCount,
                                                 LPRGNDATA lpRgnData);
__declspec(dllimport) int   __stdcall GetRgnBox(      HRGN hrgn,       LPRECT lprc);
__declspec(dllimport) HGDIOBJ __stdcall GetStockObject(      int i);
__declspec(dllimport) int   __stdcall GetStretchBltMode(     HDC hdc);
__declspec(dllimport)
UINT
__stdcall
GetSystemPaletteEntries(
         HDC  hdc,
         UINT iStart,
         UINT cEntries,
           LPPALETTEENTRY pPalEntries
    );

__declspec(dllimport) UINT  __stdcall GetSystemPaletteUse(     HDC hdc);
__declspec(dllimport) int   __stdcall GetTextCharacterExtra(     HDC hdc);
__declspec(dllimport) UINT  __stdcall GetTextAlign(     HDC hdc);
__declspec(dllimport) COLORREF __stdcall GetTextColor(     HDC hdc);

__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPointA(
         HDC hdc,
           LPCSTR lpString,
         int c,
         LPSIZE lpsz
    );
__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPointW(
         HDC hdc,
           LPCWSTR lpString,
         int c,
         LPSIZE lpsz
    );




#line 3219 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPoint32A(
         HDC hdc,
           LPCSTR lpString,
         int c,
         LPSIZE psizl
    );
__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPoint32W(
         HDC hdc,
           LPCWSTR lpString,
         int c,
         LPSIZE psizl
    );




#line 3243 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport)
BOOL
__stdcall
GetTextExtentExPointA(
         HDC hdc,
           LPCSTR lpszString,
         int cchString,
         int nMaxExtent,
           LPINT lpnFit,
             LPINT lpnDx,
         LPSIZE lpSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetTextExtentExPointW(
         HDC hdc,
           LPCWSTR lpszString,
         int cchString,
         int nMaxExtent,
           LPINT lpnFit,
             LPINT lpnDx,
         LPSIZE lpSize
    );




#line 3273 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


__declspec(dllimport) int __stdcall GetTextCharset(      HDC hdc);
__declspec(dllimport) int __stdcall GetTextCharsetInfo(      HDC hdc,        LPFONTSIGNATURE lpSig,      DWORD dwFlags);
__declspec(dllimport) BOOL __stdcall TranslateCharsetInfo(      DWORD  *lpSrc,       LPCHARSETINFO lpCs,      DWORD dwFlags);
__declspec(dllimport) DWORD __stdcall GetFontLanguageInfo(      HDC hdc);
__declspec(dllimport) DWORD __stdcall GetCharacterPlacementA(       HDC hdc,        LPCSTR lpString,      int nCount,      int nMexExtent,      LPGCP_RESULTSA lpResults,      DWORD dwFlags);
__declspec(dllimport) DWORD __stdcall GetCharacterPlacementW(       HDC hdc,        LPCWSTR lpString,      int nCount,      int nMexExtent,      LPGCP_RESULTSW lpResults,      DWORD dwFlags);




#line 3286 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
#line 3287 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"



typedef struct tagWCRANGE
{
    WCHAR  wcLow;
    USHORT cGlyphs;
} WCRANGE, *PWCRANGE, *LPWCRANGE;


typedef struct tagGLYPHSET
{
    DWORD    cbThis;
    DWORD    flAccel;
    DWORD    cGlyphsSupported;
    DWORD    cRanges;
    WCRANGE  ranges[1];
} GLYPHSET, *PGLYPHSET,  *LPGLYPHSET;









__declspec(dllimport) DWORD __stdcall GetFontUnicodeRanges(      HDC hdc,        LPGLYPHSET lpgs);
__declspec(dllimport) DWORD __stdcall GetGlyphIndicesA(      HDC hdc,        LPCSTR lpstr,      int c,      LPWORD pgi,      DWORD fl);
__declspec(dllimport) DWORD __stdcall GetGlyphIndicesW(      HDC hdc,        LPCWSTR lpstr,      int c,      LPWORD pgi,      DWORD fl);




#line 3322 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall GetTextExtentPointI(     HDC hdc,        LPWORD pgiIn,      int cgi,      LPSIZE psize);
__declspec(dllimport) BOOL	__stdcall GetTextExtentExPointI (       HDC hdc,
                                                       LPWORD lpwszString,
                                                     int cwchString,
                                                     int nMaxExtent,
                                                       LPINT lpnFit,
                                                         LPINT lpnDx,
                                                     LPSIZE lpSize
                                                );

__declspec(dllimport) BOOL  __stdcall GetCharWidthI(        HDC hdc,
                                             UINT giFirst,
                                             UINT cgi,
                                                 LPWORD pgi,
                                             LPINT piWidths
                                        );

__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsI(        HDC    hdc,
                                                 UINT   giFirst,
                                                 UINT   cgi,
                                                     LPWORD pgi,
                                                 LPABC  pabc
                                        );








typedef struct tagDESIGNVECTOR
{
    DWORD  dvReserved;
    DWORD  dvNumAxes;
    LONG   dvValues[16];
} DESIGNVECTOR, *PDESIGNVECTOR,  *LPDESIGNVECTOR;

__declspec(dllimport) int  __stdcall AddFontResourceExA(      LPCSTR name,      DWORD fl,   PVOID res);
__declspec(dllimport) int  __stdcall AddFontResourceExW(      LPCWSTR name,      DWORD fl,   PVOID res);




#line 3367 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) BOOL __stdcall RemoveFontResourceExA(      LPCSTR name,      DWORD fl,   PVOID pdv);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceExW(      LPCWSTR name,      DWORD fl,   PVOID pdv);




#line 3374 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) HANDLE __stdcall AddFontMemResourceEx(          PVOID pFileView,
                                                     DWORD cjSize,
                                                  PVOID pvResrved,
                                                     DWORD* pNumFonts);

__declspec(dllimport) BOOL __stdcall RemoveFontMemResourceEx(      HANDLE h);









typedef struct tagAXISINFOA
{
    LONG   axMinValue;
    LONG   axMaxValue;
    BYTE   axAxisName[16];
} AXISINFOA, *PAXISINFOA,  *LPAXISINFOA;
typedef struct tagAXISINFOW
{
    LONG   axMinValue;
    LONG   axMaxValue;
    WCHAR  axAxisName[16];
} AXISINFOW, *PAXISINFOW,  *LPAXISINFOW;

typedef AXISINFOW AXISINFO;
typedef PAXISINFOW PAXISINFO;
typedef LPAXISINFOW LPAXISINFO;




#line 3410 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

typedef struct tagAXESLISTA
{
    DWORD     axlReserved;
    DWORD     axlNumAxes;
    AXISINFOA axlAxisInfo[16];
} AXESLISTA, *PAXESLISTA,  *LPAXESLISTA;
typedef struct tagAXESLISTW
{
    DWORD     axlReserved;
    DWORD     axlNumAxes;
    AXISINFOW axlAxisInfo[16];
} AXESLISTW, *PAXESLISTW,  *LPAXESLISTW;

typedef AXESLISTW AXESLIST;
typedef PAXESLISTW PAXESLIST;
typedef LPAXESLISTW LPAXESLIST;




#line 3432 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"





typedef struct tagENUMLOGFONTEXDVA
{
    ENUMLOGFONTEXA elfEnumLogfontEx;
    DESIGNVECTOR   elfDesignVector;
} ENUMLOGFONTEXDVA, *PENUMLOGFONTEXDVA,  *LPENUMLOGFONTEXDVA;
typedef struct tagENUMLOGFONTEXDVW
{
    ENUMLOGFONTEXW elfEnumLogfontEx;
    DESIGNVECTOR   elfDesignVector;
} ENUMLOGFONTEXDVW, *PENUMLOGFONTEXDVW,  *LPENUMLOGFONTEXDVW;

typedef ENUMLOGFONTEXDVW ENUMLOGFONTEXDV;
typedef PENUMLOGFONTEXDVW PENUMLOGFONTEXDV;
typedef LPENUMLOGFONTEXDVW LPENUMLOGFONTEXDV;




#line 3456 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) HFONT  __stdcall CreateFontIndirectExA(      const ENUMLOGFONTEXDVA *);
__declspec(dllimport) HFONT  __stdcall CreateFontIndirectExW(      const ENUMLOGFONTEXDVW *);




#line 3464 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


typedef struct tagENUMTEXTMETRICA
{
    NEWTEXTMETRICEXA etmNewTextMetricEx;
    AXESLISTA        etmAxesList;
} ENUMTEXTMETRICA, *PENUMTEXTMETRICA,  *LPENUMTEXTMETRICA;
typedef struct tagENUMTEXTMETRICW
{
    NEWTEXTMETRICEXW etmNewTextMetricEx;
    AXESLISTW        etmAxesList;
} ENUMTEXTMETRICW, *PENUMTEXTMETRICW,  *LPENUMTEXTMETRICW;

typedef ENUMTEXTMETRICW ENUMTEXTMETRIC;
typedef PENUMTEXTMETRICW PENUMTEXTMETRIC;
typedef LPENUMTEXTMETRICW LPENUMTEXTMETRIC;




#line 3485 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
#line 3486 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

#line 3488 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) BOOL  __stdcall GetViewportExtEx(      HDC hdc,      LPSIZE lpsize);
__declspec(dllimport) BOOL  __stdcall GetViewportOrgEx(      HDC hdc,      LPPOINT lppoint);
__declspec(dllimport) BOOL  __stdcall GetWindowExtEx(      HDC hdc,      LPSIZE lpsize);
__declspec(dllimport) BOOL  __stdcall GetWindowOrgEx(      HDC hdc,      LPPOINT lppoint);

__declspec(dllimport) int  __stdcall IntersectClipRect(      HDC hdc,      int left,      int top,      int right,      int bottom);
__declspec(dllimport) BOOL __stdcall InvertRgn(      HDC hdc,      HRGN hrgn);
__declspec(dllimport) BOOL __stdcall LineDDA(      int xStart,      int yStart,      int xEnd,      int yEnd,      LINEDDAPROC lpProc,        LPARAM data);
__declspec(dllimport) BOOL __stdcall LineTo(      HDC hdc,      int x,      int y);
__declspec(dllimport) BOOL __stdcall MaskBlt(      HDC hdcDest,      int xDest,      int yDest,      int width,      int height,
                   HDC hdcSrc,      int xSrc,      int ySrc,      HBITMAP hbmMask,      int xMask,      int yMask,      DWORD rop);
__declspec(dllimport) BOOL __stdcall PlgBlt(      HDC hdcDest,        const POINT * lpPoint,      HDC hdcSrc,      int xSrc,      int ySrc,      int width,
                          int height,        HBITMAP hbmMask,      int xMask,      int yMask);

__declspec(dllimport) int  __stdcall OffsetClipRgn(     HDC hdc,      int x,      int y);
__declspec(dllimport) int  __stdcall OffsetRgn(     HRGN hrgn,      int x,      int y);
__declspec(dllimport) BOOL __stdcall PatBlt(     HDC hdc,      int x,      int y,      int w,      int h,      DWORD rop);
__declspec(dllimport) BOOL __stdcall Pie(     HDC hdc,      int left,      int top,      int right,      int bottom,      int xr1,      int yr1,      int xr2,      int yr2);
__declspec(dllimport) BOOL __stdcall PlayMetaFile(     HDC hdc,      HMETAFILE hmf);
__declspec(dllimport) BOOL __stdcall PaintRgn(     HDC hdc,      HRGN hrgn);
__declspec(dllimport) BOOL __stdcall PolyPolygon(     HDC hdc,       const POINT *apt,         const INT *asz,       int csz);
__declspec(dllimport) BOOL __stdcall PtInRegion(     HRGN hrgn,      int x,      int y);
__declspec(dllimport) BOOL __stdcall PtVisible(     HDC hdc,      int x,      int y);
__declspec(dllimport) BOOL __stdcall RectInRegion(     HRGN hrgn,      const RECT * lprect);
__declspec(dllimport) BOOL __stdcall RectVisible(     HDC hdc,      const RECT * lprect);
__declspec(dllimport) BOOL __stdcall Rectangle(     HDC hdc,      int left,      int top,      int right,      int bottom);
__declspec(dllimport) BOOL __stdcall RestoreDC(     HDC hdc,      int nSavedDC);
__declspec(dllimport) HDC  __stdcall ResetDCA(     HDC hdc,      const DEVMODEA * lpdm);
__declspec(dllimport) HDC  __stdcall ResetDCW(     HDC hdc,      const DEVMODEW * lpdm);




#line 3523 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) UINT __stdcall RealizePalette(     HDC hdc);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceA(     LPCSTR lpFileName);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceW(     LPCWSTR lpFileName);




#line 3531 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall RoundRect(     HDC hdc,      int left,      int top,      int right,      int bottom,      int width,      int height);
__declspec(dllimport) BOOL __stdcall ResizePalette(     HPALETTE hpal,      UINT n);

__declspec(dllimport) int  __stdcall SaveDC(     HDC hdc);
__declspec(dllimport) int  __stdcall SelectClipRgn(     HDC hdc,        HRGN hrgn);
__declspec(dllimport) int  __stdcall ExtSelectClipRgn(     HDC hdc,        HRGN hrgn,      int mode);
__declspec(dllimport) int  __stdcall SetMetaRgn(     HDC hdc);
__declspec(dllimport) HGDIOBJ __stdcall SelectObject(     HDC hdc,      HGDIOBJ h);
__declspec(dllimport) HPALETTE __stdcall SelectPalette(     HDC hdc,      HPALETTE hPal,      BOOL bForceBkgd);
__declspec(dllimport) COLORREF __stdcall SetBkColor(     HDC hdc,      COLORREF color);


__declspec(dllimport) COLORREF __stdcall SetDCBrushColor(     HDC hdc,      COLORREF color);
__declspec(dllimport) COLORREF __stdcall SetDCPenColor(     HDC hdc,      COLORREF color);
#line 3546 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) int   __stdcall SetBkMode(     HDC hdc,      int mode);

__declspec(dllimport)
LONG __stdcall
SetBitmapBits(
         HBITMAP hbm,
         DWORD cb,
           const void *pvBits);

__declspec(dllimport) UINT  __stdcall SetBoundsRect(     HDC hdc,        const RECT * lprect,      UINT flags);
__declspec(dllimport) int	__stdcall SetDIBits(     HDC hdc,      HBITMAP hbm,      UINT start,      UINT cLines,      const void *lpBits,      const BITMAPINFO * lpbmi,      UINT ColorUse);
__declspec(dllimport) int   __stdcall SetDIBitsToDevice(     HDC hdc,      int xDest,      int yDest,      DWORD w,      DWORD h,      int xSrc,
             int ySrc,      UINT StartScan,      UINT cLines,      const void * lpvBits,      const BITMAPINFO * lpbmi,      UINT ColorUse);
__declspec(dllimport) DWORD __stdcall SetMapperFlags(     HDC hdc,      DWORD flags);
__declspec(dllimport) int   __stdcall SetGraphicsMode(     HDC hdc,      int iMode);
__declspec(dllimport) int   __stdcall SetMapMode(     HDC hdc,      int iMode);


__declspec(dllimport) DWORD __stdcall SetLayout(     HDC hdc,      DWORD l);
__declspec(dllimport) DWORD __stdcall GetLayout(     HDC hdc);
#line 3568 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) HMETAFILE   __stdcall SetMetaFileBitsEx(     UINT cbBuffer,        const BYTE *lpData);
__declspec(dllimport) UINT  __stdcall SetPaletteEntries(        HPALETTE hpal,
                                                 UINT iStart,
                                                 UINT cEntries,
                                                   const PALETTEENTRY *pPalEntries);
__declspec(dllimport) COLORREF __stdcall SetPixel(     HDC hdc,      int x,      int y,      COLORREF color);
__declspec(dllimport) BOOL   __stdcall SetPixelV(     HDC hdc,      int x,      int y,      COLORREF color);
__declspec(dllimport) BOOL  __stdcall SetPixelFormat(     HDC hdc,      int format,      const PIXELFORMATDESCRIPTOR * ppfd);
__declspec(dllimport) int   __stdcall SetPolyFillMode(     HDC hdc,      int mode);
__declspec(dllimport) BOOL	 __stdcall StretchBlt(     HDC hdcDest,      int xDest,      int yDest,      int wDest,      int hDest,      HDC hdcSrc,      int xSrc,      int ySrc,      int wSrc,      int hSrc,      DWORD rop);
__declspec(dllimport) BOOL   __stdcall SetRectRgn(     HRGN hrgn,      int left,      int top,      int right,      int bottom);
__declspec(dllimport) int   __stdcall StretchDIBits(     HDC hdc,      int xDest,      int yDest,      int DestWidth,      int DestHeight,      int xSrc,      int ySrc,      int SrcWidth,      int SrcHeight,
             const void * lpBits,      const BITMAPINFO * lpbmi,      UINT iUsage,      DWORD rop);
__declspec(dllimport) int   __stdcall SetROP2(     HDC hdc,      int rop2);
__declspec(dllimport) int   __stdcall SetStretchBltMode(     HDC hdc,      int mode);
__declspec(dllimport) UINT  __stdcall SetSystemPaletteUse(     HDC hdc,      UINT use);
__declspec(dllimport) int   __stdcall SetTextCharacterExtra(     HDC hdc,      int extra);
__declspec(dllimport) COLORREF __stdcall SetTextColor(     HDC hdc,      COLORREF color);
__declspec(dllimport) UINT  __stdcall SetTextAlign(     HDC hdc,      UINT align);
__declspec(dllimport) BOOL  __stdcall SetTextJustification(     HDC hdc,      int extra,      int count);
__declspec(dllimport) BOOL  __stdcall UpdateColors(     HDC hdc);







typedef USHORT COLOR16;

typedef struct _TRIVERTEX
{
    LONG    x;
    LONG    y;
    COLOR16 Red;
    COLOR16 Green;
    COLOR16 Blue;
    COLOR16 Alpha;
}TRIVERTEX,*PTRIVERTEX,*LPTRIVERTEX;

typedef struct _GRADIENT_TRIANGLE
{
    ULONG Vertex1;
    ULONG Vertex2;
    ULONG Vertex3;
} GRADIENT_TRIANGLE,*PGRADIENT_TRIANGLE,*LPGRADIENT_TRIANGLE;

typedef struct _GRADIENT_RECT
{
    ULONG UpperLeft;
    ULONG LowerRight;
}GRADIENT_RECT,*PGRADIENT_RECT,*LPGRADIENT_RECT;

typedef struct _BLENDFUNCTION
{
    BYTE   BlendOp;
    BYTE   BlendFlags;
    BYTE   SourceConstantAlpha;
    BYTE   AlphaFormat;
}BLENDFUNCTION,*PBLENDFUNCTION;














__declspec(dllimport) BOOL __stdcall AlphaBlend(      HDC hdcDest,      int xoriginDest,      int yoriginDest,      int wDest,      int hDest,      HDC hdcSrc,      int xoriginSrc,      int yoriginSrc,      int wSrc,      int hSrc,      BLENDFUNCTION ftn);

__declspec(dllimport) BOOL __stdcall TransparentBlt(     HDC hdcDest,     int xoriginDest,      int yoriginDest,      int wDest,      int hDest,      HDC hdcSrc,
                                                int xoriginSrc,      int yoriginSrc,      int wSrc,      int hSrc,      UINT crTransparent);










__declspec(dllimport)
BOOL
__stdcall
GradientFill(
         HDC hdc,
           PTRIVERTEX pVertex,
         ULONG nVertex,
         PVOID pMesh,
         ULONG nMesh,
         ULONG ulMode
    );

#line 3670 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"




__declspec(dllimport) BOOL  __stdcall PlayMetaFileRecord(       HDC hdc,
                                                   LPHANDLETABLE lpHandleTable,
                                                 LPMETARECORD lpMR,
                                                 UINT noObjs);

typedef int (__stdcall* MFENUMPROC)(      HDC hdc,        HANDLETABLE * lpht,      METARECORD * lpMR,      int nObj,        LPARAM param);
__declspec(dllimport) BOOL	__stdcall EnumMetaFile(      HDC hdc,      HMETAFILE hmf,      MFENUMPROC proc,        LPARAM param);

typedef int (__stdcall* ENHMFENUMPROC)(     HDC hdc,        HANDLETABLE * lpht,      const ENHMETARECORD * lpmr,      int hHandles,        LPARAM data);



__declspec(dllimport) HENHMETAFILE __stdcall CloseEnhMetaFile(      HDC hdc);
__declspec(dllimport) HENHMETAFILE __stdcall CopyEnhMetaFileA(      HENHMETAFILE hEnh,        LPCSTR lpFileName);
__declspec(dllimport) HENHMETAFILE __stdcall CopyEnhMetaFileW(      HENHMETAFILE hEnh,        LPCWSTR lpFileName);




#line 3694 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) HDC   __stdcall CreateEnhMetaFileA(        HDC hdc,        LPCSTR lpFilename,        const RECT *lprc,        LPCSTR lpDesc);
__declspec(dllimport) HDC   __stdcall CreateEnhMetaFileW(        HDC hdc,        LPCWSTR lpFilename,        const RECT *lprc,        LPCWSTR lpDesc);




#line 3701 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall DeleteEnhMetaFile(      HENHMETAFILE hmf);
__declspec(dllimport) BOOL  __stdcall EnumEnhMetaFile(        HDC hdc,      HENHMETAFILE hmf,      ENHMFENUMPROC proc,
                                               LPVOID param,        const RECT * lpRect);
__declspec(dllimport) HENHMETAFILE  __stdcall GetEnhMetaFileA(      LPCSTR lpName);
__declspec(dllimport) HENHMETAFILE  __stdcall GetEnhMetaFileW(      LPCWSTR lpName);




#line 3711 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) UINT	__stdcall GetEnhMetaFileBits(       HENHMETAFILE hEMF,
                                                 UINT nSize,
                                                   LPBYTE lpData);
__declspec(dllimport) UINT	__stdcall GetEnhMetaFileDescriptionA(       HENHMETAFILE hemf,
                                                         UINT cchBuffer,
                                                           LPSTR lpDescription);
__declspec(dllimport) UINT	__stdcall GetEnhMetaFileDescriptionW(       HENHMETAFILE hemf,
                                                         UINT cchBuffer,
                                                           LPWSTR lpDescription);




#line 3725 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) UINT	__stdcall GetEnhMetaFileHeader(         HENHMETAFILE hemf,
                                                     UINT nSize,
                                                       LPENHMETAHEADER lpEnhMetaHeader);
__declspec(dllimport) UINT	__stdcall GetEnhMetaFilePaletteEntries(     HENHMETAFILE hemf,
                                                         UINT nNumEntries,
                                                           LPPALETTEENTRY lpPaletteEntries);

__declspec(dllimport) UINT  __stdcall GetEnhMetaFilePixelFormat(        HENHMETAFILE hemf,
                                                         UINT cbBuffer,
                                                           PIXELFORMATDESCRIPTOR *ppfd);
__declspec(dllimport) UINT	__stdcall GetWinMetaFileBits(       HENHMETAFILE hemf,
                                                 UINT cbData16,
                                                   LPBYTE pData16,
                                                 INT iMapMode,
                                                 HDC hdcRef);
__declspec(dllimport) BOOL  __stdcall PlayEnhMetaFile(      HDC hdc,      HENHMETAFILE hmf,      const RECT * lprect);
__declspec(dllimport) BOOL  __stdcall PlayEnhMetaFileRecord(        HDC hdc,
                                                       LPHANDLETABLE pht,
                                                     const ENHMETARECORD *pmr,
                                                     UINT cht);

__declspec(dllimport) HENHMETAFILE  __stdcall SetEnhMetaFileBits(       UINT nSize,
                                                           const BYTE * pb);

__declspec(dllimport) HENHMETAFILE  __stdcall SetWinMetaFileBits(       UINT nSize,
                                                           const BYTE *lpMeta16Data,
                                                           HDC hdcRef,
                                                           const METAFILEPICT *lpMFP);
__declspec(dllimport) BOOL  __stdcall GdiComment(     HDC hdc,      UINT nSize,        const BYTE *lpData);

#line 3756 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"



__declspec(dllimport) BOOL __stdcall GetTextMetricsA(      HDC hdc,      LPTEXTMETRICA lptm);
__declspec(dllimport) BOOL __stdcall GetTextMetricsW(      HDC hdc,      LPTEXTMETRICW lptm);




#line 3766 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"



















#line 3786 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

#line 3788 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"



typedef struct tagDIBSECTION {
    BITMAP		 dsBm;
    BITMAPINFOHEADER    dsBmih;
    DWORD               dsBitfields[3];
    HANDLE              dshSection;
    DWORD               dsOffset;
} DIBSECTION,  *LPDIBSECTION, *PDIBSECTION;


__declspec(dllimport) BOOL __stdcall AngleArc(      HDC hdc,      int x,      int y,      DWORD r,      FLOAT StartAngle,      FLOAT SweepAngle);
__declspec(dllimport) BOOL __stdcall PolyPolyline(     HDC hdc,      const POINT *apt,        const DWORD *asz,      DWORD csz);
__declspec(dllimport) BOOL __stdcall GetWorldTransform(      HDC hdc,      LPXFORM lpxf);
__declspec(dllimport) BOOL __stdcall SetWorldTransform(      HDC hdc,      const XFORM * lpxf);
__declspec(dllimport) BOOL __stdcall ModifyWorldTransform(      HDC hdc,        const XFORM * lpxf,      DWORD mode);
__declspec(dllimport) BOOL __stdcall CombineTransform(      LPXFORM lpxfOut,      const XFORM *lpxf1,      const XFORM *lpxf2);
__declspec(dllimport) HBITMAP __stdcall CreateDIBSection(       HDC hdc,      const BITMAPINFO *lpbmi,      UINT usage,                 void **ppvBits,        HANDLE hSection,      DWORD offset);
__declspec(dllimport) UINT __stdcall GetDIBColorTable(      HDC  hdc,
                                             UINT iStart,
                                             UINT cEntries,
                                             RGBQUAD *prgbq);
__declspec(dllimport) UINT __stdcall SetDIBColorTable(      HDC  hdc,
                                             UINT iStart,
                                             UINT cEntries,
                                               const RGBQUAD *prgbq);




































typedef struct  tagCOLORADJUSTMENT {
    WORD   caSize;
    WORD   caFlags;
    WORD   caIlluminantIndex;
    WORD   caRedGamma;
    WORD   caGreenGamma;
    WORD   caBlueGamma;
    WORD   caReferenceBlack;
    WORD   caReferenceWhite;
    SHORT  caContrast;
    SHORT  caBrightness;
    SHORT  caColorfulness;
    SHORT  caRedGreenTint;
} COLORADJUSTMENT, *PCOLORADJUSTMENT,  *LPCOLORADJUSTMENT;

__declspec(dllimport) BOOL __stdcall SetColorAdjustment(      HDC hdc,      const COLORADJUSTMENT *lpca);
__declspec(dllimport) BOOL __stdcall GetColorAdjustment(      HDC hdc,      LPCOLORADJUSTMENT lpca);
__declspec(dllimport) HPALETTE __stdcall CreateHalftonePalette(        HDC hdc);


typedef BOOL (__stdcall* ABORTPROC)(      HDC,      int);


#line 3875 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

typedef struct _DOCINFOA {
    int     cbSize;
    LPCSTR   lpszDocName;
    LPCSTR   lpszOutput;

    LPCSTR   lpszDatatype;
    DWORD    fwType;
#line 3884 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
} DOCINFOA, *LPDOCINFOA;
typedef struct _DOCINFOW {
    int     cbSize;
    LPCWSTR  lpszDocName;
    LPCWSTR  lpszOutput;

    LPCWSTR  lpszDatatype;
    DWORD    fwType;
#line 3893 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
} DOCINFOW, *LPDOCINFOW;

typedef DOCINFOW DOCINFO;
typedef LPDOCINFOW LPDOCINFO;



#line 3901 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"




#line 3906 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) int __stdcall StartDocA(     HDC hdc,      const DOCINFOA *lpdi);
__declspec(dllimport) int __stdcall StartDocW(     HDC hdc,      const DOCINFOW *lpdi);




#line 3914 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) int __stdcall EndDoc(     HDC hdc);
__declspec(dllimport) int __stdcall StartPage(     HDC hdc);
__declspec(dllimport) int __stdcall EndPage(     HDC hdc);
__declspec(dllimport) int __stdcall AbortDoc(     HDC hdc);
__declspec(dllimport) int __stdcall SetAbortProc(     HDC hdc,      ABORTPROC proc);

__declspec(dllimport) BOOL __stdcall AbortPath(     HDC hdc);
__declspec(dllimport) BOOL __stdcall ArcTo(     HDC hdc,      int left,      int top,      int right,      int bottom,      int xr1,      int yr1,      int xr2,      int yr2);
__declspec(dllimport) BOOL __stdcall BeginPath(     HDC hdc);
__declspec(dllimport) BOOL __stdcall CloseFigure(     HDC hdc);
__declspec(dllimport) BOOL __stdcall EndPath(     HDC hdc);
__declspec(dllimport) BOOL __stdcall FillPath(     HDC hdc);
__declspec(dllimport) BOOL __stdcall FlattenPath(     HDC hdc);
__declspec(dllimport) int  __stdcall GetPath(     HDC hdc,      LPPOINT apt,      LPBYTE aj, int cpt);
__declspec(dllimport) HRGN __stdcall PathToRegion(     HDC hdc);
__declspec(dllimport) BOOL __stdcall PolyDraw(     HDC hdc,        const POINT * apt,        const BYTE * aj,      int cpt);
__declspec(dllimport) BOOL __stdcall SelectClipPath(     HDC hdc,      int mode);
__declspec(dllimport) int  __stdcall SetArcDirection(     HDC hdc,      int dir);
__declspec(dllimport) BOOL __stdcall SetMiterLimit(     HDC hdc,      FLOAT limit,        PFLOAT old);
__declspec(dllimport) BOOL __stdcall StrokeAndFillPath(     HDC hdc);
__declspec(dllimport) BOOL __stdcall StrokePath(     HDC hdc);
__declspec(dllimport) BOOL __stdcall WidenPath(     HDC hdc);
__declspec(dllimport) HPEN __stdcall ExtCreatePen(      DWORD iPenStyle,
                                         DWORD cWidth,
                                         const LOGBRUSH *plbrush,
                                         DWORD cStyle,
                                             const DWORD *pstyle);
__declspec(dllimport) BOOL __stdcall GetMiterLimit(     HDC hdc,      PFLOAT plimit);
__declspec(dllimport) int  __stdcall GetArcDirection(     HDC hdc);

__declspec(dllimport) int   __stdcall GetObjectA(     HANDLE h,      int c,        LPVOID pv);
__declspec(dllimport) int   __stdcall GetObjectW(     HANDLE h,      int c,        LPVOID pv);




#line 3951 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"




















#line 3972 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


__declspec(dllimport) BOOL  __stdcall MoveToEx(      HDC hdc,      int x,      int y,        LPPOINT lppt);
__declspec(dllimport) BOOL  __stdcall TextOutA(      HDC hdc,      int x,      int y,        LPCSTR lpString,      int c);
__declspec(dllimport) BOOL  __stdcall TextOutW(      HDC hdc,      int x,      int y,        LPCWSTR lpString,      int c);




#line 3982 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) BOOL	__stdcall ExtTextOutA(      HDC hdc,      int x,      int y,      UINT options,        const RECT * lprect,        LPCSTR lpString,      UINT c,          const INT * lpDx);
__declspec(dllimport) BOOL	__stdcall ExtTextOutW(      HDC hdc,      int x,      int y,      UINT options,        const RECT * lprect,        LPCWSTR lpString,      UINT c,          const INT * lpDx);




#line 3989 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall PolyTextOutA(     HDC hdc,        const POLYTEXTA * ppt,      int nstrings);
__declspec(dllimport) BOOL  __stdcall PolyTextOutW(     HDC hdc,        const POLYTEXTW * ppt,      int nstrings);




#line 3996 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) HRGN  __stdcall CreatePolygonRgn(           const POINT *pptl,
                                                 int cPoint,
                                                 int iMode);
__declspec(dllimport) BOOL  __stdcall DPtoLP(      HDC hdc,        LPPOINT lppt,      int c);
__declspec(dllimport) BOOL  __stdcall LPtoDP(      HDC hdc,        LPPOINT lppt,      int c);
__declspec(dllimport) BOOL  __stdcall Polygon(     HDC hdc,        const POINT *apt,      int cpt);
__declspec(dllimport) BOOL  __stdcall Polyline(     HDC hdc,        const POINT *apt,      int cpt);

__declspec(dllimport) BOOL  __stdcall PolyBezier(     HDC hdc,        const POINT * apt,      DWORD cpt);
__declspec(dllimport) BOOL  __stdcall PolyBezierTo(     HDC hdc,        const POINT * apt,      DWORD cpt);
__declspec(dllimport) BOOL  __stdcall PolylineTo(     HDC hdc,        const POINT * apt,      DWORD cpt);

__declspec(dllimport) BOOL  __stdcall SetViewportExtEx(      HDC hdc,      int x,      int y,        LPSIZE lpsz);
__declspec(dllimport) BOOL  __stdcall SetViewportOrgEx(      HDC hdc,      int x,      int y,        LPPOINT lppt);
__declspec(dllimport) BOOL  __stdcall SetWindowExtEx(      HDC hdc,      int x,      int y,        LPSIZE lpsz);
__declspec(dllimport) BOOL  __stdcall SetWindowOrgEx(      HDC hdc,      int x,      int y,        LPPOINT lppt);

__declspec(dllimport) BOOL  __stdcall OffsetViewportOrgEx(      HDC hdc,      int x,      int y,        LPPOINT lppt);
__declspec(dllimport) BOOL  __stdcall OffsetWindowOrgEx(      HDC hdc,      int x,      int y,        LPPOINT lppt);
__declspec(dllimport) BOOL  __stdcall ScaleViewportExtEx(      HDC hdc,      int xn,      int dx,      int yn,      int yd,        LPSIZE lpsz);
__declspec(dllimport) BOOL  __stdcall ScaleWindowExtEx(      HDC hdc,      int xn,      int xd,      int yn,      int yd,        LPSIZE lpsz);
__declspec(dllimport) BOOL  __stdcall SetBitmapDimensionEx(      HBITMAP hbm,      int w,      int h,        LPSIZE lpsz);
__declspec(dllimport) BOOL  __stdcall SetBrushOrgEx(      HDC hdc,      int x,      int y,        LPPOINT lppt);

__declspec(dllimport) int   __stdcall GetTextFaceA(      HDC hdc,      int c,           LPSTR lpName);
__declspec(dllimport) int   __stdcall GetTextFaceW(      HDC hdc,      int c,           LPWSTR lpName);




#line 4028 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"



typedef struct tagKERNINGPAIR {
   WORD wFirst;
   WORD wSecond;
   int  iKernAmount;
} KERNINGPAIR, *LPKERNINGPAIR;

__declspec(dllimport) DWORD __stdcall GetKerningPairsA(         HDC hdc, 
                                                 DWORD nPairs, 
                                                     LPKERNINGPAIR   lpKernPair);
__declspec(dllimport) DWORD __stdcall GetKerningPairsW(         HDC hdc, 
                                                 DWORD nPairs, 
                                                     LPKERNINGPAIR   lpKernPair);




#line 4048 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


__declspec(dllimport) BOOL  __stdcall GetDCOrgEx(      HDC hdc,      LPPOINT lppt);
__declspec(dllimport) BOOL  __stdcall FixBrushOrgEx(      HDC hdc,      int x,      int y,         LPPOINT ptl);
__declspec(dllimport) BOOL  __stdcall UnrealizeObject(      HGDIOBJ h);

__declspec(dllimport) BOOL  __stdcall GdiFlush();
__declspec(dllimport) DWORD __stdcall GdiSetBatchLimit(      DWORD dw);
__declspec(dllimport) DWORD __stdcall GdiGetBatchLimit();








typedef int (__stdcall* ICMENUMPROCA)(LPSTR, LPARAM);
typedef int (__stdcall* ICMENUMPROCW)(LPWSTR, LPARAM);




#line 4072 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) int         __stdcall SetICMMode(      HDC hdc,      int mode);
__declspec(dllimport) BOOL        __stdcall CheckColorsInGamut(         HDC hdc,
                                                            LPVOID lpRGBTriple,
                                                         LPVOID dlpBuffer,
                                                         DWORD nCount);

__declspec(dllimport) HCOLORSPACE __stdcall GetColorSpace(      HDC hdc);
__declspec(dllimport) BOOL        __stdcall GetLogColorSpaceA(      HCOLORSPACE hColorSpace, 
                                                     LPLOGCOLORSPACEA lpBuffer, 
                                                     DWORD nSize);
__declspec(dllimport) BOOL        __stdcall GetLogColorSpaceW(      HCOLORSPACE hColorSpace, 
                                                     LPLOGCOLORSPACEW lpBuffer, 
                                                     DWORD nSize);




#line 4091 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) HCOLORSPACE __stdcall CreateColorSpaceA(      LPLOGCOLORSPACEA lplcs);
__declspec(dllimport) HCOLORSPACE __stdcall CreateColorSpaceW(      LPLOGCOLORSPACEW lplcs);




#line 4099 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) HCOLORSPACE __stdcall SetColorSpace(      HDC hdc,      HCOLORSPACE hcs);
__declspec(dllimport) BOOL        __stdcall DeleteColorSpace(      HCOLORSPACE hcs);
__declspec(dllimport) BOOL	      __stdcall GetICMProfileA(         HDC hdc, 
                                                     LPDWORD pBufSize,
                                                       LPSTR pszFilename);
__declspec(dllimport) BOOL	      __stdcall GetICMProfileW(         HDC hdc, 
                                                     LPDWORD pBufSize,
                                                       LPWSTR pszFilename);




#line 4112 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

__declspec(dllimport) BOOL        __stdcall SetICMProfileA(      HDC hdc,      LPSTR lpFileName);
__declspec(dllimport) BOOL        __stdcall SetICMProfileW(      HDC hdc,      LPWSTR lpFileName);




#line 4120 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) BOOL        __stdcall GetDeviceGammaRamp(      HDC hdc,      LPVOID lpRamp);
__declspec(dllimport) BOOL        __stdcall SetDeviceGammaRamp(      HDC hdc,         LPVOID lpRamp);
__declspec(dllimport) BOOL        __stdcall ColorMatchToTarget(      HDC hdc,      HDC hdcTarget,      DWORD action);
__declspec(dllimport) int         __stdcall EnumICMProfilesA(      HDC hdc,      ICMENUMPROCA proc,        LPARAM param);
__declspec(dllimport) int         __stdcall EnumICMProfilesW(      HDC hdc,      ICMENUMPROCW proc,        LPARAM param);




#line 4130 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) BOOL	      __stdcall UpdateICMRegKeyA(   DWORD reserved,      LPSTR lpszCMID,      LPSTR lpszFileName,      UINT command);
__declspec(dllimport) BOOL	      __stdcall UpdateICMRegKeyW(   DWORD reserved,      LPWSTR lpszCMID,      LPWSTR lpszFileName,      UINT command);




#line 4137 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
#line 4138 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


__declspec(dllimport) BOOL        __stdcall ColorCorrectPalette(      HDC hdc,      HPALETTE hPal,      DWORD deFirst,      DWORD num);
#line 4142 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"









#line 4152 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"




















































































































#line 4269 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"




















#line 4290 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"









#line 4300 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"



typedef struct tagEMR
{
    DWORD   iType;              
    DWORD   nSize;              
                                
} EMR, *PEMR;



typedef struct tagEMRTEXT
{
    POINTL  ptlReference;
    DWORD   nChars;
    DWORD   offString;          
    DWORD   fOptions;
    RECTL   rcl;
    DWORD   offDx;              
                                
} EMRTEXT, *PEMRTEXT;



typedef struct tagABORTPATH
{
    EMR     emr;
} EMRABORTPATH,      *PEMRABORTPATH,
  EMRBEGINPATH,      *PEMRBEGINPATH,
  EMRENDPATH,        *PEMRENDPATH,
  EMRCLOSEFIGURE,    *PEMRCLOSEFIGURE,
  EMRFLATTENPATH,    *PEMRFLATTENPATH,
  EMRWIDENPATH,      *PEMRWIDENPATH,
  EMRSETMETARGN,     *PEMRSETMETARGN,
  EMRSAVEDC,         *PEMRSAVEDC,
  EMRREALIZEPALETTE, *PEMRREALIZEPALETTE;

typedef struct tagEMRSELECTCLIPPATH
{
    EMR     emr;
    DWORD   iMode;
} EMRSELECTCLIPPATH,    *PEMRSELECTCLIPPATH,
  EMRSETBKMODE,         *PEMRSETBKMODE,
  EMRSETMAPMODE,        *PEMRSETMAPMODE,

  EMRSETLAYOUT,         *PEMRSETLAYOUT,
#line 4348 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
  EMRSETPOLYFILLMODE,   *PEMRSETPOLYFILLMODE,
  EMRSETROP2,           *PEMRSETROP2,
  EMRSETSTRETCHBLTMODE, *PEMRSETSTRETCHBLTMODE,
  EMRSETICMMODE,        *PEMRSETICMMODE,
  EMRSETTEXTALIGN,      *PEMRSETTEXTALIGN;

typedef struct tagEMRSETMITERLIMIT
{
    EMR     emr;
    FLOAT   eMiterLimit;
} EMRSETMITERLIMIT, *PEMRSETMITERLIMIT;

typedef struct tagEMRRESTOREDC
{
    EMR     emr;
    LONG    iRelative;          
} EMRRESTOREDC, *PEMRRESTOREDC;

typedef struct tagEMRSETARCDIRECTION
{
    EMR     emr;
    DWORD   iArcDirection;      
                                
} EMRSETARCDIRECTION, *PEMRSETARCDIRECTION;

typedef struct tagEMRSETMAPPERFLAGS
{
    EMR     emr;
    DWORD   dwFlags;
} EMRSETMAPPERFLAGS, *PEMRSETMAPPERFLAGS;

typedef struct tagEMRSETTEXTCOLOR
{
    EMR     emr;
    COLORREF crColor;
} EMRSETBKCOLOR,   *PEMRSETBKCOLOR,
  EMRSETTEXTCOLOR, *PEMRSETTEXTCOLOR;

typedef struct tagEMRSELECTOBJECT
{
    EMR     emr;
    DWORD   ihObject;           
} EMRSELECTOBJECT, *PEMRSELECTOBJECT,
  EMRDELETEOBJECT, *PEMRDELETEOBJECT;

typedef struct tagEMRSELECTPALETTE
{
    EMR     emr;
    DWORD   ihPal;              
} EMRSELECTPALETTE, *PEMRSELECTPALETTE;

typedef struct tagEMRRESIZEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              
    DWORD   cEntries;
} EMRRESIZEPALETTE, *PEMRRESIZEPALETTE;

typedef struct tagEMRSETPALETTEENTRIES
{
    EMR     emr;
    DWORD   ihPal;              
    DWORD   iStart;
    DWORD   cEntries;
    PALETTEENTRY aPalEntries[1];
} EMRSETPALETTEENTRIES, *PEMRSETPALETTEENTRIES;

typedef struct tagEMRSETCOLORADJUSTMENT
{
    EMR     emr;
    COLORADJUSTMENT ColorAdjustment;
} EMRSETCOLORADJUSTMENT, *PEMRSETCOLORADJUSTMENT;

typedef struct tagEMRGDICOMMENT
{
    EMR     emr;
    DWORD   cbData;             
    BYTE    Data[1];
} EMRGDICOMMENT, *PEMRGDICOMMENT;

typedef struct tagEMREOF
{
    EMR     emr;
    DWORD   nPalEntries;        
    DWORD   offPalEntries;      
    DWORD   nSizeLast;          
                                
                                
} EMREOF, *PEMREOF;

typedef struct tagEMRLINETO
{
    EMR     emr;
    POINTL  ptl;
} EMRLINETO,   *PEMRLINETO,
  EMRMOVETOEX, *PEMRMOVETOEX;

typedef struct tagEMROFFSETCLIPRGN
{
    EMR     emr;
    POINTL  ptlOffset;
} EMROFFSETCLIPRGN, *PEMROFFSETCLIPRGN;

typedef struct tagEMRFILLPATH
{
    EMR     emr;
    RECTL   rclBounds;          
} EMRFILLPATH,          *PEMRFILLPATH,
  EMRSTROKEANDFILLPATH, *PEMRSTROKEANDFILLPATH,
  EMRSTROKEPATH,        *PEMRSTROKEPATH;

typedef struct tagEMREXCLUDECLIPRECT
{
    EMR     emr;
    RECTL   rclClip;
} EMREXCLUDECLIPRECT,   *PEMREXCLUDECLIPRECT,
  EMRINTERSECTCLIPRECT, *PEMRINTERSECTCLIPRECT;

typedef struct tagEMRSETVIEWPORTORGEX
{
    EMR     emr;
    POINTL  ptlOrigin;
} EMRSETVIEWPORTORGEX, *PEMRSETVIEWPORTORGEX,
  EMRSETWINDOWORGEX,   *PEMRSETWINDOWORGEX,
  EMRSETBRUSHORGEX,    *PEMRSETBRUSHORGEX;

typedef struct tagEMRSETVIEWPORTEXTEX
{
    EMR     emr;
    SIZEL   szlExtent;
} EMRSETVIEWPORTEXTEX, *PEMRSETVIEWPORTEXTEX,
  EMRSETWINDOWEXTEX,   *PEMRSETWINDOWEXTEX;

typedef struct tagEMRSCALEVIEWPORTEXTEX
{
    EMR     emr;
    LONG    xNum;
    LONG    xDenom;
    LONG    yNum;
    LONG    yDenom;
} EMRSCALEVIEWPORTEXTEX, *PEMRSCALEVIEWPORTEXTEX,
  EMRSCALEWINDOWEXTEX,   *PEMRSCALEWINDOWEXTEX;

typedef struct tagEMRSETWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
} EMRSETWORLDTRANSFORM, *PEMRSETWORLDTRANSFORM;

typedef struct tagEMRMODIFYWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
    DWORD   iMode;
} EMRMODIFYWORLDTRANSFORM, *PEMRMODIFYWORLDTRANSFORM;

typedef struct tagEMRSETPIXELV
{
    EMR     emr;
    POINTL  ptlPixel;
    COLORREF crColor;
} EMRSETPIXELV, *PEMRSETPIXELV;

typedef struct tagEMREXTFLOODFILL
{
    EMR     emr;
    POINTL  ptlStart;
    COLORREF crColor;
    DWORD   iMode;
} EMREXTFLOODFILL, *PEMREXTFLOODFILL;

typedef struct tagEMRELLIPSE
{
    EMR     emr;
    RECTL   rclBox;             
} EMRELLIPSE,  *PEMRELLIPSE,
  EMRRECTANGLE, *PEMRRECTANGLE;


typedef struct tagEMRROUNDRECT
{
    EMR     emr;
    RECTL   rclBox;             
    SIZEL   szlCorner;
} EMRROUNDRECT, *PEMRROUNDRECT;

typedef struct tagEMRARC
{
    EMR     emr;
    RECTL   rclBox;             
    POINTL  ptlStart;
    POINTL  ptlEnd;
} EMRARC,   *PEMRARC,
  EMRARCTO, *PEMRARCTO,
  EMRCHORD, *PEMRCHORD,
  EMRPIE,   *PEMRPIE;

typedef struct tagEMRANGLEARC
{
    EMR     emr;
    POINTL  ptlCenter;
    DWORD   nRadius;
    FLOAT   eStartAngle;
    FLOAT   eSweepAngle;
} EMRANGLEARC, *PEMRANGLEARC;

typedef struct tagEMRPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cptl;
    POINTL  aptl[1];
} EMRPOLYLINE,     *PEMRPOLYLINE,
  EMRPOLYBEZIER,   *PEMRPOLYBEZIER,
  EMRPOLYGON,      *PEMRPOLYGON,
  EMRPOLYBEZIERTO, *PEMRPOLYBEZIERTO,
  EMRPOLYLINETO,   *PEMRPOLYLINETO;

typedef struct tagEMRPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cpts;
    POINTS  apts[1];
} EMRPOLYLINE16,     *PEMRPOLYLINE16,
  EMRPOLYBEZIER16,   *PEMRPOLYBEZIER16,
  EMRPOLYGON16,      *PEMRPOLYGON16,
  EMRPOLYBEZIERTO16, *PEMRPOLYBEZIERTO16,
  EMRPOLYLINETO16,   *PEMRPOLYLINETO16;

typedef struct tagEMRPOLYDRAW
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cptl;               
    POINTL  aptl[1];            
    BYTE    abTypes[1];         
} EMRPOLYDRAW, *PEMRPOLYDRAW;

typedef struct tagEMRPOLYDRAW16
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cpts;               
    POINTS  apts[1];            
    BYTE    abTypes[1];         
} EMRPOLYDRAW16, *PEMRPOLYDRAW16;

typedef struct tagEMRPOLYPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   nPolys;             
    DWORD   cptl;               
    DWORD   aPolyCounts[1];     
    POINTL  aptl[1];            
} EMRPOLYPOLYLINE, *PEMRPOLYPOLYLINE,
  EMRPOLYPOLYGON,  *PEMRPOLYPOLYGON;

typedef struct tagEMRPOLYPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   nPolys;             
    DWORD   cpts;               
    DWORD   aPolyCounts[1];     
    POINTS  apts[1];            
} EMRPOLYPOLYLINE16, *PEMRPOLYPOLYLINE16,
  EMRPOLYPOLYGON16,  *PEMRPOLYPOLYGON16;

typedef struct tagEMRINVERTRGN
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cbRgnData;          
    BYTE    RgnData[1];
} EMRINVERTRGN, *PEMRINVERTRGN,
  EMRPAINTRGN,  *PEMRPAINTRGN;

typedef struct tagEMRFILLRGN
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cbRgnData;          
    DWORD   ihBrush;            
    BYTE    RgnData[1];
} EMRFILLRGN, *PEMRFILLRGN;

typedef struct tagEMRFRAMERGN
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cbRgnData;          
    DWORD   ihBrush;            
    SIZEL   szlStroke;
    BYTE    RgnData[1];
} EMRFRAMERGN, *PEMRFRAMERGN;

typedef struct tagEMREXTSELECTCLIPRGN
{
    EMR     emr;
    DWORD   cbRgnData;          
    DWORD   iMode;
    BYTE    RgnData[1];
} EMREXTSELECTCLIPRGN, *PEMREXTSELECTCLIPRGN;

typedef struct tagEMREXTTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   iGraphicsMode;      
    FLOAT   exScale;            
    FLOAT   eyScale;            
    EMRTEXT emrtext;            
                                
} EMREXTTEXTOUTA, *PEMREXTTEXTOUTA,
  EMREXTTEXTOUTW, *PEMREXTTEXTOUTW;

typedef struct tagEMRPOLYTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   iGraphicsMode;      
    FLOAT   exScale;            
    FLOAT   eyScale;            
    LONG    cStrings;
    EMRTEXT aemrtext[1];        
                                
} EMRPOLYTEXTOUTA, *PEMRPOLYTEXTOUTA,
  EMRPOLYTEXTOUTW, *PEMRPOLYTEXTOUTW;

typedef struct tagEMRBITBLT
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
} EMRBITBLT, *PEMRBITBLT;

typedef struct tagEMRSTRETCHBLT
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    LONG    cxSrc;
    LONG    cySrc;
} EMRSTRETCHBLT, *PEMRSTRETCHBLT;

typedef struct tagEMRMASKBLT
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         
    DWORD   offBmiMask;         
    DWORD   cbBmiMask;          
    DWORD   offBitsMask;        
    DWORD   cbBitsMask;         
} EMRMASKBLT, *PEMRMASKBLT;

typedef struct tagEMRPLGBLT
{
    EMR     emr;
    RECTL   rclBounds;          
    POINTL  aptlDest[3];
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         
    DWORD   offBmiMask;         
    DWORD   cbBmiMask;          
    DWORD   offBitsMask;        
    DWORD   cbBitsMask;         
} EMRPLGBLT, *PEMRPLGBLT;

typedef struct tagEMRSETDIBITSTODEVICE
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    DWORD   iUsageSrc;          
    DWORD   iStartScan;
    DWORD   cScans;
} EMRSETDIBITSTODEVICE, *PEMRSETDIBITSTODEVICE;

typedef struct tagEMRSTRETCHDIBITS
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    DWORD   iUsageSrc;          
    DWORD   dwRop;
    LONG    cxDest;
    LONG    cyDest;
} EMRSTRETCHDIBITS, *PEMRSTRETCHDIBITS;

typedef struct tagEMREXTCREATEFONTINDIRECTW
{
    EMR     emr;
    DWORD   ihFont;             
    EXTLOGFONTW elfw;
} EMREXTCREATEFONTINDIRECTW, *PEMREXTCREATEFONTINDIRECTW;

typedef struct tagEMRCREATEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              
    LOGPALETTE lgpl;            
                                
} EMRCREATEPALETTE, *PEMRCREATEPALETTE;

typedef struct tagEMRCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              
    LOGPEN  lopn;
} EMRCREATEPEN, *PEMRCREATEPEN;

typedef struct tagEMREXTCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              
    DWORD   offBmi;             
    DWORD   cbBmi;              
                                
                                
    DWORD   offBits;            
    DWORD   cbBits;             
    EXTLOGPEN elp;              
} EMREXTCREATEPEN, *PEMREXTCREATEPEN;

typedef struct tagEMRCREATEBRUSHINDIRECT
{
    EMR        emr;
    DWORD      ihBrush;          
    LOGBRUSH32 lb;               
                                 
} EMRCREATEBRUSHINDIRECT, *PEMRCREATEBRUSHINDIRECT;

typedef struct tagEMRCREATEMONOBRUSH
{
    EMR     emr;
    DWORD   ihBrush;            
    DWORD   iUsage;             
    DWORD   offBmi;             
    DWORD   cbBmi;              
    DWORD   offBits;            
    DWORD   cbBits;             
} EMRCREATEMONOBRUSH, *PEMRCREATEMONOBRUSH;

typedef struct tagEMRCREATEDIBPATTERNBRUSHPT
{
    EMR     emr;
    DWORD   ihBrush;            
    DWORD   iUsage;             
    DWORD   offBmi;             
    DWORD   cbBmi;              
                                
                                
    DWORD   offBits;            
    DWORD   cbBits;             
} EMRCREATEDIBPATTERNBRUSHPT, *PEMRCREATEDIBPATTERNBRUSHPT;

typedef struct tagEMRFORMAT
{
    DWORD   dSignature;         
    DWORD   nVersion;           
    DWORD   cbData;             
    DWORD   offData;            
                                
} EMRFORMAT, *PEMRFORMAT;



typedef struct tagEMRGLSRECORD
{
    EMR     emr;
    DWORD   cbData;             
    BYTE    Data[1];
} EMRGLSRECORD, *PEMRGLSRECORD;

typedef struct tagEMRGLSBOUNDEDRECORD
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cbData;             
    BYTE    Data[1];
} EMRGLSBOUNDEDRECORD, *PEMRGLSBOUNDEDRECORD;

typedef struct tagEMRPIXELFORMAT
{
    EMR     emr;
    PIXELFORMATDESCRIPTOR pfd;
} EMRPIXELFORMAT, *PEMRPIXELFORMAT;

typedef struct tagEMRCREATECOLORSPACE
{
    EMR             emr;
    DWORD           ihCS;       
    LOGCOLORSPACEA  lcs;        
} EMRCREATECOLORSPACE, *PEMRCREATECOLORSPACE;

typedef struct tagEMRSETCOLORSPACE
{
    EMR     emr;
    DWORD   ihCS;               
} EMRSETCOLORSPACE,    *PEMRSETCOLORSPACE,
  EMRSELECTCOLORSPACE, *PEMRSELECTCOLORSPACE,
  EMRDELETECOLORSPACE, *PEMRDELETECOLORSPACE;

#line 4931 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"



typedef struct tagEMREXTESCAPE
{
    EMR     emr;
    INT     iEscape;            
    INT     cbEscData;          
    BYTE    EscData[1];         
} EMREXTESCAPE,  *PEMREXTESCAPE,
  EMRDRAWESCAPE, *PEMRDRAWESCAPE;

typedef struct tagEMRNAMEDESCAPE
{
    EMR     emr;
    INT     iEscape;            
    INT     cbDriver;           
    INT     cbEscData;          
    BYTE    EscData[1];         
} EMRNAMEDESCAPE, *PEMRNAMEDESCAPE;



typedef struct tagEMRSETICMPROFILE
{
    EMR     emr;
    DWORD   dwFlags;            
    DWORD   cbName;             
    DWORD   cbData;             
    BYTE    Data[1];            
} EMRSETICMPROFILE,  *PEMRSETICMPROFILE,
  EMRSETICMPROFILEA, *PEMRSETICMPROFILEA,
  EMRSETICMPROFILEW, *PEMRSETICMPROFILEW;



typedef struct tagEMRCREATECOLORSPACEW
{
    EMR             emr;
    DWORD           ihCS;       
    LOGCOLORSPACEW  lcs;        
    DWORD           dwFlags;    
    DWORD           cbData;     
    BYTE            Data[1];    
} EMRCREATECOLORSPACEW, *PEMRCREATECOLORSPACEW;



typedef struct tagCOLORMATCHTOTARGET
{
    EMR     emr;
    DWORD   dwAction;           
    DWORD   dwFlags;            
    DWORD   cbName;             
    DWORD   cbData;             
    BYTE    Data[1];            
} EMRCOLORMATCHTOTARGET, *PEMRCOLORMATCHTOTARGET;

typedef struct tagCOLORCORRECTPALETTE
{
    EMR     emr;
    DWORD   ihPalette;          
    DWORD   nFirstEntry;        
    DWORD   nPalEntries;        
    DWORD   nReserved;          
} EMRCOLORCORRECTPALETTE, *PEMRCOLORCORRECTPALETTE;

typedef struct tagEMRALPHABLEND
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    LONG    cxSrc;
    LONG    cySrc;
} EMRALPHABLEND, *PEMRALPHABLEND;

typedef struct tagEMRGRADIENTFILL
{
    EMR       emr;
    RECTL     rclBounds;          
    DWORD     nVer;
    DWORD     nTri;
    ULONG     ulMode;
    TRIVERTEX Ver[1];
}EMRGRADIENTFILL,*PEMRGRADIENTFILL;

typedef struct tagEMRTRANSPARENTBLT
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    LONG    cxSrc;
    LONG    cySrc;
} EMRTRANSPARENTBLT, *PEMRTRANSPARENTBLT;


#line 5056 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"










#line 5067 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"




__declspec(dllimport) BOOL  __stdcall wglCopyContext(HGLRC, HGLRC, UINT);
__declspec(dllimport) HGLRC __stdcall wglCreateContext(HDC);
__declspec(dllimport) HGLRC __stdcall wglCreateLayerContext(HDC, int);
__declspec(dllimport) BOOL  __stdcall wglDeleteContext(HGLRC);
__declspec(dllimport) HGLRC __stdcall wglGetCurrentContext(void);
__declspec(dllimport) HDC   __stdcall wglGetCurrentDC(void);
__declspec(dllimport) PROC  __stdcall wglGetProcAddress(LPCSTR);
__declspec(dllimport) BOOL  __stdcall wglMakeCurrent(HDC, HGLRC);
__declspec(dllimport) BOOL  __stdcall wglShareLists(HGLRC, HGLRC);
__declspec(dllimport) BOOL  __stdcall wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD);
__declspec(dllimport) BOOL  __stdcall wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD);




#line 5087 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall SwapBuffers(HDC);

typedef struct _POINTFLOAT {
    FLOAT   x;
    FLOAT   y;
} POINTFLOAT, *PPOINTFLOAT;

typedef struct _GLYPHMETRICSFLOAT {
    FLOAT       gmfBlackBoxX;
    FLOAT       gmfBlackBoxY;
    POINTFLOAT  gmfptGlyphOrigin;
    FLOAT       gmfCellIncX;
    FLOAT       gmfCellIncY;
} GLYPHMETRICSFLOAT, *PGLYPHMETRICSFLOAT,  *LPGLYPHMETRICSFLOAT;



__declspec(dllimport) BOOL  __stdcall wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);
__declspec(dllimport) BOOL  __stdcall wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);




#line 5113 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


typedef struct tagLAYERPLANEDESCRIPTOR { 
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;
    BYTE  iPixelType;
    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAccumBits;
    BYTE  cAccumRedBits;
    BYTE  cAccumGreenBits;
    BYTE  cAccumBlueBits;
    BYTE  cAccumAlphaBits;
    BYTE  cDepthBits;
    BYTE  cStencilBits;
    BYTE  cAuxBuffers;
    BYTE  iLayerPlane;
    BYTE  bReserved;
    COLORREF crTransparent;
} LAYERPLANEDESCRIPTOR, *PLAYERPLANEDESCRIPTOR,  *LPLAYERPLANEDESCRIPTOR;

















































__declspec(dllimport) BOOL  __stdcall wglDescribeLayerPlane(HDC, int, int, UINT,
                                             LPLAYERPLANEDESCRIPTOR);
__declspec(dllimport) int   __stdcall wglSetLayerPaletteEntries(HDC, int, int, int,
                                                 const COLORREF *);
__declspec(dllimport) int   __stdcall wglGetLayerPaletteEntries(HDC, int, int, int,
                                                 COLORREF *);
__declspec(dllimport) BOOL  __stdcall wglRealizeLayerPalette(HDC, int, BOOL);
__declspec(dllimport) BOOL  __stdcall wglSwapLayerBuffers(HDC, UINT);



typedef struct _WGLSWAP
{
    HDC hdc;
    UINT uiFlags;
} WGLSWAP, *PWGLSWAP,  *LPWGLSWAP;



__declspec(dllimport) DWORD __stdcall wglSwapMultipleBuffers(UINT, const WGLSWAP *);

#line 5212 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"

#line 5214 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


}
#line 5218 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


#line 5221 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wingdi.h"


#line 164 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"























#line 25 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






extern "C" {
#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









typedef HANDLE HDWP;
typedef void MENUTEMPLATEA;
typedef void MENUTEMPLATEW;

typedef MENUTEMPLATEW MENUTEMPLATE;


#line 50 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
typedef PVOID LPMENUTEMPLATEA;
typedef PVOID LPMENUTEMPLATEW;

typedef LPMENUTEMPLATEW LPMENUTEMPLATE;


#line 57 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

typedef LRESULT (__stdcall* WNDPROC)(HWND, UINT, WPARAM, LPARAM);



typedef INT_PTR (__stdcall* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
typedef void (__stdcall* TIMERPROC)(HWND, UINT, UINT_PTR, DWORD);
typedef BOOL (__stdcall* GRAYSTRINGPROC)(HDC, LPARAM, int);
typedef BOOL (__stdcall* WNDENUMPROC)(HWND, LPARAM);
typedef LRESULT (__stdcall* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
typedef void (__stdcall* SENDASYNCPROC)(HWND, UINT, ULONG_PTR, LRESULT);

typedef BOOL (__stdcall* PROPENUMPROCA)(HWND, LPCSTR, HANDLE);
typedef BOOL (__stdcall* PROPENUMPROCW)(HWND, LPCWSTR, HANDLE);

typedef BOOL (__stdcall* PROPENUMPROCEXA)(HWND, LPSTR, HANDLE, ULONG_PTR);
typedef BOOL (__stdcall* PROPENUMPROCEXW)(HWND, LPWSTR, HANDLE, ULONG_PTR);

typedef int (__stdcall* EDITWORDBREAKPROCA)(LPSTR lpch, int ichCurrent, int cch, int code);
typedef int (__stdcall* EDITWORDBREAKPROCW)(LPWSTR lpch, int ichCurrent, int cch, int code);


typedef BOOL (__stdcall* DRAWSTATEPROC)(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy);
#line 81 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





















#line 103 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


typedef PROPENUMPROCW        PROPENUMPROC;
typedef PROPENUMPROCEXW      PROPENUMPROCEX;
typedef EDITWORDBREAKPROCW   EDITWORDBREAKPROC;




#line 113 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



typedef BOOL (__stdcall* NAMEENUMPROCA)(LPSTR, LPARAM);
typedef BOOL (__stdcall* NAMEENUMPROCW)(LPWSTR, LPARAM);

typedef NAMEENUMPROCA   WINSTAENUMPROCA;
typedef NAMEENUMPROCA   DESKTOPENUMPROCA;
typedef NAMEENUMPROCW   WINSTAENUMPROCW;
typedef NAMEENUMPROCW   DESKTOPENUMPROCW;












#line 136 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


typedef WINSTAENUMPROCW     WINSTAENUMPROC;
typedef DESKTOPENUMPROCW    DESKTOPENUMPROC;






#line 147 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"








#line 156 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




























#line 185 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"















#line 201 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 204 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
int
__stdcall
wvsprintfA(
         LPSTR,
          LPCSTR,
         va_list arglist);
__declspec(dllimport)
int
__stdcall
wvsprintfW(
         LPWSTR,
          LPCWSTR,
         va_list arglist);




#line 224 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
int
__cdecl
wsprintfA(
         LPSTR,
          LPCSTR,
    ...);
__declspec(dllimport)
int
__cdecl
wsprintfW(
         LPWSTR,
          LPCWSTR,
    ...);




#line 244 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




































#line 281 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









































#line 323 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"















#line 339 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


























#line 366 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"








































































































































































#line 535 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









































#line 577 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






#line 584 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





































#line 622 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


















#line 641 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





#line 647 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




#line 652 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






#line 659 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 662 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
































typedef struct tagCBT_CREATEWNDA
{
    struct tagCREATESTRUCTA *lpcs;
    HWND           hwndInsertAfter;
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;



typedef struct tagCBT_CREATEWNDW
{
    struct tagCREATESTRUCTW *lpcs;
    HWND           hwndInsertAfter;
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;

typedef CBT_CREATEWNDW CBT_CREATEWND;
typedef LPCBT_CREATEWNDW LPCBT_CREATEWND;



#line 714 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;


























#line 750 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



























#line 778 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 782 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




#line 787 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


































































#line 854 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"











#line 866 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

typedef struct
{
    HWND    hwnd;
    RECT    rc;
} SHELLHOOKINFO, *LPSHELLHOOKINFO;




typedef struct tagEVENTMSG {
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD    time;
    HWND     hwnd;
} EVENTMSG, *PEVENTMSGMSG,  *NPEVENTMSGMSG,  *LPEVENTMSGMSG;

typedef struct tagEVENTMSG *PEVENTMSG,  *NPEVENTMSG,  *LPEVENTMSG;




typedef struct tagCWPSTRUCT {
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPSTRUCT, *PCWPSTRUCT,  *NPCWPSTRUCT,  *LPCWPSTRUCT;





typedef struct tagCWPRETSTRUCT {
    LRESULT lResult;
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPRETSTRUCT, *PCWPRETSTRUCT,  *NPCWPRETSTRUCT,  *LPCWPRETSTRUCT;

#line 909 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

















typedef struct tagKBDLLHOOKSTRUCT {
    DWORD   vkCode;
    DWORD   scanCode;
    DWORD   flags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} KBDLLHOOKSTRUCT,  *LPKBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;




typedef struct tagMSLLHOOKSTRUCT {
    POINT   pt;
    DWORD   mouseData;
    DWORD   flags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} MSLLHOOKSTRUCT,  *LPMSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;

#line 946 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




typedef struct tagDEBUGHOOKINFO
{
    DWORD   idThread;
    DWORD   idThreadInstaller;
    LPARAM  lParam;
    WPARAM  wParam;
    int     code;
} DEBUGHOOKINFO, *PDEBUGHOOKINFO,  *NPDEBUGHOOKINFO, * LPDEBUGHOOKINFO;




typedef struct tagMOUSEHOOKSTRUCT {
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    ULONG_PTR dwExtraInfo;
} MOUSEHOOKSTRUCT,  *LPMOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT;



typedef struct tagMOUSEHOOKSTRUCTEX : public tagMOUSEHOOKSTRUCT
{
    DWORD   mouseData;
} MOUSEHOOKSTRUCTEX, *LPMOUSEHOOKSTRUCTEX, *PMOUSEHOOKSTRUCTEX;






#line 982 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 983 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





typedef struct tagHARDWAREHOOKSTRUCT {
    HWND    hwnd;
    UINT    message;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT,  *LPHARDWAREHOOKSTRUCT, *PHARDWAREHOOKSTRUCT;
#line 995 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 996 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"














#line 1011 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




#line 1016 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









#line 1026 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






__declspec(dllimport)
HKL
__stdcall
LoadKeyboardLayoutA(
         LPCSTR pwszKLID,
         UINT Flags);
__declspec(dllimport)
HKL
__stdcall
LoadKeyboardLayoutW(
         LPCWSTR pwszKLID,
         UINT Flags);




#line 1049 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



__declspec(dllimport)
HKL
__stdcall
ActivateKeyboardLayout(
         HKL hkl,
         UINT Flags);







#line 1066 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
int
__stdcall
ToUnicodeEx(
         UINT wVirtKey,
         UINT wScanCode,
           const BYTE *lpKeyState,
         LPWSTR pwszBuff,
         int cchBuff,
         UINT wFlags,
           HKL dwhkl);
#line 1080 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnloadKeyboardLayout(
         HKL hkl);

__declspec(dllimport)
BOOL
__stdcall
GetKeyboardLayoutNameA(
         LPSTR pwszKLID);
__declspec(dllimport)
BOOL
__stdcall
GetKeyboardLayoutNameW(
         LPWSTR pwszKLID);




#line 1102 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
int
__stdcall
GetKeyboardLayoutList(
         int nBuff,
             HKL  *lpList);

__declspec(dllimport)
HKL
__stdcall
GetKeyboardLayout(
         DWORD idThread);

#line 1118 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



typedef struct tagMOUSEMOVEPOINT {
    int   x;
    int   y;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MOUSEMOVEPOINT, *PMOUSEMOVEPOINT, * LPMOUSEMOVEPOINT;







__declspec(dllimport)
int
__stdcall
GetMouseMovePointsEx(
         UINT cbSize,
         LPMOUSEMOVEPOINT lppt,
         LPMOUSEMOVEPOINT lpptBuf,
         int nBufPoints,
         DWORD resolution);

#line 1145 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"























__declspec(dllimport)
HDESK
__stdcall
CreateDesktopA(
         LPCSTR lpszDesktop,
      LPCSTR lpszDevice,
      LPDEVMODEA pDevmode,
         DWORD dwFlags,
         ACCESS_MASK dwDesiredAccess,
           LPSECURITY_ATTRIBUTES lpsa);
__declspec(dllimport)
HDESK
__stdcall
CreateDesktopW(
         LPCWSTR lpszDesktop,
      LPCWSTR lpszDevice,
      LPDEVMODEW pDevmode,
         DWORD dwFlags,
         ACCESS_MASK dwDesiredAccess,
           LPSECURITY_ATTRIBUTES lpsa);




#line 1193 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 1195 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 1196 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HDESK
__stdcall
OpenDesktopA(
         LPCSTR lpszDesktop,
         DWORD dwFlags,
         BOOL fInherit,
         ACCESS_MASK dwDesiredAccess);
__declspec(dllimport)
HDESK
__stdcall
OpenDesktopW(
         LPCWSTR lpszDesktop,
         DWORD dwFlags,
         BOOL fInherit,
         ACCESS_MASK dwDesiredAccess);




#line 1218 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HDESK
__stdcall
OpenInputDesktop(
         DWORD dwFlags,
         BOOL fInherit,
         ACCESS_MASK dwDesiredAccess);


__declspec(dllimport)
BOOL
__stdcall
EnumDesktopsA(
           HWINSTA hwinsta,
         DESKTOPENUMPROCA lpEnumFunc,
         LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumDesktopsW(
           HWINSTA hwinsta,
         DESKTOPENUMPROCW lpEnumFunc,
         LPARAM lParam);




#line 1247 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EnumDesktopWindows(
           HDESK hDesktop,
         WNDENUMPROC lpfn,
         LPARAM lParam);

__declspec(dllimport)
BOOL
__stdcall
SwitchDesktop(
         HDESK hDesktop);

__declspec(dllimport)
BOOL
__stdcall
SetThreadDesktop(
          HDESK hDesktop);

__declspec(dllimport)
BOOL
__stdcall
CloseDesktop(
         HDESK hDesktop);

__declspec(dllimport)
HDESK
__stdcall
GetThreadDesktop(
         DWORD dwThreadId);

#line 1281 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





























__declspec(dllimport)
HWINSTA
__stdcall
CreateWindowStationA(
           LPCSTR lpwinsta,
         DWORD dwFlags,
         ACCESS_MASK dwDesiredAccess,
           LPSECURITY_ATTRIBUTES lpsa);
__declspec(dllimport)
HWINSTA
__stdcall
CreateWindowStationW(
           LPCWSTR lpwinsta,
         DWORD dwFlags,
         ACCESS_MASK dwDesiredAccess,
           LPSECURITY_ATTRIBUTES lpsa);




#line 1331 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HWINSTA
__stdcall
OpenWindowStationA(
         LPCSTR lpszWinSta,
         BOOL fInherit,
         ACCESS_MASK dwDesiredAccess);
__declspec(dllimport)
HWINSTA
__stdcall
OpenWindowStationW(
         LPCWSTR lpszWinSta,
         BOOL fInherit,
         ACCESS_MASK dwDesiredAccess);




#line 1351 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EnumWindowStationsA(
         WINSTAENUMPROCA lpEnumFunc,
         LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumWindowStationsW(
         WINSTAENUMPROCW lpEnumFunc,
         LPARAM lParam);




#line 1369 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
CloseWindowStation(
         HWINSTA hWinSta);

__declspec(dllimport)
BOOL
__stdcall
SetProcessWindowStation(
         HWINSTA hWinSta);

__declspec(dllimport)
HWINSTA
__stdcall
GetProcessWindowStation(
    void);
#line 1388 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
SetUserObjectSecurity(
         HANDLE hObj,
         PSECURITY_INFORMATION pSIRequested,
         PSECURITY_DESCRIPTOR pSID);

__declspec(dllimport)
BOOL
__stdcall
GetUserObjectSecurity(
         HANDLE hObj,
         PSECURITY_INFORMATION pSIRequested,
           PSECURITY_DESCRIPTOR pSID,
         DWORD nLength,
         LPDWORD lpnLengthNeeded);






typedef struct tagUSEROBJECTFLAGS {
    BOOL fInherit;
    BOOL fReserved;
    DWORD dwFlags;
} USEROBJECTFLAGS, *PUSEROBJECTFLAGS;

__declspec(dllimport)
BOOL
__stdcall
GetUserObjectInformationA(
         HANDLE hObj,
         int nIndex,
           PVOID pvInfo,
         DWORD nLength,
           LPDWORD lpnLengthNeeded);
__declspec(dllimport)
BOOL
__stdcall
GetUserObjectInformationW(
         HANDLE hObj,
         int nIndex,
           PVOID pvInfo,
         DWORD nLength,
           LPDWORD lpnLengthNeeded);




#line 1443 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetUserObjectInformationA(
         HANDLE hObj,
         int nIndex,
           PVOID pvInfo,
         DWORD nLength);
__declspec(dllimport)
BOOL
__stdcall
SetUserObjectInformationW(
         HANDLE hObj,
         int nIndex,
           PVOID pvInfo,
         DWORD nLength);




#line 1465 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 1467 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


typedef struct tagWNDCLASSEXA {
    UINT        cbSize;
    
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
    
    HICON       hIconSm;
} WNDCLASSEXA, *PWNDCLASSEXA,  *NPWNDCLASSEXA,  *LPWNDCLASSEXA;
typedef struct tagWNDCLASSEXW {
    UINT        cbSize;
    
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
    
    HICON       hIconSm;
} WNDCLASSEXW, *PWNDCLASSEXW,  *NPWNDCLASSEXW,  *LPWNDCLASSEXW;

typedef WNDCLASSEXW WNDCLASSEX;
typedef PWNDCLASSEXW PWNDCLASSEX;
typedef NPWNDCLASSEXW NPWNDCLASSEX;
typedef LPWNDCLASSEXW LPWNDCLASSEX;





#line 1512 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 1513 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

typedef struct tagWNDCLASSA {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASSA, *PWNDCLASSA,  *NPWNDCLASSA,  *LPWNDCLASSA;
typedef struct tagWNDCLASSW {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
} WNDCLASSW, *PWNDCLASSW,  *NPWNDCLASSW,  *LPWNDCLASSW;

typedef WNDCLASSW WNDCLASS;
typedef PWNDCLASSW PWNDCLASS;
typedef NPWNDCLASSW NPWNDCLASS;
typedef LPWNDCLASSW LPWNDCLASS;





#line 1549 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsHungAppWindow(
         HWND hwnd);



__declspec(dllimport)
void
__stdcall
DisableProcessWindowsGhosting(
    void);
#line 1564 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







typedef struct tagMSG {
    HWND        hwnd;
    UINT        message;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       time;
    POINT       pt;



} MSG, *PMSG,  *NPMSG,  *LPMSG;











#line 1594 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"













































#line 1640 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





















#line 1662 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



































#line 1698 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







#line 1706 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
















typedef struct tagMINMAXINFO {
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO, *PMINMAXINFO, *LPMINMAXINFO;



















#line 1749 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 1750 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






















typedef struct tagCOPYDATASTRUCT {
    ULONG_PTR dwData;
    DWORD cbData;
    PVOID lpData;
} COPYDATASTRUCT, *PCOPYDATASTRUCT;


typedef struct tagMDINEXTMENU
{
    HMENU   hmenuIn;
    HMENU   hmenuNext;
    HWND    hwndNext;
} MDINEXTMENU, * PMDINEXTMENU,  * LPMDINEXTMENU;
#line 1786 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






















#line 1809 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"










#line 1820 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

















#line 1838 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




#line 1843 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"














#line 1858 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 1860 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






#line 1867 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"








































#line 1908 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 1909 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 1910 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 1912 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 1913 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"























#line 1937 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




#line 1942 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






#line 1949 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









#line 1959 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"










#line 1970 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"










#line 1981 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



























#line 2009 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 2011 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 2015 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



























#line 2043 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 2046 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 2050 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




#line 2055 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 2059 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






#line 2066 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
























#line 2091 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 2095 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 2099 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









#line 2109 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







#line 2117 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




















#line 2138 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




































#line 2175 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"










#line 2186 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 2187 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
















#line 2204 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
UINT
__stdcall
RegisterWindowMessageA(
         LPCSTR lpString);
__declspec(dllimport)
UINT
__stdcall
RegisterWindowMessageW(
         LPCWSTR lpString);




#line 2221 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"























typedef struct tagWINDOWPOS {
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;




typedef struct tagNCCALCSIZE_PARAMS {
    RECT       rgrc[3];
    PWINDOWPOS lppos;
} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;




























#line 2290 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 2292 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









#line 2302 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





#line 2308 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


typedef struct tagTRACKMOUSEEVENT {
    DWORD cbSize;
    DWORD dwFlags;
    HWND  hwndTrack;
    DWORD dwHoverTime;
} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;

__declspec(dllimport)
BOOL
__stdcall
TrackMouseEvent(
         LPTRACKMOUSEEVENT lpEventTrack);
#line 2323 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 2327 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 2328 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 2331 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


































































#line 2398 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

















#line 2416 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




#line 2421 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





#line 2427 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 2431 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 2434 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




















#line 2455 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 2459 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"























































__declspec(dllimport)
BOOL
__stdcall
DrawEdge(
         HDC hdc,
         LPRECT qrc,
         UINT edge,
         UINT grfFlags);









#line 2532 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

































#line 2566 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





__declspec(dllimport)
BOOL
__stdcall
DrawFrameControl(
         HDC,
         LPRECT,
         UINT,
         UINT);










#line 2590 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 2593 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
DrawCaption(
         HWND hwnd,
         HDC hdc,
         const RECT * lprect,
         UINT flags);





__declspec(dllimport)
BOOL
__stdcall
DrawAnimatedRects(
           HWND hwnd,
         int idAni,
         const RECT *lprcFrom,
         const RECT *lprcTo);

#line 2617 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
























#line 2642 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 2645 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







#line 2653 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




















#line 2674 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"










typedef struct tagACCEL {

    BYTE   fVirt;               
    WORD   key;
    WORD   cmd;




#line 2694 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
} ACCEL, *LPACCEL;

typedef struct tagPAINTSTRUCT {
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[32];
} PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;

typedef struct tagCREATESTRUCTA {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCSTR      lpszName;
    LPCSTR      lpszClass;
    DWORD       dwExStyle;
} CREATESTRUCTA, *LPCREATESTRUCTA;
typedef struct tagCREATESTRUCTW {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCWSTR     lpszName;
    LPCWSTR     lpszClass;
    DWORD       dwExStyle;
} CREATESTRUCTW, *LPCREATESTRUCTW;

typedef CREATESTRUCTW CREATESTRUCT;
typedef LPCREATESTRUCTW LPCREATESTRUCT;



#line 2740 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

typedef struct tagWINDOWPLACEMENT {
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;



} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;





#line 2759 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


typedef struct tagNMHDR
{
    HWND      hwndFrom;
    UINT_PTR  idFrom;
    UINT      code;         
}   NMHDR;
typedef NMHDR  * LPNMHDR;

typedef struct tagSTYLESTRUCT
{
    DWORD   styleOld;
    DWORD   styleNew;
} STYLESTRUCT, * LPSTYLESTRUCT;
#line 2775 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"











#line 2787 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



















#line 2807 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






#line 2814 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 2815 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




typedef struct tagMEASUREITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    UINT       itemWidth;
    UINT       itemHeight;
    ULONG_PTR  itemData;
} MEASUREITEMSTRUCT,  *PMEASUREITEMSTRUCT,  *LPMEASUREITEMSTRUCT;





typedef struct tagDRAWITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    ULONG_PTR   itemData;
} DRAWITEMSTRUCT,  *PDRAWITEMSTRUCT,  *LPDRAWITEMSTRUCT;




typedef struct tagDELETEITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    ULONG_PTR  itemData;
} DELETEITEMSTRUCT,  *PDELETEITEMSTRUCT,  *LPDELETEITEMSTRUCT;




typedef struct tagCOMPAREITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    HWND        hwndItem;
    UINT        itemID1;
    ULONG_PTR   itemData1;
    UINT        itemID2;
    ULONG_PTR   itemData2;
    DWORD       dwLocaleId;
} COMPAREITEMSTRUCT,  *PCOMPAREITEMSTRUCT,  *LPCOMPAREITEMSTRUCT;







__declspec(dllimport)
BOOL
__stdcall
GetMessageA(
         LPMSG lpMsg,
           HWND hWnd,
         UINT wMsgFilterMin,
         UINT wMsgFilterMax);
__declspec(dllimport)
BOOL
__stdcall
GetMessageW(
         LPMSG lpMsg,
           HWND hWnd,
         UINT wMsgFilterMin,
         UINT wMsgFilterMax);




#line 2896 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
    






















#line 2920 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
TranslateMessage(
         const MSG *lpMsg);

__declspec(dllimport)
LRESULT
__stdcall
DispatchMessageA(
         const MSG *lpMsg);
__declspec(dllimport)
LRESULT
__stdcall
DispatchMessageW(
         const MSG *lpMsg);




#line 2943 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
    
















#line 2961 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetMessageQueue(
         int cMessagesMax);

__declspec(dllimport)
BOOL
__stdcall
PeekMessageA(
         LPMSG lpMsg,
           HWND hWnd,
         UINT wMsgFilterMin,
         UINT wMsgFilterMax,
         UINT wRemoveMsg);
__declspec(dllimport)
BOOL
__stdcall
PeekMessageW(
         LPMSG lpMsg,
           HWND hWnd,
         UINT wMsgFilterMin,
         UINT wMsgFilterMax,
         UINT wRemoveMsg);




#line 2991 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"













#line 3005 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 3008 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
RegisterHotKey(
           HWND hWnd,
         int id,
         UINT fsModifiers,
         UINT vk);

__declspec(dllimport)
BOOL
__stdcall
UnregisterHotKey(
           HWND hWnd,
         int id);























#line 3048 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"








#line 3057 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




__declspec(dllimport)
BOOL
__stdcall
ExitWindowsEx(
         UINT uFlags,
         DWORD dwReason);

__declspec(dllimport)
BOOL
__stdcall
SwapMouseButton(
         BOOL fSwap);

__declspec(dllimport)
DWORD
__stdcall
GetMessagePos(
    void);

__declspec(dllimport)
LONG
__stdcall
GetMessageTime(
    void);

__declspec(dllimport)
LPARAM
__stdcall
GetMessageExtraInfo(
    void);







#line 3099 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
LPARAM
__stdcall
SetMessageExtraInfo(
         LPARAM lParam);
#line 3107 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
LRESULT
__stdcall
SendMessageA(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
SendMessageW(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);




#line 3129 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
    






















#line 3153 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



__declspec(dllimport)
LRESULT
__stdcall
SendMessageTimeoutA(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam,
         UINT fuFlags,
         UINT uTimeout,
           PDWORD_PTR lpdwResult);
__declspec(dllimport)
LRESULT
__stdcall
SendMessageTimeoutW(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam,
         UINT fuFlags,
         UINT uTimeout,
           PDWORD_PTR lpdwResult);




#line 3183 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SendNotifyMessageA(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
SendNotifyMessageW(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);




#line 3205 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SendMessageCallbackA(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam,
         SENDASYNCPROC lpResultCallBack,
         ULONG_PTR dwData);
__declspec(dllimport)
BOOL
__stdcall
SendMessageCallbackW(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam,
         SENDASYNCPROC lpResultCallBack,
         ULONG_PTR dwData);




#line 3231 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


































#line 3266 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageA(
         DWORD flags,
           LPDWORD lpInfo,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageW(
         DWORD flags,
           LPDWORD lpInfo,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);




#line 3293 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"












#line 3306 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




















#line 3327 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 3331 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 3334 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




typedef  PVOID           HDEVNOTIFY;
typedef  HDEVNOTIFY     *PHDEVNOTIFY;





#line 3346 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HDEVNOTIFY
__stdcall
RegisterDeviceNotificationA(
         HANDLE hRecipient,
         LPVOID NotificationFilter,
         DWORD Flags);
__declspec(dllimport)
HDEVNOTIFY
__stdcall
RegisterDeviceNotificationW(
         HANDLE hRecipient,
         LPVOID NotificationFilter,
         DWORD Flags);




#line 3366 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnregisterDeviceNotification(
         HDEVNOTIFY Handle);

#line 3374 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
PostMessageA(
           HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
PostMessageW(
           HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);




#line 3397 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
PostThreadMessageA(
         DWORD idThread,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
PostThreadMessageW(
         DWORD idThread,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);




#line 3419 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









#line 3429 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"








#line 3438 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
AttachThreadInput(
         DWORD idAttach,
         DWORD idAttachTo,
         BOOL fAttach);


__declspec(dllimport)
BOOL
__stdcall
ReplyMessage(
         LRESULT lResult);

__declspec(dllimport)
BOOL
__stdcall
WaitMessage(
    void);


__declspec(dllimport)
DWORD
__stdcall
WaitForInputIdle(
         HANDLE hProcess,
         DWORD dwMilliseconds);

__declspec(dllimport)

LRESULT
__stdcall



#line 3476 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
DefWindowProcA(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)

LRESULT
__stdcall



#line 3489 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
DefWindowProcW(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);




#line 3499 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
void
__stdcall
PostQuitMessage(
         int nExitCode);



__declspec(dllimport)
LRESULT
__stdcall
CallWindowProcA(
         WNDPROC lpPrevWndFunc,
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
CallWindowProcW(
         WNDPROC lpPrevWndFunc,
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);




#line 3531 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



























#line 3559 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
InSendMessage(
    void);


__declspec(dllimport)
DWORD
__stdcall
InSendMessageEx(
      LPVOID lpReserved);









#line 3582 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
UINT
__stdcall
GetDoubleClickTime(
    void);

__declspec(dllimport)
BOOL
__stdcall
SetDoubleClickTime(
         UINT);

__declspec(dllimport)
ATOM
__stdcall
RegisterClassA(
         const WNDCLASSA *lpWndClass);
__declspec(dllimport)
ATOM
__stdcall
RegisterClassW(
         const WNDCLASSW *lpWndClass);




#line 3610 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnregisterClassA(
         LPCSTR lpClassName,
         HINSTANCE hInstance);
__declspec(dllimport)
BOOL
__stdcall
UnregisterClassW(
         LPCWSTR lpClassName,
         HINSTANCE hInstance);




#line 3628 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetClassInfoA(
           HINSTANCE hInstance,
         LPCSTR lpClassName,
         LPWNDCLASSA lpWndClass);
__declspec(dllimport)
BOOL
__stdcall
GetClassInfoW(
           HINSTANCE hInstance,
         LPCWSTR lpClassName,
         LPWNDCLASSW lpWndClass);




#line 3648 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
ATOM
__stdcall
RegisterClassExA(
         const WNDCLASSEXA *);
__declspec(dllimport)
ATOM
__stdcall
RegisterClassExW(
         const WNDCLASSEXW *);




#line 3665 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetClassInfoExA(
           HINSTANCE hInstance,
         LPCSTR lpszClass,
         LPWNDCLASSEXA lpwcx);
__declspec(dllimport)
BOOL
__stdcall
GetClassInfoExW(
           HINSTANCE hInstance,
         LPCWSTR lpszClass,
         LPWNDCLASSEXW lpwcx);




#line 3685 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 3687 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"










#line 3698 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
CreateWindowExA(
         DWORD dwExStyle,
           LPCSTR lpClassName,
           LPCSTR lpWindowName,
         DWORD dwStyle,
         int X,
         int Y,
         int nWidth,
         int nHeight,
           HWND hWndParent,
           HMENU hMenu,
           HINSTANCE hInstance,
           LPVOID lpParam);
__declspec(dllimport)
HWND
__stdcall
CreateWindowExW(
         DWORD dwExStyle,
           LPCWSTR lpClassName,
           LPCWSTR lpWindowName,
         DWORD dwStyle,
         int X,
         int Y,
         int nWidth,
         int nHeight,
           HWND hWndParent,
           HMENU hMenu,
           HINSTANCE hInstance,
           LPVOID lpParam);




#line 3736 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"













#line 3750 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsWindow(
           HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
IsMenu(
         HMENU hMenu);

__declspec(dllimport)
BOOL
__stdcall
IsChild(
         HWND hWndParent,
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
DestroyWindow(
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
ShowWindow(
         HWND hWnd,
         int nCmdShow);


__declspec(dllimport)
BOOL
__stdcall
AnimateWindow(
         HWND hWnd,
         DWORD dwTime,
         DWORD dwFlags);
#line 3792 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




__declspec(dllimport)
BOOL
__stdcall
UpdateLayeredWindow(
         HWND hWnd,
           HDC hdcDst,
           POINT *pptDst,
           SIZE *psize,
           HDC hdcSrc,
           POINT *pptSrc,
         COLORREF crKey,
           BLENDFUNCTION *pblend,
         DWORD dwFlags);






typedef struct tagUPDATELAYEREDWINDOWINFO
{
                        DWORD               cbSize;
                      HDC                 hdcDst;
              POINT const         *pptDst;
              SIZE const          *psize;
                      HDC                 hdcSrc;
              POINT const         *pptSrc;
                      COLORREF            crKey;
              BLENDFUNCTION const *pblend;
                        DWORD               dwFlags;
              RECT const          *prcDirty;
} UPDATELAYEREDWINDOWINFO, *PUPDATELAYEREDWINDOWINFO;



typedef
#line 3833 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
__declspec(dllimport)
BOOL
__stdcall
UpdateLayeredWindowIndirect(
         HWND hWnd,
           UPDATELAYEREDWINDOWINFO const *pULWInfo);

#line 3841 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






















#line 3864 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetLayeredWindowAttributes(
         HWND hwnd,
         COLORREF crKey,
         BYTE bAlpha,
         DWORD dwFlags);












#line 3886 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
ShowWindowAsync(
          HWND hWnd,
          int nCmdShow);
#line 3895 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
FlashWindow(
          HWND hWnd,
          BOOL bInvert);


typedef struct {
    UINT  cbSize;
    HWND  hwnd;
    DWORD dwFlags;
    UINT  uCount;
    DWORD dwTimeout;
} FLASHWINFO, *PFLASHWINFO;

__declspec(dllimport)
BOOL
__stdcall
FlashWindowEx(
         PFLASHWINFO pfwi);








#line 3926 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
ShowOwnedPopups(
          HWND hWnd,
          BOOL fShow);

__declspec(dllimport)
BOOL
__stdcall
OpenIcon(
          HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
CloseWindow(
          HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
MoveWindow(
         HWND hWnd,
         int X,
         int Y,
         int nWidth,
         int nHeight,
         BOOL bRepaint);

__declspec(dllimport)
BOOL
__stdcall
SetWindowPos(
         HWND hWnd,
           HWND hWndInsertAfter,
         int X,
         int Y,
         int cx,
         int cy,
         UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
GetWindowPlacement(
         HWND hWnd,
         WINDOWPLACEMENT *lpwndpl);

__declspec(dllimport)
BOOL
__stdcall
SetWindowPlacement(
         HWND hWnd,
         const WINDOWPLACEMENT *lpwndpl);




__declspec(dllimport)
HDWP
__stdcall
BeginDeferWindowPos(
         int nNumWindows);

__declspec(dllimport)
HDWP
__stdcall
DeferWindowPos(
         HDWP hWinPosInfo,
         HWND hWnd,
           HWND hWndInsertAfter,
         int x,
         int y,
         int cx,
         int cy,
         UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
EndDeferWindowPos(
         HDWP hWinPosInfo);

#line 4012 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsWindowVisible(
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
IsIconic(
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
AnyPopup(
    void);

__declspec(dllimport)
BOOL
__stdcall
BringWindowToTop(
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
IsZoomed(
         HWND hWnd);






















#line 4065 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"














#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"


#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"
#line 34 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\pshpack2.h"
#line 4080 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    WORD cdit;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE;
typedef DLGTEMPLATE *LPDLGTEMPLATEA;
typedef DLGTEMPLATE *LPDLGTEMPLATEW;

typedef LPDLGTEMPLATEW LPDLGTEMPLATE;


#line 4100 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
typedef const DLGTEMPLATE *LPCDLGTEMPLATEA;
typedef const DLGTEMPLATE *LPCDLGTEMPLATEW;

typedef LPCDLGTEMPLATEW LPCDLGTEMPLATE;


#line 4107 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    short x;
    short y;
    short cx;
    short cy;
    WORD id;
} DLGITEMTEMPLATE;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEW;

typedef PDLGITEMTEMPLATEW PDLGITEMTEMPLATE;


#line 4127 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEW;

typedef LPDLGITEMTEMPLATEW LPDLGITEMTEMPLATE;


#line 4134 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"


#line 36 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"
#line 37 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\poppack.h"
#line 4137 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
CreateDialogParamA(
           HINSTANCE hInstance,
         LPCSTR lpTemplateName,
           HWND hWndParent,
           DLGPROC lpDialogFunc,
         LPARAM dwInitParam);
__declspec(dllimport)
HWND
__stdcall
CreateDialogParamW(
           HINSTANCE hInstance,
         LPCWSTR lpTemplateName,
           HWND hWndParent,
           DLGPROC lpDialogFunc,
         LPARAM dwInitParam);




#line 4161 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
CreateDialogIndirectParamA(
           HINSTANCE hInstance,
         LPCDLGTEMPLATEA lpTemplate,
           HWND hWndParent,
           DLGPROC lpDialogFunc,
         LPARAM dwInitParam);
__declspec(dllimport)
HWND
__stdcall
CreateDialogIndirectParamW(
           HINSTANCE hInstance,
         LPCDLGTEMPLATEW lpTemplate,
           HWND hWndParent,
           DLGPROC lpDialogFunc,
         LPARAM dwInitParam);




#line 4185 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









#line 4195 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









#line 4205 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxParamA(
           HINSTANCE hInstance,
         LPCSTR lpTemplateName,
           HWND hWndParent,
           DLGPROC lpDialogFunc,
         LPARAM dwInitParam);
__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxParamW(
           HINSTANCE hInstance,
         LPCWSTR lpTemplateName,
           HWND hWndParent,
           DLGPROC lpDialogFunc,
         LPARAM dwInitParam);




#line 4229 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxIndirectParamA(
           HINSTANCE hInstance,
         LPCDLGTEMPLATEA hDialogTemplate,
           HWND hWndParent,
           DLGPROC lpDialogFunc,
         LPARAM dwInitParam);
__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxIndirectParamW(
           HINSTANCE hInstance,
         LPCDLGTEMPLATEW hDialogTemplate,
           HWND hWndParent,
           DLGPROC lpDialogFunc,
         LPARAM dwInitParam);




#line 4253 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









#line 4263 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









#line 4273 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EndDialog(
         HWND hDlg,
         INT_PTR nResult);

__declspec(dllimport)
HWND
__stdcall
GetDlgItem(
           HWND hDlg,
         int nIDDlgItem);

__declspec(dllimport)
BOOL
__stdcall
SetDlgItemInt(
         HWND hDlg,
         int nIDDlgItem,
         UINT uValue,
         BOOL bSigned);

__declspec(dllimport)
UINT
__stdcall
GetDlgItemInt(
         HWND hDlg,
         int nIDDlgItem,
           BOOL *lpTranslated,
         BOOL bSigned);

__declspec(dllimport)
BOOL
__stdcall
SetDlgItemTextA(
         HWND hDlg,
         int nIDDlgItem,
         LPCSTR lpString);
__declspec(dllimport)
BOOL
__stdcall
SetDlgItemTextW(
         HWND hDlg,
         int nIDDlgItem,
         LPCWSTR lpString);




#line 4325 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
UINT
__stdcall
GetDlgItemTextA(
         HWND hDlg,
         int nIDDlgItem,
         LPSTR lpString,
         int cchMax);
__declspec(dllimport)
UINT
__stdcall
GetDlgItemTextW(
         HWND hDlg,
         int nIDDlgItem,
         LPWSTR lpString,
         int cchMax);




#line 4347 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
CheckDlgButton(
         HWND hDlg,
         int nIDButton,
         UINT uCheck);

__declspec(dllimport)
BOOL
__stdcall
CheckRadioButton(
         HWND hDlg,
         int nIDFirstButton,
         int nIDLastButton,
         int nIDCheckButton);

__declspec(dllimport)
UINT
__stdcall
IsDlgButtonChecked(
         HWND hDlg,
         int nIDButton);

__declspec(dllimport)
LRESULT
__stdcall
SendDlgItemMessageA(
         HWND hDlg,
         int nIDDlgItem,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
SendDlgItemMessageW(
         HWND hDlg,
         int nIDDlgItem,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);




#line 4395 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetNextDlgGroupItem(
         HWND hDlg,
           HWND hCtl,
         BOOL bPrevious);

__declspec(dllimport)
HWND
__stdcall
GetNextDlgTabItem(
         HWND hDlg,
           HWND hCtl,
         BOOL bPrevious);

__declspec(dllimport)
int
__stdcall
GetDlgCtrlID(
         HWND hWnd);

__declspec(dllimport)
long
__stdcall
GetDialogBaseUnits(void);

__declspec(dllimport)

LRESULT
__stdcall



#line 4431 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
DefDlgProcA(
         HWND hDlg,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)

LRESULT
__stdcall



#line 4444 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
DefDlgProcW(
         HWND hDlg,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);




#line 4454 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"








#line 4463 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 4465 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
CallMsgFilterA(
         LPMSG lpMsg,
         int nCode);
__declspec(dllimport)
BOOL
__stdcall
CallMsgFilterW(
         LPMSG lpMsg,
         int nCode);




#line 4485 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 4487 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







__declspec(dllimport)
BOOL
__stdcall
OpenClipboard(
           HWND hWndNewOwner);

__declspec(dllimport)
BOOL
__stdcall
CloseClipboard(
    void);




__declspec(dllimport)
DWORD
__stdcall
GetClipboardSequenceNumber(
    void);

#line 4516 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetClipboardOwner(
    void);

__declspec(dllimport)
HWND
__stdcall
SetClipboardViewer(
         HWND hWndNewViewer);

__declspec(dllimport)
HWND
__stdcall
GetClipboardViewer(
    void);

__declspec(dllimport)
BOOL
__stdcall
ChangeClipboardChain(
         HWND hWndRemove,
         HWND hWndNewNext);

__declspec(dllimport)
HANDLE
__stdcall
SetClipboardData(
         UINT uFormat,
           HANDLE hMem);

__declspec(dllimport)
HANDLE
__stdcall
GetClipboardData(
         UINT uFormat);

__declspec(dllimport)
UINT
__stdcall
RegisterClipboardFormatA(
         LPCSTR lpszFormat);
__declspec(dllimport)
UINT
__stdcall
RegisterClipboardFormatW(
         LPCWSTR lpszFormat);




#line 4570 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
int
__stdcall
CountClipboardFormats(
    void);

__declspec(dllimport)
UINT
__stdcall
EnumClipboardFormats(
         UINT format);

__declspec(dllimport)
int
__stdcall
GetClipboardFormatNameA(
         UINT format,
         LPSTR lpszFormatName,
         int cchMaxCount);
__declspec(dllimport)
int
__stdcall
GetClipboardFormatNameW(
         UINT format,
         LPWSTR lpszFormatName,
         int cchMaxCount);




#line 4602 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EmptyClipboard(
    void);

__declspec(dllimport)
BOOL
__stdcall
IsClipboardFormatAvailable(
         UINT format);

__declspec(dllimport)
int
__stdcall
GetPriorityClipboardFormat(
           UINT *paFormatPriorityList,
         int cFormats);

__declspec(dllimport)
HWND
__stdcall
GetOpenClipboardWindow(
    void);

#line 4629 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





__declspec(dllimport)
BOOL
__stdcall
CharToOemA(
         LPCSTR lpszSrc,
         LPSTR lpszDst);
__declspec(dllimport)
BOOL
__stdcall
CharToOemW(
         LPCWSTR lpszSrc,
         LPSTR lpszDst);




#line 4651 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
OemToCharA(
         LPCSTR lpszSrc,
         LPSTR lpszDst);
__declspec(dllimport)
BOOL
__stdcall
OemToCharW(
         LPCSTR lpszSrc,
         LPWSTR lpszDst);




#line 4669 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
CharToOemBuffA(
         LPCSTR lpszSrc,
         LPSTR lpszDst,
         DWORD cchDstLength);
__declspec(dllimport)
BOOL
__stdcall
CharToOemBuffW(
         LPCWSTR lpszSrc,
         LPSTR lpszDst,
         DWORD cchDstLength);




#line 4689 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
OemToCharBuffA(
         LPCSTR lpszSrc,
         LPSTR lpszDst,
         DWORD cchDstLength);
__declspec(dllimport)
BOOL
__stdcall
OemToCharBuffW(
         LPCSTR lpszSrc,
         LPWSTR lpszDst,
         DWORD cchDstLength);




#line 4709 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
LPSTR
__stdcall
CharUpperA(
         LPSTR lpsz);
__declspec(dllimport)
LPWSTR
__stdcall
CharUpperW(
         LPWSTR lpsz);




#line 4725 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
CharUpperBuffA(
           LPSTR lpsz,
         DWORD cchLength);
__declspec(dllimport)
DWORD
__stdcall
CharUpperBuffW(
           LPWSTR lpsz,
         DWORD cchLength);




#line 4743 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
LPSTR
__stdcall
CharLowerA(
         LPSTR lpsz);
__declspec(dllimport)
LPWSTR
__stdcall
CharLowerW(
         LPWSTR lpsz);




#line 4759 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
CharLowerBuffA(
           LPSTR lpsz,
         DWORD cchLength);
__declspec(dllimport)
DWORD
__stdcall
CharLowerBuffW(
           LPWSTR lpsz,
         DWORD cchLength);




#line 4777 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
LPSTR
__stdcall
CharNextA(
         LPCSTR lpsz);
__declspec(dllimport)
LPWSTR
__stdcall
CharNextW(
         LPCWSTR lpsz);




#line 4793 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
LPSTR
__stdcall
CharPrevA(
         LPCSTR lpszStart,
         LPCSTR lpszCurrent);
__declspec(dllimport)
LPWSTR
__stdcall
CharPrevW(
         LPCWSTR lpszStart,
         LPCWSTR lpszCurrent);




#line 4811 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
LPSTR
__stdcall
CharNextExA(
          WORD CodePage,
          LPCSTR lpCurrentChar,
          DWORD dwFlags);

__declspec(dllimport)
LPSTR
__stdcall
CharPrevExA(
          WORD CodePage,
          LPCSTR lpStart,
          LPCSTR lpCurrentChar,
          DWORD dwFlags);
#line 4830 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




















__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaA(
         CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaW(
         WCHAR ch);




#line 4865 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaNumericA(
         CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaNumericW(
         WCHAR ch);




#line 4881 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsCharUpperA(
         CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharUpperW(
         WCHAR ch);




#line 4897 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsCharLowerA(
         CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharLowerW(
         WCHAR ch);




#line 4913 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 4915 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
SetFocus(
           HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
GetActiveWindow(
    void);

__declspec(dllimport)
HWND
__stdcall
GetFocus(
    void);

__declspec(dllimport)
UINT
__stdcall
GetKBCodePage(
    void);

__declspec(dllimport)
SHORT
__stdcall
GetKeyState(
         int nVirtKey);

__declspec(dllimport)
SHORT
__stdcall
GetAsyncKeyState(
         int vKey);

__declspec(dllimport)
BOOL
__stdcall
GetKeyboardState(
         PBYTE lpKeyState);

__declspec(dllimport)
BOOL
__stdcall
SetKeyboardState(
           LPBYTE lpKeyState);

__declspec(dllimport)
int
__stdcall
GetKeyNameTextA(
         LONG lParam,
         LPSTR lpString,
         int cchSize);
__declspec(dllimport)
int
__stdcall
GetKeyNameTextW(
         LONG lParam,
         LPWSTR lpString,
         int cchSize);




#line 4983 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
int
__stdcall
GetKeyboardType(
         int nTypeFlag);

__declspec(dllimport)
int
__stdcall
ToAscii(
         UINT uVirtKey,
         UINT uScanCode,
             const BYTE *lpKeyState,
         LPWORD lpChar,
         UINT uFlags);


__declspec(dllimport)
int
__stdcall
ToAsciiEx(
         UINT uVirtKey,
         UINT uScanCode,
             const BYTE *lpKeyState,
         LPWORD lpChar,
         UINT uFlags,
           HKL dwhkl);
#line 5012 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
int
__stdcall
ToUnicode(
         UINT wVirtKey,
         UINT wScanCode,
             const BYTE *lpKeyState,
         LPWSTR pwszBuff,
         int cchBuff,
         UINT wFlags);

__declspec(dllimport)
DWORD
__stdcall
OemKeyScan(
         WORD wOemChar);

__declspec(dllimport)
SHORT
__stdcall
VkKeyScanA(
         CHAR ch);
__declspec(dllimport)
SHORT
__stdcall
VkKeyScanW(
         WCHAR ch);




#line 5045 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
SHORT
__stdcall
VkKeyScanExA(
         CHAR ch,
         HKL dwhkl);
__declspec(dllimport)
SHORT
__stdcall
VkKeyScanExW(
         WCHAR ch,
         HKL dwhkl);




#line 5064 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 5065 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





#line 5071 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
void
__stdcall
keybd_event(
         BYTE bVk,
         BYTE bScan,
         DWORD dwFlags,
         ULONG_PTR dwExtraInfo);
















__declspec(dllimport)
void
__stdcall
mouse_event(
         DWORD dwFlags,
         DWORD dx,
         DWORD dy,
         DWORD dwData,
         ULONG_PTR dwExtraInfo);



typedef struct tagMOUSEINPUT {
    LONG    dx;
    LONG    dy;
    DWORD   mouseData;
    DWORD   dwFlags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} MOUSEINPUT, *PMOUSEINPUT, * LPMOUSEINPUT;

typedef struct tagKEYBDINPUT {
    WORD    wVk;
    WORD    wScan;
    DWORD   dwFlags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} KEYBDINPUT, *PKEYBDINPUT, * LPKEYBDINPUT;

typedef struct tagHARDWAREINPUT {
    DWORD   uMsg;
    WORD    wParamL;
    WORD    wParamH;
} HARDWAREINPUT, *PHARDWAREINPUT, * LPHARDWAREINPUT;





typedef struct tagINPUT {
    DWORD   type;

    union
    {
        MOUSEINPUT      mi;
        KEYBDINPUT      ki;
        HARDWAREINPUT   hi;
    };
} INPUT, *PINPUT, * LPINPUT;

__declspec(dllimport)
UINT
__stdcall
SendInput(
         UINT cInputs,                     
           LPINPUT pInputs,  
         int cbSize);                      

#line 5155 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


typedef struct tagLASTINPUTINFO {
    UINT cbSize;
    DWORD dwTime;
} LASTINPUTINFO, * PLASTINPUTINFO;

__declspec(dllimport)
BOOL
__stdcall
GetLastInputInfo(
         PLASTINPUTINFO plii);
#line 5168 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyA(
         UINT uCode,
         UINT uMapType);
__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyW(
         UINT uCode,
         UINT uMapType);




#line 5186 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyExA(
         UINT uCode,
         UINT uMapType,
           HKL dwhkl);
__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyExW(
         UINT uCode,
         UINT uMapType,
           HKL dwhkl);




#line 5207 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 5208 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetInputState(
    void);

__declspec(dllimport)
DWORD
__stdcall
GetQueueStatus(
         UINT flags);


__declspec(dllimport)
HWND
__stdcall
GetCapture(
    void);

__declspec(dllimport)
HWND
__stdcall
SetCapture(
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
ReleaseCapture(
    void);

__declspec(dllimport)
DWORD
__stdcall
MsgWaitForMultipleObjects(
         DWORD nCount,
             const HANDLE *pHandles,
         BOOL fWaitAll,
         DWORD dwMilliseconds,
         DWORD dwWakeMask);

__declspec(dllimport)
DWORD
__stdcall
MsgWaitForMultipleObjectsEx(
         DWORD nCount,
             const HANDLE *pHandles,
         DWORD dwMilliseconds,
         DWORD dwWakeMask,
         DWORD dwFlags);




















#line 5280 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"








#line 5289 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 5292 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






















__declspec(dllimport)
UINT_PTR
__stdcall
SetTimer(
           HWND hWnd,
         UINT_PTR nIDEvent,
         UINT uElapse,
           TIMERPROC lpTimerFunc);

__declspec(dllimport)
BOOL
__stdcall
KillTimer(
           HWND hWnd,
         UINT_PTR uIDEvent);

__declspec(dllimport)
BOOL
__stdcall
IsWindowUnicode(
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
EnableWindow(
         HWND hWnd,
         BOOL bEnable);

__declspec(dllimport)
BOOL
__stdcall
IsWindowEnabled(
         HWND hWnd);

__declspec(dllimport)
HACCEL
__stdcall
LoadAcceleratorsA(
           HINSTANCE hInstance,
         LPCSTR lpTableName);
__declspec(dllimport)
HACCEL
__stdcall
LoadAcceleratorsW(
           HINSTANCE hInstance,
         LPCWSTR lpTableName);




#line 5366 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HACCEL
__stdcall
CreateAcceleratorTableA(
           LPACCEL paccel, 
         int cAccel);
__declspec(dllimport)
HACCEL
__stdcall
CreateAcceleratorTableW(
           LPACCEL paccel, 
         int cAccel);




#line 5384 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
DestroyAcceleratorTable(
         HACCEL hAccel);

__declspec(dllimport)
int
__stdcall
CopyAcceleratorTableA(
         HACCEL hAccelSrc,
             LPACCEL lpAccelDst,
         int cAccelEntries);
__declspec(dllimport)
int
__stdcall
CopyAcceleratorTableW(
         HACCEL hAccelSrc,
             LPACCEL lpAccelDst,
         int cAccelEntries);




#line 5410 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



__declspec(dllimport)
int
__stdcall
TranslateAcceleratorA(
         HWND hWnd,
         HACCEL hAccTable,
         LPMSG lpMsg);
__declspec(dllimport)
int
__stdcall
TranslateAcceleratorW(
         HWND hWnd,
         HACCEL hAccTable,
         LPMSG lpMsg);




#line 5432 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 5434 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

















































































#line 5516 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






#line 5523 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 5527 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







#line 5535 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 5538 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 5542 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






#line 5549 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 5553 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 5555 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 5557 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







#line 5565 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 5569 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 5573 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 5575 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
int
__stdcall
GetSystemMetrics(
         int nIndex);


#line 5585 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



__declspec(dllimport)
HMENU
__stdcall
LoadMenuA(
           HINSTANCE hInstance,
         LPCSTR lpMenuName);
__declspec(dllimport)
HMENU
__stdcall
LoadMenuW(
           HINSTANCE hInstance,
         LPCWSTR lpMenuName);




#line 5605 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HMENU
__stdcall
LoadMenuIndirectA(
         const MENUTEMPLATEA *lpMenuTemplate);
__declspec(dllimport)
HMENU
__stdcall
LoadMenuIndirectW(
         const MENUTEMPLATEW *lpMenuTemplate);




#line 5621 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HMENU
__stdcall
GetMenu(
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
SetMenu(
         HWND hWnd,
           HMENU hMenu);

__declspec(dllimport)
BOOL
__stdcall
ChangeMenuA(
         HMENU hMenu,
         UINT cmd,
           LPCSTR lpszNewItem,
         UINT cmdInsert,
         UINT flags);
__declspec(dllimport)
BOOL
__stdcall
ChangeMenuW(
         HMENU hMenu,
         UINT cmd,
           LPCWSTR lpszNewItem,
         UINT cmdInsert,
         UINT flags);




#line 5658 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
HiliteMenuItem(
         HWND hWnd,
         HMENU hMenu,
         UINT uIDHiliteItem,
         UINT uHilite);

__declspec(dllimport)
int
__stdcall
GetMenuStringA(
         HMENU hMenu,
         UINT uIDItem,
           LPSTR lpString,
         int cchMax,
         UINT flags);
__declspec(dllimport)
int
__stdcall
GetMenuStringW(
         HMENU hMenu,
         UINT uIDItem,
           LPWSTR lpString,
         int cchMax,
         UINT flags);




#line 5691 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
UINT
__stdcall
GetMenuState(
         HMENU hMenu,
         UINT uId,
         UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
DrawMenuBar(
         HWND hWnd);




#line 5710 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
HMENU
__stdcall
GetSystemMenu(
         HWND hWnd,
         BOOL bRevert);


__declspec(dllimport)
HMENU
__stdcall
CreateMenu(
    void);

__declspec(dllimport)
HMENU
__stdcall
CreatePopupMenu(
    void);

__declspec(dllimport)
BOOL
__stdcall
DestroyMenu(
         HMENU hMenu);

__declspec(dllimport)
DWORD
__stdcall
CheckMenuItem(
         HMENU hMenu,
         UINT uIDCheckItem,
         UINT uCheck);

__declspec(dllimport)
BOOL
__stdcall
EnableMenuItem(
         HMENU hMenu,
         UINT uIDEnableItem,
         UINT uEnable);

__declspec(dllimport)
HMENU
__stdcall
GetSubMenu(
         HMENU hMenu,
         int nPos);

__declspec(dllimport)
UINT
__stdcall
GetMenuItemID(
         HMENU hMenu,
         int nPos);

__declspec(dllimport)
int
__stdcall
GetMenuItemCount(
           HMENU hMenu);

__declspec(dllimport)
BOOL
__stdcall
InsertMenuA(
         HMENU hMenu,
         UINT uPosition,
         UINT uFlags,
         UINT_PTR uIDNewItem,
           LPCSTR lpNewItem);
__declspec(dllimport)
BOOL
__stdcall
InsertMenuW(
         HMENU hMenu,
         UINT uPosition,
         UINT uFlags,
         UINT_PTR uIDNewItem,
           LPCWSTR lpNewItem);




#line 5797 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
AppendMenuA(
         HMENU hMenu,
         UINT uFlags,
         UINT_PTR uIDNewItem,
           LPCSTR lpNewItem);
__declspec(dllimport)
BOOL
__stdcall
AppendMenuW(
         HMENU hMenu,
         UINT uFlags,
         UINT_PTR uIDNewItem,
           LPCWSTR lpNewItem);




#line 5819 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
ModifyMenuA(
         HMENU hMnu,
         UINT uPosition,
         UINT uFlags,
         UINT_PTR uIDNewItem,
           LPCSTR lpNewItem);
__declspec(dllimport)
BOOL
__stdcall
ModifyMenuW(
         HMENU hMnu,
         UINT uPosition,
         UINT uFlags,
         UINT_PTR uIDNewItem,
           LPCWSTR lpNewItem);




#line 5843 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall RemoveMenu(
         HMENU hMenu,
         UINT uPosition,
         UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
DeleteMenu(
         HMENU hMenu,
         UINT uPosition,
         UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
SetMenuItemBitmaps(
         HMENU hMenu,
         UINT uPosition,
         UINT uFlags,
           HBITMAP hBitmapUnchecked,
           HBITMAP hBitmapChecked);

__declspec(dllimport)
LONG
__stdcall
GetMenuCheckMarkDimensions(
    void);

__declspec(dllimport)
BOOL
__stdcall
TrackPopupMenu(
         HMENU hMenu,
         UINT uFlags,
         int x,
         int y,
         int nReserved,
         HWND hWnd,
           const RECT *prcRect);








typedef struct tagTPMPARAMS
{
    UINT    cbSize;     
    RECT    rcExclude;  
}   TPMPARAMS;
typedef TPMPARAMS  *LPTPMPARAMS;

__declspec(dllimport)
BOOL
__stdcall
TrackPopupMenuEx(
         HMENU,
         UINT,
         int,
         int,
         HWND,
           LPTPMPARAMS);
#line 5912 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

















typedef struct tagMENUINFO
{
    DWORD   cbSize;
    DWORD   fMask;
    DWORD   dwStyle;
    UINT    cyMax;
    HBRUSH  hbrBack;
    DWORD   dwContextHelpID;
    ULONG_PTR dwMenuData;
}   MENUINFO,  *LPMENUINFO;
typedef MENUINFO const  *LPCMENUINFO;

__declspec(dllimport)
BOOL
__stdcall
GetMenuInfo(
         HMENU,
         LPMENUINFO);

__declspec(dllimport)
BOOL
__stdcall
SetMenuInfo(
         HMENU,
         LPCMENUINFO);

__declspec(dllimport)
BOOL
__stdcall
EndMenu(
        void);







typedef struct tagMENUGETOBJECTINFO
{
    DWORD dwFlags;
    UINT uPos;
    HMENU hmenu;
    PVOID riid;
    PVOID pvObj;
} MENUGETOBJECTINFO, * PMENUGETOBJECTINFO;












#line 5988 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"








#line 5997 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

















#line 6015 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


typedef struct tagMENUITEMINFOA
{
    UINT     cbSize;
    UINT     fMask;
    UINT     fType;         
    UINT     fState;        
    UINT     wID;           
    HMENU    hSubMenu;      
    HBITMAP  hbmpChecked;   
    HBITMAP  hbmpUnchecked; 
    ULONG_PTR dwItemData;   
    LPSTR    dwTypeData;    
    UINT     cch;           

    HBITMAP  hbmpItem;      
#line 6033 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
}   MENUITEMINFOA,  *LPMENUITEMINFOA;
typedef struct tagMENUITEMINFOW
{
    UINT     cbSize;
    UINT     fMask;
    UINT     fType;         
    UINT     fState;        
    UINT     wID;           
    HMENU    hSubMenu;      
    HBITMAP  hbmpChecked;   
    HBITMAP  hbmpUnchecked; 
    ULONG_PTR dwItemData;   
    LPWSTR   dwTypeData;    
    UINT     cch;           

    HBITMAP  hbmpItem;      
#line 6050 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
}   MENUITEMINFOW,  *LPMENUITEMINFOW;

typedef MENUITEMINFOW MENUITEMINFO;
typedef LPMENUITEMINFOW LPMENUITEMINFO;



#line 6058 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
typedef MENUITEMINFOA const  *LPCMENUITEMINFOA;
typedef MENUITEMINFOW const  *LPCMENUITEMINFOW;

typedef LPCMENUITEMINFOW LPCMENUITEMINFO;


#line 6065 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
InsertMenuItemA(
         HMENU hmenu,
         UINT item,
         BOOL fByPosition,
         LPCMENUITEMINFOA lpmi);
__declspec(dllimport)
BOOL
__stdcall
InsertMenuItemW(
         HMENU hmenu,
         UINT item,
         BOOL fByPosition,
         LPCMENUITEMINFOW lpmi);




#line 6088 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetMenuItemInfoA(
         HMENU hmenu,
         UINT item,
         BOOL fByPosition,
         LPMENUITEMINFOA lpmii);
__declspec(dllimport)
BOOL
__stdcall
GetMenuItemInfoW(
         HMENU hmenu,
         UINT item,
         BOOL fByPosition,
         LPMENUITEMINFOW lpmii);




#line 6110 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetMenuItemInfoA(
         HMENU hmenu,
         UINT item,
         BOOL fByPositon,
         LPCMENUITEMINFOA lpmii);
__declspec(dllimport)
BOOL
__stdcall
SetMenuItemInfoW(
         HMENU hmenu,
         UINT item,
         BOOL fByPositon,
         LPCMENUITEMINFOW lpmii);




#line 6132 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





__declspec(dllimport)
UINT
__stdcall
GetMenuDefaultItem(
         HMENU hMenu,
         UINT fByPos,
         UINT gmdiFlags);

__declspec(dllimport)
BOOL
__stdcall
SetMenuDefaultItem(
         HMENU hMenu,
         UINT uItem,
         UINT fByPos);

__declspec(dllimport)
BOOL
__stdcall
GetMenuItemRect(
           HWND hWnd,
         HMENU hMenu,
         UINT uItem,
         LPRECT lprcItem);

__declspec(dllimport)
int
__stdcall
MenuItemFromPoint(
           HWND hWnd,
         HMENU hMenu,
         POINT ptScreen);
#line 6170 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


















#line 6189 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"








#line 6198 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 6201 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 6202 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 6205 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







typedef struct tagDROPSTRUCT
{
    HWND    hwndSource;
    HWND    hwndSink;
    DWORD   wFmt;
    ULONG_PTR dwData;
    POINT   ptDrop;
    DWORD   dwControlData;
} DROPSTRUCT, *PDROPSTRUCT, *LPDROPSTRUCT;











__declspec(dllimport)
DWORD
__stdcall
DragObject(
         HWND hwndParent,
         HWND hwndFrom,
         UINT fmt,
         ULONG_PTR data,
           HCURSOR hcur);

__declspec(dllimport)
BOOL
__stdcall
DragDetect(
         HWND hwnd,
         POINT pt);
#line 6249 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
DrawIcon(
         HDC hDC,
         int X,
         int Y,
         HICON hIcon);


































#line 6293 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 6294 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

typedef struct tagDRAWTEXTPARAMS
{
    UINT    cbSize;
    int     iTabLength;
    int     iLeftMargin;
    int     iRightMargin;
    UINT    uiLengthDrawn;
} DRAWTEXTPARAMS,  *LPDRAWTEXTPARAMS;
#line 6304 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
int
__stdcall
DrawTextA(
         HDC hdc,
           LPCSTR lpchText,
         int cchText,
         LPRECT lprc,
         UINT format);
__declspec(dllimport)
int
__stdcall
DrawTextW(
         HDC hdc,
           LPCWSTR lpchText,
         int cchText,
         LPRECT lprc,
         UINT format);




#line 6329 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
    
























#line 6355 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



__declspec(dllimport)
int
__stdcall
DrawTextExA(
         HDC hdc,
           LPSTR lpchText,
         int cchText,
         LPRECT lprc,
         UINT format,
           LPDRAWTEXTPARAMS lpdtp);
__declspec(dllimport)
int
__stdcall
DrawTextExW(
         HDC hdc,
           LPWSTR lpchText,
         int cchText,
         LPRECT lprc,
         UINT format,
           LPDRAWTEXTPARAMS lpdtp);




#line 6383 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 6384 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 6386 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GrayStringA(
         HDC hDC,
           HBRUSH hBrush,
           GRAYSTRINGPROC lpOutputFunc,
         LPARAM lpData,
         int nCount,
         int X,
         int Y,
         int nWidth,
         int nHeight);
__declspec(dllimport)
BOOL
__stdcall
GrayStringW(
         HDC hDC,
           HBRUSH hBrush,
           GRAYSTRINGPROC lpOutputFunc,
         LPARAM lpData,
         int nCount,
         int X,
         int Y,
         int nWidth,
         int nHeight);




#line 6418 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


















#line 6437 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
DrawStateA(
         HDC hdc,
           HBRUSH hbrFore,
           DRAWSTATEPROC qfnCallBack,
         LPARAM lData,
         WPARAM wData,
         int x,
         int y,
         int cx,
         int cy,
         UINT uFlags);
__declspec(dllimport)
BOOL
__stdcall
DrawStateW(
         HDC hdc,
           HBRUSH hbrFore,
           DRAWSTATEPROC qfnCallBack,
         LPARAM lData,
         WPARAM wData,
         int x,
         int y,
         int cx,
         int cy,
         UINT uFlags);




#line 6472 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 6473 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
LONG
__stdcall
TabbedTextOutA(
         HDC hdc,
         int x,
         int y,
           LPCSTR lpString,
         int chCount,
         int nTabPositions,
             const INT *lpnTabStopPositions,
         int nTabOrigin);
__declspec(dllimport)
LONG
__stdcall
TabbedTextOutW(
         HDC hdc,
         int x,
         int y,
           LPCWSTR lpString,
         int chCount,
         int nTabPositions,
             const INT *lpnTabStopPositions,
         int nTabOrigin);




#line 6503 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
GetTabbedTextExtentA(
         HDC hdc,
           LPCSTR lpString,
         int chCount,
         int nTabPositions,
             const INT *lpnTabStopPositions);
__declspec(dllimport)
DWORD
__stdcall
GetTabbedTextExtentW(
         HDC hdc,
           LPCWSTR lpString,
         int chCount,
         int nTabPositions,
             const INT *lpnTabStopPositions);




#line 6527 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UpdateWindow(
         HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
SetActiveWindow(
         HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
GetForegroundWindow(
    void);


__declspec(dllimport)
BOOL
__stdcall
PaintDesktop(
         HDC hdc);

__declspec(dllimport)
void
__stdcall
SwitchToThisWindow(
         HWND hwnd,
         BOOL fUnknown);
#line 6560 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetForegroundWindow(
         HWND hWnd);


__declspec(dllimport)
BOOL
__stdcall
AllowSetForegroundWindow(
         DWORD dwProcessId);



__declspec(dllimport)
BOOL
__stdcall
LockSetForegroundWindow(
         UINT uLockCode);




#line 6586 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
WindowFromDC(
         HDC hDC);

__declspec(dllimport)
HDC
__stdcall
GetDC(
           HWND hWnd);

__declspec(dllimport)
HDC
__stdcall
GetDCEx(
           HWND hWnd,
           HRGN hrgnClip,
         DWORD flags);


















__declspec(dllimport)
HDC
__stdcall
GetWindowDC(
           HWND hWnd);

__declspec(dllimport)
int
__stdcall
ReleaseDC(
           HWND hWnd,
         HDC hDC);

__declspec(dllimport)
HDC
__stdcall
BeginPaint(
         HWND hWnd,
         LPPAINTSTRUCT lpPaint);

__declspec(dllimport)
BOOL
__stdcall
EndPaint(
         HWND hWnd,
         const PAINTSTRUCT *lpPaint);

__declspec(dllimport)
BOOL
__stdcall
GetUpdateRect(
         HWND hWnd,
           LPRECT lpRect,
         BOOL bErase);

__declspec(dllimport)
int
__stdcall
GetUpdateRgn(
         HWND hWnd,
         HRGN hRgn,
         BOOL bErase);

__declspec(dllimport)
int
__stdcall
SetWindowRgn(
         HWND hWnd,
           HRGN hRgn,
         BOOL bRedraw);


__declspec(dllimport)
int
__stdcall
GetWindowRgn(
         HWND hWnd,
         HRGN hRgn);










#line 6693 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
int
__stdcall
ExcludeUpdateRgn(
         HDC hDC,
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
InvalidateRect(
           HWND hWnd,
           const RECT *lpRect,
         BOOL bErase);

__declspec(dllimport)
BOOL
__stdcall
ValidateRect(
           HWND hWnd,
           const RECT *lpRect);

__declspec(dllimport)
BOOL
__stdcall
InvalidateRgn(
         HWND hWnd,
           HRGN hRgn,
         BOOL bErase);

__declspec(dllimport)
BOOL
__stdcall
ValidateRgn(
         HWND hWnd,
           HRGN hRgn);


__declspec(dllimport)
BOOL
__stdcall
RedrawWindow(
           HWND hWnd,
           const RECT *lprcUpdate,
           HRGN hrgnUpdate,
         UINT flags);


























__declspec(dllimport)
BOOL
__stdcall
LockWindowUpdate(
           HWND hWndLock);

__declspec(dllimport)
BOOL
__stdcall
ScrollWindow(
         HWND hWnd,
         int XAmount,
         int YAmount,
           const RECT *lpRect,
           const RECT *lpClipRect);

__declspec(dllimport)
BOOL
__stdcall
ScrollDC(
         HDC hDC,
         int dx,
         int dy,
           const RECT *lprcScroll,
           const RECT *lprcClip,
           HRGN hrgnUpdate,
           LPRECT lprcUpdate);

__declspec(dllimport)
int
__stdcall
ScrollWindowEx(
         HWND hWnd,
         int dx,
         int dy,
           const RECT *prcScroll,
           const RECT *prcClip,
           HRGN hrgnUpdate,
           LPRECT prcUpdate,
         UINT flags);






#line 6813 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



__declspec(dllimport)
int
__stdcall
SetScrollPos(
         HWND hWnd,
         int nBar,
         int nPos,
         BOOL bRedraw);

__declspec(dllimport)
int
__stdcall
GetScrollPos(
         HWND hWnd,
         int nBar);

__declspec(dllimport)
BOOL
__stdcall
SetScrollRange(
         HWND hWnd,
         int nBar,
         int nMinPos,
         int nMaxPos,
         BOOL bRedraw);

__declspec(dllimport)
BOOL
__stdcall
GetScrollRange(
         HWND hWnd,
         int nBar,
         LPINT lpMinPos,
         LPINT lpMaxPos);

__declspec(dllimport)
BOOL
__stdcall
ShowScrollBar(
         HWND hWnd,
         int wBar,
         BOOL bShow);

__declspec(dllimport)
BOOL
__stdcall
EnableScrollBar(
         HWND hWnd,
         UINT wSBflags,
         UINT wArrows);


















#line 6885 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetPropA(
         HWND hWnd,
         LPCSTR lpString,
           HANDLE hData);
__declspec(dllimport)
BOOL
__stdcall
SetPropW(
         HWND hWnd,
         LPCWSTR lpString,
           HANDLE hData);




#line 6905 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HANDLE
__stdcall
GetPropA(
         HWND hWnd,
         LPCSTR lpString);
__declspec(dllimport)
HANDLE
__stdcall
GetPropW(
         HWND hWnd,
         LPCWSTR lpString);




#line 6923 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HANDLE
__stdcall
RemovePropA(
         HWND hWnd,
         LPCSTR lpString);
__declspec(dllimport)
HANDLE
__stdcall
RemovePropW(
         HWND hWnd,
         LPCWSTR lpString);




#line 6941 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
int
__stdcall
EnumPropsExA(
         HWND hWnd,
         PROPENUMPROCEXA lpEnumFunc,
         LPARAM lParam);
__declspec(dllimport)
int
__stdcall
EnumPropsExW(
         HWND hWnd,
         PROPENUMPROCEXW lpEnumFunc,
         LPARAM lParam);




#line 6961 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
int
__stdcall
EnumPropsA(
         HWND hWnd,
         PROPENUMPROCA lpEnumFunc);
__declspec(dllimport)
int
__stdcall
EnumPropsW(
         HWND hWnd,
         PROPENUMPROCW lpEnumFunc);




#line 6979 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetWindowTextA(
         HWND hWnd,
           LPCSTR lpString);
__declspec(dllimport)
BOOL
__stdcall
SetWindowTextW(
         HWND hWnd,
           LPCWSTR lpString);




#line 6997 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
int
__stdcall
GetWindowTextA(
         HWND hWnd,
         LPSTR lpString,
         int nMaxCount);
__declspec(dllimport)
int
__stdcall
GetWindowTextW(
         HWND hWnd,
         LPWSTR lpString,
         int nMaxCount);




#line 7017 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
int
__stdcall
GetWindowTextLengthA(
         HWND hWnd);
__declspec(dllimport)
int
__stdcall
GetWindowTextLengthW(
         HWND hWnd);




#line 7033 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetClientRect(
         HWND hWnd,
         LPRECT lpRect);

__declspec(dllimport)
BOOL
__stdcall
GetWindowRect(
         HWND hWnd,
         LPRECT lpRect);

__declspec(dllimport)
BOOL
__stdcall
AdjustWindowRect(
         LPRECT lpRect,
         DWORD dwStyle,
         BOOL bMenu);

__declspec(dllimport)
BOOL
__stdcall
AdjustWindowRectEx(
         LPRECT lpRect,
         DWORD dwStyle,
         BOOL bMenu,
         DWORD dwExStyle);





typedef struct tagHELPINFO      
{
    UINT    cbSize;             
    int     iContextType;       
    int     iCtrlId;            
    HANDLE  hItemHandle;        
    DWORD_PTR dwContextId;      
    POINT   MousePos;           
}  HELPINFO,  *LPHELPINFO;

__declspec(dllimport)
BOOL
__stdcall
SetWindowContextHelpId(
         HWND,
         DWORD);

__declspec(dllimport)
DWORD
__stdcall
GetWindowContextHelpId(
         HWND);

__declspec(dllimport)
BOOL
__stdcall
SetMenuContextHelpId(
         HMENU,
         DWORD);

__declspec(dllimport)
DWORD
__stdcall
GetMenuContextHelpId(
         HMENU);

#line 7106 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"















#line 7122 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"











#line 7134 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









#line 7144 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






#line 7151 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"











#line 7163 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






#line 7170 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 7172 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







__declspec(dllimport)
int
__stdcall
MessageBoxA(
           HWND hWnd,
           LPCSTR lpText,
           LPCSTR lpCaption,
         UINT uType);
__declspec(dllimport)
int
__stdcall
MessageBoxW(
           HWND hWnd,
           LPCWSTR lpText,
           LPCWSTR lpCaption,
         UINT uType);




#line 7200 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
    






















#line 7224 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
int
__stdcall
MessageBoxExA(
           HWND hWnd,
           LPCSTR lpText,
           LPCSTR lpCaption,
         UINT uType,
         WORD wLanguageId);
__declspec(dllimport)
int
__stdcall
MessageBoxExW(
           HWND hWnd,
           LPCWSTR lpText,
           LPCWSTR lpCaption,
         UINT uType,
         WORD wLanguageId);




#line 7248 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



typedef void (__stdcall *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);

typedef struct tagMSGBOXPARAMSA
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCSTR      lpszText;
    LPCSTR      lpszCaption;
    DWORD       dwStyle;
    LPCSTR      lpszIcon;
    DWORD_PTR   dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD       dwLanguageId;
} MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA;
typedef struct tagMSGBOXPARAMSW
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCWSTR     lpszText;
    LPCWSTR     lpszCaption;
    DWORD       dwStyle;
    LPCWSTR     lpszIcon;
    DWORD_PTR   dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD       dwLanguageId;
} MSGBOXPARAMSW, *PMSGBOXPARAMSW, *LPMSGBOXPARAMSW;

typedef MSGBOXPARAMSW MSGBOXPARAMS;
typedef PMSGBOXPARAMSW PMSGBOXPARAMS;
typedef LPMSGBOXPARAMSW LPMSGBOXPARAMS;




#line 7288 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
int
__stdcall
MessageBoxIndirectA(
         const MSGBOXPARAMSA * lpmbp);
__declspec(dllimport)
int
__stdcall
MessageBoxIndirectW(
         const MSGBOXPARAMSW * lpmbp);




#line 7304 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 7305 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
MessageBeep(
         UINT uType);

#line 7314 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
int
__stdcall
ShowCursor(
         BOOL bShow);

__declspec(dllimport)
BOOL
__stdcall
SetCursorPos(
         int X,
         int Y);

__declspec(dllimport)
HCURSOR
__stdcall
SetCursor(
           HCURSOR hCursor);

__declspec(dllimport)
BOOL
__stdcall
GetCursorPos(
         LPPOINT lpPoint);

__declspec(dllimport)
BOOL
__stdcall
ClipCursor(
           const RECT *lpRect);

__declspec(dllimport)
BOOL
__stdcall
GetClipCursor(
         LPRECT lpRect);

__declspec(dllimport)
HCURSOR
__stdcall
GetCursor(
    void);

__declspec(dllimport)
BOOL
__stdcall
CreateCaret(
         HWND hWnd,
           HBITMAP hBitmap,
         int nWidth,
         int nHeight);

__declspec(dllimport)
UINT
__stdcall
GetCaretBlinkTime(
    void);

__declspec(dllimport)
BOOL
__stdcall
SetCaretBlinkTime(
         UINT uMSeconds);

__declspec(dllimport)
BOOL
__stdcall
DestroyCaret(
    void);

__declspec(dllimport)
BOOL
__stdcall
HideCaret(
           HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
ShowCaret(
           HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
SetCaretPos(
         int X,
         int Y);

__declspec(dllimport)
BOOL
__stdcall
GetCaretPos(
         LPPOINT lpPoint);

__declspec(dllimport)
BOOL
__stdcall
ClientToScreen(
         HWND hWnd,
         LPPOINT lpPoint);

__declspec(dllimport)
BOOL
__stdcall
ScreenToClient(
         HWND hWnd,
         LPPOINT lpPoint);

__declspec(dllimport)
int
__stdcall
MapWindowPoints(
           HWND hWndFrom,
           HWND hWndTo,
           LPPOINT lpPoints,
         UINT cPoints);

__declspec(dllimport)
HWND
__stdcall
WindowFromPoint(
         POINT Point);

__declspec(dllimport)
HWND
__stdcall
ChildWindowFromPoint(
         HWND hWndParent,
         POINT Point);







__declspec(dllimport)
HWND
__stdcall
ChildWindowFromPointEx(
         HWND hwnd,
         POINT pt,
         UINT flags);
#line 7460 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"










































#line 7503 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"








#line 7512 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 7513 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"








#line 7522 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
DWORD
__stdcall
GetSysColor(
         int nIndex);


__declspec(dllimport)
HBRUSH
__stdcall
GetSysColorBrush(
         int nIndex);


#line 7539 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetSysColors(
         int cElements,
           const INT * lpaElements,
           const COLORREF * lpaRgbValues);

#line 7549 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
DrawFocusRect(
         HDC hDC,
         const RECT * lprc);

__declspec(dllimport)
int
__stdcall
FillRect(
         HDC hDC,
         const RECT *lprc,
         HBRUSH hbr);

__declspec(dllimport)
int
__stdcall
FrameRect(
         HDC hDC,
         const RECT *lprc,
         HBRUSH hbr);

__declspec(dllimport)
BOOL
__stdcall
InvertRect(
         HDC hDC,
         const RECT *lprc);

__declspec(dllimport)
BOOL
__stdcall
SetRect(
         LPRECT lprc,
         int xLeft,
         int yTop,
         int xRight,
         int yBottom);

__declspec(dllimport)
BOOL
__stdcall
SetRectEmpty(
         LPRECT lprc);

__declspec(dllimport)
BOOL
__stdcall
CopyRect(
         LPRECT lprcDst,
         const RECT *lprcSrc);

__declspec(dllimport)
BOOL
__stdcall
InflateRect(
         LPRECT lprc,
         int dx,
         int dy);

__declspec(dllimport)
BOOL
__stdcall
IntersectRect(
         LPRECT lprcDst,
         const RECT *lprcSrc1,
         const RECT *lprcSrc2);

__declspec(dllimport)
BOOL
__stdcall
UnionRect(
         LPRECT lprcDst,
         const RECT *lprcSrc1,
         const RECT *lprcSrc2);

__declspec(dllimport)
BOOL
__stdcall
SubtractRect(
         LPRECT lprcDst,
         const RECT *lprcSrc1,
         const RECT *lprcSrc2);

__declspec(dllimport)
BOOL
__stdcall
OffsetRect(
         LPRECT lprc,
         int dx,
         int dy);

__declspec(dllimport)
BOOL
__stdcall
IsRectEmpty(
         const RECT *lprc);

__declspec(dllimport)
BOOL
__stdcall
EqualRect(
         const RECT *lprc1,
         const RECT *lprc2);

__declspec(dllimport)
BOOL
__stdcall
PtInRect(
         const RECT *lprc,
         POINT pt);



__declspec(dllimport)
WORD
__stdcall
GetWindowWord(
         HWND hWnd,
         int nIndex);

__declspec(dllimport)
WORD
__stdcall
SetWindowWord(
         HWND hWnd,
         int nIndex,
         WORD wNewWord);

__declspec(dllimport)
LONG
__stdcall
GetWindowLongA(
         HWND hWnd,
         int nIndex);
__declspec(dllimport)
LONG
__stdcall
GetWindowLongW(
         HWND hWnd,
         int nIndex);




#line 7697 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
LONG
__stdcall
SetWindowLongA(
         HWND hWnd,
         int nIndex,
         LONG dwNewLong);
__declspec(dllimport)
LONG
__stdcall
SetWindowLongW(
         HWND hWnd,
         int nIndex,
         LONG dwNewLong);




#line 7717 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

















































#line 7767 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







#line 7775 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 7777 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
WORD
__stdcall
GetClassWord(
         HWND hWnd,
         int nIndex);

__declspec(dllimport)
WORD
__stdcall
SetClassWord(
         HWND hWnd,
         int nIndex,
         WORD wNewWord);

__declspec(dllimport)
DWORD
__stdcall
GetClassLongA(
         HWND hWnd,
         int nIndex);
__declspec(dllimport)
DWORD
__stdcall
GetClassLongW(
         HWND hWnd,
         int nIndex);




#line 7810 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
SetClassLongA(
         HWND hWnd,
         int nIndex,
         LONG dwNewLong);
__declspec(dllimport)
DWORD
__stdcall
SetClassLongW(
         HWND hWnd,
         int nIndex,
         LONG dwNewLong);




#line 7830 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

















































#line 7880 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







#line 7888 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 7890 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 7892 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
GetProcessDefaultLayout(
         DWORD *pdwDefaultLayout);

__declspec(dllimport)
BOOL
__stdcall
SetProcessDefaultLayout(
         DWORD dwDefaultLayout);
#line 7906 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetDesktopWindow(
    void);


__declspec(dllimport)
HWND
__stdcall
GetParent(
         HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
SetParent(
         HWND hWndChild,
           HWND hWndNewParent);

__declspec(dllimport)
BOOL
__stdcall
EnumChildWindows(
           HWND hWndParent,
         WNDENUMPROC lpEnumFunc,
         LPARAM lParam);

__declspec(dllimport)
HWND
__stdcall
FindWindowA(
           LPCSTR lpClassName,
           LPCSTR lpWindowName);
__declspec(dllimport)
HWND
__stdcall
FindWindowW(
           LPCWSTR lpClassName,
           LPCWSTR lpWindowName);




#line 7952 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
HWND
__stdcall
FindWindowExA(
           HWND hWndParent,
           HWND hWndChildAfter,
           LPCSTR lpszClass,
           LPCSTR lpszWindow);
__declspec(dllimport)
HWND
__stdcall
FindWindowExW(
           HWND hWndParent,
           HWND hWndChildAfter,
           LPCWSTR lpszClass,
           LPCWSTR lpszWindow);




#line 7975 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetShellWindow(
    void);

#line 7983 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
RegisterShellHookWindow(
         HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
DeregisterShellHookWindow(
         HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
EnumWindows(
         WNDENUMPROC lpEnumFunc,
         LPARAM lParam);

__declspec(dllimport)
BOOL
__stdcall
EnumThreadWindows(
         DWORD dwThreadId,
         WNDENUMPROC lpfn,
         LPARAM lParam);



__declspec(dllimport)
int
__stdcall
GetClassNameA(
         HWND hWnd,
           LPSTR lpClassName,
         int nMaxCount
    );
__declspec(dllimport)
int
__stdcall
GetClassNameW(
         HWND hWnd,
           LPWSTR lpClassName,
         int nMaxCount
    );




#line 8035 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
    




















#line 8057 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



__declspec(dllimport)
HWND
__stdcall
GetTopWindow(
           HWND hWnd);





__declspec(dllimport)
DWORD
__stdcall
GetWindowThreadProcessId(
         HWND hWnd,
           LPDWORD lpdwProcessId);








#line 8085 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




__declspec(dllimport)
HWND
__stdcall
GetLastActivePopup(
         HWND hWnd);












#line 8107 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 8110 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetWindow(
         HWND hWnd,
         UINT uCmd);






__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookA(
         int nFilterType,
         HOOKPROC pfnFilterProc);
__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookW(
         int nFilterType,
         HOOKPROC pfnFilterProc);




#line 8140 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





















#line 8162 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnhookWindowsHook(
         int nCode,
         HOOKPROC pfnFilterProc);

__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookExA(
         int idHook,
         HOOKPROC lpfn,
           HINSTANCE hmod,
         DWORD dwThreadId);
__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookExW(
         int idHook,
         HOOKPROC lpfn,
           HINSTANCE hmod,
         DWORD dwThreadId);




#line 8191 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnhookWindowsHookEx(
         HHOOK hhk);

__declspec(dllimport)
LRESULT
__stdcall
CallNextHookEx(
           HHOOK hhk,
         int nCode,
         WPARAM wParam,
         LPARAM lParam);










#line 8217 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 8218 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"








































#line 8259 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




#line 8264 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




#line 8269 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






















#line 8292 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




__declspec(dllimport)
BOOL
__stdcall
CheckMenuRadioItem(
         HMENU hmenu,
         UINT first,
         UINT last,
         UINT check,
         UINT flags);
#line 8306 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




typedef struct {
    WORD versionNumber;
    WORD offset;
} MENUITEMTEMPLATEHEADER, *PMENUITEMTEMPLATEHEADER;

typedef struct {        
    WORD mtOption;
    WORD mtID;
    WCHAR mtString[1];
} MENUITEMTEMPLATE, *PMENUITEMTEMPLATE;


#line 8323 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



























#line 8351 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







#line 8359 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





__declspec(dllimport)
HBITMAP
__stdcall
LoadBitmapA(
           HINSTANCE hInstance,
         LPCSTR lpBitmapName);
__declspec(dllimport)
HBITMAP
__stdcall
LoadBitmapW(
           HINSTANCE hInstance,
         LPCWSTR lpBitmapName);




#line 8381 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorA(
           HINSTANCE hInstance,
         LPCSTR lpCursorName);
__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorW(
           HINSTANCE hInstance,
         LPCWSTR lpCursorName);




#line 8399 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorFromFileA(
         LPCSTR lpFileName);
__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorFromFileW(
         LPCWSTR lpFileName);




#line 8415 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HCURSOR
__stdcall
CreateCursor(
           HINSTANCE hInst,
         int xHotSpot,
         int yHotSpot,
         int nWidth,
         int nHeight,
         const void *pvANDPlane,
         const void *pvXORPlane);

__declspec(dllimport)
BOOL
__stdcall
DestroyCursor(
         HCURSOR hCursor);









#line 8443 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



















#line 8463 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 8467 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetSystemCursor(
         HCURSOR hcur,
         DWORD id);

typedef struct _ICONINFO {
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
} ICONINFO;
typedef ICONINFO *PICONINFO;

__declspec(dllimport)
HICON
__stdcall
LoadIconA(
           HINSTANCE hInstance,
         LPCSTR lpIconName);
__declspec(dllimport)
HICON
__stdcall
LoadIconW(
           HINSTANCE hInstance,
         LPCWSTR lpIconName);




#line 8501 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
UINT
__stdcall
PrivateExtractIconsA(
         LPCSTR szFileName,
         int nIconIndex,
         int cxIcon,
         int cyIcon,
             HICON *phicon,
             UINT *piconid,
         UINT nIcons,
         UINT flags);
__declspec(dllimport)
UINT
__stdcall
PrivateExtractIconsW(
         LPCWSTR szFileName,
         int nIconIndex,
         int cxIcon,
         int cyIcon,
             HICON *phicon,
             UINT *piconid,
         UINT nIcons,
         UINT flags);




#line 8532 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HICON
__stdcall
CreateIcon(
           HINSTANCE hInstance,
         int nWidth,
         int nHeight,
         BYTE cPlanes,
         BYTE cBitsPixel,
         const BYTE *lpbANDbits,
         const BYTE *lpbXORbits);

__declspec(dllimport)
BOOL
__stdcall
DestroyIcon(
         HICON hIcon);

__declspec(dllimport)
int
__stdcall
LookupIconIdFromDirectory(
         PBYTE presbits,
         BOOL fIcon);


__declspec(dllimport)
int
__stdcall
LookupIconIdFromDirectoryEx(
         PBYTE presbits,
         BOOL fIcon,
         int cxDesired,
         int cyDesired,
         UINT Flags);
#line 8569 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HICON
__stdcall
CreateIconFromResource(
         PBYTE presbits,
         DWORD dwResSize,
         BOOL fIcon,
         DWORD dwVer);


__declspec(dllimport)
HICON
__stdcall
CreateIconFromResourceEx(
         PBYTE presbits,
         DWORD dwResSize,
         BOOL fIcon,
         DWORD dwVer,
         int cxDesired,
         int cyDesired,
         UINT Flags);


typedef struct tagCURSORSHAPE
{
    int     xHotSpot;
    int     yHotSpot;
    int     cx;
    int     cy;
    int     cbWidth;
    BYTE    Planes;
    BYTE    BitsPixel;
} CURSORSHAPE,  *LPCURSORSHAPE;
#line 8604 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





















__declspec(dllimport)
HANDLE
__stdcall
LoadImageA(
           HINSTANCE hInst,
         LPCSTR name,
         UINT type,
         int cx,
         int cy,
         UINT fuLoad);
__declspec(dllimport)
HANDLE
__stdcall
LoadImageW(
           HINSTANCE hInst,
         LPCWSTR name,
         UINT type,
         int cx,
         int cy,
         UINT fuLoad);




#line 8650 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HANDLE
__stdcall
CopyImage(
         HANDLE h,
         UINT type,
         int cx,
         int cy,
         UINT flags);








#line 8669 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport) BOOL __stdcall DrawIconEx(
         HDC hdc,
         int xLeft,
         int yTop,
         HICON hIcon,
         int cxWidth,
         int cyWidth,
         UINT istepIfAniCur,
           HBRUSH hbrFlickerFreeDraw,
         UINT diFlags);

#line 8682 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
HICON
__stdcall
CreateIconIndirect(
         PICONINFO piconinfo);

__declspec(dllimport)
HICON
__stdcall
CopyIcon(
         HICON hIcon);

__declspec(dllimport)
BOOL
__stdcall
GetIconInfo(
         HICON hIcon,
         PICONINFO piconinfo);




#line 8706 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"












































































































#line 8815 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 8816 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





#line 8822 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 8825 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
int
__stdcall
LoadStringA(
           HINSTANCE hInstance,
         UINT uID,
         LPSTR lpBuffer,
         int cchBufferMax);
__declspec(dllimport)
int
__stdcall
LoadStringW(
           HINSTANCE hInstance,
         UINT uID,
         LPWSTR lpBuffer,
         int cchBufferMax);




#line 8847 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"















#line 8863 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




#line 8868 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




#line 8873 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 8874 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





























#line 8904 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 8907 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
















#line 8924 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






#line 8931 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









#line 8941 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"













































#line 8987 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




#line 8992 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 8995 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









































#line 9037 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
















#line 9054 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



















#line 9074 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

























#line 9100 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 9103 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"












#line 9116 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
















#line 9133 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 9135 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"































__declspec(dllimport)
BOOL
__stdcall
IsDialogMessageA(
         HWND hDlg,
         LPMSG lpMsg);
__declspec(dllimport)
BOOL
__stdcall
IsDialogMessageW(
         HWND hDlg,
         LPMSG lpMsg);




#line 9183 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 9185 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
MapDialogRect(
         HWND hDlg,
         LPRECT lpRect);

__declspec(dllimport)
int
__stdcall
DlgDirListA(
         HWND hDlg,
         LPSTR lpPathSpec,
         int nIDListBox,
         int nIDStaticPath,
         UINT uFileType);
__declspec(dllimport)
int
__stdcall
DlgDirListW(
         HWND hDlg,
         LPWSTR lpPathSpec,
         int nIDListBox,
         int nIDStaticPath,
         UINT uFileType);




#line 9216 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"















__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectExA(
         HWND hwndDlg,
         LPSTR lpString,
         int chCount,
         int idListBox);
__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectExW(
         HWND hwndDlg,
         LPWSTR lpString,
         int chCount,
         int idListBox);




#line 9252 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
int
__stdcall
DlgDirListComboBoxA(
         HWND hDlg,
         LPSTR lpPathSpec,
         int nIDComboBox,
         int nIDStaticPath,
         UINT uFiletype);
__declspec(dllimport)
int
__stdcall
DlgDirListComboBoxW(
         HWND hDlg,
         LPWSTR lpPathSpec,
         int nIDComboBox,
         int nIDStaticPath,
         UINT uFiletype);




#line 9276 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectComboBoxExA(
         HWND hwndDlg,
         LPSTR lpString,
         int cchOut,
         int idComboBox);
__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectComboBoxExW(
         HWND hwndDlg,
         LPWSTR lpString,
         int cchOut,
         int idComboBox);




#line 9298 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

























#line 9324 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 9328 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







#line 9336 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


































                                  




























































#line 9432 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 9435 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




#line 9440 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 9444 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 9446 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 9450 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 9452 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"























#line 9476 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





#line 9482 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"












































#line 9527 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 9529 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"











































#line 9573 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 9574 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 9578 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 9582 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 9584 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 9588 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 9589 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




















#line 9610 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 9613 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"














#line 9628 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



#line 9632 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









typedef struct tagSCROLLINFO
{
    UINT    cbSize;
    UINT    fMask;
    int     nMin;
    int     nMax;
    UINT    nPage;
    int     nPos;
    int     nTrackPos;
}   SCROLLINFO,  *LPSCROLLINFO;
typedef SCROLLINFO const  *LPCSCROLLINFO;

__declspec(dllimport)
int
__stdcall
SetScrollInfo(
         HWND hwnd,
         int nBar,
         LPCSCROLLINFO lpsi,
         BOOL redraw);

__declspec(dllimport)
BOOL
__stdcall
GetScrollInfo(
         HWND hwnd,
         int nBar,
         LPSCROLLINFO lpsi);

#line 9671 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 9672 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 9673 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
















#line 9690 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

typedef struct tagMDICREATESTRUCTA {
    LPCSTR   szClass;
    LPCSTR   szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        
} MDICREATESTRUCTA, *LPMDICREATESTRUCTA;
typedef struct tagMDICREATESTRUCTW {
    LPCWSTR  szClass;
    LPCWSTR  szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        
} MDICREATESTRUCTW, *LPMDICREATESTRUCTW;

typedef MDICREATESTRUCTW MDICREATESTRUCT;
typedef LPMDICREATESTRUCTW LPMDICREATESTRUCT;



#line 9720 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

typedef struct tagCLIENTCREATESTRUCT {
    HANDLE hWindowMenu;
    UINT idFirstChild;
} CLIENTCREATESTRUCT, *LPCLIENTCREATESTRUCT;

__declspec(dllimport)
LRESULT
__stdcall
DefFrameProcA(
         HWND hWnd,
           HWND hWndMDIClient,
         UINT uMsg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
DefFrameProcW(
         HWND hWnd,
           HWND hWndMDIClient,
         UINT uMsg,
         WPARAM wParam,
         LPARAM lParam);




#line 9749 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)

LRESULT
__stdcall



#line 9758 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
DefMDIChildProcA(
         HWND hWnd,
         UINT uMsg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)

LRESULT
__stdcall



#line 9771 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
DefMDIChildProcW(
         HWND hWnd,
         UINT uMsg,
         WPARAM wParam,
         LPARAM lParam);




#line 9781 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
TranslateMDISysAccel(
         HWND hWndClient,
         LPMSG lpMsg);

#line 9792 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
UINT
__stdcall
ArrangeIconicWindows(
         HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
CreateMDIWindowA(
         LPCSTR lpClassName,
         LPCSTR lpWindowName,
         DWORD dwStyle,
         int X,
         int Y,
         int nWidth,
         int nHeight,
           HWND hWndParent,
           HINSTANCE hInstance,
         LPARAM lParam);
__declspec(dllimport)
HWND
__stdcall
CreateMDIWindowW(
         LPCWSTR lpClassName,
         LPCWSTR lpWindowName,
         DWORD dwStyle,
         int X,
         int Y,
         int nWidth,
         int nHeight,
           HWND hWndParent,
           HINSTANCE hInstance,
         LPARAM lParam);




#line 9832 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport) 
WORD 
__stdcall 
TileWindows(
           HWND hwndParent,
         UINT wHow,
           const RECT * lpRect,
         UINT cKids,
             const HWND  * lpKids);

__declspec(dllimport)
WORD
__stdcall CascadeWindows(
           HWND hwndParent,
         UINT wHow,
           const RECT * lpRect,
         UINT cKids,
             const HWND  * lpKids);

#line 9854 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 9855 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 9857 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





typedef DWORD HELPPOLY;
typedef struct tagMULTIKEYHELPA {

    DWORD  mkSize;


#line 9869 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
    CHAR   mkKeylist;
    CHAR   szKeyphrase[1];
} MULTIKEYHELPA, *PMULTIKEYHELPA, *LPMULTIKEYHELPA;
typedef struct tagMULTIKEYHELPW {

    DWORD  mkSize;


#line 9878 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
    WCHAR  mkKeylist;
    WCHAR  szKeyphrase[1];
} MULTIKEYHELPW, *PMULTIKEYHELPW, *LPMULTIKEYHELPW;

typedef MULTIKEYHELPW MULTIKEYHELP;
typedef PMULTIKEYHELPW PMULTIKEYHELP;
typedef LPMULTIKEYHELPW LPMULTIKEYHELP;




#line 9890 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

typedef struct tagHELPWININFOA {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    CHAR   rgchMember[2];
} HELPWININFOA, *PHELPWININFOA, *LPHELPWININFOA;
typedef struct tagHELPWININFOW {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    WCHAR  rgchMember[2];
} HELPWININFOW, *PHELPWININFOW, *LPHELPWININFOW;

typedef HELPWININFOW HELPWININFO;
typedef PHELPWININFOW PHELPWININFO;
typedef LPHELPWININFOW LPHELPWININFO;




#line 9918 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





































#line 9956 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
WinHelpA(
           HWND hWndMain,
           LPCSTR lpszHelp,
         UINT uCommand,
         ULONG_PTR dwData);
__declspec(dllimport)
BOOL
__stdcall
WinHelpW(
           HWND hWndMain,
           LPCWSTR lpszHelp,
         UINT uCommand,
         ULONG_PTR dwData);




#line 9980 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 9982 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






__declspec(dllimport)
DWORD
__stdcall
GetGuiResources(
         HANDLE hProcess,
         DWORD uiFlags);
#line 9995 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





















































































#line 10081 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"















#line 10097 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





#line 10103 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"















#line 10119 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







#line 10127 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"












































#line 10172 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





































#line 10210 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 10212 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"












typedef struct tagNONCLIENTMETRICSA
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTA lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTA lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTA lfMenuFont;
    LOGFONTA lfStatusFont;
    LOGFONTA lfMessageFont;
}   NONCLIENTMETRICSA, *PNONCLIENTMETRICSA, * LPNONCLIENTMETRICSA;
typedef struct tagNONCLIENTMETRICSW
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTW lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTW lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTW lfMenuFont;
    LOGFONTW lfStatusFont;
    LOGFONTW lfMessageFont;
}   NONCLIENTMETRICSW, *PNONCLIENTMETRICSW, * LPNONCLIENTMETRICSW;

typedef NONCLIENTMETRICSW NONCLIENTMETRICS;
typedef PNONCLIENTMETRICSW PNONCLIENTMETRICS;
typedef LPNONCLIENTMETRICSW LPNONCLIENTMETRICS;




#line 10269 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 10270 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 10271 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"















typedef struct tagMINIMIZEDMETRICS
{
    UINT    cbSize;
    int     iWidth;
    int     iHorzGap;
    int     iVertGap;
    int     iArrange;
}   MINIMIZEDMETRICS, *PMINIMIZEDMETRICS, *LPMINIMIZEDMETRICS;



typedef struct tagICONMETRICSA
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTA lfFont;
}   ICONMETRICSA, *PICONMETRICSA, *LPICONMETRICSA;
typedef struct tagICONMETRICSW
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTW lfFont;
}   ICONMETRICSW, *PICONMETRICSW, *LPICONMETRICSW;

typedef ICONMETRICSW ICONMETRICS;
typedef PICONMETRICSW PICONMETRICS;
typedef LPICONMETRICSW LPICONMETRICS;




#line 10322 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 10323 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 10324 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

typedef struct tagANIMATIONINFO
{
    UINT    cbSize;
    int     iMinAnimate;
}   ANIMATIONINFO, *LPANIMATIONINFO;

typedef struct tagSERIALKEYSA
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR     lpszActivePort;
    LPSTR     lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}   SERIALKEYSA, *LPSERIALKEYSA;
typedef struct tagSERIALKEYSW
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR    lpszActivePort;
    LPWSTR    lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}   SERIALKEYSW, *LPSERIALKEYSW;

typedef SERIALKEYSW SERIALKEYS;
typedef LPSERIALKEYSW LPSERIALKEYS;



#line 10358 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







typedef struct tagHIGHCONTRASTA
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR   lpszDefaultScheme;
}   HIGHCONTRASTA, *LPHIGHCONTRASTA;
typedef struct tagHIGHCONTRASTW
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR  lpszDefaultScheme;
}   HIGHCONTRASTW, *LPHIGHCONTRASTW;

typedef HIGHCONTRASTW HIGHCONTRAST;
typedef LPHIGHCONTRASTW LPHIGHCONTRAST;



#line 10384 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"






















#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\tvout.h"










#pragma once
#line 13 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\tvout.h"





typedef struct _VIDEOPARAMETERS {
    GUID  Guid;                         
    ULONG dwOffset;                     
    ULONG dwCommand;                    
    ULONG dwFlags;                      
    ULONG dwMode;                       
    ULONG dwTVStandard;                 
    ULONG dwAvailableModes;             
    ULONG dwAvailableTVStandard;        
    ULONG dwFlickerFilter;              
    ULONG dwOverScanX;                  
    ULONG dwOverScanY;                  
    ULONG dwMaxUnscaledX;               
    ULONG dwMaxUnscaledY;               
    ULONG dwPositionX;                  
    ULONG dwPositionY;                  
    ULONG dwBrightness;                 
    ULONG dwContrast;                   
    ULONG dwCPType;                     
    ULONG dwCPCommand;                  
    ULONG dwCPStandard;                 
    ULONG dwCPKey;
    ULONG bCP_APSTriggerBits;           
    UCHAR bOEMCopyProtection[256];      
} VIDEOPARAMETERS, *PVIDEOPARAMETERS, *LPVIDEOPARAMETERS;


                                        












































#line 91 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\tvout.h"
#line 10407 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"











#line 10419 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsA(
           LPDEVMODEA lpDevMode,
         DWORD dwFlags);
__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsW(
           LPDEVMODEW lpDevMode,
         DWORD dwFlags);




#line 10440 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsExA(
           LPCSTR lpszDeviceName,
           LPDEVMODEA lpDevMode,
      HWND hwnd,
         DWORD dwflags,
           LPVOID lParam);
__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsExW(
           LPCWSTR lpszDeviceName,
           LPDEVMODEW lpDevMode,
      HWND hwnd,
         DWORD dwflags,
           LPVOID lParam);




#line 10464 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsA(
           LPCSTR lpszDeviceName,
         DWORD iModeNum,
         LPDEVMODEA lpDevMode);
__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsW(
           LPCWSTR lpszDeviceName,
         DWORD iModeNum,
         LPDEVMODEW lpDevMode);




#line 10487 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsExA(
           LPCSTR lpszDeviceName,
         DWORD iModeNum,
         LPDEVMODEA lpDevMode,
         DWORD dwFlags);
__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsExW(
           LPCWSTR lpszDeviceName,
         DWORD iModeNum,
         LPDEVMODEW lpDevMode,
         DWORD dwFlags);




#line 10511 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




__declspec(dllimport)
BOOL
__stdcall
EnumDisplayDevicesA(
           LPCSTR lpDevice,
         DWORD iDevNum,
         PDISPLAY_DEVICEA lpDisplayDevice,
         DWORD dwFlags);
__declspec(dllimport)
BOOL
__stdcall
EnumDisplayDevicesW(
           LPCWSTR lpDevice,
         DWORD iDevNum,
         PDISPLAY_DEVICEW lpDisplayDevice,
         DWORD dwFlags);




#line 10536 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 10537 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 10539 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 10540 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
SystemParametersInfoA(
         UINT uiAction,
         UINT uiParam,
           PVOID pvParam,
         UINT fWinIni);
__declspec(dllimport)
BOOL
__stdcall
SystemParametersInfoW(
         UINT uiAction,
         UINT uiParam,
           PVOID pvParam,
         UINT fWinIni);




#line 10563 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


#line 10566 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




typedef struct tagFILTERKEYS
{
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iWaitMSec;            
    DWORD iDelayMSec;           
    DWORD iRepeatMSec;          
    DWORD iBounceMSec;          
} FILTERKEYS, *LPFILTERKEYS;












typedef struct tagSTICKYKEYS
{
    UINT  cbSize;
    DWORD dwFlags;
} STICKYKEYS, *LPSTICKYKEYS;






























#line 10627 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

typedef struct tagMOUSEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iMaxSpeed;
    DWORD iTimeToMaxSpeed;
    DWORD iCtrlSpeed;
    DWORD dwReserved1;
    DWORD dwReserved2;
} MOUSEKEYS, *LPMOUSEKEYS;


















#line 10657 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

typedef struct tagACCESSTIMEOUT
{
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iTimeOutMSec;
} ACCESSTIMEOUT, *LPACCESSTIMEOUT;
























typedef struct tagSOUNDSENTRYA
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPSTR   lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYA, *LPSOUNDSENTRYA;
typedef struct tagSOUNDSENTRYW
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPWSTR  lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYW, *LPSOUNDSENTRYW;

typedef SOUNDSENTRYW SOUNDSENTRY;
typedef LPSOUNDSENTRYW LPSOUNDSENTRY;



#line 10725 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"








typedef struct tagTOGGLEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
} TOGGLEKEYS, *LPTOGGLEKEYS;















__declspec(dllimport)
void
__stdcall
SetDebugErrorLevel(
         DWORD dwLevel);









__declspec(dllimport)
void
__stdcall
SetLastErrorEx(
         DWORD dwErrCode,
         DWORD dwType);

__declspec(dllimport)
int
__stdcall
InternalGetWindowText(
         HWND hWnd,
           LPWSTR pString,
         int cchMaxCount);









#line 10791 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"












__declspec(dllimport)
HMONITOR
__stdcall
MonitorFromPoint(
         POINT pt,
         DWORD dwFlags);

__declspec(dllimport)
HMONITOR
__stdcall
MonitorFromRect(
         LPCRECT lprc,
         DWORD dwFlags);

__declspec(dllimport)
HMONITOR
__stdcall
MonitorFromWindow(
         HWND hwnd,
         DWORD dwFlags);







typedef struct tagMONITORINFO
{
    DWORD   cbSize;
    RECT    rcMonitor;
    RECT    rcWork;
    DWORD   dwFlags;
} MONITORINFO, *LPMONITORINFO;


typedef struct tagMONITORINFOEXA : public tagMONITORINFO
{
    CHAR        szDevice[32];
} MONITORINFOEXA, *LPMONITORINFOEXA;
typedef struct tagMONITORINFOEXW : public tagMONITORINFO
{
    WCHAR       szDevice[32];
} MONITORINFOEXW, *LPMONITORINFOEXW;

typedef MONITORINFOEXW MONITORINFOEX;
typedef LPMONITORINFOEXW LPMONITORINFOEX;



#line 10854 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


















#line 10873 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetMonitorInfoA(
         HMONITOR hMonitor,
         LPMONITORINFO lpmi);
__declspec(dllimport)
BOOL
__stdcall
GetMonitorInfoW(
         HMONITOR hMonitor,
         LPMONITORINFO lpmi);




#line 10891 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

typedef BOOL (__stdcall* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumDisplayMonitors(
           HDC hdc,
           LPCRECT lprcClip,
         MONITORENUMPROC lpfnEnum,
         LPARAM dwData);








__declspec(dllimport)
void
__stdcall
NotifyWinEvent(
         DWORD event,
         HWND  hwnd,
         LONG  idObject,
         LONG  idChild);

typedef void (__stdcall* WINEVENTPROC)(
    HWINEVENTHOOK hWinEventHook,
    DWORD         event,
    HWND          hwnd,
    LONG          idObject,
    LONG          idChild,
    DWORD         idEventThread,
    DWORD         dwmsEventTime);

__declspec(dllimport)
HWINEVENTHOOK
__stdcall
SetWinEventHook(
         DWORD eventMin,
         DWORD eventMax,
           HMODULE hmodWinEventProc,
         WINEVENTPROC pfnWinEventProc,
         DWORD idProcess,
         DWORD idThread,
         DWORD dwFlags);







#line 10947 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"









__declspec(dllimport)
BOOL
__stdcall
UnhookWinEvent(
         HWINEVENTHOOK hWinEventHook);

































































































































































































































#line 11187 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




















































































































































































































typedef struct tagGUITHREADINFO
{
    DWORD   cbSize;
    DWORD   flags;
    HWND    hwndActive;
    HWND    hwndFocus;
    HWND    hwndCapture;
    HWND    hwndMenuOwner;
    HWND    hwndMoveSize;
    HWND    hwndCaret;
    RECT    rcCaret;
} GUITHREADINFO, *PGUITHREADINFO,  * LPGUITHREADINFO;








#line 11420 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetGUIThreadInfo(
         DWORD idThread,
         PGUITHREADINFO pgui);


__declspec(dllimport)
UINT
__stdcall
GetWindowModuleFileNameA(
         HWND hwnd,
           LPSTR pszFileName,
         UINT cchFileNameMax);
__declspec(dllimport)
UINT
__stdcall
GetWindowModuleFileNameW(
         HWND hwnd,
           LPWSTR pszFileName,
         UINT cchFileNameMax);




#line 11448 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


































#line 11483 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







typedef struct tagCURSORINFO
{
    DWORD   cbSize;
    DWORD   flags;
    HCURSOR hCursor;
    POINT   ptScreenPos;
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;



__declspec(dllimport)
BOOL
__stdcall
GetCursorInfo(
         PCURSORINFO pci);




typedef struct tagWINDOWINFO
{
    DWORD cbSize;
    RECT rcWindow;
    RECT rcClient;
    DWORD dwStyle;
    DWORD dwExStyle;
    DWORD dwWindowStatus;
    UINT cxWindowBorders;
    UINT cyWindowBorders;
    ATOM atomWindowType;
    WORD wCreatorVersion;
} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO;



__declspec(dllimport)
BOOL
__stdcall
GetWindowInfo(
         HWND hwnd,
         PWINDOWINFO pwi);




typedef struct tagTITLEBARINFO
{
    DWORD cbSize;
    RECT rcTitleBar;
    DWORD rgstate[5 + 1];
} TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO;

__declspec(dllimport)
BOOL
__stdcall
GetTitleBarInfo(
         HWND hwnd,
         PTITLEBARINFO pti);




typedef struct tagMENUBARINFO
{
    DWORD cbSize;
    RECT rcBar;          
    HMENU hMenu;         
    HWND hwndMenu;       
    BOOL fBarFocused:1;  
    BOOL fFocused:1;     
} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;

__declspec(dllimport)
BOOL
__stdcall
GetMenuBarInfo(
         HWND hwnd,
         LONG idObject,
         LONG idItem,
         PMENUBARINFO pmbi);




typedef struct tagSCROLLBARINFO
{
    DWORD cbSize;
    RECT rcScrollBar;
    int dxyLineButton;
    int xyThumbTop;
    int xyThumbBottom;
    int reserved;
    DWORD rgstate[5 + 1];
} SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO;

__declspec(dllimport)
BOOL
__stdcall
GetScrollBarInfo(
         HWND hwnd,
         LONG idObject,
         PSCROLLBARINFO psbi);




typedef struct tagCOMBOBOXINFO
{
    DWORD cbSize;
    RECT rcItem;
    RECT rcButton;
    DWORD stateButton;
    HWND hwndCombo;
    HWND hwndItem;
    HWND hwndList;
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;

__declspec(dllimport)
BOOL
__stdcall
GetComboBoxInfo(
         HWND hwndCombo,
         PCOMBOBOXINFO pcbi);








__declspec(dllimport)
HWND
__stdcall
GetAncestor(
         HWND hwnd,
         UINT gaFlags);








__declspec(dllimport)
HWND
__stdcall
RealChildWindowFromPoint(
         HWND hwndParent,
         POINT ptParentClientCoords);






__declspec(dllimport)
UINT
__stdcall
RealGetWindowClassA(
         HWND hwnd,
           LPSTR ptszClassName,
         UINT cchClassNameMax);




__declspec(dllimport)
UINT
__stdcall
RealGetWindowClassW(
         HWND hwnd,
           LPWSTR ptszClassName,
         UINT cchClassNameMax);




#line 11670 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"




typedef struct tagALTTABINFO
{
    DWORD cbSize;
    int cItems;
    int cColumns;
    int cRows;
    int iColFocus;
    int iRowFocus;
    int cxItem;
    int cyItem;
    POINT ptStart;
} ALTTABINFO, *PALTTABINFO, *LPALTTABINFO;

__declspec(dllimport)
BOOL
__stdcall
GetAltTabInfoA(
           HWND hwnd,
         int iItem,
         PALTTABINFO pati,
           LPSTR pszItemText,
         UINT cchItemText);
__declspec(dllimport)
BOOL
__stdcall
GetAltTabInfoW(
           HWND hwnd,
         int iItem,
         PALTTABINFO pati,
           LPWSTR pszItemText,
         UINT cchItemText);




#line 11710 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





__declspec(dllimport)
DWORD
__stdcall
GetListBoxInfo(
         HWND hwnd);

#line 11722 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 11723 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
LockWorkStation(
    void);
#line 11732 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
UserHandleGrantAccess(
         HANDLE hUserHandle,
         HANDLE hJob,
         BOOL   bGrant);

#line 11744 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"













































































































































































































































































































































































#line 12110 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"







#line 12118 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"
#line 12119 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"


}
#line 12123 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

#line 12125 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"





#line 165 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"





















extern "C" {
#line 24 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"








































#line 65 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"




















































































#line 150 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"















































































































































































































































#line 390 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"























































































































#line 510 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"










#line 521 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"





















#line 543 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"


























#line 570 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"























































#line 626 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"



























































typedef DWORD LGRPID;





typedef DWORD LCTYPE;





typedef DWORD CALTYPE;





typedef DWORD CALID;






typedef struct _cpinfo {
    UINT    MaxCharSize;                    
    BYTE    DefaultChar[2];   
    BYTE    LeadByte[12];        
} CPINFO, *LPCPINFO;

typedef struct _cpinfoexA {
    UINT    MaxCharSize;                    
    BYTE    DefaultChar[2];   
    BYTE    LeadByte[12];        
    WCHAR   UnicodeDefaultChar;             
    UINT    CodePage;                       
    CHAR    CodePageName[260];         
} CPINFOEXA, *LPCPINFOEXA;
typedef struct _cpinfoexW {
    UINT    MaxCharSize;                    
    BYTE    DefaultChar[2];   
    BYTE    LeadByte[12];        
    WCHAR   UnicodeDefaultChar;             
    UINT    CodePage;                       
    WCHAR   CodePageName[260];         
} CPINFOEXW, *LPCPINFOEXW;

typedef CPINFOEXW CPINFOEX;
typedef LPCPINFOEXW LPCPINFOEX;



#line 739 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"






typedef struct _numberfmtA {
    UINT    NumDigits;                 
    UINT    LeadingZero;               
    UINT    Grouping;                  
    LPSTR   lpDecimalSep;              
    LPSTR   lpThousandSep;             
    UINT    NegativeOrder;             
} NUMBERFMTA, *LPNUMBERFMTA;
typedef struct _numberfmtW {
    UINT    NumDigits;                 
    UINT    LeadingZero;               
    UINT    Grouping;                  
    LPWSTR  lpDecimalSep;              
    LPWSTR  lpThousandSep;             
    UINT    NegativeOrder;             
} NUMBERFMTW, *LPNUMBERFMTW;

typedef NUMBERFMTW NUMBERFMT;
typedef LPNUMBERFMTW LPNUMBERFMT;



#line 768 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"






typedef struct _currencyfmtA {
    UINT    NumDigits;                 
    UINT    LeadingZero;               
    UINT    Grouping;                  
    LPSTR   lpDecimalSep;              
    LPSTR   lpThousandSep;             
    UINT    NegativeOrder;             
    UINT    PositiveOrder;             
    LPSTR   lpCurrencySymbol;          
} CURRENCYFMTA, *LPCURRENCYFMTA;
typedef struct _currencyfmtW {
    UINT    NumDigits;                 
    UINT    LeadingZero;               
    UINT    Grouping;                  
    LPWSTR  lpDecimalSep;              
    LPWSTR  lpThousandSep;             
    UINT    NegativeOrder;             
    UINT    PositiveOrder;             
    LPWSTR  lpCurrencySymbol;          
} CURRENCYFMTW, *LPCURRENCYFMTW;

typedef CURRENCYFMTW CURRENCYFMT;
typedef LPCURRENCYFMTW LPCURRENCYFMT;



#line 801 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"





enum SYSNLS_FUNCTION{
    COMPARE_STRING    =  0x0001,
};
typedef DWORD NLS_FUNCTION;






typedef struct _nlsversioninfo{ 
    DWORD dwNLSVersionInfoSize; 
    DWORD dwNLSVersion; 
    DWORD dwDefinedVersion; 
} NLSVERSIONINFO, *LPNLSVERSIONINFO; 






typedef LONG    GEOID;
typedef DWORD   GEOTYPE;
typedef DWORD   GEOCLASS;







enum SYSGEOTYPE {
    GEO_NATION      =       0x0001,
    GEO_LATITUDE    =       0x0002,
    GEO_LONGITUDE   =       0x0003,
    GEO_ISO2        =       0x0004,
    GEO_ISO3        =       0x0005,
    GEO_RFC1766     =       0x0006,
    GEO_LCID        =       0x0007,
    GEO_FRIENDLYNAME=       0x0008,
    GEO_OFFICIALNAME=       0x0009,
    GEO_TIMEZONES   =       0x000A,
    GEO_OFFICIALLANGUAGES = 0x000B,
};





enum SYSGEOCLASS {
    GEOCLASS_NATION  = 16,
    GEOCLASS_REGION  = 14,
};








typedef BOOL (__stdcall* LANGUAGEGROUP_ENUMPROCA)(LGRPID, LPSTR, LPSTR, DWORD, LONG_PTR);
typedef BOOL (__stdcall* LANGGROUPLOCALE_ENUMPROCA)(LGRPID, LCID, LPSTR, LONG_PTR);
typedef BOOL (__stdcall* UILANGUAGE_ENUMPROCA)(LPSTR, LONG_PTR);
typedef BOOL (__stdcall* LOCALE_ENUMPROCA)(LPSTR);
typedef BOOL (__stdcall* CODEPAGE_ENUMPROCA)(LPSTR);
typedef BOOL (__stdcall* DATEFMT_ENUMPROCA)(LPSTR);
typedef BOOL (__stdcall* DATEFMT_ENUMPROCEXA)(LPSTR, CALID);
typedef BOOL (__stdcall* TIMEFMT_ENUMPROCA)(LPSTR);
typedef BOOL (__stdcall* CALINFO_ENUMPROCA)(LPSTR);
typedef BOOL (__stdcall* CALINFO_ENUMPROCEXA)(LPSTR, CALID);

typedef BOOL (__stdcall* LANGUAGEGROUP_ENUMPROCW)(LGRPID, LPWSTR, LPWSTR, DWORD, LONG_PTR);
typedef BOOL (__stdcall* LANGGROUPLOCALE_ENUMPROCW)(LGRPID, LCID, LPWSTR, LONG_PTR);
typedef BOOL (__stdcall* UILANGUAGE_ENUMPROCW)(LPWSTR, LONG_PTR);
typedef BOOL (__stdcall* LOCALE_ENUMPROCW)(LPWSTR);
typedef BOOL (__stdcall* CODEPAGE_ENUMPROCW)(LPWSTR);
typedef BOOL (__stdcall* DATEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (__stdcall* DATEFMT_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (__stdcall* TIMEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (__stdcall* CALINFO_ENUMPROCW)(LPWSTR);
typedef BOOL (__stdcall* CALINFO_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (__stdcall* GEO_ENUMPROC)(GEOID);


























#line 916 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"



























#line 944 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"



























__declspec(dllimport)
BOOL
__stdcall
IsValidCodePage(
         UINT  CodePage);

__declspec(dllimport)
UINT
__stdcall
GetACP(void);

__declspec(dllimport)
UINT
__stdcall
GetOEMCP(void);

__declspec(dllimport)
BOOL
__stdcall
GetCPInfo(
         UINT       CodePage,
         LPCPINFO  lpCPInfo);

__declspec(dllimport)
BOOL
__stdcall
GetCPInfoExA(
         UINT          CodePage,
         DWORD         dwFlags,
         LPCPINFOEXA  lpCPInfoEx);
__declspec(dllimport)
BOOL
__stdcall
GetCPInfoExW(
         UINT          CodePage,
         DWORD         dwFlags,
         LPCPINFOEXW  lpCPInfoEx);




#line 1013 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
IsDBCSLeadByte(
         BYTE  TestChar);

__declspec(dllimport)
BOOL
__stdcall
IsDBCSLeadByteEx(
         UINT  CodePage,
         BYTE  TestChar);

__declspec(dllimport)
int
__stdcall
MultiByteToWideChar(
         UINT     CodePage,
         DWORD    dwFlags,
         LPCSTR   lpMultiByteStr,
         int      cbMultiByte,
           LPWSTR  lpWideCharStr,
         int      cchWideChar);

__declspec(dllimport)
int
__stdcall
WideCharToMultiByte(
         UINT     CodePage,
         DWORD    dwFlags,
           LPCWSTR  lpWideCharStr,
         int      cchWideChar,
           LPSTR   lpMultiByteStr,
         int      cbMultiByte,
           LPCSTR   lpDefaultChar,
           LPBOOL  lpUsedDefaultChar);






__declspec(dllimport)
int
__stdcall
CompareStringA(
         LCID     Locale,
         DWORD    dwCmpFlags,
         LPCSTR  lpString1,
         int      cchCount1,
         LPCSTR  lpString2,
         int      cchCount2);
__declspec(dllimport)
int
__stdcall
CompareStringW(
         LCID     Locale,
         DWORD    dwCmpFlags,
         LPCWSTR  lpString1,
         int      cchCount1,
         LPCWSTR  lpString2,
         int      cchCount2);




#line 1081 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"



























#line 1109 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
int
__stdcall
LCMapStringA(
         LCID     Locale,
         DWORD    dwMapFlags,
         LPCSTR  lpSrcStr,
         int      cchSrc,
           LPSTR  lpDestStr,
         int      cchDest);
__declspec(dllimport)
int
__stdcall
LCMapStringW(
         LCID     Locale,
         DWORD    dwMapFlags,
         LPCWSTR  lpSrcStr,
         int      cchSrc,
           LPWSTR  lpDestStr,
         int      cchDest);




#line 1135 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
int
__stdcall
GetLocaleInfoA(
         LCID     Locale,
         LCTYPE   LCType,
           LPSTR  lpLCData,
         int      cchData);
__declspec(dllimport)
int
__stdcall
GetLocaleInfoW(
         LCID     Locale,
         LCTYPE   LCType,
           LPWSTR  lpLCData,
         int      cchData);




#line 1157 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
SetLocaleInfoA(
         LCID     Locale,
         LCTYPE   LCType,
         LPCSTR  lpLCData);
__declspec(dllimport)
BOOL
__stdcall
SetLocaleInfoW(
         LCID     Locale,
         LCTYPE   LCType,
         LPCWSTR  lpLCData);




#line 1177 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"


__declspec(dllimport)
int
__stdcall
GetCalendarInfoA(
         LCID     Locale,
         CALID    Calendar,
         CALTYPE  CalType,
           LPSTR   lpCalData,
         int      cchData,
           LPDWORD  lpValue);
__declspec(dllimport)
int
__stdcall
GetCalendarInfoW(
         LCID     Locale,
         CALID    Calendar,
         CALTYPE  CalType,
           LPWSTR   lpCalData,
         int      cchData,
           LPDWORD  lpValue);




#line 1204 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
SetCalendarInfoA(
         LCID     Locale,
         CALID    Calendar,
         CALTYPE  CalType,
         LPCSTR  lpCalData);
__declspec(dllimport)
BOOL
__stdcall
SetCalendarInfoW(
         LCID     Locale,
         CALID    Calendar,
         CALTYPE  CalType,
         LPCWSTR  lpCalData);




#line 1226 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"
#line 1227 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
int
__stdcall
GetTimeFormatA(
         LCID             Locale,
         DWORD            dwFlags,
           const SYSTEMTIME *lpTime,
           LPCSTR          lpFormat,
           LPSTR          lpTimeStr,
         int              cchTime);
__declspec(dllimport)
int
__stdcall
GetTimeFormatW(
         LCID             Locale,
         DWORD            dwFlags,
           const SYSTEMTIME *lpTime,
           LPCWSTR          lpFormat,
           LPWSTR          lpTimeStr,
         int              cchTime);




#line 1253 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
int
__stdcall
GetDateFormatA(
         LCID             Locale,
         DWORD            dwFlags,
           const SYSTEMTIME *lpDate,
           LPCSTR          lpFormat,
           LPSTR          lpDateStr,
         int              cchDate);
__declspec(dllimport)
int
__stdcall
GetDateFormatW(
         LCID             Locale,
         DWORD            dwFlags,
           const SYSTEMTIME *lpDate,
           LPCWSTR          lpFormat,
           LPWSTR          lpDateStr,
         int              cchDate);




#line 1279 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
int
__stdcall
GetNumberFormatA(
         LCID             Locale,
         DWORD            dwFlags,
         LPCSTR          lpValue,
           const NUMBERFMTA *lpFormat,
           LPSTR          lpNumberStr,
         int              cchNumber);
__declspec(dllimport)
int
__stdcall
GetNumberFormatW(
         LCID             Locale,
         DWORD            dwFlags,
         LPCWSTR          lpValue,
           const NUMBERFMTW *lpFormat,
           LPWSTR          lpNumberStr,
         int              cchNumber);




#line 1305 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
int
__stdcall
GetCurrencyFormatA(
         LCID               Locale,
         DWORD              dwFlags,
         LPCSTR            lpValue,
           const CURRENCYFMTA *lpFormat,
           LPSTR            lpCurrencyStr,
         int                cchCurrency);
__declspec(dllimport)
int
__stdcall
GetCurrencyFormatW(
         LCID               Locale,
         DWORD              dwFlags,
         LPCWSTR            lpValue,
           const CURRENCYFMTW *lpFormat,
           LPWSTR            lpCurrencyStr,
         int                cchCurrency);




#line 1331 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoA(
         CALINFO_ENUMPROCA lpCalInfoEnumProc,
         LCID              Locale,
         CALID             Calendar,
         CALTYPE           CalType);
__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoW(
         CALINFO_ENUMPROCW lpCalInfoEnumProc,
         LCID              Locale,
         CALID             Calendar,
         CALTYPE           CalType);




#line 1353 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoExA(
         CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx,
         LCID                Locale,
         CALID               Calendar,
         CALTYPE             CalType);
__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoExW(
         CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx,
         LCID                Locale,
         CALID               Calendar,
         CALTYPE             CalType);




#line 1376 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"
#line 1377 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
EnumTimeFormatsA(
         TIMEFMT_ENUMPROCA lpTimeFmtEnumProc,
         LCID              Locale,
         DWORD             dwFlags);
__declspec(dllimport)
BOOL
__stdcall
EnumTimeFormatsW(
         TIMEFMT_ENUMPROCW lpTimeFmtEnumProc,
         LCID              Locale,
         DWORD             dwFlags);




#line 1397 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsA(
         DATEFMT_ENUMPROCA lpDateFmtEnumProc,
         LCID              Locale,
         DWORD             dwFlags);
__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsW(
         DATEFMT_ENUMPROCW lpDateFmtEnumProc,
         LCID              Locale,
         DWORD             dwFlags);




#line 1417 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsExA(
         DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx,
         LCID                Locale,
         DWORD               dwFlags);
__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsExW(
         DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx,
         LCID                Locale,
         DWORD               dwFlags);




#line 1438 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"
#line 1439 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
IsValidLanguageGroup(
         LGRPID  LanguageGroup,
         DWORD   dwFlags);
#line 1448 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
GetNLSVersion(
         NLS_FUNCTION     Function,
         LCID             Locale,
         LPNLSVERSIONINFO lpVersionInformation);

__declspec(dllimport)
BOOL
__stdcall
IsNLSDefinedString(
         NLS_FUNCTION     Function,
         DWORD            dwFlags,
         LPNLSVERSIONINFO lpVersionInformation,
         LPCWSTR          lpString,
         INT              cchStr);

__declspec(dllimport)
BOOL
__stdcall
IsValidLocale(
         LCID   Locale,
         DWORD  dwFlags);

__declspec(dllimport)
int
__stdcall
GetGeoInfoA(
         GEOID       Location,
         GEOTYPE     GeoType,
           LPSTR     lpGeoData,
         int         cchData,
         LANGID      LangId);
__declspec(dllimport)
int
__stdcall
GetGeoInfoW(
         GEOID       Location,
         GEOTYPE     GeoType,
           LPWSTR     lpGeoData,
         int         cchData,
         LANGID      LangId);




#line 1497 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
EnumSystemGeoID(
         GEOCLASS        GeoClass,
         GEOID           ParentGeoId,
         GEO_ENUMPROC    lpGeoEnumProc);

__declspec(dllimport)
GEOID
__stdcall
GetUserGeoID(
         GEOCLASS    GeoClass);

__declspec(dllimport)
BOOL
__stdcall
SetUserGeoID(
         GEOID       GeoId);

__declspec(dllimport)
LCID
__stdcall
ConvertDefaultLocale(
         LCID   Locale);

__declspec(dllimport)
LCID
__stdcall
GetThreadLocale(void);

__declspec(dllimport)
BOOL
__stdcall
SetThreadLocale(
         LCID  Locale
    );


__declspec(dllimport)
LANGID
__stdcall
GetSystemDefaultUILanguage(void);

__declspec(dllimport)
LANGID
__stdcall
GetUserDefaultUILanguage(void);
#line 1547 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
LANGID
__stdcall
GetSystemDefaultLangID(void);

__declspec(dllimport)
LANGID
__stdcall
GetUserDefaultLangID(void);

__declspec(dllimport)
LCID
__stdcall
GetSystemDefaultLCID(void);

__declspec(dllimport)
LCID
__stdcall
GetUserDefaultLCID(void);







__declspec(dllimport)
BOOL
__stdcall
GetStringTypeExA(
         LCID     Locale,
         DWORD    dwInfoType,
         LPCSTR  lpSrcStr,
         int      cchSrc,
         LPWORD  lpCharType);
__declspec(dllimport)
BOOL
__stdcall
GetStringTypeExW(
         LCID     Locale,
         DWORD    dwInfoType,
         LPCWSTR  lpSrcStr,
         int      cchSrc,
         LPWORD  lpCharType);




#line 1597 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"












__declspec(dllimport)
BOOL
__stdcall
GetStringTypeA(
         LCID     Locale,
         DWORD    dwInfoType,
         LPCSTR   lpSrcStr,
         int      cchSrc,
         LPWORD  lpCharType);

__declspec(dllimport)
BOOL
__stdcall
GetStringTypeW(
         DWORD    dwInfoType,
         LPCWSTR  lpSrcStr,
         int      cchSrc,
         LPWORD  lpCharType);


__declspec(dllimport)
int
__stdcall
FoldStringA(
         DWORD    dwMapFlags,
         LPCSTR  lpSrcStr,
         int      cchSrc,
           LPSTR  lpDestStr,
         int      cchDest);
__declspec(dllimport)
int
__stdcall
FoldStringW(
         DWORD    dwMapFlags,
         LPCWSTR  lpSrcStr,
         int      cchSrc,
           LPWSTR  lpDestStr,
         int      cchDest);




#line 1652 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
EnumSystemLanguageGroupsA(
         LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc,
         DWORD                   dwFlags,
         LONG_PTR                lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumSystemLanguageGroupsW(
         LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc,
         DWORD                   dwFlags,
         LONG_PTR                lParam);




#line 1673 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
EnumLanguageGroupLocalesA(
         LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc,
         LGRPID                    LanguageGroup,
         DWORD                     dwFlags,
         LONG_PTR                  lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumLanguageGroupLocalesW(
         LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc,
         LGRPID                    LanguageGroup,
         DWORD                     dwFlags,
         LONG_PTR                  lParam);




#line 1695 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
EnumUILanguagesA(
         UILANGUAGE_ENUMPROCA lpUILanguageEnumProc,
         DWORD                dwFlags,
         LONG_PTR             lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumUILanguagesW(
         UILANGUAGE_ENUMPROCW lpUILanguageEnumProc,
         DWORD                dwFlags,
         LONG_PTR             lParam);




#line 1715 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"
#line 1716 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
EnumSystemLocalesA(
         LOCALE_ENUMPROCA lpLocaleEnumProc,
         DWORD            dwFlags);
__declspec(dllimport)
BOOL
__stdcall
EnumSystemLocalesW(
         LOCALE_ENUMPROCW lpLocaleEnumProc,
         DWORD            dwFlags);




#line 1734 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
EnumSystemCodePagesA(
         CODEPAGE_ENUMPROCA lpCodePageEnumProc,
         DWORD              dwFlags);
__declspec(dllimport)
BOOL
__stdcall
EnumSystemCodePagesW(
         CODEPAGE_ENUMPROCW lpCodePageEnumProc,
         DWORD              dwFlags);




#line 1752 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"


#line 1755 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"



}
#line 1760 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

#line 1762 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnls.h"

#line 167 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 168 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

























extern "C" {
#line 28 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

typedef struct _COORD {
    SHORT X;
    SHORT Y;
} COORD, *PCOORD;

typedef struct _SMALL_RECT {
    SHORT Left;
    SHORT Top;
    SHORT Right;
    SHORT Bottom;
} SMALL_RECT, *PSMALL_RECT;

typedef struct _KEY_EVENT_RECORD {
    BOOL bKeyDown;
    WORD wRepeatCount;
    WORD wVirtualKeyCode;
    WORD wVirtualScanCode;
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } uChar;
    DWORD dwControlKeyState;
} KEY_EVENT_RECORD, *PKEY_EVENT_RECORD;






















typedef struct _MOUSE_EVENT_RECORD {
    COORD dwMousePosition;
    DWORD dwButtonState;
    DWORD dwControlKeyState;
    DWORD dwEventFlags;
} MOUSE_EVENT_RECORD, *PMOUSE_EVENT_RECORD;



















typedef struct _WINDOW_BUFFER_SIZE_RECORD {
    COORD dwSize;
} WINDOW_BUFFER_SIZE_RECORD, *PWINDOW_BUFFER_SIZE_RECORD;

typedef struct _MENU_EVENT_RECORD {
    UINT dwCommandId;
} MENU_EVENT_RECORD, *PMENU_EVENT_RECORD;

typedef struct _FOCUS_EVENT_RECORD {
    BOOL bSetFocus;
} FOCUS_EVENT_RECORD, *PFOCUS_EVENT_RECORD;

typedef struct _INPUT_RECORD {
    WORD EventType;
    union {
        KEY_EVENT_RECORD KeyEvent;
        MOUSE_EVENT_RECORD MouseEvent;
        WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
        MENU_EVENT_RECORD MenuEvent;
        FOCUS_EVENT_RECORD FocusEvent;
    } Event;
} INPUT_RECORD, *PINPUT_RECORD;











typedef struct _CHAR_INFO {
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } Char;
    WORD Attributes;
} CHAR_INFO, *PCHAR_INFO;
























typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
    COORD dwSize;
    COORD dwCursorPosition;
    WORD  wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO, *PCONSOLE_SCREEN_BUFFER_INFO;

typedef struct _CONSOLE_CURSOR_INFO {
    DWORD  dwSize;
    BOOL   bVisible;
} CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO;

typedef struct _CONSOLE_FONT_INFO {
    DWORD  nFont;
    COORD  dwFontSize;
} CONSOLE_FONT_INFO, *PCONSOLE_FONT_INFO;


typedef struct _CONSOLE_SELECTION_INFO {
    DWORD dwFlags;
    COORD dwSelectionAnchor;
    SMALL_RECT srSelection;
} CONSOLE_SELECTION_INFO, *PCONSOLE_SELECTION_INFO;










#line 198 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"





typedef
BOOL
(__stdcall *PHANDLER_ROUTINE)(
    DWORD CtrlType
    );






























__declspec(dllimport)
BOOL
__stdcall
PeekConsoleInputA(
     HANDLE hConsoleInput,
     PINPUT_RECORD lpBuffer,
     DWORD nLength,
     LPDWORD lpNumberOfEventsRead
    );
__declspec(dllimport)
BOOL
__stdcall
PeekConsoleInputW(
     HANDLE hConsoleInput,
     PINPUT_RECORD lpBuffer,
     DWORD nLength,
     LPDWORD lpNumberOfEventsRead
    );




#line 261 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
ReadConsoleInputA(
     HANDLE hConsoleInput,
     PINPUT_RECORD lpBuffer,
     DWORD nLength,
     LPDWORD lpNumberOfEventsRead
    );
__declspec(dllimport)
BOOL
__stdcall
ReadConsoleInputW(
     HANDLE hConsoleInput,
     PINPUT_RECORD lpBuffer,
     DWORD nLength,
     LPDWORD lpNumberOfEventsRead
    );




#line 285 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleInputA(
     HANDLE hConsoleInput,
     const INPUT_RECORD *lpBuffer,
     DWORD nLength,
     LPDWORD lpNumberOfEventsWritten
    );
__declspec(dllimport)
BOOL
__stdcall
WriteConsoleInputW(
     HANDLE hConsoleInput,
     const INPUT_RECORD *lpBuffer,
     DWORD nLength,
     LPDWORD lpNumberOfEventsWritten
    );




#line 309 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputA(
     HANDLE hConsoleOutput,
     PCHAR_INFO lpBuffer,
     COORD dwBufferSize,
     COORD dwBufferCoord,
      PSMALL_RECT lpReadRegion
    );
__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputW(
     HANDLE hConsoleOutput,
     PCHAR_INFO lpBuffer,
     COORD dwBufferSize,
     COORD dwBufferCoord,
      PSMALL_RECT lpReadRegion
    );




#line 335 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputA(
     HANDLE hConsoleOutput,
     const CHAR_INFO *lpBuffer,
     COORD dwBufferSize,
     COORD dwBufferCoord,
      PSMALL_RECT lpWriteRegion
    );
__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputW(
     HANDLE hConsoleOutput,
     const CHAR_INFO *lpBuffer,
     COORD dwBufferSize,
     COORD dwBufferCoord,
      PSMALL_RECT lpWriteRegion
    );




#line 361 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputCharacterA(
     HANDLE hConsoleOutput,
     LPSTR lpCharacter,
      DWORD nLength,
     COORD dwReadCoord,
     LPDWORD lpNumberOfCharsRead
    );
__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputCharacterW(
     HANDLE hConsoleOutput,
     LPWSTR lpCharacter,
      DWORD nLength,
     COORD dwReadCoord,
     LPDWORD lpNumberOfCharsRead
    );




#line 387 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputAttribute(
     HANDLE hConsoleOutput,
     LPWORD lpAttribute,
     DWORD nLength,
     COORD dwReadCoord,
     LPDWORD lpNumberOfAttrsRead
    );

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputCharacterA(
     HANDLE hConsoleOutput,
     LPCSTR lpCharacter,
     DWORD nLength,
     COORD dwWriteCoord,
     LPDWORD lpNumberOfCharsWritten
    );
__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputCharacterW(
     HANDLE hConsoleOutput,
     LPCWSTR lpCharacter,
     DWORD nLength,
     COORD dwWriteCoord,
     LPDWORD lpNumberOfCharsWritten
    );




#line 424 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputAttribute(
     HANDLE hConsoleOutput,
     const WORD *lpAttribute,
     DWORD nLength,
     COORD dwWriteCoord,
     LPDWORD lpNumberOfAttrsWritten
    );

__declspec(dllimport)
BOOL
__stdcall
FillConsoleOutputCharacterA(
     HANDLE hConsoleOutput,
     CHAR  cCharacter,
     DWORD  nLength,
     COORD  dwWriteCoord,
     LPDWORD lpNumberOfCharsWritten
    );
__declspec(dllimport)
BOOL
__stdcall
FillConsoleOutputCharacterW(
     HANDLE hConsoleOutput,
     WCHAR  cCharacter,
     DWORD  nLength,
     COORD  dwWriteCoord,
     LPDWORD lpNumberOfCharsWritten
    );




#line 461 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
FillConsoleOutputAttribute(
     HANDLE hConsoleOutput,
     WORD   wAttribute,
     DWORD  nLength,
     COORD  dwWriteCoord,
     LPDWORD lpNumberOfAttrsWritten
    );

__declspec(dllimport)
BOOL
__stdcall
GetConsoleMode(
     HANDLE hConsoleHandle,
     LPDWORD lpMode
    );

__declspec(dllimport)
BOOL
__stdcall
GetNumberOfConsoleInputEvents(
     HANDLE hConsoleInput,
     LPDWORD lpNumberOfEvents
    );

__declspec(dllimport)
BOOL
__stdcall
GetConsoleScreenBufferInfo(
     HANDLE hConsoleOutput,
     PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo
    );

__declspec(dllimport)
COORD
__stdcall
GetLargestConsoleWindowSize(
     HANDLE hConsoleOutput
    );

__declspec(dllimport)
BOOL
__stdcall
GetConsoleCursorInfo(
     HANDLE hConsoleOutput,
     PCONSOLE_CURSOR_INFO lpConsoleCursorInfo
    );



__declspec(dllimport)
BOOL
__stdcall
GetCurrentConsoleFont(
     HANDLE hConsoleOutput,
     BOOL bMaximumWindow,
     PCONSOLE_FONT_INFO lpConsoleCurrentFont
    );

__declspec(dllimport)
COORD
__stdcall
GetConsoleFontSize(
     HANDLE hConsoleOutput,
     DWORD nFont
    );

__declspec(dllimport)
BOOL
__stdcall
GetConsoleSelectionInfo(
     PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo
    );

#line 539 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
GetNumberOfConsoleMouseButtons(
     LPDWORD lpNumberOfMouseButtons
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleMode(
     HANDLE hConsoleHandle,
     DWORD dwMode
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleActiveScreenBuffer(
     HANDLE hConsoleOutput
    );

__declspec(dllimport)
BOOL
__stdcall
FlushConsoleInputBuffer(
     HANDLE hConsoleInput
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleScreenBufferSize(
     HANDLE hConsoleOutput,
     COORD dwSize
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleCursorPosition(
     HANDLE hConsoleOutput,
     COORD dwCursorPosition
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleCursorInfo(
     HANDLE hConsoleOutput,
     const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo
    );

__declspec(dllimport)
BOOL
__stdcall
ScrollConsoleScreenBufferA(
     HANDLE hConsoleOutput,
     const SMALL_RECT *lpScrollRectangle,
     const SMALL_RECT *lpClipRectangle,
     COORD dwDestinationOrigin,
     const CHAR_INFO *lpFill
    );
__declspec(dllimport)
BOOL
__stdcall
ScrollConsoleScreenBufferW(
     HANDLE hConsoleOutput,
     const SMALL_RECT *lpScrollRectangle,
     const SMALL_RECT *lpClipRectangle,
     COORD dwDestinationOrigin,
     const CHAR_INFO *lpFill
    );




#line 618 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
SetConsoleWindowInfo(
     HANDLE hConsoleOutput,
     BOOL bAbsolute,
     const SMALL_RECT *lpConsoleWindow
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleTextAttribute(
     HANDLE hConsoleOutput,
     WORD wAttributes
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleCtrlHandler(
     PHANDLER_ROUTINE HandlerRoutine,
     BOOL Add
    );

__declspec(dllimport)
BOOL
__stdcall
GenerateConsoleCtrlEvent(
     DWORD dwCtrlEvent,
     DWORD dwProcessGroupId
    );

__declspec(dllimport)
BOOL
__stdcall
AllocConsole( void );

__declspec(dllimport)
BOOL
__stdcall
FreeConsole( void );


__declspec(dllimport)
BOOL
__stdcall
AttachConsole(
     DWORD dwProcessId
    );


#line 672 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleTitleA(
     LPSTR lpConsoleTitle,
     DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetConsoleTitleW(
     LPWSTR lpConsoleTitle,
     DWORD nSize
    );




#line 692 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
SetConsoleTitleA(
     LPCSTR lpConsoleTitle
    );
__declspec(dllimport)
BOOL
__stdcall
SetConsoleTitleW(
     LPCWSTR lpConsoleTitle
    );




#line 710 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
ReadConsoleA(
     HANDLE hConsoleInput,
     LPVOID lpBuffer,
     DWORD nNumberOfCharsToRead,
     LPDWORD lpNumberOfCharsRead,
     LPVOID lpReserved
    );
__declspec(dllimport)
BOOL
__stdcall
ReadConsoleW(
     HANDLE hConsoleInput,
     LPVOID lpBuffer,
     DWORD nNumberOfCharsToRead,
     LPDWORD lpNumberOfCharsRead,
     LPVOID lpReserved
    );




#line 736 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleA(
     HANDLE hConsoleOutput,
     const void *lpBuffer,
     DWORD nNumberOfCharsToWrite,
     LPDWORD lpNumberOfCharsWritten,
     LPVOID lpReserved
    );
__declspec(dllimport)
BOOL
__stdcall
WriteConsoleW(
     HANDLE hConsoleOutput,
     const void *lpBuffer,
     DWORD nNumberOfCharsToWrite,
     LPDWORD lpNumberOfCharsWritten,
     LPVOID lpReserved
    );




#line 762 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"



__declspec(dllimport)
HANDLE
__stdcall
CreateConsoleScreenBuffer(
     DWORD dwDesiredAccess,
     DWORD dwShareMode,
     const SECURITY_ATTRIBUTES *lpSecurityAttributes,
     DWORD dwFlags,
     LPVOID lpScreenBufferData
    );

__declspec(dllimport)
UINT
__stdcall
GetConsoleCP( void );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleCP(
     UINT wCodePageID
    );

__declspec(dllimport)
UINT
__stdcall
GetConsoleOutputCP( void );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleOutputCP(
     UINT wCodePageID
    );






__declspec(dllimport)
BOOL
__stdcall
GetConsoleDisplayMode(
     LPDWORD lpModeFlags
    );

__declspec(dllimport)
HWND
__stdcall
GetConsoleWindow(
    void
    );

#line 820 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"






























































































































#line 947 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"


}
#line 951 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

#line 953 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\wincon.h"

#line 170 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winver.h"
















extern "C" {
#line 19 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winver.h"











#line 31 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winver.h"





































































































typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            
    DWORD   dwStrucVersion;         
    DWORD   dwFileVersionMS;        
    DWORD   dwFileVersionLS;        
    DWORD   dwProductVersionMS;     
    DWORD   dwProductVersionLS;     
    DWORD   dwFileFlagsMask;        
    DWORD   dwFileFlags;            
    DWORD   dwFileOS;               
    DWORD   dwFileType;             
    DWORD   dwFileSubtype;          
    DWORD   dwFileDateMS;           
    DWORD   dwFileDateLS;           
} VS_FIXEDFILEINFO;



DWORD
__stdcall
VerFindFileA(
        DWORD uFlags,
        LPSTR szFileName,
        LPSTR szWinDir,
        LPSTR szAppDir,
        LPSTR szCurDir,
        PUINT lpuCurDirLen,
        LPSTR szDestDir,
        PUINT lpuDestDirLen
        );
DWORD
__stdcall
VerFindFileW(
        DWORD uFlags,
        LPWSTR szFileName,
        LPWSTR szWinDir,
        LPWSTR szAppDir,
        LPWSTR szCurDir,
        PUINT lpuCurDirLen,
        LPWSTR szDestDir,
        PUINT lpuDestDirLen
        );




#line 180 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winver.h"

DWORD
__stdcall
VerInstallFileA(
        DWORD uFlags,
        LPSTR szSrcFileName,
        LPSTR szDestFileName,
        LPSTR szSrcDir,
        LPSTR szDestDir,
        LPSTR szCurDir,
        LPSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
DWORD
__stdcall
VerInstallFileW(
        DWORD uFlags,
        LPWSTR szSrcFileName,
        LPWSTR szDestFileName,
        LPWSTR szSrcDir,
        LPWSTR szDestDir,
        LPWSTR szCurDir,
        LPWSTR szTmpFile,
        PUINT lpuTmpFileLen
        );




#line 210 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winver.h"


DWORD
__stdcall
GetFileVersionInfoSizeA(
         LPCSTR lptstrFilename, 
           LPDWORD lpdwHandle
    );                      

DWORD
__stdcall
GetFileVersionInfoSizeW(
         LPCWSTR lptstrFilename, 
           LPDWORD lpdwHandle
    );                      




#line 230 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winver.h"


BOOL
__stdcall
GetFileVersionInfoA(
         LPCSTR lptstrFilename, 
         DWORD dwHandle,         
         DWORD dwLen,            
         LPVOID lpData
    );                      

BOOL
__stdcall
GetFileVersionInfoW(
         LPCWSTR lptstrFilename, 
         DWORD dwHandle,         
         DWORD dwLen,            
         LPVOID lpData
    );                      




#line 254 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winver.h"

DWORD
__stdcall
VerLanguageNameA(
        DWORD wLang,
        LPSTR szLang,
        DWORD nSize
        );
DWORD
__stdcall
VerLanguageNameW(
        DWORD wLang,
        LPWSTR szLang,
        DWORD nSize
        );




#line 274 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winver.h"

BOOL
__stdcall
VerQueryValueA(
        const LPVOID pBlock,
        LPSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
BOOL
__stdcall
VerQueryValueW(
        const LPVOID pBlock,
        LPWSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );




#line 296 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winver.h"

#line 298 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winver.h"


}
#line 302 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winver.h"

#line 304 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winver.h"

#line 171 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 172 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"
























extern "C" {
#line 27 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"




























typedef ACCESS_MASK REGSAM;



























struct val_context {
    int valuelen;       
    LPVOID value_context;   
    LPVOID val_buff_ptr;    
};

typedef struct val_context  *PVALCONTEXT;

typedef struct pvalueA {           
    LPSTR   pv_valuename;          
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEA,  *PPVALUEA;
typedef struct pvalueW {           
    LPWSTR  pv_valuename;          
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEW,  *PPVALUEW;

typedef PVALUEW PVALUE;
typedef PPVALUEW PPVALUE;



#line 110 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

typedef
DWORD _cdecl
QUERYHANDLER (LPVOID keycontext, PVALCONTEXT val_list, DWORD num_vals,
          LPVOID outputbuffer, DWORD  *total_outlen, DWORD input_blen);

typedef QUERYHANDLER  *PQUERYHANDLER;

typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;    
    LPVOID pi_key_context;
}REG_PROVIDER;

typedef struct provider_info  *PPROVIDER;

typedef struct value_entA {
    LPSTR   ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTA,  *PVALENTA;
typedef struct value_entW {
    LPWSTR  ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTW,  *PVALENTW;

typedef VALENTW VALENT;
typedef PVALENTW PVALENT;



#line 148 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

#line 150 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"


#line 153 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"













__declspec(dllimport)
LONG
__stdcall
RegCloseKey (
         HKEY hKey
    );

__declspec(dllimport)
LONG
__stdcall
RegOverridePredefKey (
         HKEY hKey,
           HKEY hNewHKey
    );

__declspec(dllimport)
LONG
__stdcall
RegOpenUserClassesRoot(
         HANDLE hToken,
      DWORD dwOptions,
         REGSAM samDesired,
         PHKEY  phkResult
    );

__declspec(dllimport)
LONG
__stdcall
RegOpenCurrentUser(
         REGSAM samDesired,
         PHKEY phkResult
    );

__declspec(dllimport)
LONG
__stdcall
RegDisablePredefinedCache(
    );

__declspec(dllimport)
LONG
__stdcall
RegConnectRegistryA (
           LPCSTR lpMachineName,
         HKEY hKey,
         PHKEY phkResult
    );
__declspec(dllimport)
LONG
__stdcall
RegConnectRegistryW (
           LPCWSTR lpMachineName,
         HKEY hKey,
         PHKEY phkResult
    );




#line 226 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegConnectRegistryExA (
           LPCSTR lpMachineName,
         HKEY hKey,
         ULONG Flags,
         PHKEY phkResult
    );
__declspec(dllimport)
LONG
__stdcall
RegConnectRegistryExW (
           LPCWSTR lpMachineName,
         HKEY hKey,
         ULONG Flags,
         PHKEY phkResult
    );




#line 250 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegCreateKeyA (
         HKEY hKey,
           LPCSTR lpSubKey,
         PHKEY phkResult
    );
__declspec(dllimport)
LONG
__stdcall
RegCreateKeyW (
         HKEY hKey,
           LPCWSTR lpSubKey,
         PHKEY phkResult
    );




#line 272 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegCreateKeyExA (
         HKEY hKey,
         LPCSTR lpSubKey,
      DWORD Reserved,
           LPSTR lpClass,
         DWORD dwOptions,
         REGSAM samDesired,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes,
         PHKEY phkResult,
           LPDWORD lpdwDisposition
    );
__declspec(dllimport)
LONG
__stdcall
RegCreateKeyExW (
         HKEY hKey,
         LPCWSTR lpSubKey,
      DWORD Reserved,
           LPWSTR lpClass,
         DWORD dwOptions,
         REGSAM samDesired,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes,
         PHKEY phkResult,
           LPDWORD lpdwDisposition
    );




#line 306 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegDeleteKeyA (
         HKEY hKey,
         LPCSTR lpSubKey
    );
__declspec(dllimport)
LONG
__stdcall
RegDeleteKeyW (
         HKEY hKey,
         LPCWSTR lpSubKey
    );




#line 326 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"
    
__declspec(dllimport)
LONG
__stdcall
RegDeleteKeyExA (
         HKEY hKey,
         LPCSTR lpSubKey,
         REGSAM samDesired,
      DWORD Reserved
    );
__declspec(dllimport)
LONG
__stdcall
RegDeleteKeyExW (
         HKEY hKey,
         LPCWSTR lpSubKey,
         REGSAM samDesired,
      DWORD Reserved
    );




#line 350 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegDisableReflectionKey (
         HKEY hBase
    );    

__declspec(dllimport)
LONG
__stdcall
RegEnableReflectionKey (
         HKEY hBase
    );    

__declspec(dllimport)
LONG
__stdcall
RegQueryReflectionKey (
         HKEY hBase,
         BOOL *bIsReflectionDisabled
    );    


__declspec(dllimport)
LONG
__stdcall
RegDeleteValueA (
         HKEY hKey,
           LPCSTR lpValueName
    );
__declspec(dllimport)
LONG
__stdcall
RegDeleteValueW (
         HKEY hKey,
           LPCWSTR lpValueName
    );




#line 393 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegEnumKeyA (
         HKEY hKey,
         DWORD dwIndex,
           LPSTR lpName,
         DWORD cchName
    );
__declspec(dllimport)
LONG
__stdcall
RegEnumKeyW (
         HKEY hKey,
         DWORD dwIndex,
           LPWSTR lpName,
         DWORD cchName
    );




#line 417 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegEnumKeyExA (
         HKEY hKey,
         DWORD dwIndex,
           LPSTR lpName,
         LPDWORD lpcchName,
      LPDWORD lpReserved,
             LPSTR lpClass,
           LPDWORD lpcchClass,
           PFILETIME lpftLastWriteTime
    );
__declspec(dllimport)
LONG
__stdcall
RegEnumKeyExW (
         HKEY hKey,
         DWORD dwIndex,
           LPWSTR lpName,
         LPDWORD lpcchName,
      LPDWORD lpReserved,
             LPWSTR lpClass,
           LPDWORD lpcchClass,
           PFILETIME lpftLastWriteTime
    );




#line 449 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegEnumValueA (
         HKEY hKey,
         DWORD dwIndex,
           LPSTR lpValueName,
         LPDWORD lpcchValueName,
      LPDWORD lpReserved,
           LPDWORD lpType,
           LPBYTE lpData,
           LPDWORD lpcbData
    );
__declspec(dllimport)
LONG
__stdcall
RegEnumValueW (
         HKEY hKey,
         DWORD dwIndex,
           LPWSTR lpValueName,
         LPDWORD lpcchValueName,
      LPDWORD lpReserved,
           LPDWORD lpType,
           LPBYTE lpData,
           LPDWORD lpcbData
    );




#line 481 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegFlushKey (
         HKEY hKey
    );

__declspec(dllimport)
LONG
__stdcall
RegGetKeySecurity (
         HKEY hKey,
         SECURITY_INFORMATION SecurityInformation,
           PSECURITY_DESCRIPTOR pSecurityDescriptor,
         LPDWORD lpcbSecurityDescriptor
    );

__declspec(dllimport)
LONG
__stdcall
RegLoadKeyA (
         HKEY    hKey,
           LPCSTR  lpSubKey,
         LPCSTR  lpFile
    );
__declspec(dllimport)
LONG
__stdcall
RegLoadKeyW (
         HKEY    hKey,
           LPCWSTR  lpSubKey,
         LPCWSTR  lpFile
    );




#line 520 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegNotifyChangeKeyValue (
         HKEY hKey,
         BOOL bWatchSubtree,
         DWORD dwNotifyFilter,
           HANDLE hEvent,
         BOOL fAsynchronous
    );

__declspec(dllimport)
LONG
__stdcall
RegOpenKeyA (
         HKEY hKey,
           LPCSTR lpSubKey,
         PHKEY phkResult
    );
__declspec(dllimport)
LONG
__stdcall
RegOpenKeyW (
         HKEY hKey,
           LPCWSTR lpSubKey,
         PHKEY phkResult
    );




#line 553 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegOpenKeyExA (
         HKEY hKey,
           LPCSTR lpSubKey,
      DWORD ulOptions,
         REGSAM samDesired,
         PHKEY phkResult
    );
__declspec(dllimport)
LONG
__stdcall
RegOpenKeyExW (
         HKEY hKey,
           LPCWSTR lpSubKey,
      DWORD ulOptions,
         REGSAM samDesired,
         PHKEY phkResult
    );




#line 579 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegQueryInfoKeyA (
         HKEY hKey,
           LPSTR lpClass,
           LPDWORD lpcchClass,
      LPDWORD lpReserved,
           LPDWORD lpcSubKeys,
           LPDWORD lpcbMaxSubKeyLen,
           LPDWORD lpcbMaxClassLen,
           LPDWORD lpcValues,
           LPDWORD lpcbMaxValueNameLen,
           LPDWORD lpcbMaxValueLen,
           LPDWORD lpcbSecurityDescriptor,
           PFILETIME lpftLastWriteTime
    );
__declspec(dllimport)
LONG
__stdcall
RegQueryInfoKeyW (
         HKEY hKey,
           LPWSTR lpClass,
           LPDWORD lpcchClass,
      LPDWORD lpReserved,
           LPDWORD lpcSubKeys,
           LPDWORD lpcbMaxSubKeyLen,
           LPDWORD lpcbMaxClassLen,
           LPDWORD lpcValues,
           LPDWORD lpcbMaxValueNameLen,
           LPDWORD lpcbMaxValueLen,
           LPDWORD lpcbSecurityDescriptor,
           PFILETIME lpftLastWriteTime
    );




#line 619 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegQueryValueA (
         HKEY hKey,
           LPCSTR lpSubKey,
           LPSTR lpData,
           PLONG lpcbData
    );
__declspec(dllimport)
LONG
__stdcall
RegQueryValueW (
         HKEY hKey,
           LPCWSTR lpSubKey,
           LPWSTR lpData,
           PLONG lpcbData
    );




#line 643 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"


__declspec(dllimport)
LONG
__stdcall
RegQueryMultipleValuesA (
         HKEY hKey,
         PVALENTA val_list,
         DWORD num_vals,
           LPSTR lpValueBuf,
           LPDWORD ldwTotsize
    );
__declspec(dllimport)
LONG
__stdcall
RegQueryMultipleValuesW (
         HKEY hKey,
         PVALENTW val_list,
         DWORD num_vals,
           LPWSTR lpValueBuf,
           LPDWORD ldwTotsize
    );




#line 670 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"
#line 671 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegQueryValueExA (
         HKEY hKey,
           LPCSTR lpValueName,
      LPDWORD lpReserved,
           LPDWORD lpType,
           LPBYTE lpData,
           LPDWORD lpcbData
    );
__declspec(dllimport)
LONG
__stdcall
RegQueryValueExW (
         HKEY hKey,
           LPCWSTR lpValueName,
      LPDWORD lpReserved,
           LPDWORD lpType,
           LPBYTE lpData,
           LPDWORD lpcbData
    );




#line 699 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegReplaceKeyA (
         HKEY hKey,
           LPCSTR lpSubKey,
         LPCSTR lpNewFile,
         LPCSTR lpOldFile
    );
__declspec(dllimport)
LONG
__stdcall
RegReplaceKeyW (
         HKEY hKey,
           LPCWSTR lpSubKey,
         LPCWSTR lpNewFile,
         LPCWSTR lpOldFile
    );




#line 723 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegRestoreKeyA (
         HKEY hKey,
         LPCSTR lpFile,
         DWORD dwFlags
    );
__declspec(dllimport)
LONG
__stdcall
RegRestoreKeyW (
         HKEY hKey,
         LPCWSTR lpFile,
         DWORD dwFlags
    );




#line 745 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegSaveKeyA (
         HKEY hKey,
         LPCSTR lpFile,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
LONG
__stdcall
RegSaveKeyW (
         HKEY hKey,
         LPCWSTR lpFile,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 767 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegSetKeySecurity (
         HKEY hKey,
         SECURITY_INFORMATION SecurityInformation,
         PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

__declspec(dllimport)
LONG
__stdcall
RegSetValueA (
         HKEY hKey,
           LPCSTR lpSubKey,
         DWORD dwType,
             LPCSTR lpData,
         DWORD cbData
    );
__declspec(dllimport)
LONG
__stdcall
RegSetValueW (
         HKEY hKey,
           LPCWSTR lpSubKey,
         DWORD dwType,
             LPCWSTR lpData,
         DWORD cbData
    );




#line 802 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"


__declspec(dllimport)
LONG
__stdcall
RegSetValueExA (
         HKEY hKey,
           LPCSTR lpValueName,
      DWORD Reserved,
         DWORD dwType,
             const BYTE* lpData,
         DWORD cbData
    );
__declspec(dllimport)
LONG
__stdcall
RegSetValueExW (
         HKEY hKey,
           LPCWSTR lpValueName,
      DWORD Reserved,
         DWORD dwType,
             const BYTE* lpData,
         DWORD cbData
    );




#line 831 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegUnLoadKeyA (
         HKEY    hKey,
           LPCSTR lpSubKey
    );
__declspec(dllimport)
LONG
__stdcall
RegUnLoadKeyW (
         HKEY    hKey,
           LPCWSTR lpSubKey
    );




#line 851 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegGetValueA (
         HKEY    hkey,
           LPCSTR  lpSubKey,
           LPCSTR  lpValue,
           DWORD    dwFlags,
           LPDWORD pdwType,
           PVOID   pvData,
           LPDWORD pcbData 
    );
__declspec(dllimport)
LONG
__stdcall
RegGetValueW (
         HKEY    hkey,
           LPCWSTR  lpSubKey,
           LPCWSTR  lpValue,
           DWORD    dwFlags,
           LPDWORD pdwType,
           PVOID   pvData,
           LPDWORD pcbData 
    );




#line 881 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"





__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownA(
           LPSTR lpMachineName,
           LPSTR lpMessage,
         DWORD dwTimeout,
         BOOL bForceAppsClosed,
         BOOL bRebootAfterShutdown
    );
__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownW(
           LPWSTR lpMachineName,
           LPWSTR lpMessage,
         DWORD dwTimeout,
         BOOL bForceAppsClosed,
         BOOL bRebootAfterShutdown
    );




#line 911 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"


__declspec(dllimport)
BOOL
__stdcall
AbortSystemShutdownA(
           LPSTR lpMachineName
    );
__declspec(dllimport)
BOOL
__stdcall
AbortSystemShutdownW(
           LPWSTR lpMachineName
    );




#line 930 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"





#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\reason.h"



















































































































#line 117 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\reason.h"
#line 936 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"


















__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownExA(
           LPSTR lpMachineName,
           LPSTR lpMessage,
         DWORD dwTimeout,
         BOOL bForceAppsClosed,
         BOOL bRebootAfterShutdown,
         DWORD dwReason
    );
__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownExW(
           LPWSTR lpMachineName,
           LPWSTR lpMessage,
         DWORD dwTimeout,
         BOOL bForceAppsClosed,
         BOOL bRebootAfterShutdown,
         DWORD dwReason
    );




#line 981 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"


__declspec(dllimport)
LONG
__stdcall
RegSaveKeyExA (
         HKEY hKey,
         LPCSTR lpFile,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes,
         DWORD Flags
    );
__declspec(dllimport)
LONG
__stdcall
RegSaveKeyExW (
         HKEY hKey,
         LPCWSTR lpFile,
           LPSECURITY_ATTRIBUTES lpSecurityAttributes,
         DWORD Flags
    );




#line 1006 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
Wow64Win32ApiEntry (
         DWORD dwFuncNumber,
         DWORD dwFlag,
         DWORD dwRes
    );


}
#line 1019 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"


#line 1022 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winreg.h"

#line 174 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 175 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"



























extern "C" {
#line 30 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"










































































#line 105 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"






#line 112 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"









#line 122 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"













#line 136 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"



#line 140 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

typedef struct  _NETRESOURCEA {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPSTR    lpLocalName;
    LPSTR    lpRemoteName;
    LPSTR    lpComment ;
    LPSTR    lpProvider;
}NETRESOURCEA, *LPNETRESOURCEA;
typedef struct  _NETRESOURCEW {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPWSTR   lpLocalName;
    LPWSTR   lpRemoteName;
    LPWSTR   lpComment ;
    LPWSTR   lpProvider;
}NETRESOURCEW, *LPNETRESOURCEW;

typedef NETRESOURCEW NETRESOURCE;
typedef LPNETRESOURCEW LPNETRESOURCE;



#line 168 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"





















#line 190 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"



#line 194 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

DWORD __stdcall
WNetAddConnectionA(
      LPCSTR   lpRemoteName,
      LPCSTR   lpPassword,
      LPCSTR   lpLocalName
    );
DWORD __stdcall
WNetAddConnectionW(
      LPCWSTR   lpRemoteName,
      LPCWSTR   lpPassword,
      LPCWSTR   lpLocalName
    );




#line 212 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

DWORD __stdcall
WNetAddConnection2A(
      LPNETRESOURCEA lpNetResource,
      LPCSTR       lpPassword,
      LPCSTR       lpUserName,
      DWORD          dwFlags
    );
DWORD __stdcall
WNetAddConnection2W(
      LPNETRESOURCEW lpNetResource,
      LPCWSTR       lpPassword,
      LPCWSTR       lpUserName,
      DWORD          dwFlags
    );




#line 232 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

DWORD __stdcall
WNetAddConnection3A(
      HWND           hwndOwner,
      LPNETRESOURCEA lpNetResource,
      LPCSTR       lpPassword,
      LPCSTR       lpUserName,
      DWORD          dwFlags
    );
DWORD __stdcall
WNetAddConnection3W(
      HWND           hwndOwner,
      LPNETRESOURCEW lpNetResource,
      LPCWSTR       lpPassword,
      LPCWSTR       lpUserName,
      DWORD          dwFlags
    );




#line 254 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

DWORD __stdcall
WNetCancelConnectionA(
      LPCSTR lpName,
      BOOL     fForce
    );
DWORD __stdcall
WNetCancelConnectionW(
      LPCWSTR lpName,
      BOOL     fForce
    );




#line 270 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

DWORD __stdcall
WNetCancelConnection2A(
      LPCSTR lpName,
      DWORD    dwFlags,
      BOOL     fForce
    );
DWORD __stdcall
WNetCancelConnection2W(
      LPCWSTR lpName,
      DWORD    dwFlags,
      BOOL     fForce
    );




#line 288 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

DWORD __stdcall
WNetGetConnectionA(
      LPCSTR lpLocalName,
      LPSTR  lpRemoteName,
       LPDWORD  lpnLength
    );
DWORD __stdcall
WNetGetConnectionW(
      LPCWSTR lpLocalName,
      LPWSTR  lpRemoteName,
       LPDWORD  lpnLength
    );




#line 306 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"


DWORD __stdcall
WNetRestoreConnectionA(
     HWND     hwndParent,
     LPCSTR lpDevice
    );
DWORD __stdcall
WNetRestoreConnectionW(
     HWND     hwndParent,
     LPCWSTR lpDevice
    );




#line 323 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"



DWORD __stdcall
WNetUseConnectionA(
     HWND            hwndOwner,
     LPNETRESOURCEA  lpNetResource,
     LPCSTR        lpPassword,
     LPCSTR        lpUserID,
     DWORD           dwFlags,
     LPSTR        lpAccessName,
      LPDWORD     lpBufferSize,
     LPDWORD        lpResult
    );
DWORD __stdcall
WNetUseConnectionW(
     HWND            hwndOwner,
     LPNETRESOURCEW  lpNetResource,
     LPCWSTR        lpPassword,
     LPCWSTR        lpUserID,
     DWORD           dwFlags,
     LPWSTR        lpAccessName,
      LPDWORD     lpBufferSize,
     LPDWORD        lpResult
    );




#line 353 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"
#line 354 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"






DWORD __stdcall
WNetConnectionDialog(
     HWND  hwnd,
     DWORD dwType
    );

DWORD __stdcall
WNetDisconnectDialog(
     HWND  hwnd,
     DWORD dwType
    );


typedef struct _CONNECTDLGSTRUCTA{
    DWORD cbStructure;       
    HWND hwndOwner;          
    LPNETRESOURCEA lpConnRes;
    DWORD dwFlags;           
    DWORD dwDevNum;          
} CONNECTDLGSTRUCTA,  *LPCONNECTDLGSTRUCTA;
typedef struct _CONNECTDLGSTRUCTW{
    DWORD cbStructure;       
    HWND hwndOwner;          
    LPNETRESOURCEW lpConnRes;
    DWORD dwFlags;           
    DWORD dwDevNum;          
} CONNECTDLGSTRUCTW,  *LPCONNECTDLGSTRUCTW;

typedef CONNECTDLGSTRUCTW CONNECTDLGSTRUCT;
typedef LPCONNECTDLGSTRUCTW LPCONNECTDLGSTRUCT;



#line 394 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"














DWORD __stdcall
WNetConnectionDialog1A(
      LPCONNECTDLGSTRUCTA lpConnDlgStruct
    );
DWORD __stdcall
WNetConnectionDialog1W(
      LPCONNECTDLGSTRUCTW lpConnDlgStruct
    );




#line 421 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

typedef struct _DISCDLGSTRUCTA{
    DWORD           cbStructure;      
    HWND            hwndOwner;        
    LPSTR           lpLocalName;      
    LPSTR           lpRemoteName;     
    DWORD           dwFlags;          
} DISCDLGSTRUCTA,  *LPDISCDLGSTRUCTA;
typedef struct _DISCDLGSTRUCTW{
    DWORD           cbStructure;      
    HWND            hwndOwner;        
    LPWSTR          lpLocalName;      
    LPWSTR          lpRemoteName;     
    DWORD           dwFlags;          
} DISCDLGSTRUCTW,  *LPDISCDLGSTRUCTW;

typedef DISCDLGSTRUCTW DISCDLGSTRUCT;
typedef LPDISCDLGSTRUCTW LPDISCDLGSTRUCT;



#line 443 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"




DWORD __stdcall
WNetDisconnectDialog1A(
     LPDISCDLGSTRUCTA lpConnDlgStruct
    );
DWORD __stdcall
WNetDisconnectDialog1W(
     LPDISCDLGSTRUCTW lpConnDlgStruct
    );




#line 460 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"
#line 461 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"





DWORD __stdcall
WNetOpenEnumA(
      DWORD          dwScope,
      DWORD          dwType,
      DWORD          dwUsage,
      LPNETRESOURCEA lpNetResource,
      LPHANDLE       lphEnum
    );
DWORD __stdcall
WNetOpenEnumW(
      DWORD          dwScope,
      DWORD          dwType,
      DWORD          dwUsage,
      LPNETRESOURCEW lpNetResource,
      LPHANDLE       lphEnum
    );




#line 487 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

DWORD __stdcall
WNetEnumResourceA(
      HANDLE  hEnum,
       LPDWORD lpcCount,
      LPVOID  lpBuffer,
       LPDWORD lpBufferSize
    );
DWORD __stdcall
WNetEnumResourceW(
      HANDLE  hEnum,
       LPDWORD lpcCount,
      LPVOID  lpBuffer,
       LPDWORD lpBufferSize
    );




#line 507 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

DWORD __stdcall
WNetCloseEnum(
     HANDLE   hEnum
    );


DWORD __stdcall
WNetGetResourceParentA(
     LPNETRESOURCEA lpNetResource,
     LPVOID lpBuffer,
      LPDWORD lpcbBuffer
    );
DWORD __stdcall
WNetGetResourceParentW(
     LPNETRESOURCEW lpNetResource,
     LPVOID lpBuffer,
      LPDWORD lpcbBuffer
    );




#line 531 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

DWORD __stdcall
WNetGetResourceInformationA(
     LPNETRESOURCEA  lpNetResource,
     LPVOID          lpBuffer,
      LPDWORD         lpcbBuffer,
     LPSTR         *lplpSystem
    );
DWORD __stdcall
WNetGetResourceInformationW(
     LPNETRESOURCEW  lpNetResource,
     LPVOID          lpBuffer,
      LPDWORD         lpcbBuffer,
     LPWSTR         *lplpSystem
    );




#line 551 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"
#line 552 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"








typedef struct  _UNIVERSAL_NAME_INFOA {
    LPSTR    lpUniversalName;
}UNIVERSAL_NAME_INFOA, *LPUNIVERSAL_NAME_INFOA;
typedef struct  _UNIVERSAL_NAME_INFOW {
    LPWSTR   lpUniversalName;
}UNIVERSAL_NAME_INFOW, *LPUNIVERSAL_NAME_INFOW;

typedef UNIVERSAL_NAME_INFOW UNIVERSAL_NAME_INFO;
typedef LPUNIVERSAL_NAME_INFOW LPUNIVERSAL_NAME_INFO;



#line 573 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

typedef struct  _REMOTE_NAME_INFOA {
    LPSTR    lpUniversalName;
    LPSTR    lpConnectionName;
    LPSTR    lpRemainingPath;
}REMOTE_NAME_INFOA, *LPREMOTE_NAME_INFOA;
typedef struct  _REMOTE_NAME_INFOW {
    LPWSTR   lpUniversalName;
    LPWSTR   lpConnectionName;
    LPWSTR   lpRemainingPath;
}REMOTE_NAME_INFOW, *LPREMOTE_NAME_INFOW;

typedef REMOTE_NAME_INFOW REMOTE_NAME_INFO;
typedef LPREMOTE_NAME_INFOW LPREMOTE_NAME_INFO;



#line 591 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

DWORD __stdcall
WNetGetUniversalNameA(
      LPCSTR lpLocalPath,
      DWORD    dwInfoLevel,
      LPVOID   lpBuffer,
       LPDWORD  lpBufferSize
     );
DWORD __stdcall
WNetGetUniversalNameW(
      LPCWSTR lpLocalPath,
      DWORD    dwInfoLevel,
      LPVOID   lpBuffer,
       LPDWORD  lpBufferSize
     );




#line 611 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"





DWORD __stdcall
WNetGetUserA(
      LPCSTR  lpName,
      LPSTR   lpUserName,
       LPDWORD   lpnLength
    );
DWORD __stdcall
WNetGetUserW(
      LPCWSTR  lpName,
      LPWSTR   lpUserName,
       LPDWORD   lpnLength
    );




#line 633 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"











#line 645 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"



DWORD __stdcall
WNetGetProviderNameA(
     DWORD   dwNetType,
     LPSTR lpProviderName,
      LPDWORD lpBufferSize
    );
DWORD __stdcall
WNetGetProviderNameW(
     DWORD   dwNetType,
     LPWSTR lpProviderName,
      LPDWORD lpBufferSize
    );




#line 665 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

typedef struct _NETINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwProviderVersion;
    DWORD dwStatus;
    DWORD dwCharacteristics;
    ULONG_PTR dwHandle;
    WORD  wNetType;
    DWORD dwPrinters;
    DWORD dwDrives;
} NETINFOSTRUCT,  *LPNETINFOSTRUCT;





DWORD __stdcall
WNetGetNetworkInformationA(
     LPCSTR          lpProvider,
     LPNETINFOSTRUCT   lpNetInfoStruct
    );
DWORD __stdcall
WNetGetNetworkInformationW(
     LPCWSTR          lpProvider,
     LPNETINFOSTRUCT   lpNetInfoStruct
    );




#line 696 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"





typedef UINT ( __stdcall *PFNGETPROFILEPATHA) (
    LPCSTR    pszUsername,
    LPSTR     pszBuffer,
    UINT        cbBuffer
    );
typedef UINT ( __stdcall *PFNGETPROFILEPATHW) (
    LPCWSTR    pszUsername,
    LPWSTR     pszBuffer,
    UINT        cbBuffer
    );




#line 716 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

typedef UINT ( __stdcall *PFNRECONCILEPROFILEA) (
    LPCSTR    pszCentralFile,
    LPCSTR    pszLocalFile,
    DWORD       dwFlags
    );
typedef UINT ( __stdcall *PFNRECONCILEPROFILEW) (
    LPCWSTR    pszCentralFile,
    LPCWSTR    pszLocalFile,
    DWORD       dwFlags
    );




#line 732 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"









typedef BOOL ( __stdcall *PFNPROCESSPOLICIESA) (
    HWND        hwnd,
    LPCSTR    pszPath,
    LPCSTR    pszUsername,
    LPCSTR    pszComputerName,
    DWORD       dwFlags
    );
typedef BOOL ( __stdcall *PFNPROCESSPOLICIESW) (
    HWND        hwnd,
    LPCWSTR    pszPath,
    LPCWSTR    pszUsername,
    LPCWSTR    pszComputerName,
    DWORD       dwFlags
    );




#line 760 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"


#line 763 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"





DWORD __stdcall
WNetGetLastErrorA(
      LPDWORD    lpError,
      LPSTR    lpErrorBuf,
      DWORD      nErrorBufSize,
      LPSTR    lpNameBuf,
      DWORD      nNameBufSize
    );
DWORD __stdcall
WNetGetLastErrorW(
      LPDWORD    lpError,
      LPWSTR    lpErrorBuf,
      DWORD      nErrorBufSize,
      LPWSTR    lpNameBuf,
      DWORD      nNameBufSize
    );




#line 789 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"





























#line 819 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"




















#line 840 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"












#line 853 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"






typedef struct _NETCONNECTINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwFlags;
    DWORD dwSpeed;
    DWORD dwDelay;
    DWORD dwOptDataSize;
} NETCONNECTINFOSTRUCT,  *LPNETCONNECTINFOSTRUCT;






DWORD __stdcall
MultinetGetConnectionPerformanceA(
         LPNETRESOURCEA lpNetResource,
         LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
        );
DWORD __stdcall
MultinetGetConnectionPerformanceW(
         LPNETRESOURCEW lpNetResource,
         LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
        );




#line 887 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"
#line 888 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"


}
#line 892 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

#line 894 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winnetwk.h"

#line 177 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 178 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"




































#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"





















































#line 55 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"
#line 56 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"




#line 61 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"

#line 63 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"
#line 64 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"


extern "C" {
#line 68 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"



















#line 88 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"


__inline
PUWSTR
static
__declspec(deprecated)
ua_wcscpy(
     PUWSTR  Destination,
     PCUWSTR Source
    )
{
#pragma warning(push)
#pragma warning(disable:4996)
    return wcscpy(Destination, Source);
#pragma warning(pop)
}
































































































































































































































































































































































#line 457 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"






































































#line 528 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"




































#line 565 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"











































#line 609 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"



#line 613 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"












#line 626 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"














#line 641 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"


}
#line 645 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"


#line 648 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\stralign.h"

    

                                         



                                                      
#line 215 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"












#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"






























#line 32 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"


extern "C" {
#line 36 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"




































#line 73 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"


















































































































typedef struct _SERVICE_DESCRIPTIONA {
    LPSTR       lpDescription;
} SERVICE_DESCRIPTIONA, *LPSERVICE_DESCRIPTIONA;



typedef struct _SERVICE_DESCRIPTIONW {
    LPWSTR      lpDescription;
} SERVICE_DESCRIPTIONW, *LPSERVICE_DESCRIPTIONW;

typedef SERVICE_DESCRIPTIONW SERVICE_DESCRIPTION;
typedef LPSERVICE_DESCRIPTIONW LPSERVICE_DESCRIPTION;



#line 203 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"




typedef enum _SC_ACTION_TYPE {
        SC_ACTION_NONE          = 0,
        SC_ACTION_RESTART       = 1,
        SC_ACTION_REBOOT        = 2,
        SC_ACTION_RUN_COMMAND   = 3
} SC_ACTION_TYPE;

typedef struct _SC_ACTION {
    SC_ACTION_TYPE  Type;
    DWORD           Delay;
} SC_ACTION, *LPSC_ACTION;

typedef struct _SERVICE_FAILURE_ACTIONSA {
    DWORD       dwResetPeriod;
    LPSTR       lpRebootMsg;
    LPSTR       lpCommand;
    DWORD       cActions;



    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSA, *LPSERVICE_FAILURE_ACTIONSA;
typedef struct _SERVICE_FAILURE_ACTIONSW {
    DWORD       dwResetPeriod;
    LPWSTR      lpRebootMsg;
    LPWSTR      lpCommand;
    DWORD       cActions;



    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSW, *LPSERVICE_FAILURE_ACTIONSW;

typedef SERVICE_FAILURE_ACTIONSW SERVICE_FAILURE_ACTIONS;
typedef LPSERVICE_FAILURE_ACTIONSW LPSERVICE_FAILURE_ACTIONS;



#line 246 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"






struct SC_HANDLE__ { int unused; }; typedef struct SC_HANDLE__ *SC_HANDLE;
typedef SC_HANDLE   *LPSC_HANDLE;

struct SERVICE_STATUS_HANDLE__ { int unused; }; typedef struct SERVICE_STATUS_HANDLE__ *SERVICE_STATUS_HANDLE;





typedef enum _SC_STATUS_TYPE {
        SC_STATUS_PROCESS_INFO      = 0
} SC_STATUS_TYPE;




typedef enum _SC_ENUM_TYPE {
        SC_ENUM_PROCESS_INFO        = 0
} SC_ENUM_TYPE;






typedef struct _SERVICE_STATUS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;

typedef struct _SERVICE_STATUS_PROCESS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
    DWORD   dwProcessId;
    DWORD   dwServiceFlags;
} SERVICE_STATUS_PROCESS, *LPSERVICE_STATUS_PROCESS;






typedef struct _ENUM_SERVICE_STATUSA {
    LPSTR             lpServiceName;
    LPSTR             lpDisplayName;
    SERVICE_STATUS    ServiceStatus;
} ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;
typedef struct _ENUM_SERVICE_STATUSW {
    LPWSTR            lpServiceName;
    LPWSTR            lpDisplayName;
    SERVICE_STATUS    ServiceStatus;
} ENUM_SERVICE_STATUSW, *LPENUM_SERVICE_STATUSW;

typedef ENUM_SERVICE_STATUSW ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSW LPENUM_SERVICE_STATUS;



#line 321 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"

typedef struct _ENUM_SERVICE_STATUS_PROCESSA {
    LPSTR                     lpServiceName;
    LPSTR                     lpDisplayName;
    SERVICE_STATUS_PROCESS    ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSA, *LPENUM_SERVICE_STATUS_PROCESSA;
typedef struct _ENUM_SERVICE_STATUS_PROCESSW {
    LPWSTR                    lpServiceName;
    LPWSTR                    lpDisplayName;
    SERVICE_STATUS_PROCESS    ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSW, *LPENUM_SERVICE_STATUS_PROCESSW;

typedef ENUM_SERVICE_STATUS_PROCESSW ENUM_SERVICE_STATUS_PROCESS;
typedef LPENUM_SERVICE_STATUS_PROCESSW LPENUM_SERVICE_STATUS_PROCESS;



#line 339 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"





typedef LPVOID  SC_LOCK;

typedef struct _QUERY_SERVICE_LOCK_STATUSA {
    DWORD   fIsLocked;
    LPSTR   lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSA, *LPQUERY_SERVICE_LOCK_STATUSA;
typedef struct _QUERY_SERVICE_LOCK_STATUSW {
    DWORD   fIsLocked;
    LPWSTR  lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSW, *LPQUERY_SERVICE_LOCK_STATUSW;

typedef QUERY_SERVICE_LOCK_STATUSW QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSW LPQUERY_SERVICE_LOCK_STATUS;



#line 363 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"







typedef struct _QUERY_SERVICE_CONFIGA {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPSTR   lpBinaryPathName;
    LPSTR   lpLoadOrderGroup;
    DWORD   dwTagId;
    LPSTR   lpDependencies;
    LPSTR   lpServiceStartName;
    LPSTR   lpDisplayName;
} QUERY_SERVICE_CONFIGA, *LPQUERY_SERVICE_CONFIGA;
typedef struct _QUERY_SERVICE_CONFIGW {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPWSTR  lpBinaryPathName;
    LPWSTR  lpLoadOrderGroup;
    DWORD   dwTagId;
    LPWSTR  lpDependencies;
    LPWSTR  lpServiceStartName;
    LPWSTR  lpDisplayName;
} QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW;

typedef QUERY_SERVICE_CONFIGW QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGW LPQUERY_SERVICE_CONFIG;



#line 399 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"







typedef void (__stdcall *LPSERVICE_MAIN_FUNCTIONW)(
    DWORD   dwNumServicesArgs,
    LPWSTR  *lpServiceArgVectors
    );

typedef void (__stdcall *LPSERVICE_MAIN_FUNCTIONA)(
    DWORD   dwNumServicesArgs,
    LPSTR   *lpServiceArgVectors
    );





#line 421 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"






typedef struct _SERVICE_TABLE_ENTRYA {
    LPSTR                       lpServiceName;
    LPSERVICE_MAIN_FUNCTIONA    lpServiceProc;
}SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA;
typedef struct _SERVICE_TABLE_ENTRYW {
    LPWSTR                      lpServiceName;
    LPSERVICE_MAIN_FUNCTIONW    lpServiceProc;
}SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;

typedef SERVICE_TABLE_ENTRYW SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYW LPSERVICE_TABLE_ENTRY;



#line 442 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"





typedef void (__stdcall *LPHANDLER_FUNCTION)(
    DWORD    dwControl
    );

typedef DWORD (__stdcall *LPHANDLER_FUNCTION_EX)(
    DWORD    dwControl,
    DWORD    dwEventType,
    LPVOID   lpEventData,
    LPVOID   lpContext
    );






__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfigA(
                SC_HANDLE    hService,
                DWORD        dwServiceType,
                DWORD        dwStartType,
                DWORD        dwErrorControl,
              LPCSTR     lpBinaryPathName,
              LPCSTR     lpLoadOrderGroup,
             LPDWORD      lpdwTagId,
              LPCSTR     lpDependencies,
              LPCSTR     lpServiceStartName,
              LPCSTR     lpPassword,
              LPCSTR     lpDisplayName
    );
__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfigW(
                SC_HANDLE    hService,
                DWORD        dwServiceType,
                DWORD        dwStartType,
                DWORD        dwErrorControl,
              LPCWSTR     lpBinaryPathName,
              LPCWSTR     lpLoadOrderGroup,
             LPDWORD      lpdwTagId,
              LPCWSTR     lpDependencies,
              LPCWSTR     lpServiceStartName,
              LPCWSTR     lpPassword,
              LPCWSTR     lpDisplayName
    );




#line 500 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfig2A(
                SC_HANDLE    hService,
                DWORD        dwInfoLevel,
              LPVOID       lpInfo
    );
__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfig2W(
                SC_HANDLE    hService,
                DWORD        dwInfoLevel,
              LPVOID       lpInfo
    );




#line 522 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
CloseServiceHandle(
                SC_HANDLE   hSCObject
    );

__declspec(dllimport)
BOOL
__stdcall
ControlService(
                SC_HANDLE           hService,
                DWORD               dwControl,
               LPSERVICE_STATUS    lpServiceStatus
    );


__declspec(dllimport)
SC_HANDLE
__stdcall
CreateServiceA(
                SC_HANDLE    hSCManager,
                LPCSTR     lpServiceName,
              LPCSTR     lpDisplayName,
                DWORD        dwDesiredAccess,
                DWORD        dwServiceType,
                DWORD        dwStartType,
                DWORD        dwErrorControl,
              LPCSTR     lpBinaryPathName,
              LPCSTR     lpLoadOrderGroup,
             LPDWORD      lpdwTagId,
              LPCSTR     lpDependencies,
              LPCSTR     lpServiceStartName,
              LPCSTR     lpPassword
    );

__declspec(dllimport)
SC_HANDLE
__stdcall
CreateServiceW(
                SC_HANDLE    hSCManager,
                LPCWSTR     lpServiceName,
              LPCWSTR     lpDisplayName,
                DWORD        dwDesiredAccess,
                DWORD        dwServiceType,
                DWORD        dwStartType,
                DWORD        dwErrorControl,
              LPCWSTR     lpBinaryPathName,
              LPCWSTR     lpLoadOrderGroup,
             LPDWORD      lpdwTagId,
              LPCWSTR     lpDependencies,
              LPCWSTR     lpServiceStartName,
              LPCWSTR     lpPassword
    );




#line 582 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
DeleteService(
                SC_HANDLE   hService
    );


__declspec(dllimport)
BOOL
__stdcall
EnumDependentServicesA(
                    SC_HANDLE               hService,
                    DWORD                   dwServiceState,
               
                    LPENUM_SERVICE_STATUSA  lpServices,
                    DWORD                   cbBufSize,
                   LPDWORD                 pcbBytesNeeded,
                   LPDWORD                 lpServicesReturned
    );

__declspec(dllimport)
BOOL
__stdcall
EnumDependentServicesW(
                    SC_HANDLE               hService,
                    DWORD                   dwServiceState,
               
                    LPENUM_SERVICE_STATUSW  lpServices,
                    DWORD                   cbBufSize,
                   LPDWORD                 pcbBytesNeeded,
                   LPDWORD                 lpServicesReturned
    );




#line 621 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"


__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusA(
                    SC_HANDLE               hSCManager,
                    DWORD                   dwServiceType,
                    DWORD                   dwServiceState,
          
                    LPENUM_SERVICE_STATUSA  lpServices,
                    DWORD                   cbBufSize,
                   LPDWORD                 pcbBytesNeeded,
                   LPDWORD                 lpServicesReturned,
               LPDWORD                 lpResumeHandle
    );

__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusW(
                    SC_HANDLE               hSCManager,
                    DWORD                   dwServiceType,
                    DWORD                   dwServiceState,
          
                    LPENUM_SERVICE_STATUSW  lpServices,
                    DWORD                   cbBufSize,
                   LPDWORD                 pcbBytesNeeded,
                   LPDWORD                 lpServicesReturned,
               LPDWORD                 lpResumeHandle
    );




#line 657 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"


__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusExA(
                    SC_HANDLE               hSCManager,
                    SC_ENUM_TYPE            InfoLevel,
                    DWORD                   dwServiceType,
                    DWORD                   dwServiceState,
           
                    LPBYTE                  lpServices,
                    DWORD                   cbBufSize,
                   LPDWORD                 pcbBytesNeeded,
                   LPDWORD                 lpServicesReturned,
               LPDWORD                 lpResumeHandle,
                  LPCSTR                pszGroupName
    );

__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusExW(
                    SC_HANDLE               hSCManager,
                    SC_ENUM_TYPE            InfoLevel,
                    DWORD                   dwServiceType,
                    DWORD                   dwServiceState,
           
                    LPBYTE                  lpServices,
                    DWORD                   cbBufSize,
                   LPDWORD                 pcbBytesNeeded,
                   LPDWORD                 lpServicesReturned,
               LPDWORD                 lpResumeHandle,
                  LPCWSTR                pszGroupName
    );




#line 697 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"


__declspec(dllimport)
BOOL
__stdcall
GetServiceKeyNameA(
                    SC_HANDLE               hSCManager,
                    LPCSTR                lpDisplayName,
          
                    LPSTR                 lpServiceName,
                 LPDWORD                 lpcchBuffer
    );

__declspec(dllimport)
BOOL
__stdcall
GetServiceKeyNameW(
                    SC_HANDLE               hSCManager,
                    LPCWSTR                lpDisplayName,
          
                    LPWSTR                 lpServiceName,
                 LPDWORD                 lpcchBuffer
    );




#line 725 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"


__declspec(dllimport)
BOOL
__stdcall
GetServiceDisplayNameA(
                    SC_HANDLE               hSCManager,
                    LPCSTR                lpServiceName,
           
                    LPSTR                 lpDisplayName,
                 LPDWORD                 lpcchBuffer
    );

__declspec(dllimport)
BOOL
__stdcall
GetServiceDisplayNameW(
                    SC_HANDLE               hSCManager,
                    LPCWSTR                lpServiceName,
           
                    LPWSTR                 lpDisplayName,
                 LPDWORD                 lpcchBuffer
    );




#line 753 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"

__declspec(dllimport)
SC_LOCK
__stdcall
LockServiceDatabase(
                    SC_HANDLE               hSCManager
    );

__declspec(dllimport)
BOOL
__stdcall
NotifyBootConfigStatus(
                    BOOL                    BootAcceptable
    );


__declspec(dllimport)
SC_HANDLE
__stdcall
OpenSCManagerA(
                  LPCSTR                lpMachineName,
                  LPCSTR                lpDatabaseName,
                    DWORD                   dwDesiredAccess
    );

__declspec(dllimport)
SC_HANDLE
__stdcall
OpenSCManagerW(
                  LPCWSTR                lpMachineName,
                  LPCWSTR                lpDatabaseName,
                    DWORD                   dwDesiredAccess
    );




#line 791 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"


__declspec(dllimport)
SC_HANDLE
__stdcall
OpenServiceA(
                    SC_HANDLE               hSCManager,
                    LPCSTR                lpServiceName,
                    DWORD                   dwDesiredAccess
    );

__declspec(dllimport)
SC_HANDLE
__stdcall
OpenServiceW(
                    SC_HANDLE               hSCManager,
                    LPCWSTR                lpServiceName,
                    DWORD                   dwDesiredAccess
    );




#line 815 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"


__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfigA(
                    SC_HANDLE               hService,
                
                    LPQUERY_SERVICE_CONFIGA lpServiceConfig,
                    DWORD                   cbBufSize,
                   LPDWORD                 pcbBytesNeeded
    );

__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfigW(
                    SC_HANDLE               hService,
                
                    LPQUERY_SERVICE_CONFIGW lpServiceConfig,
                    DWORD                   cbBufSize,
                   LPDWORD                 pcbBytesNeeded
    );




#line 843 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"


__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfig2A(
                    SC_HANDLE               hService,
                    DWORD                   dwInfoLevel,
           
                    LPBYTE                  lpBuffer,
                    DWORD                   cbBufSize,
                   LPDWORD                 pcbBytesNeeded
    );

__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfig2W(
                    SC_HANDLE               hService,
                    DWORD                   dwInfoLevel,
           
                    LPBYTE                  lpBuffer,
                    DWORD                   cbBufSize,
                   LPDWORD                 pcbBytesNeeded
    );




#line 873 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"


__declspec(dllimport)
BOOL
__stdcall
QueryServiceLockStatusA(
                    SC_HANDLE                       hSCManager,
           
                    LPQUERY_SERVICE_LOCK_STATUSA    lpLockStatus,
                    DWORD                           cbBufSize,
                   LPDWORD                         pcbBytesNeeded
    );

__declspec(dllimport)
BOOL
__stdcall
QueryServiceLockStatusW(
                    SC_HANDLE                       hSCManager,
           
                    LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
                    DWORD                           cbBufSize,
                   LPDWORD                         pcbBytesNeeded
    );




#line 901 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"


__declspec(dllimport)
BOOL
__stdcall
QueryServiceObjectSecurity(
                    SC_HANDLE               hService,
                    SECURITY_INFORMATION    dwSecurityInformation,
           
                    PSECURITY_DESCRIPTOR    lpSecurityDescriptor,
                    DWORD                   cbBufSize,
                   LPDWORD                 pcbBytesNeeded
    );


__declspec(dllimport)
BOOL
__stdcall
QueryServiceStatus(
                    SC_HANDLE           hService,
                   LPSERVICE_STATUS    lpServiceStatus
    );


__declspec(dllimport)
BOOL
__stdcall
QueryServiceStatusEx(
                    SC_HANDLE           hService,
                    SC_STATUS_TYPE      InfoLevel,
           
                    LPBYTE              lpBuffer,
                    DWORD               cbBufSize,
                   LPDWORD             pcbBytesNeeded
    );


__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerA(
            LPCSTR                    lpServiceName,
              
            LPHANDLER_FUNCTION          lpHandlerProc
    );

__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerW(
            LPCWSTR                    lpServiceName,
              
            LPHANDLER_FUNCTION          lpHandlerProc
    );




#line 960 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"


__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerExA(
            LPCSTR                    lpServiceName,
            
            LPHANDLER_FUNCTION_EX       lpHandlerProc,
           LPVOID                     lpContext
    );

__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerExW(
            LPCWSTR                    lpServiceName,
            
            LPHANDLER_FUNCTION_EX       lpHandlerProc,
           LPVOID                     lpContext
    );




#line 986 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
SetServiceObjectSecurity(
                SC_HANDLE               hService,
                SECURITY_INFORMATION    dwSecurityInformation,
                PSECURITY_DESCRIPTOR    lpSecurityDescriptor
    );

__declspec(dllimport)
BOOL
__stdcall
SetServiceStatus(
                SERVICE_STATUS_HANDLE   hServiceStatus,
                LPSERVICE_STATUS        lpServiceStatus
    );

__declspec(dllimport)
BOOL
__stdcall
StartServiceCtrlDispatcherA(
         const  SERVICE_TABLE_ENTRYA    *lpServiceStartTable
    );
__declspec(dllimport)
BOOL
__stdcall
StartServiceCtrlDispatcherW(
         const  SERVICE_TABLE_ENTRYW    *lpServiceStartTable
    );




#line 1021 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"


__declspec(dllimport)
BOOL
__stdcall
StartServiceA(
                    SC_HANDLE            hService,
                    DWORD                dwNumServiceArgs,
                   
                    LPCSTR             *lpServiceArgVectors
    );
__declspec(dllimport)
BOOL
__stdcall
StartServiceW(
                    SC_HANDLE            hService,
                    DWORD                dwNumServiceArgs,
                   
                    LPCWSTR             *lpServiceArgVectors
    );




#line 1046 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
UnlockServiceDatabase(
                    SC_LOCK             ScLock
    );



}
#line 1058 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"

#line 1060 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winsvc.h"

#line 228 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 229 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\mcx.h"












#pragma once
#line 15 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\mcx.h"

typedef struct _MODEMDEVCAPS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    
    DWORD   dwModemProviderVersion;
    DWORD   dwModemManufacturerOffset;
    DWORD   dwModemManufacturerSize;
    DWORD   dwModemModelOffset;
    DWORD   dwModemModelSize;
    DWORD   dwModemVersionOffset;
    DWORD   dwModemVersionSize;

    
    DWORD   dwDialOptions;          
    DWORD   dwCallSetupFailTimer;   
    DWORD   dwInactivityTimeout;    
    DWORD   dwSpeakerVolume;        
    DWORD   dwSpeakerMode;          
    DWORD   dwModemOptions;         
    DWORD   dwMaxDTERate;           
    DWORD   dwMaxDCERate;           

    
    BYTE    abVariablePortion [1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;

typedef struct _MODEMSETTINGS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    
    DWORD   dwCallSetupFailTimer;       
    DWORD   dwInactivityTimeout;        
    DWORD   dwSpeakerVolume;            
    DWORD   dwSpeakerMode;              
    DWORD   dwPreferredModemOptions;    

    
    DWORD   dwNegotiatedModemOptions;   
    DWORD   dwNegotiatedDCERate;        

    
    BYTE    abVariablePortion [1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;

















































































































































































































































































































































































































































































































































































































































































#line 723 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\mcx.h"
#line 233 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 234 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"


#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"











extern "C" {
#line 14 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"






struct HIMC__ { int unused; }; typedef struct HIMC__ *HIMC;
struct HIMCC__ { int unused; }; typedef struct HIMCC__ *HIMCC;



#line 26 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

typedef HKL   *LPHKL;
typedef UINT  *LPUINT;

typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM,  *NPCOMPOSITIONFORM,  *LPCOMPOSITIONFORM;


typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM,  *NPCANDIDATEFORM,  *LPCANDIDATEFORM;


typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST,  *NPCANDIDATELIST,  *LPCANDIDATELIST;

typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA,  *NPREGISTERWORDA,  *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW,  *NPREGISTERWORDW,  *LPREGISTERWORDW;

typedef REGISTERWORDW REGISTERWORD;
typedef PREGISTERWORDW PREGISTERWORD;
typedef NPREGISTERWORDW NPREGISTERWORD;
typedef LPREGISTERWORDW LPREGISTERWORD;





#line 74 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"



typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING,  *NPRECONVERTSTRING,  *LPRECONVERTSTRING;

#line 89 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"



typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[32];
} STYLEBUFA, *PSTYLEBUFA,  *NPSTYLEBUFA,  *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[32];
} STYLEBUFW, *PSTYLEBUFW,  *NPSTYLEBUFW,  *LPSTYLEBUFW;

typedef STYLEBUFW STYLEBUF;
typedef PSTYLEBUFW PSTYLEBUF;
typedef NPSTYLEBUFW NPSTYLEBUF;
typedef LPSTYLEBUFW LPSTYLEBUF;





#line 111 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"






typedef struct tagIMEMENUITEMINFOA {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    CHAR        szString[80];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA,  *NPIMEMENUITEMINFOA,  *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    WCHAR       szString[80];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW,  *NPIMEMENUITEMINFOW,  *LPIMEMENUITEMINFOW;

typedef IMEMENUITEMINFOW IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOW PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOW NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOW LPIMEMENUITEMINFO;





#line 150 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

typedef struct tagIMECHARPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION,  *NPIMECHARPOSITION,  *LPIMECHARPOSITION;

typedef BOOL    (__stdcall* IMCENUMPROC)(HIMC, LPARAM);

#line 162 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"





HKL  __stdcall ImmInstallIMEA( LPCSTR lpszIMEFileName,  LPCSTR lpszLayoutText);
HKL  __stdcall ImmInstallIMEW( LPCWSTR lpszIMEFileName,  LPCWSTR lpszLayoutText);




#line 174 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

HWND __stdcall ImmGetDefaultIMEWnd( HWND);

UINT __stdcall ImmGetDescriptionA( HKL,  LPSTR,  UINT uBufLen);
UINT __stdcall ImmGetDescriptionW( HKL,  LPWSTR,  UINT uBufLen);




#line 184 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

UINT __stdcall ImmGetIMEFileNameA( HKL,  LPSTR,  UINT uBufLen);
UINT __stdcall ImmGetIMEFileNameW( HKL,  LPWSTR,  UINT uBufLen);




#line 192 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

DWORD __stdcall ImmGetProperty( HKL,  DWORD);

BOOL __stdcall ImmIsIME( HKL);

BOOL __stdcall ImmSimulateHotKey( HWND,  DWORD);

HIMC __stdcall ImmCreateContext(void);
BOOL __stdcall ImmDestroyContext( HIMC);
HIMC __stdcall ImmGetContext( HWND);
BOOL __stdcall ImmReleaseContext( HWND,  HIMC);
HIMC __stdcall ImmAssociateContext( HWND,  HIMC);

BOOL __stdcall ImmAssociateContextEx( HWND,  HIMC,  DWORD);
#line 207 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

LONG  __stdcall ImmGetCompositionStringA( HIMC,  DWORD,  LPVOID,  DWORD);
LONG  __stdcall ImmGetCompositionStringW( HIMC,  DWORD,  LPVOID,  DWORD);




#line 215 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

BOOL  __stdcall ImmSetCompositionStringA( HIMC,  DWORD dwIndex,  LPVOID lpComp,  DWORD,  LPVOID lpRead,  DWORD);
BOOL  __stdcall ImmSetCompositionStringW( HIMC,  DWORD dwIndex,  LPVOID lpComp,  DWORD,  LPVOID lpRead,  DWORD);




#line 223 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

DWORD __stdcall ImmGetCandidateListCountA( HIMC,  LPDWORD lpdwListCount);
DWORD __stdcall ImmGetCandidateListCountW( HIMC,  LPDWORD lpdwListCount);




#line 231 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

DWORD __stdcall ImmGetCandidateListA( HIMC,  DWORD deIndex,  LPCANDIDATELIST,  DWORD dwBufLen);
DWORD __stdcall ImmGetCandidateListW( HIMC,  DWORD deIndex,  LPCANDIDATELIST,  DWORD dwBufLen);




#line 239 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

DWORD __stdcall ImmGetGuideLineA( HIMC,  DWORD dwIndex,  LPSTR,  DWORD dwBufLen);
DWORD __stdcall ImmGetGuideLineW( HIMC,  DWORD dwIndex,  LPWSTR,  DWORD dwBufLen);




#line 247 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

BOOL __stdcall ImmGetConversionStatus( HIMC,  LPDWORD,  LPDWORD);
BOOL __stdcall ImmSetConversionStatus( HIMC,  DWORD,  DWORD);
BOOL __stdcall ImmGetOpenStatus( HIMC);
BOOL __stdcall ImmSetOpenStatus( HIMC,  BOOL);


BOOL __stdcall ImmGetCompositionFontA( HIMC,  LPLOGFONTA);
BOOL __stdcall ImmGetCompositionFontW( HIMC,  LPLOGFONTW);




#line 261 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

BOOL __stdcall ImmSetCompositionFontA( HIMC,  LPLOGFONTA);
BOOL __stdcall ImmSetCompositionFontW( HIMC,  LPLOGFONTW);




#line 269 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"
#line 270 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

BOOL    __stdcall ImmConfigureIMEA( HKL,  HWND,  DWORD,  LPVOID);
BOOL    __stdcall ImmConfigureIMEW( HKL,  HWND,  DWORD,  LPVOID);




#line 278 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

LRESULT __stdcall ImmEscapeA( HKL,  HIMC,  UINT,  LPVOID);
LRESULT __stdcall ImmEscapeW( HKL,  HIMC,  UINT,  LPVOID);




#line 286 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

DWORD   __stdcall ImmGetConversionListA( HKL,  HIMC,  LPCSTR,  LPCANDIDATELIST,  DWORD dwBufLen,  UINT uFlag);
DWORD   __stdcall ImmGetConversionListW( HKL,  HIMC,  LPCWSTR,  LPCANDIDATELIST,  DWORD dwBufLen,  UINT uFlag);




#line 294 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

BOOL    __stdcall ImmNotifyIME( HIMC,  DWORD dwAction,  DWORD dwIndex,  DWORD dwValue);

BOOL __stdcall ImmGetStatusWindowPos( HIMC,  LPPOINT);
BOOL __stdcall ImmSetStatusWindowPos( HIMC,  LPPOINT);
BOOL __stdcall ImmGetCompositionWindow( HIMC,  LPCOMPOSITIONFORM);
BOOL __stdcall ImmSetCompositionWindow( HIMC,  LPCOMPOSITIONFORM);
BOOL __stdcall ImmGetCandidateWindow( HIMC,  DWORD,  LPCANDIDATEFORM);
BOOL __stdcall ImmSetCandidateWindow( HIMC,  LPCANDIDATEFORM);

BOOL __stdcall ImmIsUIMessageA( HWND,  UINT,  WPARAM,  LPARAM);
BOOL __stdcall ImmIsUIMessageW( HWND,  UINT,  WPARAM,  LPARAM);




#line 311 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"


UINT __stdcall ImmGetVirtualKey( HWND);

typedef int (__stdcall *REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID);
typedef int (__stdcall *REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID);




#line 322 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

BOOL __stdcall ImmRegisterWordA( HKL,  LPCSTR lpszReading,  DWORD,  LPCSTR lpszRegister);
BOOL __stdcall ImmRegisterWordW( HKL,  LPCWSTR lpszReading,  DWORD,  LPCWSTR lpszRegister);




#line 330 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

BOOL __stdcall ImmUnregisterWordA( HKL,  LPCSTR lpszReading,  DWORD,  LPCSTR lpszUnregister);
BOOL __stdcall ImmUnregisterWordW( HKL,  LPCWSTR lpszReading,  DWORD,  LPCWSTR lpszUnregister);




#line 338 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

UINT __stdcall ImmGetRegisterWordStyleA( HKL,  UINT nItem,  LPSTYLEBUFA);
UINT __stdcall ImmGetRegisterWordStyleW( HKL,  UINT nItem,  LPSTYLEBUFW);




#line 346 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

UINT __stdcall ImmEnumRegisterWordA( HKL,  REGISTERWORDENUMPROCA,  LPCSTR lpszReading,  DWORD,  LPCSTR lpszRegister,  LPVOID);
UINT __stdcall ImmEnumRegisterWordW( HKL,  REGISTERWORDENUMPROCW,  LPCWSTR lpszReading,  DWORD,  LPCWSTR lpszRegister,  LPVOID);




#line 354 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"


BOOL __stdcall ImmDisableIME( DWORD);
BOOL __stdcall ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);
DWORD __stdcall ImmGetImeMenuItemsA( HIMC,  DWORD,  DWORD,  LPIMEMENUITEMINFOA,  LPIMEMENUITEMINFOA,  DWORD);
DWORD __stdcall ImmGetImeMenuItemsW( HIMC,  DWORD,  DWORD,  LPIMEMENUITEMINFOW,  LPIMEMENUITEMINFOW,  DWORD);




#line 365 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

BOOL __stdcall ImmDisableTextFrameService(DWORD idThread);
#line 368 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"








































































































































































































































































#line 633 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"






































































#line 704 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"








#line 713 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"


}
#line 717 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"

#line 719 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\imm.h"
#line 237 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 238 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 239 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 240 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"




#pragma warning(pop)





#line 251 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 252 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 253 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"

#line 255 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"

#line 257 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"
#line 258 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\windows.h"

#line 31 "c:\\qt-3.3.8\\include\\qt_windows.h"



















#line 1 "c:\\qt-3.3.8\\include\\qnamespace.h"





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 51 "c:\\qt-3.3.8\\include\\qt_windows.h"



#line 55 "c:\\qt-3.3.8\\include\\qt_windows.h"

void qlasterror( CHAR *msg, DWORD dwLastError, bool showWindow = false );



#line 61 "c:\\qt-3.3.8\\include\\qt_windows.h"



#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\winuser.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 65 "c:\\qt-3.3.8\\include\\qt_windows.h"
#line 66 "c:\\qt-3.3.8\\include\\qt_windows.h"




























































































#line 159 "c:\\qt-3.3.8\\include\\qt_windows.h"






#line 166 "c:\\qt-3.3.8\\include\\qt_windows.h"






































































































































































































































































#line 429 "c:\\qt-3.3.8\\include\\qt_windows.h"
#line 63 "C:\\qt-3.3.8\\include\\qgl.h"
#line 64 "C:\\qt-3.3.8\\include\\qgl.h"














#line 79 "C:\\qt-3.3.8\\include\\qgl.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\GL/gl.h"






















extern "C" {
#line 25 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\GL/gl.h"


















typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































__declspec(dllimport) void __stdcall glAccum (GLenum op, GLfloat value);
__declspec(dllimport) void __stdcall glAlphaFunc (GLenum func, GLclampf ref);
__declspec(dllimport) GLboolean __stdcall glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
__declspec(dllimport) void __stdcall glArrayElement (GLint i);
__declspec(dllimport) void __stdcall glBegin (GLenum mode);
__declspec(dllimport) void __stdcall glBindTexture (GLenum target, GLuint texture);
__declspec(dllimport) void __stdcall glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
__declspec(dllimport) void __stdcall glBlendFunc (GLenum sfactor, GLenum dfactor);
__declspec(dllimport) void __stdcall glCallList (GLuint list);
__declspec(dllimport) void __stdcall glCallLists (GLsizei n, GLenum type, const GLvoid *lists);
__declspec(dllimport) void __stdcall glClear (GLbitfield mask);
__declspec(dllimport) void __stdcall glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
__declspec(dllimport) void __stdcall glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
__declspec(dllimport) void __stdcall glClearDepth (GLclampd depth);
__declspec(dllimport) void __stdcall glClearIndex (GLfloat c);
__declspec(dllimport) void __stdcall glClearStencil (GLint s);
__declspec(dllimport) void __stdcall glClipPlane (GLenum plane, const GLdouble *equation);
__declspec(dllimport) void __stdcall glColor3b (GLbyte red, GLbyte green, GLbyte blue);
__declspec(dllimport) void __stdcall glColor3bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glColor3d (GLdouble red, GLdouble green, GLdouble blue);
__declspec(dllimport) void __stdcall glColor3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glColor3f (GLfloat red, GLfloat green, GLfloat blue);
__declspec(dllimport) void __stdcall glColor3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glColor3i (GLint red, GLint green, GLint blue);
__declspec(dllimport) void __stdcall glColor3iv (const GLint *v);
__declspec(dllimport) void __stdcall glColor3s (GLshort red, GLshort green, GLshort blue);
__declspec(dllimport) void __stdcall glColor3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
__declspec(dllimport) void __stdcall glColor3ubv (const GLubyte *v);
__declspec(dllimport) void __stdcall glColor3ui (GLuint red, GLuint green, GLuint blue);
__declspec(dllimport) void __stdcall glColor3uiv (const GLuint *v);
__declspec(dllimport) void __stdcall glColor3us (GLushort red, GLushort green, GLushort blue);
__declspec(dllimport) void __stdcall glColor3usv (const GLushort *v);
__declspec(dllimport) void __stdcall glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
__declspec(dllimport) void __stdcall glColor4bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
__declspec(dllimport) void __stdcall glColor4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
__declspec(dllimport) void __stdcall glColor4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
__declspec(dllimport) void __stdcall glColor4iv (const GLint *v);
__declspec(dllimport) void __stdcall glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
__declspec(dllimport) void __stdcall glColor4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
__declspec(dllimport) void __stdcall glColor4ubv (const GLubyte *v);
__declspec(dllimport) void __stdcall glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
__declspec(dllimport) void __stdcall glColor4uiv (const GLuint *v);
__declspec(dllimport) void __stdcall glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
__declspec(dllimport) void __stdcall glColor4usv (const GLushort *v);
__declspec(dllimport) void __stdcall glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
__declspec(dllimport) void __stdcall glColorMaterial (GLenum face, GLenum mode);
__declspec(dllimport) void __stdcall glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
__declspec(dllimport) void __stdcall glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
__declspec(dllimport) void __stdcall glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
__declspec(dllimport) void __stdcall glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
__declspec(dllimport) void __stdcall glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
__declspec(dllimport) void __stdcall glCullFace (GLenum mode);
__declspec(dllimport) void __stdcall glDeleteLists (GLuint list, GLsizei range);
__declspec(dllimport) void __stdcall glDeleteTextures (GLsizei n, const GLuint *textures);
__declspec(dllimport) void __stdcall glDepthFunc (GLenum func);
__declspec(dllimport) void __stdcall glDepthMask (GLboolean flag);
__declspec(dllimport) void __stdcall glDepthRange (GLclampd zNear, GLclampd zFar);
__declspec(dllimport) void __stdcall glDisable (GLenum cap);
__declspec(dllimport) void __stdcall glDisableClientState (GLenum array);
__declspec(dllimport) void __stdcall glDrawArrays (GLenum mode, GLint first, GLsizei count);
__declspec(dllimport) void __stdcall glDrawBuffer (GLenum mode);
__declspec(dllimport) void __stdcall glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
__declspec(dllimport) void __stdcall glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glEdgeFlag (GLboolean flag);
__declspec(dllimport) void __stdcall glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glEdgeFlagv (const GLboolean *flag);
__declspec(dllimport) void __stdcall glEnable (GLenum cap);
__declspec(dllimport) void __stdcall glEnableClientState (GLenum array);
__declspec(dllimport) void __stdcall glEnd (void);
__declspec(dllimport) void __stdcall glEndList (void);
__declspec(dllimport) void __stdcall glEvalCoord1d (GLdouble u);
__declspec(dllimport) void __stdcall glEvalCoord1dv (const GLdouble *u);
__declspec(dllimport) void __stdcall glEvalCoord1f (GLfloat u);
__declspec(dllimport) void __stdcall glEvalCoord1fv (const GLfloat *u);
__declspec(dllimport) void __stdcall glEvalCoord2d (GLdouble u, GLdouble v);
__declspec(dllimport) void __stdcall glEvalCoord2dv (const GLdouble *u);
__declspec(dllimport) void __stdcall glEvalCoord2f (GLfloat u, GLfloat v);
__declspec(dllimport) void __stdcall glEvalCoord2fv (const GLfloat *u);
__declspec(dllimport) void __stdcall glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
__declspec(dllimport) void __stdcall glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
__declspec(dllimport) void __stdcall glEvalPoint1 (GLint i);
__declspec(dllimport) void __stdcall glEvalPoint2 (GLint i, GLint j);
__declspec(dllimport) void __stdcall glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
__declspec(dllimport) void __stdcall glFinish (void);
__declspec(dllimport) void __stdcall glFlush (void);
__declspec(dllimport) void __stdcall glFogf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glFogfv (GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glFogi (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glFogiv (GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glFrontFace (GLenum mode);
__declspec(dllimport) void __stdcall glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
__declspec(dllimport) GLuint __stdcall glGenLists (GLsizei range);
__declspec(dllimport) void __stdcall glGenTextures (GLsizei n, GLuint *textures);
__declspec(dllimport) void __stdcall glGetBooleanv (GLenum pname, GLboolean *params);
__declspec(dllimport) void __stdcall glGetClipPlane (GLenum plane, GLdouble *equation);
__declspec(dllimport) void __stdcall glGetDoublev (GLenum pname, GLdouble *params);
__declspec(dllimport) GLenum __stdcall glGetError (void);
__declspec(dllimport) void __stdcall glGetFloatv (GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetIntegerv (GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetLightiv (GLenum light, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetMapdv (GLenum target, GLenum query, GLdouble *v);
__declspec(dllimport) void __stdcall glGetMapfv (GLenum target, GLenum query, GLfloat *v);
__declspec(dllimport) void __stdcall glGetMapiv (GLenum target, GLenum query, GLint *v);
__declspec(dllimport) void __stdcall glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetPixelMapfv (GLenum map, GLfloat *values);
__declspec(dllimport) void __stdcall glGetPixelMapuiv (GLenum map, GLuint *values);
__declspec(dllimport) void __stdcall glGetPixelMapusv (GLenum map, GLushort *values);
__declspec(dllimport) void __stdcall glGetPointerv (GLenum pname, GLvoid* *params);
__declspec(dllimport) void __stdcall glGetPolygonStipple (GLubyte *mask);
__declspec(dllimport) const GLubyte * __stdcall glGetString (GLenum name);
__declspec(dllimport) void __stdcall glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
__declspec(dllimport) void __stdcall glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
__declspec(dllimport) void __stdcall glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glHint (GLenum target, GLenum mode);
__declspec(dllimport) void __stdcall glIndexMask (GLuint mask);
__declspec(dllimport) void __stdcall glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glIndexd (GLdouble c);
__declspec(dllimport) void __stdcall glIndexdv (const GLdouble *c);
__declspec(dllimport) void __stdcall glIndexf (GLfloat c);
__declspec(dllimport) void __stdcall glIndexfv (const GLfloat *c);
__declspec(dllimport) void __stdcall glIndexi (GLint c);
__declspec(dllimport) void __stdcall glIndexiv (const GLint *c);
__declspec(dllimport) void __stdcall glIndexs (GLshort c);
__declspec(dllimport) void __stdcall glIndexsv (const GLshort *c);
__declspec(dllimport) void __stdcall glIndexub (GLubyte c);
__declspec(dllimport) void __stdcall glIndexubv (const GLubyte *c);
__declspec(dllimport) void __stdcall glInitNames (void);
__declspec(dllimport) void __stdcall glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) GLboolean __stdcall glIsEnabled (GLenum cap);
__declspec(dllimport) GLboolean __stdcall glIsList (GLuint list);
__declspec(dllimport) GLboolean __stdcall glIsTexture (GLuint texture);
__declspec(dllimport) void __stdcall glLightModelf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glLightModelfv (GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glLightModeli (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glLightModeliv (GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glLightf (GLenum light, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glLightfv (GLenum light, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glLighti (GLenum light, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glLightiv (GLenum light, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glLineStipple (GLint factor, GLushort pattern);
__declspec(dllimport) void __stdcall glLineWidth (GLfloat width);
__declspec(dllimport) void __stdcall glListBase (GLuint base);
__declspec(dllimport) void __stdcall glLoadIdentity (void);
__declspec(dllimport) void __stdcall glLoadMatrixd (const GLdouble *m);
__declspec(dllimport) void __stdcall glLoadMatrixf (const GLfloat *m);
__declspec(dllimport) void __stdcall glLoadName (GLuint name);
__declspec(dllimport) void __stdcall glLogicOp (GLenum opcode);
__declspec(dllimport) void __stdcall glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
__declspec(dllimport) void __stdcall glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
__declspec(dllimport) void __stdcall glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
__declspec(dllimport) void __stdcall glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
__declspec(dllimport) void __stdcall glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
__declspec(dllimport) void __stdcall glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
__declspec(dllimport) void __stdcall glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
__declspec(dllimport) void __stdcall glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
__declspec(dllimport) void __stdcall glMaterialf (GLenum face, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glMateriali (GLenum face, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glMaterialiv (GLenum face, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glMatrixMode (GLenum mode);
__declspec(dllimport) void __stdcall glMultMatrixd (const GLdouble *m);
__declspec(dllimport) void __stdcall glMultMatrixf (const GLfloat *m);
__declspec(dllimport) void __stdcall glNewList (GLuint list, GLenum mode);
__declspec(dllimport) void __stdcall glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
__declspec(dllimport) void __stdcall glNormal3bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
__declspec(dllimport) void __stdcall glNormal3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
__declspec(dllimport) void __stdcall glNormal3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glNormal3i (GLint nx, GLint ny, GLint nz);
__declspec(dllimport) void __stdcall glNormal3iv (const GLint *v);
__declspec(dllimport) void __stdcall glNormal3s (GLshort nx, GLshort ny, GLshort nz);
__declspec(dllimport) void __stdcall glNormal3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
__declspec(dllimport) void __stdcall glPassThrough (GLfloat token);
__declspec(dllimport) void __stdcall glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values);
__declspec(dllimport) void __stdcall glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values);
__declspec(dllimport) void __stdcall glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values);
__declspec(dllimport) void __stdcall glPixelStoref (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glPixelStorei (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glPixelTransferf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glPixelTransferi (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glPixelZoom (GLfloat xfactor, GLfloat yfactor);
__declspec(dllimport) void __stdcall glPointSize (GLfloat size);
__declspec(dllimport) void __stdcall glPolygonMode (GLenum face, GLenum mode);
__declspec(dllimport) void __stdcall glPolygonOffset (GLfloat factor, GLfloat units);
__declspec(dllimport) void __stdcall glPolygonStipple (const GLubyte *mask);
__declspec(dllimport) void __stdcall glPopAttrib (void);
__declspec(dllimport) void __stdcall glPopClientAttrib (void);
__declspec(dllimport) void __stdcall glPopMatrix (void);
__declspec(dllimport) void __stdcall glPopName (void);
__declspec(dllimport) void __stdcall glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
__declspec(dllimport) void __stdcall glPushAttrib (GLbitfield mask);
__declspec(dllimport) void __stdcall glPushClientAttrib (GLbitfield mask);
__declspec(dllimport) void __stdcall glPushMatrix (void);
__declspec(dllimport) void __stdcall glPushName (GLuint name);
__declspec(dllimport) void __stdcall glRasterPos2d (GLdouble x, GLdouble y);
__declspec(dllimport) void __stdcall glRasterPos2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos2f (GLfloat x, GLfloat y);
__declspec(dllimport) void __stdcall glRasterPos2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos2i (GLint x, GLint y);
__declspec(dllimport) void __stdcall glRasterPos2iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos2s (GLshort x, GLshort y);
__declspec(dllimport) void __stdcall glRasterPos2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glRasterPos3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glRasterPos3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos3i (GLint x, GLint y, GLint z);
__declspec(dllimport) void __stdcall glRasterPos3iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos3s (GLshort x, GLshort y, GLshort z);
__declspec(dllimport) void __stdcall glRasterPos3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
__declspec(dllimport) void __stdcall glRasterPos4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
__declspec(dllimport) void __stdcall glRasterPos4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
__declspec(dllimport) void __stdcall glRasterPos4iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
__declspec(dllimport) void __stdcall glRasterPos4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glReadBuffer (GLenum mode);
__declspec(dllimport) void __stdcall glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
__declspec(dllimport) void __stdcall glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
__declspec(dllimport) void __stdcall glRectdv (const GLdouble *v1, const GLdouble *v2);
__declspec(dllimport) void __stdcall glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
__declspec(dllimport) void __stdcall glRectfv (const GLfloat *v1, const GLfloat *v2);
__declspec(dllimport) void __stdcall glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
__declspec(dllimport) void __stdcall glRectiv (const GLint *v1, const GLint *v2);
__declspec(dllimport) void __stdcall glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
__declspec(dllimport) void __stdcall glRectsv (const GLshort *v1, const GLshort *v2);
__declspec(dllimport) GLint __stdcall glRenderMode (GLenum mode);
__declspec(dllimport) void __stdcall glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glScaled (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glScalef (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
__declspec(dllimport) void __stdcall glSelectBuffer (GLsizei size, GLuint *buffer);
__declspec(dllimport) void __stdcall glShadeModel (GLenum mode);
__declspec(dllimport) void __stdcall glStencilFunc (GLenum func, GLint ref, GLuint mask);
__declspec(dllimport) void __stdcall glStencilMask (GLuint mask);
__declspec(dllimport) void __stdcall glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
__declspec(dllimport) void __stdcall glTexCoord1d (GLdouble s);
__declspec(dllimport) void __stdcall glTexCoord1dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord1f (GLfloat s);
__declspec(dllimport) void __stdcall glTexCoord1fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord1i (GLint s);
__declspec(dllimport) void __stdcall glTexCoord1iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord1s (GLshort s);
__declspec(dllimport) void __stdcall glTexCoord1sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord2d (GLdouble s, GLdouble t);
__declspec(dllimport) void __stdcall glTexCoord2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord2f (GLfloat s, GLfloat t);
__declspec(dllimport) void __stdcall glTexCoord2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord2i (GLint s, GLint t);
__declspec(dllimport) void __stdcall glTexCoord2iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord2s (GLshort s, GLshort t);
__declspec(dllimport) void __stdcall glTexCoord2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
__declspec(dllimport) void __stdcall glTexCoord3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
__declspec(dllimport) void __stdcall glTexCoord3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord3i (GLint s, GLint t, GLint r);
__declspec(dllimport) void __stdcall glTexCoord3iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord3s (GLshort s, GLshort t, GLshort r);
__declspec(dllimport) void __stdcall glTexCoord3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
__declspec(dllimport) void __stdcall glTexCoord4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
__declspec(dllimport) void __stdcall glTexCoord4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
__declspec(dllimport) void __stdcall glTexCoord4iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
__declspec(dllimport) void __stdcall glTexCoord4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glTexEnvf (GLenum target, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexEnvi (GLenum target, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexEnviv (GLenum target, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexGend (GLenum coord, GLenum pname, GLdouble param);
__declspec(dllimport) void __stdcall glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
__declspec(dllimport) void __stdcall glTexGenf (GLenum coord, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexGeni (GLenum coord, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTexParameterf (GLenum target, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexParameteri (GLenum target, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTranslated (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glTranslatef (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glVertex2d (GLdouble x, GLdouble y);
__declspec(dllimport) void __stdcall glVertex2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex2f (GLfloat x, GLfloat y);
__declspec(dllimport) void __stdcall glVertex2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex2i (GLint x, GLint y);
__declspec(dllimport) void __stdcall glVertex2iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex2s (GLshort x, GLshort y);
__declspec(dllimport) void __stdcall glVertex2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertex3d (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glVertex3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex3f (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glVertex3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex3i (GLint x, GLint y, GLint z);
__declspec(dllimport) void __stdcall glVertex3iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex3s (GLshort x, GLshort y, GLshort z);
__declspec(dllimport) void __stdcall glVertex3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
__declspec(dllimport) void __stdcall glVertex4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
__declspec(dllimport) void __stdcall glVertex4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex4i (GLint x, GLint y, GLint z, GLint w);
__declspec(dllimport) void __stdcall glVertex4iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
__declspec(dllimport) void __stdcall glVertex4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glViewport (GLint x, GLint y, GLsizei width, GLsizei height);


typedef void (__stdcall * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void (__stdcall * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (__stdcall * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean *pointer);
typedef void (__stdcall * PFNGLGETPOINTERVEXTPROC) (GLenum pname, GLvoid* *params);
typedef void (__stdcall * PFNGLARRAYELEMENTARRAYEXTPROC)(GLenum mode, GLsizei count, const GLvoid* pi);


typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSWINPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);


typedef void (__stdcall * PFNGLADDSWAPHINTRECTWINPROC)  (GLint x, GLint y, GLsizei width, GLsizei height);


typedef void (__stdcall * PFNGLCOLORTABLEEXTPROC)
    (GLenum target, GLenum internalFormat, GLsizei width, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (__stdcall * PFNGLCOLORSUBTABLEEXTPROC)
    (GLenum target, GLsizei start, GLsizei count, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (__stdcall * PFNGLGETCOLORTABLEEXTPROC)
    (GLenum target, GLenum format, GLenum type, GLvoid *data);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)
    (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)
    (GLenum target, GLenum pname, GLfloat *params);


}
#line 1524 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\GL/gl.h"

#line 1526 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\GL/gl.h"
#line 1527 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\GL/gl.h"

#line 80 "C:\\qt-3.3.8\\include\\qgl.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\GL/glu.h"





















#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\GL/gl.h"























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 23 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\GL/glu.h"


extern "C" {
#line 27 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\GL/glu.h"































#line 59 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\GL/glu.h"

const GLubyte* __stdcall gluErrorString (
    GLenum   errCode);

const wchar_t* __stdcall gluErrorUnicodeStringEXT (
    GLenum   errCode);

const GLubyte* __stdcall gluGetString (
    GLenum   name);

void __stdcall gluOrtho2D (
    GLdouble left, 
    GLdouble right, 
    GLdouble bottom, 
    GLdouble top);

void __stdcall gluPerspective (
    GLdouble fovy, 
    GLdouble aspect, 
    GLdouble zNear, 
    GLdouble zFar);

void __stdcall gluPickMatrix (
    GLdouble x, 
    GLdouble y, 
    GLdouble width, 
    GLdouble height, 
    GLint    viewport[4]);

void __stdcall gluLookAt (
    GLdouble eyex, 
    GLdouble eyey, 
    GLdouble eyez, 
    GLdouble centerx, 
    GLdouble centery, 
    GLdouble centerz, 
    GLdouble upx, 
    GLdouble upy, 
    GLdouble upz);

int __stdcall gluProject (
    GLdouble        objx, 
    GLdouble        objy, 
    GLdouble        objz,  
    const GLdouble  modelMatrix[16], 
    const GLdouble  projMatrix[16], 
    const GLint     viewport[4], 
    GLdouble        *winx, 
    GLdouble        *winy, 
    GLdouble        *winz);

int __stdcall gluUnProject (
    GLdouble       winx, 
    GLdouble       winy, 
    GLdouble       winz, 
    const GLdouble modelMatrix[16], 
    const GLdouble projMatrix[16], 
    const GLint    viewport[4], 
    GLdouble       *objx, 
    GLdouble       *objy, 
    GLdouble       *objz);


int __stdcall gluScaleImage (
    GLenum      format, 
    GLint       widthin, 
    GLint       heightin, 
    GLenum      typein, 
    const void  *datain, 
    GLint       widthout, 
    GLint       heightout, 
    GLenum      typeout, 
    void        *dataout);


int __stdcall gluBuild1DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);

int __stdcall gluBuild2DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLint       height, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);



class GLUnurbs;
class GLUquadric;
class GLUtesselator;


typedef class GLUnurbs GLUnurbsObj;
typedef class GLUquadric GLUquadricObj;
typedef class GLUtesselator GLUtesselatorObj;
typedef class GLUtesselator GLUtriangulatorObj;













#line 176 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\GL/glu.h"


GLUquadric* __stdcall gluNewQuadric (void);
void __stdcall gluDeleteQuadric (
    GLUquadric          *state);

void __stdcall gluQuadricNormals (
    GLUquadric          *quadObject, 
    GLenum              normals);

void __stdcall gluQuadricTexture (
    GLUquadric          *quadObject, 
    GLboolean           textureCoords);

void __stdcall gluQuadricOrientation (
    GLUquadric          *quadObject, 
    GLenum              orientation);

void __stdcall gluQuadricDrawStyle (
    GLUquadric          *quadObject, 
    GLenum              drawStyle);

void __stdcall gluCylinder (
    GLUquadric          *qobj, 
    GLdouble            baseRadius, 
    GLdouble            topRadius, 
    GLdouble            height, 
    GLint               slices, 
    GLint               stacks);

void __stdcall gluDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops);

void __stdcall gluPartialDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops, 
    GLdouble            startAngle, 
    GLdouble            sweepAngle);

void __stdcall gluSphere (
    GLUquadric          *qobj, 
    GLdouble            radius, 
    GLint               slices, 
    GLint               stacks);

void __stdcall gluQuadricCallback (
    GLUquadric          *qobj, 
    GLenum              which, 
    void                (__stdcall* fn)());

GLUtesselator* __stdcall  gluNewTess(          
    void );

void __stdcall  gluDeleteTess(       
    GLUtesselator       *tess );

void __stdcall  gluTessBeginPolygon( 
    GLUtesselator       *tess,
    void                *polygon_data );

void __stdcall  gluTessBeginContour( 
    GLUtesselator       *tess );

void __stdcall  gluTessVertex(       
    GLUtesselator       *tess,
    GLdouble            coords[3], 
    void                *data );

void __stdcall  gluTessEndContour(   
    GLUtesselator       *tess );

void __stdcall  gluTessEndPolygon(   
    GLUtesselator       *tess );

void __stdcall  gluTessProperty(     
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            value );
 
void __stdcall  gluTessNormal(       
    GLUtesselator       *tess, 
    GLdouble            x,
    GLdouble            y, 
    GLdouble            z );

void __stdcall  gluTessCallback(     
    GLUtesselator       *tess,
    GLenum              which, 
    void                (__stdcall *fn)());

void __stdcall  gluGetTessProperty(  
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            *value );
 
GLUnurbs* __stdcall gluNewNurbsRenderer (void);

void __stdcall gluDeleteNurbsRenderer (
    GLUnurbs            *nobj);

void __stdcall gluBeginSurface (
    GLUnurbs            *nobj);

void __stdcall gluBeginCurve (
    GLUnurbs            *nobj);

void __stdcall gluEndCurve (
    GLUnurbs            *nobj);

void __stdcall gluEndSurface (
    GLUnurbs            *nobj);

void __stdcall gluBeginTrim (
    GLUnurbs            *nobj);

void __stdcall gluEndTrim (
    GLUnurbs            *nobj);

void __stdcall gluPwlCurve (
    GLUnurbs            *nobj, 
    GLint               count, 
    GLfloat             *array, 
    GLint               stride, 
    GLenum              type);

void __stdcall gluNurbsCurve (
    GLUnurbs            *nobj, 
    GLint               nknots, 
    GLfloat             *knot, 
    GLint               stride, 
    GLfloat             *ctlarray, 
    GLint               order, 
    GLenum              type);

void __stdcall 
gluNurbsSurface(     
    GLUnurbs            *nobj, 
    GLint               sknot_count, 
    float               *sknot, 
    GLint               tknot_count, 
    GLfloat             *tknot, 
    GLint               s_stride, 
    GLint               t_stride, 
    GLfloat             *ctlarray, 
    GLint               sorder, 
    GLint               torder, 
    GLenum              type);

void __stdcall 
gluLoadSamplingMatrices (
    GLUnurbs            *nobj, 
    const GLfloat       modelMatrix[16], 
    const GLfloat       projMatrix[16], 
    const GLint         viewport[4] );

void __stdcall 
gluNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             value );

void __stdcall 
gluGetNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             *value );

void __stdcall 
gluNurbsCallback (
    GLUnurbs            *nobj, 
    GLenum              which, 
    void                (__stdcall* fn)() );





typedef void (__stdcall* GLUquadricErrorProc) (GLenum);


typedef void (__stdcall* GLUtessBeginProc)        (GLenum);
typedef void (__stdcall* GLUtessEdgeFlagProc)     (GLboolean);
typedef void (__stdcall* GLUtessVertexProc)       (void *);
typedef void (__stdcall* GLUtessEndProc)          (void);
typedef void (__stdcall* GLUtessErrorProc)        (GLenum);
typedef void (__stdcall* GLUtessCombineProc)      (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void** );
typedef void (__stdcall* GLUtessBeginDataProc)    (GLenum, void *);
typedef void (__stdcall* GLUtessEdgeFlagDataProc) (GLboolean, void *);
typedef void (__stdcall* GLUtessVertexDataProc)   (void *, void *);
typedef void (__stdcall* GLUtessEndDataProc)      (void *);
typedef void (__stdcall* GLUtessErrorDataProc)    (GLenum, void *);
typedef void (__stdcall* GLUtessCombineDataProc)  (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void**,
                                                  void* );


typedef void (__stdcall* GLUnurbsErrorProc)   (GLenum);













































































































































































void __stdcall   gluBeginPolygon( GLUtesselator *tess );

void __stdcall   gluNextContour(  GLUtesselator *tess, 
                                 GLenum        type );

void __stdcall   gluEndPolygon(   GLUtesselator *tess );
















}
#line 582 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\GL/glu.h"

#line 584 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\GL/glu.h"
#line 585 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\PlatformSDK\\include\\GL/glu.h"
#line 81 "C:\\qt-3.3.8\\include\\qgl.h"
#line 82 "C:\\qt-3.3.8\\include\\qgl.h"


class QGLCmap;
#line 86 "C:\\qt-3.3.8\\include\\qgl.h"

class QPixmap;


#line 91 "C:\\qt-3.3.8\\include\\qgl.h"


class __declspec(dllimport) QGL
{
public:
    enum FormatOption {
	DoubleBuffer		= 0x0001,
	DepthBuffer		= 0x0002,
	Rgba			= 0x0004,
	AlphaChannel		= 0x0008,
	AccumBuffer		= 0x0010,
	StencilBuffer		= 0x0020,
	StereoBuffers		= 0x0040,
	DirectRendering		= 0x0080,
	HasOverlay		= 0x0100,
	SingleBuffer            = DoubleBuffer  << 16,
	NoDepthBuffer           = DepthBuffer   << 16,
	ColorIndex              = Rgba          << 16,
	NoAlphaChannel          = AlphaChannel  << 16,
	NoAccumBuffer           = AccumBuffer   << 16,
	NoStencilBuffer         = StencilBuffer << 16,
	NoStereoBuffers         = StereoBuffers << 16,
	IndirectRendering       = DirectRendering << 16,
	NoOverlay		= HasOverlay << 16
    };
};



class __declspec(dllimport) QGLFormat : public QGL
{
public:
    QGLFormat();
    QGLFormat( int options, int plane = 0 );

    bool doubleBuffer() const;
    void setDoubleBuffer( bool enable );
    bool depth() const;
    void setDepth( bool enable );
    bool rgba() const;
    void setRgba( bool enable );
    bool alpha() const;
    void setAlpha( bool enable );
    bool accum() const;
    void setAccum( bool enable );
    bool stencil() const;
    void setStencil( bool enable );
    bool stereo() const;
    void setStereo( bool enable );
    bool directRendering() const;
    void setDirectRendering( bool enable );
    bool hasOverlay() const;
    void setOverlay( bool enable );

    int plane() const;
    void setPlane( int plane );

    void setOption( FormatOption opt );
    bool testOption( FormatOption opt ) const;

    static QGLFormat defaultFormat();
    static void setDefaultFormat( const QGLFormat& f );

    static QGLFormat defaultOverlayFormat();
    static void setDefaultOverlayFormat( const QGLFormat& f );

    static bool hasOpenGL();
    static bool hasOpenGLOverlays();

    friend __declspec(dllimport) bool operator==( const QGLFormat&,
					     const QGLFormat& );
    friend __declspec(dllimport) bool operator!=( const QGLFormat&,
					     const QGLFormat& );
private:
    uint opts;
    int pln;
};


__declspec(dllimport) bool operator==( const QGLFormat&, const QGLFormat& );
__declspec(dllimport) bool operator!=( const QGLFormat&, const QGLFormat& );

class __declspec(dllimport) QGLContext : public QGL
{
public:
    QGLContext( const QGLFormat& format, QPaintDevice* device );
    QGLContext( const QGLFormat& format );
    virtual ~QGLContext();

    virtual bool create( const QGLContext* shareContext = 0 );
    bool isValid() const;
    bool isSharing() const;
    virtual void reset();

    QGLFormat format() const;
    QGLFormat requestedFormat() const;
    virtual void setFormat( const QGLFormat& format );

    virtual void makeCurrent();
    virtual void swapBuffers() const;

    QPaintDevice* device() const;

    QColor overlayTransparentColor() const;

    static const QGLContext* currentContext();

protected:
    virtual bool chooseContext( const QGLContext* shareContext = 0 );
    virtual void doneCurrent(); 


    virtual int choosePixelFormat( void* pfd, HDC pdc );
#line 205 "C:\\qt-3.3.8\\include\\qgl.h"



#line 209 "C:\\qt-3.3.8\\include\\qgl.h"


#line 212 "C:\\qt-3.3.8\\include\\qgl.h"

    bool deviceIsPixmap() const;
    bool windowCreated() const;
    void setWindowCreated( bool on );
    bool initialized() const;
    void setInitialized( bool on );
    void generateFontDisplayLists( const QFont & fnt, int listBase );

    uint colorIndex( const QColor& c ) const;
    void setValid( bool valid );
    void setDevice( QPaintDevice *pDev );

protected:

    HGLRC rc;
    HDC dc;
    WId	win;
    int pixelFormatId;
    QGLCmap* cmap;






#line 238 "C:\\qt-3.3.8\\include\\qgl.h"
    QGLFormat glFormat;
    QGLFormat reqFormat;
    static QGLContext*	currentCtx;

private:
    void init( QPaintDevice *dev = 0 );
    class Private {
    public:
	bool valid;
	bool sharing;
	bool initDone;
	bool crWin;
	QPaintDevice* paintDevice;
	QColor transpColor;



    };
    Private* d;

    friend class QGLWidget;




private:	
    QGLContext() {}
    QGLContext( const QGLContext& ) {}
    QGLContext& operator=( const QGLContext& ) { return *this; }
};




class __declspec(dllimport) QGLWidget : public QWidget, public QGL
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QGLWidget( QWidget* parent=0, const char* name=0,
	       const QGLWidget* shareWidget = 0, WFlags f=0 );
    QGLWidget( QGLContext *context, QWidget* parent, const char* name=0,
	       const QGLWidget* shareWidget = 0, WFlags f=0 );
    QGLWidget( const QGLFormat& format, QWidget* parent=0, const char* name=0,
	       const QGLWidget* shareWidget = 0, WFlags f=0 );
    ~QGLWidget();

    void qglColor( const QColor& c ) const;
    void qglClearColor( const QColor& c ) const;

    bool isValid() const;
    bool isSharing() const;
    virtual void makeCurrent();
    void doneCurrent();
    
    bool doubleBuffer() const;
    virtual void swapBuffers();

    QGLFormat format() const;

    virtual void setFormat( const QGLFormat& format );
#line 299 "C:\\qt-3.3.8\\include\\qgl.h"

    const QGLContext* context() const;

    virtual void setContext( QGLContext* context,
			     const QGLContext* shareContext = 0,
			     bool deleteOldContext = 1 );
#line 306 "C:\\qt-3.3.8\\include\\qgl.h"

    virtual QPixmap renderPixmap( int w = 0, int h = 0,
				  bool useContext = 0 );
    virtual QImage grabFrameBuffer( bool withAlpha = 0 );

    virtual void makeOverlayCurrent();
    const QGLContext* overlayContext() const;

    static QImage convertToGLFormat( const QImage& img );

    void setMouseTracking( bool enable );
    virtual void  reparent( QWidget* parent, WFlags f, const QPoint& p,
			    bool showIt = 0 );

    const QGLColormap & colormap() const;
    void  setColormap( const QGLColormap & map );

    void renderText( int x, int y, const QString & str,
		     const QFont & fnt = QFont(), int listBase = 2000 );
    void renderText( double x, double y, double z, const QString & str,
		     const QFont & fnt = QFont(), int listBase = 2000 );
public :
    virtual void updateGL();
    virtual void updateOverlayGL();

protected:
    virtual void initializeGL();
    virtual void resizeGL( int w, int h );
    virtual void paintGL();

    virtual void initializeOverlayGL();
    virtual void resizeOverlayGL( int w, int h );
    virtual void paintOverlayGL();

    void setAutoBufferSwap( bool on );
    bool autoBufferSwap() const;

    void paintEvent( QPaintEvent* );
    void resizeEvent( QResizeEvent* );

    virtual void glInit();
    virtual void glDraw();

private:
    int displayListBase( const QFont & fnt, int listBase );
    void cleanupColormaps();
    void init( QGLContext *context, const QGLWidget* shareWidget );
    bool renderCxPm( QPixmap* pm );
    QGLContext* glcx;
    bool autoSwap;

    QGLColormap cmap;


    QGLContext* olcx;



#line 365 "C:\\qt-3.3.8\\include\\qgl.h"

private:	



#line 371 "C:\\qt-3.3.8\\include\\qgl.h"

















#line 389 "C:\\qt-3.3.8\\include\\qgl.h"
private :
    void macInternalFixBufferRect();
};






inline bool QGLFormat::doubleBuffer() const
{
    return testOption( DoubleBuffer );
}

inline bool QGLFormat::depth() const
{
    return testOption( DepthBuffer );
}

inline bool QGLFormat::rgba() const
{
    return testOption( Rgba );
}

inline bool QGLFormat::alpha() const
{
    return testOption( AlphaChannel );
}

inline bool QGLFormat::accum() const
{
    return testOption( AccumBuffer );
}

inline bool QGLFormat::stencil() const
{
    return testOption( StencilBuffer );
}

inline bool QGLFormat::stereo() const
{
    return testOption( StereoBuffers );
}

inline bool QGLFormat::directRendering() const
{
    return testOption( DirectRendering );
}

inline bool QGLFormat::hasOverlay() const
{
    return testOption( HasOverlay );
}





inline bool QGLContext::isValid() const
{
    return d->valid;
}

inline void QGLContext::setValid( bool valid )
{
    d->valid = valid;
}

inline bool QGLContext::isSharing() const
{
    return d->sharing;
}

inline QGLFormat QGLContext::format() const
{
    return glFormat;
}

inline QGLFormat QGLContext::requestedFormat() const
{
    return reqFormat;
}

inline QPaintDevice* QGLContext::device() const
{
    return d->paintDevice;
}

inline bool QGLContext::deviceIsPixmap() const
{
    return d->paintDevice->devType() == QInternal::Pixmap;
}


inline bool QGLContext::windowCreated() const
{
    return d->crWin;
}


inline void QGLContext::setWindowCreated( bool on )
{
    d->crWin = on;
}

inline bool QGLContext::initialized() const
{
    return d->initDone;
}

inline void QGLContext::setInitialized( bool on )
{
    d->initDone = on;
}

inline const QGLContext* QGLContext::currentContext()
{
    return currentCtx;
}





inline QGLFormat QGLWidget::format() const
{
    return glcx->format();
}

inline const QGLContext *QGLWidget::context() const
{
    return glcx;
}

inline bool QGLWidget::doubleBuffer() const
{
    return glcx->format().doubleBuffer();
}

inline void QGLWidget::setAutoBufferSwap( bool on )
{
    autoSwap = on;
}

inline bool QGLWidget::autoBufferSwap() const
{
    return autoSwap;
}

#line 539 "C:\\qt-3.3.8\\include\\qgl.h"
#line 7 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\bbb_GLWidget.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

#pragma once







#pragma pack(push,8)
#pragma warning(push,3)

 #pragma warning(disable: 4244)
#line 15 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

namespace std {
template<class _Ty,
	class _Ax = allocator<_Ty> >
	class vector;

		
template<class _Ty,
	class _Alloc>
	class _Vector_const_iterator
		: public _Ranit<_Ty, typename _Alloc::difference_type,
			typename _Alloc::const_pointer, typename _Alloc::const_reference>
	{	
public:
	typedef _Vector_const_iterator<_Ty, _Alloc> _Myt;
	typedef vector<_Ty, _Alloc> _Myvec;
	typedef typename _Alloc::pointer _Tptr;

	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef typename _Alloc::const_pointer pointer;
	typedef typename _Alloc::const_reference reference;


	typedef _Range_checked_iterator_tag _Checked_iterator_category;
#line 42 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"













#line 56 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

	
	
	
	
	typedef _Tptr _Inner_type;

	_Vector_const_iterator()
		{	
		_Myptr = 0;
		}

 
	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)
		{	
		{ if (!(_Pvector == 0 || (((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast))) { (void) ((!!((("_Pvector == NULL || (((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast)", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 71, 0, L"(\"_Pvector == NULL || (((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast)\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 71, 0); } ; };
		this->_Adopt(_Pvector);
		_Myptr = _Ptr;
		}

 












#line 90 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

	reference operator*() const
		{	

 
		if (this->_Mycont == 0
			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
			{
			_Debug_message(L"vector iterator not dereferencable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 99);
			{ (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 100, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 100, 0); };
			}
 


#line 106 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		return (*_Myptr);
		}

	pointer operator->() const
		{	
		return (&**this);
		}

	_Myt& operator++()
		{	
		{ if (!(this->_Mycont != 0)) { (void) ((!!((("this->_Mycont != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 117, 0, L"(\"this->_Mycont != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 117, 0); } ; };
		{ if (!(_Myptr < ((_Myvec *)(this->_Mycont))->_Mylast)) { (void) ((!!((("_Myptr < ((_Myvec *)(this->_Mycont))->_Mylast", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 118, 0, L"(\"_Myptr < ((_Myvec *)(this->_Mycont))->_Mylast\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 118, 0); } ; };
		++_Myptr;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		{ if (!(this->_Mycont != 0)) { (void) ((!!((("this->_Mycont != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 132, 0, L"(\"this->_Mycont != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 132, 0); } ; };
		{ if (!(_Myptr > ((_Myvec *)(this->_Mycont))->_Myfirst)) { (void) ((!!((("_Myptr > ((_Myvec *)(this->_Mycont))->_Myfirst", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 133, 0, L"(\"_Myptr > ((_Myvec *)(this->_Mycont))->_Myfirst\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 133, 0); } ; };
		--_Myptr;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt& operator+=(difference_type _Off)
		{	
		{ if (!(this->_Mycont != 0)) { (void) ((!!((("this->_Mycont != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 147, 0, L"(\"this->_Mycont != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 147, 0); } ; };
		{ if (!(_Myptr + _Off <= ((_Myvec *)(this->_Mycont))->_Mylast && _Myptr + _Off >= ((_Myvec *)(this->_Mycont))->_Myfirst)) { (void) ((!!((("_Myptr + _Off <= ((_Myvec *)(this->_Mycont))->_Mylast && _Myptr + _Off >= ((_Myvec *)(this->_Mycont))->_Myfirst", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 150, 0, L"(\"_Myptr + _Off <= ((_Myvec *)(this->_Mycont))->_Mylast && _Myptr + _Off >= ((_Myvec *)(this->_Mycont))->_Myfirst\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 150, 0); } ; };
#line 151 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"
		_Myptr += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myt operator-(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myt& _Right) const
		{	

 
		_Compat(_Right);
 

#line 180 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		return (_Myptr - _Right._Myptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myt& _Right) const
		{	

 
		_Compat(_Right);
 

#line 197 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		return (_Myptr == _Right._Myptr);
		}

	bool operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myt& _Right) const
		{	

 
		_Compat(_Right);
 

#line 214 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		return (_Myptr < _Right._Myptr);
		}

	bool operator>(const _Myt& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myt& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myt& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Myt& _Right) const
		{	
		if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
			{
			_Debug_message(L"vector iterators incompatible", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 238);
			{ (void) ((!!((("Standard C++ Libraries Invalid Argument", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 239, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 239, 0); };
			}
		}
 #line 243 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

	static void _Xlen()
		{	
		throw length_error("vector<T> too long");
		}

	static void _Xran()
		{	
		throw out_of_range("invalid vector<T> subscript");
		}

	static void _Xinvarg()
		{	
		throw invalid_argument("invalid vector<T> argument");
		}

	_Tptr _Myptr;	
	};

template<class _Ty,
	class _Alloc> inline
	_Vector_const_iterator<_Ty, _Alloc> operator+(
		typename _Vector_const_iterator<_Ty, _Alloc>::difference_type _Off,
		_Vector_const_iterator<_Ty, _Alloc> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Ty,
	class _Alloc>
	class _Vector_iterator
		: public _Vector_const_iterator<_Ty, _Alloc>
		{	
public:
	typedef _Vector_iterator<_Ty, _Alloc> _Myt;
	typedef _Vector_const_iterator<_Ty, _Alloc> _Mybase;

	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef typename _Alloc::pointer pointer;
	typedef typename _Alloc::reference reference;













#line 300 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

	_Vector_iterator()
		{	
		}

 
	_Vector_iterator(pointer _Ptr, const _Container_base *_Pvector)
		: _Mybase(_Ptr, _Pvector)
		{	
		}

 










#line 323 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (&**this);
		}

	_Myt& operator++()
		{	
		++(*(_Mybase *)this);
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		--(*(_Mybase *)this);
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt& operator+=(difference_type _Off)
		{	
		(*(_Mybase *)this) += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myt operator-(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Ty,
	class _Alloc> inline
	_Vector_iterator<_Ty, _Alloc> operator+(
		typename _Vector_iterator<_Ty, _Alloc>::difference_type _Off,
		_Vector_iterator<_Ty, _Alloc> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Ty,
	class _Alloc>
	class _Vector_val
		: public _Container_base
	{	
protected:
	_Vector_val(_Alloc _Al = _Alloc())
		: _Alval(_Al)
		{	
		}

	typedef typename _Alloc::template
		rebind<_Ty>::other _Alty;

	_Alty _Alval;	
	};

		
template<class _Ty,
	class _Ax>
	class vector
		: public _Vector_val<_Ty, _Ax>
	{	
public:
	typedef vector<_Ty, _Ax> _Myt;
	typedef _Vector_val<_Ty, _Ax> _Mybase;
	typedef typename _Mybase::_Alty _Alloc;
	typedef _Alloc allocator_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type _Dift;
	typedef _Dift difference_type;
	typedef typename _Alloc::pointer _Tptr;
	typedef typename _Alloc::const_pointer _Ctptr;
	typedef _Tptr pointer;
	typedef _Ctptr const_pointer;
	typedef typename _Alloc::reference _Reft;
	typedef _Reft reference;
	typedef typename _Alloc::const_reference const_reference;
	typedef typename _Alloc::value_type value_type;

  

	typedef _Vector_iterator<_Ty, _Alloc> iterator;
	typedef _Vector_const_iterator<_Ty, _Alloc> const_iterator;


	friend class _Vector_const_iterator<_Ty, _Alloc>;

	typedef std::reverse_iterator<iterator> reverse_iterator;
	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

	vector()
		: _Mybase()
		{	
		_Buy(0);
		}

	explicit vector(const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Buy(0);
		}

	explicit vector(size_type _Count)
		: _Mybase()
		{	
		_Construct_n(_Count, _Ty());
		}

	vector(size_type _Count, const _Ty& _Val)
		: _Mybase()
		{	
		_Construct_n(_Count, _Val);
		}

	vector(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Construct_n(_Count, _Val);
		}

	vector(const _Myt& _Right)
		: _Mybase(_Right._Alval)
		{	
		if (_Buy(_Right.size()))
			try {
			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);
			} catch (...) {
			_Tidy();
			throw;
			}
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last)
		: _Mybase()
		{	
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Construct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{	
		size_type _Size = (size_type)_Count;
		_Construct_n(_Size, (_Ty)_Val);
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, input_iterator_tag)
		{	
		_Buy(0);
		try {
		insert(begin(), _First, _Last);
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	void _Construct_n(size_type _Count, const _Ty& _Val)
		{	
		if (_Buy(_Count))
			{	
			try {
			_Mylast = _Ufill(_Myfirst, _Count, _Val);
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	~vector()
		{	
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	

 
			this->_Orphan_all();
 #line 557 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

			if (_Right.size() == 0)
				clear();	
			else if (_Right.size() <= size())
				{	
				pointer _Ptr = ::stdext:: unchecked_copy(_Right._Myfirst, _Right._Mylast,
					_Myfirst);	
				_Destroy(_Ptr, _Mylast);	
				_Mylast = _Myfirst + _Right.size();
				}
			else if (_Right.size() <= capacity())
				{	
				pointer _Ptr = _Right._Myfirst + size();
				::stdext:: unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);
				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);
				}
			else
				{	
				if (_Myfirst != 0)
					{	
					_Destroy(_Myfirst, _Mylast);
					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
					}
				if (_Buy(_Right.size()))
					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
						_Myfirst);
				}
			}
		return (*this);
		}

	void reserve(size_type _Count)
		{	
		if (max_size() < _Count)
			_Xlen();	
		else if (capacity() < _Count)
			{	
			pointer _Ptr = this->_Alval.allocate(_Count);

			try {
			_Umove(begin(), end(), _Ptr);
			} catch (...) {
			this->_Alval.deallocate(_Ptr, _Count);
			throw;
			}

			size_type _Size = size();
			if (_Myfirst != 0)
				{	
				_Destroy(_Myfirst, _Mylast);
				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
				}

 
			this->_Orphan_all();
 #line 613 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

			_Myend = _Ptr + _Count;
			_Mylast = _Ptr + _Size;
			_Myfirst = _Ptr;
			}
		}

	size_type capacity() const
		{	
		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);
		}

 
	iterator begin()
		{	
		return (iterator(_Myfirst, this));
		}

	const_iterator begin() const
		{	
		return (const_iterator(_Myfirst, this));
		}

	iterator end()
		{	
		return (iterator(_Mylast, this));
		}

	const_iterator end() const
		{	
		return (const_iterator(_Mylast, this));
		}

 



















#line 667 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

	reverse_iterator rbegin()
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend()
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const
		{	
		return (const_reverse_iterator(begin()));
		}

	void resize(size_type _Newsize)
		{	
		resize(_Newsize, _Ty());
		}

	void resize(size_type _Newsize, _Ty _Val)
		{	
		if (size() < _Newsize)
			_Insert_n(end(), _Newsize - size(), _Val);
		else if (_Newsize < size())
			erase(begin() + _Newsize, end());
		}

	size_type size() const
		{	
		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);
		}

	size_type max_size() const
		{	
		return (this->_Alval.max_size());
		}

	bool empty() const
		{	
		return (size() == 0);
		}

	_Alloc get_allocator() const
		{	
		return (this->_Alval);
		}

	const_reference at(size_type _Pos) const
		{	
		if (size() <= _Pos)
			_Xran();
		return (*(begin() + _Pos));
		}

	reference at(size_type _Pos)
		{	
		if (size() <= _Pos)
			_Xran();
		return (*(begin() + _Pos));
		}

	const_reference operator[](size_type _Pos) const
		{	

 
		if (size() <= _Pos)
			{
			_Debug_message(L"vector subscript out of range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 741);
			{ (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 742, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 742, 0); };
			}
 #line 745 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"
		{ if (!(_Pos < size())) { (void) ((!!((("_Pos < size()", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 745, 0, L"(\"_Pos < size()\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 745, 0); } ; };

		return (*(_Myfirst + _Pos));
		}

	reference operator[](size_type _Pos)
		{	

 
		if (size() <= _Pos)
			{
			_Debug_message(L"vector subscript out of range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 756);
			{ (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 757, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 757, 0); };
			}
 #line 760 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"
		{ if (!(_Pos < size())) { (void) ((!!((("_Pos < size()", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 760, 0, L"(\"_Pos < size()\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 760, 0); } ; };

		return (*(_Myfirst + _Pos));
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	void push_back(const _Ty& _Val)
		{	
		if (size() < capacity())

 
			{ 
			_Orphan_range(_Mylast, _Mylast);
			_Mylast = _Ufill(_Mylast, 1, _Val);
			}

 

#line 798 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		else
			insert(end(), _Val);
		}

 
	void pop_back()
		{	
		if (empty())
			_Debug_message(L"vector empty before pop", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 807);
		else
			{	
			_Orphan_range(_Mylast - 1, _Mylast);
			_Destroy(_Mylast - 1, _Mylast);
			--_Mylast;
			}
		}

 








#line 826 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

	template<class _Iter>
		void assign(_Iter _First, _Iter _Last)
		{	
		_Assign(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{	
		_Assign_n((size_type)_Count, (_Ty)_Val);
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{	
		erase(begin(), end());
		insert(begin(), _First, _Last);
		}

	void assign(size_type _Count, const _Ty& _Val)
		{	
		_Assign_n(_Count, _Val);
		}

	iterator insert(iterator _Where, const _Ty& _Val)
		{	
		size_type _Off = size() == 0 ? 0 : _Where - begin();
		_Insert_n(_Where, (size_type)1, _Val);
		return (begin() + _Off);
		}

	void insert(iterator _Where, size_type _Count, const _Ty& _Val)
		{	
		_Insert_n(_Where, _Count, _Val);
		}

	template<class _Iter>
		void insert(iterator _Where, _Iter _First, _Iter _Last)
		{	
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last,
			_Int_iterator_tag)
		{	
		_Insert_n(_Where, (size_type)_First, (_Ty)_Last);
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last,
			input_iterator_tag)
		{	
		for (; _First != _Last; ++_First, ++_Where)
			_Where = insert(_Where, *_First);
		}

	template<class _Iter>
		void _Insert(iterator _Where,
			_Iter _First, _Iter _Last, forward_iterator_tag)
		{	

 
		if (_Where._Mycont != this
			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
			_Debug_message(L"vector insert iterator outside range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 892);
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 893);
		if (_Debug_get_cont(_First) == this)
			_Debug_message(L"vector insertion overlaps range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 895);
 #line 897 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		size_type _Count = 0;
		_Distance(_First, _Last, _Count);
		size_type _Capacity = capacity();

		if (_Count == 0)
			;
		else if (max_size() - size() < _Count)
			_Xlen();	
		else if (_Capacity < size() + _Count)
			{	
			_Capacity = max_size() - _Capacity / 2 < _Capacity
				? 0 : _Capacity + _Capacity / 2;	
			if (_Capacity < size() + _Count)
				_Capacity = size() + _Count;
			pointer _Newvec = this->_Alval.allocate(_Capacity);
			pointer _Ptr = _Newvec;

			try {
			_Ptr = _Umove(_Myfirst, (_Where)._Myptr,
				_Newvec);	
			_Ptr = _Ucopy(_First, _Last, _Ptr);	
			_Umove((_Where)._Myptr, _Mylast, _Ptr);	
			} catch (...) {
			_Destroy(_Newvec, _Ptr);
			this->_Alval.deallocate(_Newvec, _Capacity);
			throw;
			}

			_Count += size();
			if (_Myfirst != 0)
				{	
				_Destroy(_Myfirst, _Mylast);
				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
				}

 
			this->_Orphan_all();
 #line 936 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

			_Myend = _Newvec + _Capacity;
			_Mylast = _Newvec + _Count;
			_Myfirst = _Newvec;
			}
		else if ((size_type)(end() - _Where) < _Count)
			{	
			_Umove((_Where)._Myptr, _Mylast,
				(_Where)._Myptr + _Count);	
			_Iter _Mid = _First;
			advance(_Mid, end() - _Where);

			try {
			_Ucopy(_Mid, _Last, _Mylast);	
			} catch (...) {
			_Destroy((_Where)._Myptr + _Count, _Mylast + _Count);
			throw;
			}

			_Mylast += _Count;

 
			_Orphan_range(_Where._Myptr, _Mylast);
 #line 960 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

			::stdext:: unchecked_copy(_First, _Mid,
				(_Where)._Myptr);	
			}
		else
			{	
			pointer _Oldend = _Mylast;
			_Mylast = _Umove(_Oldend - _Count, _Oldend,
				_Mylast);	
			::stdext:: _Unchecked_move_backward((_Where)._Myptr, _Oldend - _Count,
				_Oldend);	

 
			_Orphan_range(_Where._Myptr, _Mylast);
 #line 975 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

			::stdext:: unchecked_copy(_First, _Last,
				(_Where)._Myptr);	
			}
		}

 
	iterator erase(iterator _Where)
		{	
		if (_Where._Mycont != this
			|| _Where._Myptr < _Myfirst || _Mylast <= _Where._Myptr)
			_Debug_message(L"vector erase iterator outside range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 986);
		::stdext:: unchecked_copy(_Where._Myptr + 1, _Mylast, _Where._Myptr);
		_Destroy(_Mylast - 1, _Mylast);
		_Orphan_range(_Where._Myptr, _Mylast);
		--_Mylast;
		return (iterator(_Where._Myptr, this));
		}

 








#line 1004 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

	iterator erase(iterator _First, iterator _Last)
		{	
		if (_First != _Last)
			{	

 
			if (_Last < _First || _First._Mycont != this
				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
				_Debug_message(L"vector erase iterator outside range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1013);
			pointer _Ptr = ::stdext:: unchecked_copy((_Last)._Myptr, _Mylast,
				(_First)._Myptr);
			_Orphan_range(_First._Myptr, _Mylast);

 


#line 1022 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

			_Destroy(_Ptr, _Mylast);
			_Mylast = _Ptr;
			}

        return (iterator(_First._Myptr, this));


#line 1031 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"
		}

	void clear()
		{	
		erase(begin(), end());
		}

	void swap(_Myt& _Right)
		{	
		if (this->_Alval == _Right._Alval)
			{	

 
			this->_Swap_all(_Right);
 #line 1046 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

			std::swap(_Myfirst, _Right._Myfirst);
			std::swap(_Mylast, _Right._Mylast);
			std::swap(_Myend, _Right._Myend);
			}
		else
			{	
			_Myt _Ts = *this; *this = _Right, _Right = _Ts;
			}
		}

protected:
	void _Assign_n(size_type _Count, const _Ty& _Val)
		{	
		_Ty _Tmp = _Val;	
		erase(begin(), end());
		insert(begin(), _Count, _Tmp);
		}

	bool _Buy(size_type _Capacity)
		{	
		_Myfirst = 0, _Mylast = 0, _Myend = 0;
		if (_Capacity == 0)
			return (false);
		else if (max_size() < _Capacity)
			_Xlen();	
		else
			{	
			_Myfirst = this->_Alval.allocate(_Capacity);
			_Mylast = _Myfirst;
			_Myend = _Myfirst + _Capacity;
			}
		return (true);
		}

	void _Destroy(pointer _First, pointer _Last)
		{	
		_Destroy_range(_First, _Last, this->_Alval);
		}

	void _Tidy()
		{	
		if (_Myfirst != 0)
			{	

 
			this->_Orphan_all();
 #line 1094 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

			_Destroy(_Myfirst, _Mylast);
			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
			}
		_Myfirst = 0, _Mylast = 0, _Myend = 0;
		}

	template<class _Iter>
		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
		{	
		return (::stdext:: unchecked_uninitialized_copy(_First, _Last,
			_Ptr, this->_Alval));
		}

	template<class _Iter>
		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
		{	
		return (::stdext:: _Unchecked_uninitialized_move(_First, _Last,
			_Ptr, this->_Alval));
		}

	void _Insert_n(iterator _Where,
		size_type _Count, const _Ty& _Val)
		{	

 
		if (_Where._Mycont != this
			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
			_Debug_message(L"vector insert iterator outside range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1122);
 #line 1124 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		_Ty _Tmp = _Val;	
		size_type _Capacity = capacity();

		if (_Count == 0)
			;
		else if (max_size() - size() < _Count)
			_Xlen();	
		else if (_Capacity < size() + _Count)
			{	
			_Capacity = max_size() - _Capacity / 2 < _Capacity
				? 0 : _Capacity + _Capacity / 2;	
			if (_Capacity < size() + _Count)
				_Capacity = size() + _Count;
			pointer _Newvec = this->_Alval.allocate(_Capacity);
			pointer _Ptr = _Newvec;

			try {
			_Ptr = _Umove(_Myfirst, (_Where)._Myptr,
				_Newvec);	
			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	
			_Umove((_Where)._Myptr, _Mylast, _Ptr);	
			} catch (...) {
			_Destroy(_Newvec, _Ptr);
			this->_Alval.deallocate(_Newvec, _Capacity);
			throw;
			}

			_Count += size();
			if (_Myfirst != 0)
				{	
				_Destroy(_Myfirst, _Mylast);
				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
				}

 
			this->_Orphan_all();
 #line 1162 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

			_Myend = _Newvec + _Capacity;
			_Mylast = _Newvec + _Count;
			_Myfirst = _Newvec;
			}
		else if ((size_type)(_Mylast - (_Where)._Myptr) < _Count)
			{	
			_Umove((_Where)._Myptr, _Mylast,
				(_Where)._Myptr + _Count);	

			try {
			_Ufill(_Mylast, _Count - (_Mylast - (_Where)._Myptr),
				_Tmp);	
			} catch (...) {
			_Destroy((_Where)._Myptr + _Count, _Mylast + _Count);
			throw;
			}

			_Mylast += _Count;

 
			_Orphan_range(_Where._Myptr, _Mylast);
 #line 1185 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

			fill((_Where)._Myptr, _Mylast - _Count,
				_Tmp);	
			}
		else
			{	
			pointer _Oldend = _Mylast;
			_Mylast = _Umove(_Oldend - _Count, _Oldend,
				_Mylast);	

 
			_Orphan_range(_Where._Myptr, _Mylast);
 #line 1198 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

			::stdext:: _Unchecked_move_backward((_Where)._Myptr, _Oldend - _Count,
				_Oldend);	
			fill((_Where)._Myptr, (_Where)._Myptr + _Count,
				_Tmp);	
			}
		}

	pointer _Ufill(pointer _Ptr, size_type _Count, const _Ty &_Val)
		{	
		::stdext:: unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);
		return (_Ptr + _Count);
		}

	static void _Xlen()
		{	
		throw length_error("vector<T> too long");
		}

	static void _Xran()
		{	
		throw out_of_range("invalid vector<T> subscript");
		}

	static void _Xinvarg()
		{	
		throw invalid_argument("invalid vector<T> argument");
		}

 
	void _Orphan_range(pointer _First, pointer _Last) const
		{	
		_Lockit _Lock(3);
		const_iterator **_Pnext = (const_iterator **)&this->_Myfirstiter;
		while (*_Pnext != 0)
			if ((*_Pnext)->_Myptr < _First || _Last < (*_Pnext)->_Myptr)
				_Pnext = (const_iterator **)&(*_Pnext)->_Mynextiter;
			else
				{	
				(*_Pnext)->_Mycont = 0;
				*_Pnext = (const_iterator *)(*_Pnext)->_Mynextiter;
				}
		}
 #line 1242 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

	pointer _Myfirst;	
	pointer _Mylast;	
	pointer _Myend;	
	};

	
template <class _Ty, class _Ax>
	class _Move_operation_category<vector<_Ty, _Ax> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};

		
template<class _Ty,
	class _Alloc> inline
	bool operator==(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator!=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Ty,
	class _Alloc> inline
	void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}




typedef unsigned _Vbase;	
const int _VBITS = 8 * sizeof (_Vbase);	

		
template<class _MycontTy>
	class _Vb_iter_base
		: public _Ranit<_Bool, typename _MycontTy::difference_type,
			bool *, bool>
	{	
public:

	typedef _Range_checked_iterator_tag _Checked_iterator_category;
#line 1330 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

	_Vb_iter_base()
		: _Myptr(0), _Myoff(0)
		{	
		}

 
	_Vb_iter_base(const _Vb_iter_base<_MycontTy>& _Right)
		: _Myptr(_Right._Myptr), _Myoff(_Right._Myoff)
		{	
		{ if (!(_Right._Mycont != 0)) { (void) ((!!((("_Right._Mycont != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1340, 0, L"(\"_Right._Mycont != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1340, 0); } ; };
		this->_Adopt(_Right._Mycont);
		}

	_Vb_iter_base(_Vbase *_Ptr, _MycontTy *_Mypvbool)
		: _Myptr(_Ptr), _Myoff(0)
		{	
		{ if (!(_Mypvbool != 0)) { (void) ((!!((("_Mypvbool != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1347, 0, L"(\"_Mypvbool != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1347, 0); } ; };
		this->_Adopt(_Mypvbool);
		}

 

























#line 1378 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

	_Vbase *_Myptr;
	typename _MycontTy::size_type _Myoff;

	static void _Xlen()
		{	
		throw length_error("vector<bool> too long");
			}

	static void _Xran()
		{	
		throw out_of_range("invalid vector<bool> subscript");
		}

	static void _Xinvarg()
		{	
		throw invalid_argument("invalid vector<bool> argument");
		}

 
	_Vbase * _My_cont_begin() const
		{
			return (((_MycontTy *)this->_Mycont)->_Myvec.begin())._Myptr;
		}

	typename _MycontTy::size_type _My_actual_offset() const
		{
		_MycontTy::size_type _Off = this->_Myoff;
		_Off += _VBITS * (this->_Myptr - _My_cont_begin());
		return _Off;
		}
 #line 1410 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"
	};

		
template<class _MycontTy>
	class _Vb_reference
		: public _Vb_iter_base<_MycontTy>
	{	
public:
	_Vb_reference()
		{	
		}

	_Vb_reference(const _Vb_iter_base<_MycontTy>& _Right)
		: _Vb_iter_base<_MycontTy>(_Right)
		{	
		}

	_Vb_reference& operator=(const _Vb_reference<_MycontTy>& _Right)
		{	
		return (*this = bool(_Right));
		}

	_Vb_reference<_MycontTy>& operator=(bool _Val)
		{	
		if (_Val)
			*_Getptr() |= _Mask();
		else
			*_Getptr() &= ~_Mask();
		return (*this);
		}

	void flip()
		{	
		*_Getptr() ^= _Mask();
		}

	bool operator~() const
		{	
		return (!bool(*this));
		}

	operator bool() const
		{	
		return ((*_Getptr() & _Mask()) != 0);
		}

	_Vbase *_Getptr() const
		{	

 
		if (this->_Mycont == 0 || this->_Myptr == 0
			|| ((_MycontTy *)this->_Mycont)->_Mysize <= this->_My_actual_offset())
			{
			_Debug_message(L"vector<bool> iterator not dereferencable", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1463);
			{ (void) ((!!((("Standard C++ Libraries Out of Range", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1464, 0, L"(\"Standard C++ Libraries Out of Range\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1464, 0); };
			}
 


#line 1470 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		return (this->_Myptr);
		}

protected:
	_Vbase _Mask() const
		{	
		return ((_Vbase)(1 << this->_Myoff));
		}
	};

template<class _MycontTy>
	void swap(_Vb_reference<_MycontTy> _Left, _Vb_reference<_MycontTy> _Right)
	{	
	bool _Val = _Left;
	_Left = _Right;
	_Right = _Val;
	}

		
template<class _MycontTy>
	class _Vb_const_iterator
		: public _Vb_iter_base<_MycontTy>
	{	
public:
	typedef _Vb_reference<_MycontTy> _Reft;
	typedef bool const_reference;

	typedef random_access_iterator_tag iterator_category;
	typedef _Bool value_type;
	typedef typename _MycontTy::size_type size_type;
	typedef typename _MycontTy::difference_type difference_type;
	typedef const_reference *pointer;
	typedef const_reference reference;

	_Vb_const_iterator()
		{	
		}

 
	_Vb_const_iterator(const _Vbase *_Ptr, const _MycontTy *_Mypvbool)
		: _Vb_iter_base<_MycontTy>((_Vbase *)_Ptr, (_MycontTy *)_Mypvbool)

 



#line 1518 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"
		{	
		}

	const_reference operator*() const
		{	
		return (_Reft(*this));
		}

	_Vb_const_iterator<_MycontTy>& operator++()
		{	
		_Inc();
		return (*this);
		}

	_Vb_const_iterator<_MycontTy> operator++(int)
		{	
		_Vb_const_iterator<_MycontTy> _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Vb_const_iterator<_MycontTy>& operator--()
		{	
		_Dec();
		return (*this);
		}

	_Vb_const_iterator<_MycontTy> operator--(int)
		{	
		_Vb_const_iterator<_MycontTy> _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Vb_const_iterator<_MycontTy>& operator+=(difference_type _Off)
		{	
		if (_Off == 0)
			return (*this); 
		{ if (!(this->_Mycont != 0 && this->_Myptr != 0)) { (void) ((!!((("this->_Mycont != NULL && this->_Myptr != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1556, 0, L"(\"this->_Mycont != NULL && this->_Myptr != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1556, 0); } ; };
		if (_Off < 0)
			{
			{ if (!(this->_My_actual_offset() >= ((size_type)-_Off))) { (void) ((!!((("this->_My_actual_offset() >= ((size_type)-_Off)", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1559, 0, L"(\"this->_My_actual_offset() >= ((size_type)-_Off)\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1559, 0); } ; };
			}
		else
			{
			{ if (!((this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Mycont)->_Mysize)) { (void) ((!!((("(this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Mycont)->_Mysize", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1563, 0, L"(\"(this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Mycont)->_Mysize\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1563, 0); } ; };
			}
		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)
			{	
			this->_Myoff += _Off;
			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;
			this->_Myoff %= _VBITS;
			}
		else
			{	
			this->_Myoff += _Off;
			this->_Myptr += this->_Myoff / _VBITS;
			this->_Myoff %= _VBITS;
			}
		return (*this);
		}

	_Vb_const_iterator<_MycontTy> operator+(difference_type _Off) const
		{	
		_Vb_const_iterator<_MycontTy> _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Vb_const_iterator<_MycontTy>& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Vb_const_iterator<_MycontTy> operator-(difference_type _Off) const
		{	
		_Vb_const_iterator<_MycontTy> _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(
		const _Vb_const_iterator<_MycontTy>& _Right) const
		{	

 
		_Compat(_Right);
 #line 1604 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		return (_VBITS * (this->_Myptr - _Right._Myptr)
			+ (difference_type)this->_Myoff
			- (difference_type)_Right._Myoff);
		}

	const_reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Vb_const_iterator<_MycontTy>& _Right) const
		{	

 
		_Compat(_Right);
 #line 1621 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		return (this->_Myptr == _Right._Myptr
			&& this->_Myoff == _Right._Myoff);
		}

	bool operator!=(const _Vb_const_iterator<_MycontTy>& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Vb_const_iterator<_MycontTy>& _Right) const
		{	

 
		_Compat(_Right);
 #line 1637 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		return (this->_Myptr < _Right._Myptr
			|| this->_Myptr == _Right._Myptr
				&& this->_Myoff < _Right._Myoff);
		}

	bool operator>(const _Vb_const_iterator<_MycontTy>& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Vb_const_iterator<_MycontTy>& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Vb_const_iterator<_MycontTy>& _Right) const
		{	
		return (!(*this < _Right));
		}

protected:

 
	void _Compat(const _Vb_const_iterator<_MycontTy>& _Right) const
		{	
		if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
			_Debug_message(L"vector<bool> iterators incompatible", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1664);
		}
 #line 1667 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

	void _Dec()
		{	
		if (this->_Myoff != 0)
			{
			--this->_Myoff;
			}
		else
			{
			{ if (!(this->_Mycont != 0 && this->_Myptr != 0)) { (void) ((!!((("this->_Mycont != NULL && this->_Myptr != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1676, 0, L"(\"this->_Mycont != NULL && this->_Myptr != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1676, 0); } ; };
			{ if (!(this->_Myptr > this->_My_cont_begin())) { (void) ((!!((("this->_Myptr > this->_My_cont_begin()", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1677, 0, L"(\"this->_Myptr > this->_My_cont_begin()\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1677, 0); } ; };
			--this->_Myptr;
			this->_Myoff = _VBITS - 1;
			}
		}

	void _Inc()
		{	
		{ if (!(this->_Mycont != 0 && this->_Myptr != 0)) { (void) ((!!((("this->_Mycont != NULL && this->_Myptr != NULL", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1685, 0, L"(\"this->_Mycont != NULL && this->_Myptr != NULL\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1685, 0); } ; };
		{ if (!((this->_My_actual_offset() + 1) <= ((_MycontTy *)this->_Mycont)->_Mysize)) { (void) ((!!((("(this->_My_actual_offset() + 1) <= ((_MycontTy *)this->_Mycont)->_Mysize", 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1686, 0, L"(\"(this->_My_actual_offset() + 1) <= ((_MycontTy *)this->_Mycont)->_Mysize\", 0)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 1686, 0); } ; };
		if (this->_Myoff < _VBITS - 1)
			++this->_Myoff;
		else
			this->_Myoff = 0, ++this->_Myptr;
		}
	};

template<class _MycontTy>
	_Vb_const_iterator<_MycontTy> operator+(
		typename _Vb_const_iterator<_MycontTy>::difference_type _Off,
		_Vb_const_iterator<_MycontTy> _Right)
		{	
		return (_Right += _Off);
		}

	
template<class _MycontTy>
	class _Vb_iterator
		: public _Vb_const_iterator<_MycontTy>
	{	
public:
	typedef _Vb_reference<_MycontTy> _Reft;
	typedef bool const_reference;

	typedef random_access_iterator_tag iterator_category;
	typedef _Bool value_type;
	typedef typename _MycontTy::size_type size_type;
	typedef typename _MycontTy::difference_type difference_type;
	typedef _Reft *pointer;
	typedef _Reft reference;

	_Vb_iterator()
		{	
		}

 
	_Vb_iterator(_Vbase *_Ptr, _MycontTy *_Mypvbool)
		: _Vb_const_iterator<_MycontTy>(_Ptr, _Mypvbool)

 


#line 1730 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		{	
		}

	reference operator*() const
		{	
		return (_Reft(*this));
		}

	_Vb_iterator<_MycontTy>& operator++()
		{	
		++*(_Vb_const_iterator<_MycontTy> *)this;
		return (*this);
		}

	_Vb_iterator<_MycontTy> operator++(int)
		{	
		_Vb_iterator<_MycontTy> _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Vb_iterator<_MycontTy>& operator--()
		{	
		--*(_Vb_const_iterator<_MycontTy> *)this;
		return (*this);
		}

	_Vb_iterator<_MycontTy> operator--(int)
		{	
		_Vb_iterator<_MycontTy> _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Vb_iterator<_MycontTy>& operator+=(difference_type _Off)
		{	
		*(_Vb_const_iterator<_MycontTy> *)this += _Off;
		return (*this);
		}

	_Vb_iterator<_MycontTy> operator+(difference_type _Off) const
		{	
		_Vb_iterator<_MycontTy> _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Vb_iterator<_MycontTy>& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Vb_iterator<_MycontTy> operator-(difference_type _Off) const
		{	
		_Vb_iterator<_MycontTy> _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Vb_const_iterator<_MycontTy>& _Right) const
		{	
		return (*(_Vb_const_iterator<_MycontTy> *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _MycontTy>
	_Vb_iterator<_MycontTy> operator+(
		typename _Vb_iterator<_MycontTy>::difference_type _Off,
		_Vb_iterator<_MycontTy> _Right)
		{	
		return (_Right += _Off);
		}

		
template<class _Alloc>
	class vector<_Bool, _Alloc>
		: public _Container_base
	{	
public:
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type _Dift;
	typedef std::vector<_Vbase,
		typename _Alloc::template rebind<_Vbase>::other>
			_Vbtype;
	typedef std::vector<_Bool, _Alloc> _Myt;
	typedef _Dift difference_type;
	typedef _Bool _Ty;
	typedef _Alloc allocator_type;

	typedef _Vb_reference<_Myt> reference;
	typedef bool const_reference;
	typedef bool value_type;

	typedef reference _Reft;
	typedef _Vb_const_iterator<_Myt> const_iterator;
	typedef _Vb_iterator<_Myt> iterator;

	friend class _Vb_reference<_Myt>;
	friend class _Vb_iter_base<_Myt>;
	friend class _Vb_const_iterator<_Myt>;

	typedef iterator pointer;
	typedef const_iterator const_pointer;
	typedef std::reverse_iterator<iterator> reverse_iterator;
	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

	vector()
		: _Mysize(0), _Myvec()
		{	
		}

	explicit vector(const _Alloc& _Al)
		: _Mysize(0), _Myvec(_Al)
		{	
		}

	explicit vector(size_type _Count, bool _Val = false)
		: _Mysize(0), _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0))
		{	
		_Trim(_Count);
		}

	vector(size_type _Count, bool _Val, const _Alloc& _Al)
		: _Mysize(0), _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)
		{	
		_Trim(_Count);
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last)
		: _Mysize(0), _Myvec()
		{	
		_BConstruct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mysize(0), _Myvec(_Al)
		{	
		_BConstruct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _BConstruct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{	
		size_type _Num = (size_type)_Count;
		_Myvec.assign(_Num, (_Ty)_Val ? -1 : 0);
		_Trim(_Num);
		}

	template<class _Iter>
		void _BConstruct(_Iter _First, _Iter _Last, input_iterator_tag)
		{	
		insert(begin(), _First, _Last);
		}

	~vector()
		{	
		_Mysize = 0;
		}

	void reserve(size_type _Count)
		{	
		_Myvec.reserve(_Nw(_Count));
		}

	size_type capacity() const
		{	
		return (_Myvec.capacity() * _VBITS);
		}

 
	iterator begin()
		{	
		return (iterator((_Myvec.begin())._Myptr, this));
		}

	const_iterator begin() const
		{	
		return (const_iterator((_Myvec.begin())._Myptr, this));
		}

 









#line 1927 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

	iterator end()
		{	
		iterator _Tmp = begin();
		if (0 < _Mysize)
			_Tmp += _Mysize;
		return (_Tmp);
		}

	const_iterator end() const
		{	
		const_iterator _Tmp = begin();
		if (0 < _Mysize)
			_Tmp += _Mysize;
		return (_Tmp);
		}

	reverse_iterator rbegin()
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend()
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const
		{	
		return (const_reverse_iterator(begin()));
		}

	void resize(size_type _Newsize, bool _Val = false)
		{	
		if (size() < _Newsize)
			_Insert_n(end(), _Newsize - size(), _Val);
		else if (_Newsize < size())
			erase(begin() + _Newsize, end());
		}

	size_type size() const
		{	
		return (_Mysize);
		}

	size_type max_size() const
		{	
		const size_type _Maxsize = _Myvec.max_size();
		return (_Maxsize < (size_type)(-1) / _VBITS
			? _Maxsize * _VBITS : (size_type)(-1));
		}

	bool empty() const
		{	
		return (size() == 0);
		}

	_Alloc get_allocator() const
		{	
		return (_Myvec.get_allocator());
		}

	const_reference at(size_type _Off) const
		{	
		if (size() <= _Off)
			_Xran();
		return (*(begin() + _Off));
		}

	reference at(size_type _Off)
		{	
		if (size() <= _Off)
			_Xran();
		return (*(begin() + _Off));
		}

	const_reference operator[](size_type _Off) const
		{	
		return (*(begin() + _Off));
		}

	reference operator[](size_type _Off)
		{	
		return (*(begin() + _Off));
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	void push_back(bool _Val)
		{	
		insert(end(), _Val);
		}

	void pop_back()
		{	
		if (!empty())
			erase(end() - 1);
		}

	template<class _Iter>
		void assign(_Iter _First, _Iter _Last)
		{	
		_Assign(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{	
		_Assign_n((size_type)_Count, (bool)_Val);
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{	
		erase(begin(), end());
		insert(begin(), _First, _Last);
		}

	void assign(size_type _Count, bool _Val)
		{	
		_Assign_n(_Count, _Val);
		}

	iterator insert(iterator _Where, bool _Val)
		{	
		size_type _Off = _Where - begin();
		_Insert_n(_Where, (size_type)1, _Val);
		return (begin() + _Off);
		}

	void insert(iterator _Where, size_type _Count, bool _Val)
		{	
		_Insert_n(_Where, _Count, _Val);
		}

	template<class _Iter>
		void insert(iterator _Where, _Iter _First, _Iter _Last)
		{	
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _Count, _Iter _Val,
			_Int_iterator_tag)
		{	
		_Insert_n(_Where, (size_type)_Count, (bool)_Val);
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last,
			input_iterator_tag)
		{	
		size_type _Off = _Where - begin();

		for (; _First != _Last; ++_First, ++_Off)
			insert(begin() + _Off, *_First);
		}

	template<class _Iter>
		void _Insert(iterator _Where,
			_Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	

 
		_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 2115);
		if (_Debug_get_cont(_First) == this)
			_Debug_message(L"vector<bool> insertion overlaps range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 2117);
 #line 2119 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		size_type _Count = 0;
		_Distance(_First, _Last, _Count);

		size_type _Off = _Insert_x(_Where, _Count);
		std::copy(_First, _Last, begin() + _Off);
		}

	iterator erase(iterator _Where)
		{	
		size_type _Off = _Where - begin();

 
		if (end() <= _Where)
			_Debug_message(L"vector<bool> erase iterator outside range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 2133);
		std::copy(_Where + 1, end(), _Where);
		_Orphan_range(_Off, _Mysize);

 

#line 2140 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		_Trim(_Mysize - 1);
		return (begin() + _Off);
		}

	iterator erase(iterator _First, iterator _Last)
		{	
		size_type _Off = _First - begin();

 
		if (_Last < _First || end() < _Last)
			_Debug_message(L"vector<bool> erase iterator outside range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 2151);
		iterator _Next = std::copy(_Last, end(), _First);
		size_type _Newsize = _Next - begin();
		_Orphan_range(_Newsize, _Mysize);
		_Trim(_Newsize);

 


#line 2161 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		return (begin() + _Off);
		}

	void clear()
		{	
		erase(begin(), end());
		}

	void flip()
		{	
		for (_Vbtype::iterator _Next = _Myvec.begin();
			_Next != _Myvec.end(); ++_Next)
			*_Next = (_Vbase)~*_Next;
		_Trim(_Mysize);
		}

	void swap(_Myt& _Right)
		{	

 
			this->_Swap_all(_Right);
 #line 2184 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		std::swap(_Mysize, _Right._Mysize);
		_Myvec.swap(_Right._Myvec);
		}

	static void swap(reference _Left, reference _Right)
		{	
		bool _Val = _Left;
		_Left = _Right;
		_Right = _Val;
		}


protected:
	void _Assign_n(size_type _Count, bool _Val)
		{	
		erase(begin(), end());
		_Insert_n(begin(), _Count, _Val);
		}

	void _Insert_n(iterator _Where,
		size_type _Count, bool _Val)
		{	
		size_type _Off = _Insert_x(_Where, _Count);
		fill(begin() + _Off, begin() + (_Off + _Count), _Val);
		}

	size_type _Insert_x(iterator _Where, size_type _Count)
		{	
		size_type _Off = _Where - begin();

 
		if (end() < _Where)
			_Debug_message(L"vector<bool> insert iterator outside range", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector", 2217);
		bool _Realloc = capacity() - size() < _Count;
 #line 2220 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

		if (_Count == 0)
			;
		else if (max_size() - size() < _Count)
			_Xlen();	
		else
			{	
			_Myvec.resize(_Nw(size() + _Count), 0);
			if (size() == 0)
				_Mysize += _Count;
			else
				{	
				iterator _Oldend = end();
				_Mysize += _Count;
				copy_backward(begin() + _Off, _Oldend, end());
				}

 
			_Orphan_range(_Realloc ? 0 : _Off, _Mysize);
 #line 2240 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

			}
		return (_Off);
		}

	static size_type _Nw(size_type _Count)
		{	
		return ((_Count + _VBITS - 1) / _VBITS);
		}

 
	void _Orphan_range(size_type _Offlo, size_type _Offhi) const
		{	
		_Lockit _Lock(3);
		_Vbase *_Base = (_Vbase *)(_Myvec.begin())._Myptr;

		_Vb_iter_base<_Myt> **_Pnext =
			(_Vb_iter_base<_Myt> **)&this->_Myfirstiter;
		while (*_Pnext != 0)
			{	
			size_type _Off = _VBITS * ((*_Pnext)->_Myptr - _Base)
				+ (*_Pnext)->_Myoff;
			if (_Off < _Offlo || _Offhi < _Off)
				_Pnext = (_Vb_iter_base<_Myt> **)&(*_Pnext)->_Mynextiter;
			else
				{	
				(*_Pnext)->_Mycont = 0;
				*_Pnext = (_Vb_iter_base<_Myt> *)(*_Pnext)->_Mynextiter;
				}
			}
		}
 #line 2272 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

	void _Trim(size_type _Size)
		{	
		if (max_size() < _Size)
			_Xlen();	
		size_type _Words = _Nw(_Size);

		if (_Words < _Myvec.size())
			_Myvec.erase(_Myvec.begin() + _Words, _Myvec.end());
		_Mysize = _Size;
		_Size %= _VBITS;
		if (0 < _Size)
			_Myvec[_Words - 1] &= (_Vbase)((1 << _Size) - 1);
		}

	void _Xlen() const
		{	
		throw length_error("vector<bool> too long");
		}

	void _Xran() const
		{	
		throw out_of_range("invalid vector<bool> subscript");
		}

	size_type _Mysize;	
	_Vbtype _Myvec;	
	};

typedef vector<bool, allocator<bool> > _Bvector;
}


  #pragma warning(default: 4244)
#pragma warning(pop)
#pragma pack(pop)
#line 2309 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"

#line 2311 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"
#line 2312 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector"























#line 8 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\bbb_GLWidget.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"


	
	
	
	
	
	
	
	
	
	#pragma warning( disable : 4003 ) 

	
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AABox.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Point.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_Assert.h"





#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\assert.h"













#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 15 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\assert.h"










extern "C" {
#line 27 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\assert.h"

__declspec(dllimport) void __cdecl _wassert(       const wchar_t * _Message,        const wchar_t *_File,      unsigned _Line);


}
#line 33 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\assert.h"



#line 37 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\assert.h"
#line 7 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_Assert.h"



#line 11 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_Assert.h"


#line 14 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_Assert.h"
#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h"

namespace gmtl
{









template<class DATA_TYPE, unsigned SIZE>
class VecBase
{
public:
   
   typedef DATA_TYPE DataType;

   
   enum { Size = SIZE };

public:
   





   VecBase() {}

   




   VecBase(const VecBase<DATA_TYPE, SIZE>& rVec);

   
   


   VecBase(const DATA_TYPE& val0,const DATA_TYPE& val1);
   VecBase(const DATA_TYPE& val0,const DATA_TYPE& val1,const DATA_TYPE& val2);
   VecBase(const DATA_TYPE& val0,const DATA_TYPE& val1,const DATA_TYPE& val2,const DATA_TYPE& val3);
   

   





   inline void set(const DATA_TYPE* dataPtr);

   
   


   inline void set(const DATA_TYPE& val0);
   inline void set(const DATA_TYPE& val0,const DATA_TYPE& val1);
   inline void set(const DATA_TYPE& val0,const DATA_TYPE& val1,const DATA_TYPE& val2);
   inline void set(const DATA_TYPE& val0,const DATA_TYPE& val1,const DATA_TYPE& val2,const DATA_TYPE& val3);
   

   
   







   inline DATA_TYPE& operator [](const unsigned i)
   {
      (void)( (!!((i < SIZE))) || (_wassert(L"(i < SIZE)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h", 115), 0) );
      return mData[i];
   }
   inline const DATA_TYPE&  operator [](const unsigned i) const
   {
      (void)( (!!((i < SIZE))) || (_wassert(L"(i < SIZE)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h", 120), 0) );
      return mData[i];
   }
   

   
   




   DATA_TYPE* getData()
   { return mData; }
   const DATA_TYPE* getData() const
   { return mData; }
   

public:
   
   DATA_TYPE mData[SIZE];
};


template<class DATA_TYPE, unsigned SIZE>
VecBase<DATA_TYPE,SIZE>::VecBase(const VecBase<DATA_TYPE, SIZE>& rVec)
{
   for(unsigned i=0;i<SIZE;++i)
      mData[i] = rVec.mData[i];
}

template<class DATA_TYPE, unsigned SIZE>
VecBase<DATA_TYPE,SIZE>::VecBase(const DATA_TYPE& val0,const DATA_TYPE& val1)
{
   
   (void)( (!!((SIZE == 2 && "out of bounds element access in VecBase"))) || (_wassert(L"(SIZE == 2 && \"out of bounds element access in VecBase\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h", 154), 0) );
   mData[0] = val0;
   mData[1] = val1;
}

template<class DATA_TYPE, unsigned SIZE>
VecBase<DATA_TYPE,SIZE>::VecBase(const DATA_TYPE& val0,const DATA_TYPE& val1,const DATA_TYPE& val2)
{
   
   (void)( (!!((SIZE == 3 && "out of bounds element access in VecBase"))) || (_wassert(L"(SIZE == 3 && \"out of bounds element access in VecBase\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h", 163), 0) );
   mData[0] = val0;
   mData[1] = val1;
   mData[2] = val2;
}

template<class DATA_TYPE, unsigned SIZE>
VecBase<DATA_TYPE,SIZE>::VecBase(const DATA_TYPE& val0,const DATA_TYPE& val1,const DATA_TYPE& val2,const DATA_TYPE& val3)
{
   
   (void)( (!!((SIZE == 4 && "out of bounds element access in VecBase"))) || (_wassert(L"(SIZE == 4 && \"out of bounds element access in VecBase\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h", 173), 0) );
   mData[0] = val0;
   mData[1] = val1;
   mData[2] = val2;
   mData[3] = val3;
}



template<class DATA_TYPE, unsigned SIZE>
inline void VecBase<DATA_TYPE,SIZE>::set(const DATA_TYPE* dataPtr)
{
   for(unsigned i=0;i<SIZE;++i)
      mData[i] = dataPtr[i];
}
template<class DATA_TYPE, unsigned SIZE>
inline void VecBase<DATA_TYPE,SIZE>::set(const DATA_TYPE& val0)
{
   (void)( (!!((SIZE >= 1 && "out of bounds element access in VecBase"))) || (_wassert(L"(SIZE >= 1 && \"out of bounds element access in VecBase\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h", 191), 0) );
   mData[0] = val0;
}
template<class DATA_TYPE, unsigned SIZE>
inline void VecBase<DATA_TYPE,SIZE>::set(const DATA_TYPE& val0,const DATA_TYPE& val1)
{
   (void)( (!!((SIZE >= 2 && "out of bounds element access in VecBase"))) || (_wassert(L"(SIZE >= 2 && \"out of bounds element access in VecBase\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h", 197), 0) );
   mData[0] = val0;
   mData[1] = val1;
}
template<class DATA_TYPE, unsigned SIZE>
inline void VecBase<DATA_TYPE,SIZE>::set(const DATA_TYPE& val0,const DATA_TYPE& val1,const DATA_TYPE& val2)
{
   (void)( (!!((SIZE >= 3 && "out of bounds element access in VecBase"))) || (_wassert(L"(SIZE >= 3 && \"out of bounds element access in VecBase\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h", 204), 0) );
   mData[0] = val0;
   mData[1] = val1;
   mData[2] = val2;
}
template<class DATA_TYPE, unsigned SIZE>
inline void VecBase<DATA_TYPE,SIZE>::set(const DATA_TYPE& val0,const DATA_TYPE& val1,const DATA_TYPE& val2,const DATA_TYPE& val3)
{
   (void)( (!!((SIZE >= 4 && "out of bounds element access in VecBase"))) || (_wassert(L"(SIZE >= 4 && \"out of bounds element access in VecBase\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h", 212), 0) );
   mData[0] = val0;
   mData[1] = val1;
   mData[2] = val2;
   mData[3] = val3;
}

};

#line 222 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h"
#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Point.h"

namespace gmtl
{















template<class DATA_TYPE, unsigned SIZE>
class Point : public VecBase<DATA_TYPE, SIZE>
{
public:
   typedef DATA_TYPE DataType;
   enum { Size = SIZE };

   
   typedef VecBase<DATA_TYPE, SIZE> BaseType;

public:
   

   Point()
   {
      for (unsigned i = 0; i < SIZE; ++i)
         this->mData[i] = (DATA_TYPE)0;
   }

   


   
   Point(const Point<DATA_TYPE, SIZE>& rVec)
      : BaseType(static_cast<BaseType>(rVec))
   {;}
   Point(const VecBase<DATA_TYPE, SIZE>& rVec)
      : BaseType(rVec)
   {;}

   


   Point(const DATA_TYPE& val0,const DATA_TYPE& val1)
   : BaseType(val0, val1)
   {
      
      (void)( (!!((SIZE == 2 && "out of bounds element access in Point"))) || (_wassert(L"(SIZE == 2 && \"out of bounds element access in Point\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Point.h", 94), 0) );
   }

   


   Point(const DATA_TYPE& val0,const DATA_TYPE& val1,const DATA_TYPE& val2)
   : BaseType(val0, val1, val2)
   {
      
      (void)( (!!((SIZE == 3 && "out of bounds element access in Point"))) || (_wassert(L"(SIZE == 3 && \"out of bounds element access in Point\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Point.h", 104), 0) );
   }

   


   Point(const DATA_TYPE& val0,const DATA_TYPE& val1,const DATA_TYPE& val2,const DATA_TYPE& val3)
   : BaseType(val0, val1, val2, val3)
   {
      
      (void)( (!!((SIZE == 4 && "out of bounds element access in Point"))) || (_wassert(L"(SIZE == 4 && \"out of bounds element access in Point\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Point.h", 114), 0) );
   }
   

};


typedef Point<int,2> Point2i;
typedef Point<float,2> Point2f;
typedef Point<double,2> Point2d;
typedef Point<int, 3> Point3i;
typedef Point<float,3> Point3f;
typedef Point<double,3> Point3d;
typedef Point<int, 4> Point4i;
typedef Point<float,4> Point4f;
typedef Point<double,4> Point4d;


};

#line 135 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Point.h"
#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AABox.h"

namespace gmtl
{
   







   template< class DATA_TYPE >
   class AABox
   {
   public:
      typedef DATA_TYPE DataType;

   public:
      


      AABox()
         : mMin(0,0,0), mMax(0,0,0), mEmpty(true)
      {}

      








      AABox(const Point<DATA_TYPE, 3>& min, const Point<DATA_TYPE, 3>& max)
         : mMin(min), mMax(max), mEmpty(false)
      {}

      




      AABox(const AABox<DATA_TYPE>& box)
         : mMin(box.mMin), mMax(box.mMax), mEmpty(box.mEmpty)
      {}

      




      const Point<DATA_TYPE, 3>& getMin() const
      {
         return mMin;
      }

      




      const Point<DATA_TYPE, 3>& getMax() const
      {
         return mMax;
      }

      




      bool isEmpty() const
      {
         return mEmpty;
      }

      




      void setMin(const Point<DATA_TYPE, 3>& min)
      {
         mMin = min;
      }

      




      void setMax(const Point<DATA_TYPE, 3>& max)
      {
         mMax = max;
      }

      




      void setEmpty(bool empty)
      {
         mEmpty = empty;
      }

   public:
      


      Point<DATA_TYPE, 3> mMin;

      


      Point<DATA_TYPE, 3> mMax;

      


      bool mEmpty;
   };

   
   typedef AABox<float>    AABoxf;
   typedef AABox<double>   AABoxd;
}

#line 169 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AABox.h"
#line 16 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AABoxOps.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AABox.h"








































































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AABoxOps.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecOps.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Defines.h"





































namespace gmtl
{
   











   enum VectorIndex { Xelt = 0, Yelt = 1, Zelt = 2, Welt = 3 };

   






   enum PlaneSide
   {
      ON_PLANE,
      POS_SIDE,
      NEG_SIDE
   };

   


    
   const float GMTL_EPSILON = 1.0e-6f;
   const float GMTL_MAT_EQUAL_EPSILON = 0.001f;  
   const float GMTL_VEC_EQUAL_EPSILON = 0.0001f; 
   
   


};
















#line 97 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Defines.h"


#line 100 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Defines.h"
#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecOps.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"





































#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"

















#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 19 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"






#pragma pack(push,8)
#line 27 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"


extern "C" {
#line 31 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"








struct _exception {
        int type;       
        char *name;     
        double arg1;    
        double arg2;    
        double retval;  
        } ;


#line 49 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"







struct _complex {
        double x,y; 
        } ;




#line 64 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"


#line 67 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"
#line 68 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"






















__declspec(dllimport) extern double _HUGE;


#line 94 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"
#line 95 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"












        double  __cdecl acos(     double _X);
        double  __cdecl asin(     double _X);
        double  __cdecl atan(     double _X);
        double  __cdecl atan2(     double _Y,      double _X);

__declspec(dllimport)  double __cdecl _copysign (     double _Number,      double _Sign);
__declspec(dllimport)  double __cdecl _chgsign (     double _X);

#line 116 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"
        double  __cdecl cos(     double _X);
        double  __cdecl cosh(     double _X);
        double  __cdecl exp(     double _X);
 double  __cdecl fabs(     double _X);
        double  __cdecl fmod(     double _X,      double _Y);
        double  __cdecl log(     double _X);
        double  __cdecl log10(     double _X);
        double  __cdecl pow(     double _X,      double _Y);
        double  __cdecl sin(     double _X);
        double  __cdecl sinh(     double _X);
        double  __cdecl tan(     double _X);
        double  __cdecl tanh(     double _X);
        double  __cdecl sqrt(     double _X);






__declspec(dllimport) double  __cdecl _cabs(     struct _complex _Complex);
__declspec(dllimport) double  __cdecl ceil(     double _X);
__declspec(dllimport) double  __cdecl floor(     double _X);
__declspec(dllimport) double  __cdecl frexp(     double _X,      int * _Y);
__declspec(dllimport) double  __cdecl _hypot(     double _X,      double _Y);
__declspec(dllimport) double  __cdecl _j0(     double _X );
__declspec(dllimport) double  __cdecl _j1(     double _X );
__declspec(dllimport) double  __cdecl _jn(int _X,      double _Y);
__declspec(dllimport) double  __cdecl ldexp(     double _X,      int _Y);




#line 149 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"
        int     __cdecl _matherr(     struct _exception * _Except);
#line 151 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"
#line 152 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"
__declspec(dllimport) double  __cdecl modf(     double _X,      double * _Y);

__declspec(dllimport) double  __cdecl _y0(     double _X);
__declspec(dllimport) double  __cdecl _y1(     double _X);
__declspec(dllimport) double  __cdecl _yn(     int _X,      double _Y);




__declspec(dllimport) int     __cdecl _set_SSE2_enable(     int _Flag);
__declspec(dllimport) float  __cdecl _hypotf(     float _X,      float _Y);

#line 165 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"







































#line 205 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"













































#line 251 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"


































































inline long double acosl(     long double _X)
        {return (acos((double)_X)); }
inline long double asinl(     long double _X)
        {return (asin((double)_X)); }
inline long double atanl(     long double _X)
        {return (atan((double)_X)); }
inline long double atan2l(     long double _X,      long double _Y)
        {return (atan2((double)_X, (double)_Y)); }
inline long double ceill(     long double _X)
        {return (ceil((double)_X)); }
inline long double cosl(     long double _X)
        {return (cos((double)_X)); }
inline long double coshl(     long double _X)
        {return (cosh((double)_X)); }
inline long double expl(     long double _X)
        {return (exp((double)_X)); }
inline long double fabsl(     long double _X)
        {return (fabs((double)_X)); }
inline long double floorl(     long double _X)
        {return (floor((double)_X)); }
inline long double fmodl(     long double _X,      long double _Y)
        {return (fmod((double)_X, (double)_Y)); }
inline long double frexpl(     long double _X,      int *_Y)
        {return (frexp((double)_X, _Y)); }
inline long double ldexpl(     long double _X,      int _Y)
        {return (ldexp((double)_X, _Y)); }
inline long double logl(     long double _X)
        {return (log((double)_X)); }
inline long double log10l(     long double _X)
        {return (log10((double)_X)); }
inline long double modfl(     long double _X,      long double *_Y)
        {double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (long double)_Di;
        return (_Df); }
inline long double powl(     long double _X,      long double _Y)
        {return (pow((double)_X, (double)_Y)); }
inline long double sinl(     long double _X)
        {return (sin((double)_X)); }
inline long double sinhl(     long double _X)
        {return (sinh((double)_X)); }
inline long double sqrtl(     long double _X)
        {return (sqrt((double)_X)); }

inline long double tanl(     long double _X)
        {return (tan((double)_X)); }


#line 365 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"

inline long double tanhl(     long double _X)
        {return (tanh((double)_X)); }

inline long double _chgsignl(     long double _Number)
{
    return _chgsign(static_cast<double>(_Number)); 
}

inline long double _copysignl(     long double _Number,      long double _Sign)
{
    return _copysign(static_cast<double>(_Number), static_cast<double>(_Sign)); 
}

inline float frexpf(     float _X,      int *_Y)
        {return ((float)frexp((double)_X, _Y)); }


inline float fabsf(     float _X)
        {return ((float)fabs((double)_X)); }
inline float ldexpf(     float _X,      int _Y)
        {return ((float)ldexp((double)_X, _Y)); }

inline float acosf(     float _X)
        {return ((float)acos((double)_X)); }
inline float asinf(     float _X)
        {return ((float)asin((double)_X)); }
inline float atanf(     float _X)
        {return ((float)atan((double)_X)); }
inline float atan2f(     float _X,      float _Y)
        {return ((float)atan2((double)_X, (double)_Y)); }
inline float ceilf(     float _X)
        {return ((float)ceil((double)_X)); }
inline float cosf(     float _X)
        {return ((float)cos((double)_X)); }
inline float coshf(     float _X)
        {return ((float)cosh((double)_X)); }
inline float expf(     float _X)
        {return ((float)exp((double)_X)); }
inline float floorf(     float _X)
        {return ((float)floor((double)_X)); }
inline float fmodf(     float _X,      float _Y)
        {return ((float)fmod((double)_X, (double)_Y)); }
inline float logf(     float _X)
        {return ((float)log((double)_X)); }
inline float log10f(     float _X)
        {return ((float)log10((double)_X)); }
inline float modff(     float _X,      float *_Y)
        { double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (float)_Di;
        return ((float)_Df); }
inline float powf(     float _X,      float _Y)
        {return ((float)pow((double)_X, (double)_Y)); }
inline float sinf(     float _X)
        {return ((float)sin((double)_X)); }
inline float sinhf(     float _X)
        {return ((float)sinh((double)_X)); }
inline float sqrtf(     float _X)
        {return ((float)sqrt((double)_X)); }
inline float tanf(     float _X)
        {return ((float)tan((double)_X)); }
inline float tanhf(     float _X)
        {return ((float)tanh((double)_X)); }
#line 429 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"
#line 430 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"
#line 431 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"
#line 432 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"

















__declspec(dllimport) extern double HUGE;


#line 453 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"

__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_cabs" ". See online help for details.")) __declspec(dllimport) double  __cdecl cabs(     struct _complex _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_hypot" ". See online help for details.")) __declspec(dllimport) double  __cdecl hypot(     double _X,      double _Y);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_j0" ". See online help for details.")) __declspec(dllimport) double  __cdecl j0(     double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_j1" ". See online help for details.")) __declspec(dllimport) double  __cdecl j1(     double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_jn" ". See online help for details.")) __declspec(dllimport) double  __cdecl jn(     int _X,      double _Y);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_y0" ". See online help for details.")) __declspec(dllimport) double  __cdecl y0(     double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_y1" ". See online help for details.")) __declspec(dllimport) double  __cdecl y1(     double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_yn" ". See online help for details.")) __declspec(dllimport) double  __cdecl yn(     int _X,      double _Y);

#line 464 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"

#line 466 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"


}

extern "C++" {

template<class _Ty> inline
        _Ty _Pow_int(_Ty _X, int _Y)
        {unsigned int _N;
        if (_Y >= 0)
                _N = (unsigned int)_Y;
        else
                _N = (unsigned int)(-_Y);
        for (_Ty _Z = _Ty(1); ; _X *= _X)
                {if ((_N & 1) != 0)
                        _Z *= _X;
                if ((_N >>= 1) == 0)
                        return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

inline long __cdecl abs(     long _X)
        {return (labs(_X)); }
inline double __cdecl abs(     double _X)
        {return (fabs(_X)); }
inline double __cdecl pow(     double _X,      int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl abs(     float _X)
        {return (fabsf(_X)); }
inline float __cdecl acos(     float _X)
        {return (acosf(_X)); }
inline float __cdecl asin(     float _X)
        {return (asinf(_X)); }
inline float __cdecl atan(     float _X)
        {return (atanf(_X)); }
inline float __cdecl atan2(     float _Y,      float _X)
        {return (atan2f(_Y, _X)); }
inline float __cdecl ceil(     float _X)
        {return (ceilf(_X)); }
inline float __cdecl cos(     float _X)
        {return (cosf(_X)); }
inline float __cdecl cosh(     float _X)
        {return (coshf(_X)); }
inline float __cdecl exp(     float _X)
        {return (expf(_X)); }
inline float __cdecl fabs(     float _X)
        {return (fabsf(_X)); }
inline float __cdecl floor(     float _X)
        {return (floorf(_X)); }
inline float __cdecl fmod(     float _X,      float _Y)
        {return (fmodf(_X, _Y)); }
inline float __cdecl frexp(     float _X,      int * _Y)
        {return (frexpf(_X, _Y)); }
inline float __cdecl ldexp(     float _X,      int _Y)
        {return (ldexpf(_X, _Y)); }
inline float __cdecl log(     float _X)
        {return (logf(_X)); }
inline float __cdecl log10(     float _X)
        {return (log10f(_X)); }
inline float __cdecl modf(     float _X,      float * _Y)
        {return (modff(_X, _Y)); }
inline float __cdecl pow(     float _X,      float _Y)
        {return (powf(_X, _Y)); }
inline float __cdecl pow(     float _X,      int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl sin(     float _X)
        {return (sinf(_X)); }
inline float __cdecl sinh(     float _X)
        {return (sinhf(_X)); }
inline float __cdecl sqrt(     float _X)
        {return (sqrtf(_X)); }
inline float __cdecl tan(     float _X)
        {return (tanf(_X)); }
inline float __cdecl tanh(     float _X)
        {return (tanhf(_X)); }
inline long double __cdecl abs(     long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl acos(     long double _X)
        {return (acosl(_X)); }
inline long double __cdecl asin(     long double _X)
        {return (asinl(_X)); }
inline long double __cdecl atan(     long double _X)
        {return (atanl(_X)); }
inline long double __cdecl atan2(     long double _Y,      long double _X)
        {return (atan2l(_Y, _X)); }
inline long double __cdecl ceil(     long double _X)
        {return (ceill(_X)); }
inline long double __cdecl cos(     long double _X)
        {return (cosl(_X)); }
inline long double __cdecl cosh(     long double _X)
        {return (coshl(_X)); }
inline long double __cdecl exp(     long double _X)
        {return (expl(_X)); }
inline long double __cdecl fabs(     long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl floor(     long double _X)
        {return (floorl(_X)); }
inline long double __cdecl fmod(     long double _X,      long double _Y)
        {return (fmodl(_X, _Y)); }
inline long double __cdecl frexp(     long double _X,      int * _Y)
        {return (frexpl(_X, _Y)); }
inline long double __cdecl ldexp(     long double _X,      int _Y)
        {return (ldexpl(_X, _Y)); }
inline long double __cdecl log(     long double _X)
        {return (logl(_X)); }
inline long double __cdecl log10(     long double _X)
        {return (log10l(_X)); }
inline long double __cdecl modf(     long double _X,      long double * _Y)
        {return (modfl(_X, _Y)); }
inline long double __cdecl pow(     long double _X,      long double _Y)
        {return (powl(_X, _Y)); }
inline long double __cdecl pow(     long double _X,      int _Y)
        {return (_Pow_int(_X, _Y)); }
inline long double __cdecl sin(     long double _X)
        {return (sinl(_X)); }
inline long double __cdecl sinh(     long double _X)
        {return (sinhl(_X)); }
inline long double __cdecl sqrt(     long double _X)
        {return (sqrtl(_X)); }
inline long double __cdecl tan(     long double _X)
        {return (tanl(_X)); }
inline long double __cdecl tanh(     long double _X)
        {return (tanhl(_X)); }

}
#line 590 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"


#pragma pack(pop)
#line 594 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"

#line 596 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"







































#line 636 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"

#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"

#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Defines.h"



































































































#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_Assert.h"













#line 42 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"

namespace gmtl
{





struct RotationOrderBase { enum { IS_ROTORDER = 1 }; };



struct XYZ : public RotationOrderBase { enum { ID = 0 }; };



struct ZYX : public RotationOrderBase { enum { ID = 1 }; };



struct ZXY : public RotationOrderBase { enum { ID = 2 }; };

namespace Math
{
   



   const float PI = 3.14159265358979323846f; 
   const float PI_OVER_2 = 1.57079632679489661923f;
   const float PI_OVER_4 = 0.78539816339744830962f;
   

   




template <typename T>
inline T abs( T iValue )
{
    return T( iValue >= ((T)0) ? iValue : -iValue );
}

template <typename T>
inline T ceil( T fValue );
inline float ceil( float fValue )
{



   return float( ::ceilf( fValue ) );
#line 95 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"
}
inline double ceil( double fValue )
{
    return double( ::ceil( fValue ) );
}

template <typename T>
inline T floor( T fValue ); 
inline float floor( float fValue )
{



   return float( ::floorf( fValue ) );
#line 110 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"
}
inline double floor( double fValue )
{
    return double( ::floor( fValue ) );
}

template <typename T>
inline int sign( T iValue )
{
   if (iValue > T(0))
   {
      return 1;
   }
   else
   {
      if (iValue < T(0))
      {
         return -1;
      }
      else
      {
         return 0;
      }
   }
}









template <typename T>
inline T zeroClamp( T value, T eps = T(0) )
{
   return ( (gmtl::Math::abs(value) <= eps) ? T(0) : value );
}





template <typename T>
inline T aCos( T fValue );
inline float aCos( float fValue )
{
    if ( -1.0f < fValue )
    {
        if ( fValue < 1.0f )
        {



            return float( ::acosf( fValue ) );
#line 167 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"
        }
        else
            return 0.0f;
    }
    else
    {
        return (float)gmtl::Math::PI;
    }
}
inline double aCos( double fValue )
{
    if ( -1.0 < fValue )
    {
        if ( fValue < 1.0 )
            return double( ::acos( fValue ) );
        else
            return 0.0;
    }
    else
    {
        return (double)gmtl::Math::PI;
    }
}

template <typename T>
inline T aSin( T fValue );
inline float aSin( float fValue )
{
    if ( -1.0f < fValue )
    {
        if ( fValue < 1.0f )
        {



            return float( ::asinf( fValue ) );
#line 204 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"
        }
        else
            return (float)-gmtl::Math::PI_OVER_2;
    }
    else
    {
        return (float)gmtl::Math::PI_OVER_2;
    }
}
inline double aSin( double fValue )
{
    if ( -1.0 < fValue )
    {
        if ( fValue < 1.0 )
            return double( ::asin( fValue ) );
        else
            return (double)-gmtl::Math::PI_OVER_2;
    }
    else
    {
        return (double)gmtl::Math::PI_OVER_2;
    }
}

template <typename T>
inline T aTan( T fValue );
inline double aTan( double fValue )
{
    return ::atan( fValue );
}
inline float aTan( float fValue )
{



   return float( ::atanf( fValue ) );
#line 241 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"
}

template <typename T>
inline T atan2( T fY, T fX );
inline float aTan2( float fY, float fX )
{



   return float( ::atan2f( fY, fX ) );
#line 252 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"
}
inline double aTan2( double fY, double fX )
{
    return double( ::atan2( fY, fX ) );
}

template <typename T>
inline T cos( T fValue );
inline float cos( float fValue )
{



   return float( ::cosf( fValue ) );
#line 267 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"
}
inline double cos( double fValue )
{
    return double( ::cos( fValue ) );
}

template <typename T>
inline T exp( T fValue );
inline float exp( float fValue )
{



   return float( ::expf( fValue ) );
#line 282 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"
}
inline double exp( double fValue )
{
    return double( ::exp( fValue ) );
}

template <typename T>
inline T log( T fValue );
inline double log( double fValue )
{
    return double( ::log( fValue ) );
}
inline float log( float fValue )
{



   return float( ::logf( fValue ) );
#line 301 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"
}

inline double pow( double fBase, double fExponent)
{
    return double( ::pow( fBase, fExponent ) );
}
inline float pow( float fBase, float fExponent)
{



   return float( ::powf( fBase, fExponent ) );
#line 314 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"
}

template <typename T>
inline T sin( T fValue );
inline double sin( double fValue )
{
    return double( ::sin( fValue ) );
}
inline float sin( float fValue )
{



   return float( ::sinf( fValue ) );
#line 329 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"
}

template <typename T>
inline T tan( T fValue );
inline double tan( double fValue )
{
    return double( ::tan( fValue ) );
}
inline float tan( float fValue )
{



   return float( ::tanf( fValue ) );
#line 344 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"
}

template <typename T>
inline T sqr( T fValue )
{
    return T( fValue * fValue );
}

template <typename T>
inline T sqrt( T fValue )
{



   return T( ::sqrtf( ((float)fValue) ) );
#line 360 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"
}
inline double sqrt( double fValue )
{
    return double( ::sqrt( fValue ) );
}







inline void seedRandom(unsigned int seed)
{
   ::srand(seed);
}




inline float unitRandom()
{
   return float(::rand())/float(0x7fff);
}




inline float rangeRandom( float x1, float x2 )
{
   float r = gmtl::Math::unitRandom();
   float size = x2 - x1;
   return float( r * size + x1 );
}









inline float deg2Rad( float fVal )
{
   return float( fVal * (float)(gmtl::Math::PI/180.0) );
}
inline double deg2Rad( double fVal )
{
   return double( fVal * (double)(gmtl::Math::PI/180.0) );
}

inline float rad2Deg( float fVal )
{
   return float( fVal * (float)(180.0/gmtl::Math::PI) );
}
inline double rad2Deg( double fVal )
{
   return double( fVal * (double)(180.0/gmtl::Math::PI) );
}






template <class T>
inline bool isEqual( const T& a, const T& b, const T& tolerance )
{
   (void)( (!!((tolerance >= (T)0))) || (_wassert(L"(tolerance >= (T)0)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h", 429), 0) );
   return bool( gmtl::Math::abs( a - b ) <= tolerance );
}


template <class T>
inline T trunc( T val )
{
   return T( (val < ((T)0)) ? gmtl::Math::ceil( val ) : gmtl::Math::floor( val ) );
}

template <class T>
inline T round( T p )
{
   return T( gmtl::Math::floor( p + (T)0.5 ) );
}


template <class T>
inline T Min( const T& x, const T& y )
{
   return ( x > y ) ? y : x;
}

template <class T>
inline T Min( const T& x, const T& y, const T& z )
{
   return Min( gmtl::Math::Min( x, y ), z );
}

template <class T>
inline T Min( const T& w, const T& x, const T& y, const T& z )
{
   return gmtl::Math::Min( gmtl::Math::Min( w, x ), gmtl::Math::Min( y, z ) );
}


template <class T>
inline T Max( const T& x, const T& y )
{
   return ( x > y ) ? x : y;
}

template <class T>
inline T Max( const T& x, const T& y, const T& z )
{
   return Max( gmtl::Math::Max( x, y ), z );
}

template <class T>
inline T Max( const T& w, const T& x, const T& y, const T& z )
{
   return gmtl::Math::Max( gmtl::Math::Max( w, x ), gmtl::Math::Max( y, z ) );
}






template<class T>
inline T factorial(T rhs)
{
   T lhs = (T)1;

   for( T x = (T)1; x <= rhs; ++x )
   {
      lhs *= x;
   }

   return lhs;
}





template <class T>
inline T clamp( T number, T lo, T hi )
{
   if (number > hi) number = hi;
   else if (number < lo) number = lo;
   return number;
}









template <class T, typename U>
inline void lerp( T& result, const U& lerp, const T& a, const T& b )
{
    T size = b - a;
    result = ((U)a) + (((U)size) * lerp);
}














template <class T>
inline bool quadraticFormula(T& r1, T& r2, const T& a, const T& b, const T& c)
{
   const T q = b*b - T(4)*a*c;

   
   if (q >= 0)
   {
      const T sq = gmtl::Math::sqrt(q);
      const T d = T(1) / (T(2) * a);
      r1 = (-b + sq) * d;
      r2 = (-b - sq) * d;
      return true;
   }
   
   else
   {
      return false;
   }
}

} 
} 

#line 567 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"
#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecOps.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h"





























































































































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h"
 
namespace gmtl
{













template<class DATA_TYPE, unsigned SIZE>
class Vec : public VecBase<DATA_TYPE, SIZE>
{
public:
   
   typedef DATA_TYPE DataType;

   
   enum { Size = SIZE };

   
   typedef VecBase<DATA_TYPE, SIZE> BaseType;

public:
   


   Vec()
   {
      for (unsigned i = 0; i < SIZE; ++i)
         this->mData[i] = (DATA_TYPE)0;
   }

   
   
   




   Vec( const Vec<DATA_TYPE, SIZE>& rVec )
      : BaseType( static_cast<BaseType>( rVec ) )
   {
   }
   
   Vec( const VecBase<DATA_TYPE, SIZE>& rVec )
      : BaseType( rVec )
   {
   }

   


   Vec(const DATA_TYPE& val0,const DATA_TYPE& val1)
   : BaseType(val0, val1)
   {
      
      (void)( (!!((SIZE == 2 && "out of bounds element access in Point"))) || (_wassert(L"(SIZE == 2 && \"out of bounds element access in Point\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h", 102), 0) );
   }

   Vec(const DATA_TYPE& val0,const DATA_TYPE& val1,const DATA_TYPE& val2)
   : BaseType(val0, val1, val2)
   {
      
      (void)( (!!((SIZE == 3 && "out of bounds element access in Point"))) || (_wassert(L"(SIZE == 3 && \"out of bounds element access in Point\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h", 109), 0) );
   }

   Vec(const DATA_TYPE& val0,const DATA_TYPE& val1,const DATA_TYPE& val2,const DATA_TYPE& val3)
   : BaseType(val0, val1, val2, val3)
   {
      
      (void)( (!!((SIZE == 4 && "out of bounds element access in Point"))) || (_wassert(L"(SIZE == 4 && \"out of bounds element access in Point\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h", 116), 0) );
   }
   
};


typedef Vec<int, 2> Vec2i;
typedef Vec<float,2> Vec2f;
typedef Vec<double,2> Vec2d;
typedef Vec<int, 3> Vec3i;
typedef Vec<float,3> Vec3f;
typedef Vec<double,3> Vec3d;
typedef Vec<int, 4> Vec4i;
typedef Vec<float,4> Vec4f;
typedef Vec<double,4> Vec4d;

};

#line 135 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h"
#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecOps.h"

namespace gmtl
{















template<typename DATA_TYPE, unsigned SIZE>
Vec<DATA_TYPE, SIZE> operator- (const VecBase<DATA_TYPE, SIZE>& v1)
{
   Vec<DATA_TYPE, SIZE> ret_val;
   for ( unsigned i=0; i < SIZE; ++i )
   {
      ret_val[i] = -v1[i];
   }
   return ret_val;
}










template<class DATA_TYPE, unsigned SIZE>
VecBase<DATA_TYPE, SIZE>& operator +=(VecBase<DATA_TYPE, SIZE>& v1,
                                      const VecBase<DATA_TYPE, SIZE>& v2)
{
   for(unsigned i=0;i<SIZE;++i)
   {
      v1[i] += v2[i];
   }

   return v1;
}









template<class DATA_TYPE, unsigned SIZE>
VecBase<DATA_TYPE, SIZE> operator +(const VecBase<DATA_TYPE, SIZE>& v1,
                                    const VecBase<DATA_TYPE, SIZE>& v2)
{
   VecBase<DATA_TYPE, SIZE> ret_val(v1);
   ret_val += v2;
   return ret_val;
}










template<class DATA_TYPE, unsigned SIZE>
VecBase<DATA_TYPE, SIZE>& operator -=(VecBase<DATA_TYPE, SIZE>& v1,
                                      const VecBase<DATA_TYPE, SIZE>& v2)
{
   for(unsigned i=0;i<SIZE;++i)
   {
      v1[i] -= v2[i];
   }

   return v1;
}









template < class DATA_TYPE, unsigned SIZE>
Vec<DATA_TYPE, SIZE> operator -(const VecBase<DATA_TYPE, SIZE>& v1,
                                const VecBase<DATA_TYPE, SIZE>& v2)
{
   Vec<DATA_TYPE, SIZE> ret_val(v1);
   ret_val -= v2;
   return ret_val;
}










template<class DATA_TYPE, unsigned SIZE, class SCALAR_TYPE>
VecBase<DATA_TYPE, SIZE>& operator *=(VecBase<DATA_TYPE, SIZE>& v1,
                                      const SCALAR_TYPE& scalar)
{
   for(unsigned i=0;i<SIZE;++i)
   {
      v1[i] *= (DATA_TYPE)scalar;
   }

   return v1;
}










template<class DATA_TYPE, unsigned SIZE, class SCALAR_TYPE>
VecBase<DATA_TYPE, SIZE> operator *(const VecBase<DATA_TYPE, SIZE>& v1,
                                    const SCALAR_TYPE& scalar)
{
   VecBase<DATA_TYPE, SIZE> ret_val(v1);
   ret_val *= scalar;
   return ret_val;

   
}










template<class DATA_TYPE, unsigned SIZE, class SCALAR_TYPE>
VecBase<DATA_TYPE, SIZE> operator *(const SCALAR_TYPE& scalar,
                                    const VecBase<DATA_TYPE, SIZE>& v1)
{
   VecBase<DATA_TYPE, SIZE> ret_val(v1);
   ret_val *= scalar;
   return ret_val;

   
}










template<class DATA_TYPE, unsigned SIZE, class SCALAR_TYPE>
VecBase<DATA_TYPE, SIZE>& operator /=(VecBase<DATA_TYPE, SIZE>& v1,
                                      const SCALAR_TYPE& scalar)
{
   for(unsigned i=0;i<SIZE;++i)
   {
      v1[i] /= scalar;
   }

   return v1;
}










template<class DATA_TYPE, unsigned SIZE, class SCALAR_TYPE>
VecBase<DATA_TYPE, SIZE> operator /(const VecBase<DATA_TYPE, SIZE>& v1,
                                    const SCALAR_TYPE& scalar)
{
   VecBase<DATA_TYPE, SIZE> ret_val(v1);
   ret_val /= scalar;
   return ret_val;
   
}
















template<class DATA_TYPE, unsigned SIZE>
DATA_TYPE dot(const Vec<DATA_TYPE, SIZE>& v1, const Vec<DATA_TYPE, SIZE>& v2)
{
   DATA_TYPE ret_val(0);
   for(unsigned i=0;i<SIZE;++i)
   {
      ret_val += (v1[i] * v2[i]);
   }
   return ret_val;
}








template<class DATA_TYPE, unsigned SIZE>
DATA_TYPE length(const Vec<DATA_TYPE, SIZE>& v1)
{
   DATA_TYPE ret_val = lengthSquared(v1);
   if (ret_val == 0.0f)
      return 0.0f;
   else
      return Math::sqrt(ret_val);
}










template<class DATA_TYPE, unsigned SIZE>
DATA_TYPE lengthSquared(const Vec<DATA_TYPE, SIZE>& v1)
{
   DATA_TYPE ret_val(0);
   for(unsigned i=0;i<SIZE;++i)
   {
      ret_val += (v1[i] * v1[i]);
   }

   return ret_val;
}












template<class DATA_TYPE, unsigned SIZE>
DATA_TYPE normalize(Vec<DATA_TYPE, SIZE>& v1)
{
   DATA_TYPE len = length(v1);

   if(len != 0.0f)
   {
      for(unsigned i=0;i<SIZE;++i)
      {
         v1[i] /= len;
      }
   }

   return len;
}










template< class DATA_TYPE, unsigned SIZE >
bool isNormalized( const Vec<DATA_TYPE, SIZE>& v1,
                   const DATA_TYPE eps = (DATA_TYPE)0.0001 )
{
   return Math::isEqual( lengthSquared( v1 ), (DATA_TYPE)1.0, eps );
}













template<class DATA_TYPE>
Vec<DATA_TYPE,3> cross(const Vec<DATA_TYPE, 3>& v1, const Vec<DATA_TYPE, 3>& v2)
{
   return Vec<DATA_TYPE,3>( ((v1[Yelt]*v2[Zelt]) - (v1[Zelt]*v2[Yelt])),
                            ((v1[Zelt]*v2[Xelt]) - (v1[Xelt]*v2[Zelt])),
                            ((v1[Xelt]*v2[Yelt]) - (v1[Yelt]*v2[Xelt])) );
}
















template<class DATA_TYPE>
Vec<DATA_TYPE,3>& cross( Vec<DATA_TYPE,3>& result, const Vec<DATA_TYPE, 3>& v1,
                         const Vec<DATA_TYPE, 3>& v2 )
{
   result.set( (v1[Yelt]*v2[Zelt]) - (v1[Zelt]*v2[Yelt]),
               (v1[Zelt]*v2[Xelt]) - (v1[Xelt]*v2[Zelt]),
               (v1[Xelt]*v2[Yelt]) - (v1[Yelt]*v2[Xelt]) );
   return result;
}









template<class DATA_TYPE, unsigned SIZE>
VecBase<DATA_TYPE, SIZE>& reflect( VecBase<DATA_TYPE, SIZE>& result, const
                           VecBase<DATA_TYPE, SIZE>& vec,
                           const Vec<DATA_TYPE, SIZE>& normal )
{
   result = vec - DATA_TYPE( 2.0 ) * dot( (Vec<DATA_TYPE, SIZE>)vec, normal ) * normal;
   return result;
}





















template <typename DATA_TYPE, unsigned SIZE>
VecBase<DATA_TYPE, SIZE>& lerp( VecBase<DATA_TYPE, SIZE>& result,
                                const DATA_TYPE& lerpVal,
                                const VecBase<DATA_TYPE, SIZE>& from,
                                const VecBase<DATA_TYPE, SIZE>& to )
{
   
   for (unsigned int x = 0; x < SIZE; ++x)
   {
      Math::lerp( result[x], lerpVal, from[x], to[x] );
   }
   return result;
}


















template<class DATA_TYPE, unsigned SIZE>
inline bool operator==(const VecBase<DATA_TYPE, SIZE>& v1,
                       const VecBase<DATA_TYPE, SIZE>& v2)
{
   for(unsigned i=0;i<SIZE;++i)
   {
      if(v1[i] != v2[i])
      {
         return false;
      }
   }

   return true;

   




}










template<class DATA_TYPE, unsigned SIZE>
inline bool operator!=(const VecBase<DATA_TYPE, SIZE>& v1,
                       const VecBase<DATA_TYPE, SIZE>& v2)
{
   return(! (v1 == v2));
}













template<class DATA_TYPE, unsigned SIZE>
inline bool isEqual(const VecBase<DATA_TYPE, SIZE>& v1,
                    const VecBase<DATA_TYPE, SIZE>& v2, const DATA_TYPE& eps)
{
   (void)( (!!((eps >= 0))) || (_wassert(L"(eps >= 0)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecOps.h", 520), 0) );

   for(unsigned i=0;i<SIZE;++i)
   {
      if (fabs(v1[i] - v2[i]) > eps)
      {
         return false;
      }
   }
   return true;
}



}

#line 537 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecOps.h"
#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AABoxOps.h"

namespace gmtl
{















template< class DATA_TYPE >
inline bool operator==( const AABox<DATA_TYPE>& b1, const AABox<DATA_TYPE>& b2 )
{
   return ( (b1.isEmpty() == b2.isEmpty()) &&
            (b1.getMin() == b2.getMin()) &&
            (b1.getMax() == b2.getMax()) );
}










template< class DATA_TYPE >
inline bool operator!=( const AABox<DATA_TYPE>& b1, const AABox<DATA_TYPE>& b2 )
{
   return (! (b1 == b2));
}












template< class DATA_TYPE >
inline bool isEqual( const AABox<DATA_TYPE>& b1, const AABox<DATA_TYPE>& b2, const DATA_TYPE& eps )
{
   (void)( (!!((eps >= 0))) || (_wassert(L"(eps >= 0)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AABoxOps.h", 95), 0) );
   return ( (b1.isEmpty() == b2.isEmpty())
            (isEqual(b1.getMin(), b2.getMin(), eps)) &&
            (isEqual(b1.getMax(), b2.getMax(), eps)) );
}


}

#line 105 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AABoxOps.h"

#line 17 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AxisAngle.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"






















































































































































































































































































































































































































































































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AxisAngle.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h"





























































































































































































































#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AxisAngle.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h"






































































































































#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AxisAngle.h"
 
namespace gmtl
{



















template <typename DATA_TYPE>
class AxisAngle : public VecBase<DATA_TYPE, 4>
{
public:
   enum { Size = 4 };
   
   
   AxisAngle() : 
      VecBase<DATA_TYPE, 4>( (DATA_TYPE)0.0, (DATA_TYPE)1.0, 
                             (DATA_TYPE)0.0, (DATA_TYPE)0.0 )
   {
   }
   
   
   AxisAngle( const AxisAngle& e ) : VecBase<DATA_TYPE, 4>( e )
   {
   }
   
   
   AxisAngle( const DATA_TYPE& rad_angle, const DATA_TYPE& x, 
              const DATA_TYPE& y, const DATA_TYPE& z ) :
            VecBase<DATA_TYPE, 4>( rad_angle, x, y, z )
   {
   }
   
   
   AxisAngle( const DATA_TYPE& rad_angle, const Vec<DATA_TYPE, 3>& axis ) :
            VecBase<DATA_TYPE, 4>( rad_angle, axis[0], axis[1], axis[2] )
   {
   }
   
   
   void set( const DATA_TYPE& rad_angle, const DATA_TYPE& x, 
             const DATA_TYPE& y, const DATA_TYPE& z )
   {
      VecBase<DATA_TYPE, 4>::set( rad_angle, x, y, z );
   }
   
   
   void set( const DATA_TYPE& rad_angle, const Vec<DATA_TYPE, 3>& axis )
   {
      VecBase<DATA_TYPE, 4>::set( rad_angle, axis[0], axis[1], axis[2] );
   }
   
   



   void setAxis( const Vec<DATA_TYPE, 3>& axis ) 
   { 
      VecBase<DATA_TYPE, 4>::operator[]( 1 ) = axis[0];
      VecBase<DATA_TYPE, 4>::operator[]( 2 ) = axis[1];
      VecBase<DATA_TYPE, 4>::operator[]( 3 ) = axis[2];
   }
   
   



   void setAngle( const DATA_TYPE& rad_angle ) 
   {
      VecBase<DATA_TYPE, 4>::operator[]( 0 ) = rad_angle;
   }
   
   


   Vec<DATA_TYPE, 3> getAxis() const 
   { 
      return Vec<DATA_TYPE, 3>( VecBase<DATA_TYPE, 4>::operator[]( 1 ),
                                VecBase<DATA_TYPE, 4>::operator[]( 2 ),
                                VecBase<DATA_TYPE, 4>::operator[]( 3 ) );
   }
   
   


   const DATA_TYPE& getAngle() const 
   {
      return VecBase<DATA_TYPE, 4>::operator[]( 0 );
   }
};

const AxisAngle<float> AXISANGLE_IDENTITYF( 0.0f, 1.0f, 0.0f, 0.0f );
const AxisAngle<double> AXISANGLE_IDENTITYD( 0.0, 1.0, 0.0, 0.0 );

typedef AxisAngle<float> AxisAnglef;
typedef AxisAngle<double> AxisAngled;

} 

#line 155 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AxisAngle.h"
#line 18 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AxisAngleOps.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AxisAngle.h"


























































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AxisAngleOps.h"

namespace gmtl
{














template<class DATA_TYPE>
inline bool operator==(const AxisAngle<DATA_TYPE>& a1,
                       const AxisAngle<DATA_TYPE>& a2)
{
   
   if (a1[0] != a2[0]) return false;
   if (a1[1] != a2[1]) return false;
   if (a1[2] != a2[2]) return false;
   if (a1[3] != a2[3]) return false;
   return true;
}









template<class DATA_TYPE>
inline bool operator!=(const AxisAngle<DATA_TYPE>& a1,
                       const AxisAngle<DATA_TYPE>& a2)
{
   return !(a1 == a2);
}













template<class DATA_TYPE>
inline bool isEqual( const AxisAngle<DATA_TYPE>& a1,
                     const AxisAngle<DATA_TYPE>& a2, 
                     const DATA_TYPE& eps = (DATA_TYPE)0 )
{
   (void)( (!!((eps >= (DATA_TYPE)0))) || (_wassert(L"(eps >= (DATA_TYPE)0)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AxisAngleOps.h", 100), 0) );
   
   
   if (!Math::isEqual( a1[0], a2[0], eps )) return false;
   if (!Math::isEqual( a1[1], a2[1], eps )) return false;
   if (!Math::isEqual( a1[2], a2[2], eps )) return false;
   if (!Math::isEqual( a1[3], a2[3], eps )) return false;
   return true;
}






} 

#line 118 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AxisAngleOps.h"
#line 19 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Containment.h"







































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Sphere.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Point.h"






































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Sphere.h"

namespace gmtl
{







template<class DATA_TYPE>
class Sphere
{
public:
   typedef DATA_TYPE DataType;

public:
   


   Sphere()
      : mRadius( 0 )
   {}

   





   Sphere( const Point<DATA_TYPE, 3>& center, const DATA_TYPE& radius )
      : mCenter( center ), mRadius( radius )
   {}

   




   Sphere( const Sphere<DATA_TYPE>& sphere )
      : mCenter( sphere.mCenter ), mRadius( sphere.mRadius )
   {}

   




   const Point<DATA_TYPE, 3>& getCenter() const
   {
      return mCenter;
   }

   




   const DATA_TYPE& getRadius() const
   {
      return mRadius;
   }

   




   void setCenter( const Point<DATA_TYPE, 3>& center )
   {
      mCenter = center;
   }

   




   void setRadius( const DATA_TYPE& radius )
   {
      mRadius = radius;
   }

public:
   


   Point<DATA_TYPE, 3> mCenter;

   


   DATA_TYPE mRadius;
};


typedef Sphere<float>   Spheref;
typedef Sphere<double>  Sphered;

};

#line 141 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Sphere.h"
#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Containment.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AABox.h"








































































































































































#line 42 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Containment.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecOps.h"
























































































































































































































































































































































































































































































































































#line 43 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Containment.h"








namespace gmtl
{














template< class DATA_TYPE >
bool isInVolume( const Sphere<DATA_TYPE>& container,
                 const Point<DATA_TYPE, 3>& pt )
{
   
   
   
   
   return ( length(pt - container.mCenter) <= container.mRadius );
}










template< class DATA_TYPE >
bool isInVolume( const Sphere<DATA_TYPE>& container,
                 const Sphere<DATA_TYPE>& sphere )
{
   
   
   
   
   return ( length(sphere.mCenter - container.mCenter) + sphere.mRadius
            <= container.mRadius );
}







template< class DATA_TYPE >
void extendVolume( Sphere<DATA_TYPE>& container,
                   const Point<DATA_TYPE, 3>& pt )
{
   
   if ( isInVolume( container, pt ) )
   {
      return;
   }

   
   
   Vec<DATA_TYPE, 3> dir = pt - container.mCenter;
   DATA_TYPE len = normalize( dir );

   
   DATA_TYPE newRadius =  (len + container.mRadius) * DATA_TYPE(0.5);

   
   Point<DATA_TYPE, 3> newCenter = container.mCenter +
                                   (dir * (newRadius - container.mRadius));

   
   container.mCenter = newCenter;
   container.mRadius = newRadius;
}







template< class DATA_TYPE >
void extendVolume( Sphere<DATA_TYPE>& container,
                   const Sphere<DATA_TYPE>& sphere )
{
   
   if ( isInVolume( container, sphere ) )
   {
      return;
   }

   
   
   Vec<DATA_TYPE, 3> dir = sphere.mCenter - container.mCenter;
   DATA_TYPE len = normalize( dir );

   
   DATA_TYPE newRadius = (len + sphere.mRadius + container.mRadius) *
                         DATA_TYPE(0.5);

   
   Point<DATA_TYPE, 3> newCenter = container.mCenter +
                                   (dir * (newRadius - container.mRadius));

   
   container.mCenter = newCenter;
   container.mRadius = newRadius;
}











template< class DATA_TYPE >
void makeVolume( Sphere<DATA_TYPE>& container,
                 const std::vector< Point<DATA_TYPE, 3> >& pts )
{
   (void)( (!!((pts.size() > 0 && "pts must contain at least 1 point"))) || (_wassert(L"(pts.size() > 0 && \"pts must contain at least 1 point\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Containment.h", 180), 0) );

   
   
   typename std::vector< Point<DATA_TYPE, 3> >::const_iterator itr = pts.begin();

   
   Point<DATA_TYPE, 3> sum = *itr;
   ++itr;
   while ( itr != pts.end() )
   {
      sum += *itr;
      ++itr;
   }
   container.mCenter = sum / pts.size();

   
   
   DATA_TYPE radiusSqr(0);
   for ( itr = pts.begin(); itr != pts.end(); ++itr )
   {
      float len = lengthSquared( *itr - container.mCenter );
      if ( len > radiusSqr )
         radiusSqr = len;
   }

   container.mRadius = Math::sqrt( radiusSqr );
}
















































































template< class DATA_TYPE >
bool isOnVolume( const Sphere<DATA_TYPE>& container,
                 const Point<DATA_TYPE, 3>& pt )
{
   
   return ( length(container.mCenter - pt) - container.mRadius == 0 );
}











template< class DATA_TYPE >
bool isOnVolume( const Sphere<DATA_TYPE>& container,
                 const Point<DATA_TYPE, 3>& pt,
                 const DATA_TYPE& tol )
{
   (void)( (!!((tol >= 0 && "tolerance must be positive"))) || (_wassert(L"(tol >= 0 && \"tolerance must be positive\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Containment.h", 311), 0) );

   
   return ( Math::abs( length(container.mCenter - pt) - container.mRadius )
            <= tol );
}














template< class DATA_TYPE >
bool isInVolume(const AABox<DATA_TYPE>& container,
                const Point<DATA_TYPE, 3>& pt)
{
   if (! container.isEmpty())
   {
      return ( pt[0] >= container.mMin[0] &&
               pt[1] >= container.mMin[1] &&
               pt[2] >= container.mMin[2] &&
               pt[0] <= container.mMax[0] &&
               pt[1] <= container.mMax[1] &&
               pt[2] <= container.mMax[2]);
   }
   else
   {
      return false;
   }
}










template< class DATA_TYPE >
bool isInVolume(const AABox<DATA_TYPE>& container,
                const AABox<DATA_TYPE>& box)
{
   
   if (container.isEmpty() || box.isEmpty())
   {
      return false;
   }

   
   if (container.mMax[0] < box.mMin[0] || container.mMin[0] > box.mMax[0] ||
       container.mMax[1] < box.mMin[1] || container.mMin[1] > box.mMax[1] ||
       container.mMax[2] < box.mMin[2] || container.mMin[2] > box.mMax[2])
   {
      return false;
   }
   else
   {
      return true;
   }
}







template< class DATA_TYPE >
void extendVolume(AABox<DATA_TYPE>& container,
                  const Point<DATA_TYPE, 3>& pt)
{
   if (! container.isEmpty())
   {
      
      if (pt[0] > container.mMax[0])
      {
         container.mMax[0] = pt[0];
      }
      else if (pt[0] < container.mMin[0])
      {
         container.mMin[0] = pt[0];
      }

      
      if (pt[1] > container.mMax[1])
      {
         container.mMax[1] = pt[1];
      }
      else if (pt[1] < container.mMin[1])
      {
         container.mMin[1] = pt[1];
      }

      
      if (pt[2] > container.mMax[2])
      {
         container.mMax[2] = pt[2];
      }
      else if (pt[2] < container.mMin[2])
      {
         container.mMin[2] = pt[2];
      }
   }
   else
   {
      
      container.setMin(pt);
      container.setMax(pt);
      container.setEmpty(false);
   }
}







template< class DATA_TYPE >
void extendVolume(AABox<DATA_TYPE>& container,
                  const AABox<DATA_TYPE>& box)
{
   
   if (box.isEmpty())
   {
      return;
   }

   
   if (container.isEmpty())
   {
      container = box;
   }

   
   extendVolume(container, box.getMin());
   extendVolume(container, box.getMax());
}






template< class DATA_TYPE >
void makeVolume(AABox<DATA_TYPE>& box, const Sphere<DATA_TYPE>& sph)
{
   const gmtl::Point<DATA_TYPE, 3>& center = sph.getCenter();
   const DATA_TYPE& radius = sph.getRadius();

   
   gmtl::Point<DATA_TYPE, 3> min_pt(center[0] - radius,
                                    center[1] - radius,
                                    center[2] - radius);
   gmtl::Point<DATA_TYPE, 3> max_pt(center[0] + radius,
                                    center[1] + radius,
                                    center[2] + radius);

   box.setMin(min_pt);
   box.setMax(max_pt);
   box.setEmpty(radius == DATA_TYPE(0));
}































































































































































































}

#line 677 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Containment.h"
#line 20 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Coord.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h"






































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Coord.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AxisAngle.h"


























































































































































#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Coord.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_EulerAngle.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"






















































































































































































































































































































































































































































































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_EulerAngle.h"
 
namespace gmtl
{
























template <typename DATA_TYPE, typename ROTATION_ORDER>
class EulerAngle
{
public:
   enum { Size = 3, Order = ROTATION_ORDER::ID };

   
   EulerAngle()
   {
      (void)( (!!((ROTATION_ORDER::IS_ROTORDER == 1 && "you must specify a RotationOrder derived type for the rotationorder in euler angle."))) || (_wassert(L"(ROTATION_ORDER::IS_ROTORDER == 1 && \"you must specify a RotationOrder derived type for the rotationorder in euler angle.\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_EulerAngle.h", 76), 0) );
#line 77 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_EulerAngle.h"
      mData[0] = DATA_TYPE( 0 );
      mData[1] = DATA_TYPE( 0 );
      mData[2] = DATA_TYPE( 0 );
   }

   
   EulerAngle( const EulerAngle& e )
   {
      mData[0] = e.mData[0];
      mData[1] = e.mData[1];
      mData[2] = e.mData[2];
   }

   
   EulerAngle( DATA_TYPE p0, DATA_TYPE p1, DATA_TYPE p2 )
   {
      mData[0] = p0;
      mData[1] = p1;
      mData[2] = p2;
   }
   
   
   void set( const DATA_TYPE& p0, const DATA_TYPE& p1, 
             const DATA_TYPE& p2 )
   {
      mData[0] = p0;
      mData[1] = p1;
      mData[2] = p2;
   }
   
   
   




   inline DATA_TYPE& operator[]( const unsigned i )
   {
      (void)( (!!((i < Size))) || (_wassert(L"(i < Size)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_EulerAngle.h", 115), 0) );
      return mData[i];
   }
   inline const DATA_TYPE&  operator[]( const unsigned i ) const
   {
      (void)( (!!((i < Size))) || (_wassert(L"(i < Size)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_EulerAngle.h", 120), 0) );
      return mData[i];
   }
   
   
   
   


   DATA_TYPE* getData() { return mData; }
   
   


   const DATA_TYPE* getData() const { return mData; }
   
   
private:
   DATA_TYPE mData[Size];
};

const EulerAngle<float, XYZ> EULERANGLE_IDENTITY_XYZF( 0.0f, 0.0f, 0.0f );
const EulerAngle<double, XYZ> EULERANGLE_IDENTITY_XYZD( 0.0, 0.0, 0.0 );
const EulerAngle<float, ZYX> EULERANGLE_IDENTITY_ZYXF( 0.0f, 0.0f, 0.0f );
const EulerAngle<double, ZYX> EULERANGLE_IDENTITY_ZYXD( 0.0, 0.0, 0.0 );
const EulerAngle<float, ZXY> EULERANGLE_IDENTITY_ZXYF( 0.0f, 0.0f, 0.0f );
const EulerAngle<double, ZXY> EULERANGLE_IDENTITY_ZXYD( 0.0, 0.0, 0.0 );

typedef EulerAngle<float, XYZ> EulerAngleXYZf;
typedef EulerAngle<double, XYZ> EulerAngleXYZd;
typedef EulerAngle<float, ZYX> EulerAngleZYXf;
typedef EulerAngle<double, ZYX> EulerAngleZYXd;
typedef EulerAngle<float, ZXY> EulerAngleZXYf;
typedef EulerAngle<double, ZXY> EulerAngleZXYd;

} 

#line 158 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_EulerAngle.h"
#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Coord.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Quat.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Defines.h"



































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Quat.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h"






































































































































#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Quat.h"
 
namespace gmtl
{
































template <typename DATA_TYPE>
class Quat
{
public:
   

   typedef DATA_TYPE DataType;

   enum { Size = 4 };

   



   Quat<DATA_TYPE>()
         : mData( (DATA_TYPE)0.0, (DATA_TYPE)0.0, (DATA_TYPE)0.0, (DATA_TYPE)1.0 )
   {
   }
   
   



   Quat<DATA_TYPE>( const DATA_TYPE x, const DATA_TYPE y,
                    const DATA_TYPE z, const DATA_TYPE w )
         : mData( x, y, z, w )
   {
   }

   

   Quat<DATA_TYPE>( const Quat<DATA_TYPE>& q ) : mData( q.mData )
   {
   }

   



   void set( const DATA_TYPE x, const DATA_TYPE y, const DATA_TYPE z, const DATA_TYPE w )
   {
      mData.set( x, y, z, w );
   }

   


   void get( DATA_TYPE& x, DATA_TYPE& y, DATA_TYPE& z, DATA_TYPE& w )
   {
      x = mData[Xelt];
      y = mData[Yelt];
      z = mData[Zelt];
      w = mData[Welt];
   }

   













   DATA_TYPE& operator[]( const int x )
   {
      (void)( (!!((x >= 0 && x < 4 && "out of bounds error"))) || (_wassert(L"(x >= 0 && x < 4 && \"out of bounds error\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Quat.h", 146), 0) );
      return mData[x];
   }

   










   const DATA_TYPE& operator[]( const int x ) const
   {
      (void)( (!!((x >= 0 && x < 4 && "out of bounds error"))) || (_wassert(L"(x >= 0 && x < 4 && \"out of bounds error\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Quat.h", 163), 0) );
      return mData[x];
   }

   


   const DATA_TYPE*  getData() const { return (DATA_TYPE*)mData.getData();}

public:
   
   Vec<DATA_TYPE, 4> mData;
};

const Quat<float> QUAT_MULT_IDENTITYF( 0.0f, 0.0f, 0.0f, 1.0f );
const Quat<float> QUAT_ADD_IDENTITYF( 0.0f, 0.0f, 0.0f, 0.0f );
const Quat<float> QUAT_IDENTITYF( QUAT_MULT_IDENTITYF );
const Quat<double> QUAT_MULT_IDENTITYD( 0.0, 0.0, 0.0, 1.0 );
const Quat<double> QUAT_ADD_IDENTITYD( 0.0, 0.0, 0.0, 0.0 );
const Quat<double> QUAT_IDENTITYD( QUAT_MULT_IDENTITYD );

typedef Quat<float> Quatf;
typedef Quat<double> Quatd;

} 

#line 190 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Quat.h"
#line 42 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Coord.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_Meta.h"































































namespace gmtl
{  
   
   
   
   




   template <typename T>
   struct Type2Type
   {
      typedef T OriginalType;
   };
   
   

   
   
   template <class T> inline void ignore_unused_variable_warning(const T&) { }

   

} 
#line 90 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_Meta.h"
#line 43 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Coord.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_StaticAssert.h"






#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Defines.h"



































































































#line 8 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_StaticAssert.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_Meta.h"

























































































#line 9 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_StaticAssert.h"







namespace gmtl
{


template <bool x> struct STATIC_ASSERTION_FAILURE;

template <> struct STATIC_ASSERTION_FAILURE<true>{};


template<int x> struct static_assert_test{};

}




































#line 65 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_StaticAssert.h"





#line 71 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_StaticAssert.h"


#line 74 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_StaticAssert.h"
#line 44 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Coord.h"

namespace gmtl
{
   
















template <typename POS_TYPE, typename ROT_TYPE>
class Coord
{
public:
   Coord() : mPos(), mRot()
   {
   }
   
   typedef typename POS_TYPE::DataType DataType;
   typedef POS_TYPE PosDataType;
   typedef ROT_TYPE RotDataType;
   enum
   {
       PosSize = POS_TYPE::Size,
       RotSize = ROT_TYPE::Size
   };
    
   Coord( const Coord<POS_TYPE, ROT_TYPE>& coord ) : mPos( coord.mPos ), mRot( coord.mRot )
   {
   }
   
   Coord( const POS_TYPE& pos, const ROT_TYPE& rot ) : mPos( pos ), mRot( rot )
   {
   }

   



   
   Coord( DataType a0, DataType a1, DataType a2, DataType a3, DataType a4, DataType a5 )
   {
      typedef ::gmtl::static_assert_test< sizeof(::gmtl::STATIC_ASSERTION_FAILURE< (bool)( PosSize == 3 ) >)> gmtl_static_assert_typedef_96;   
      typedef ::gmtl::static_assert_test< sizeof(::gmtl::STATIC_ASSERTION_FAILURE< (bool)( RotSize == 3 ) >)> gmtl_static_assert_typedef_97;   
      if(PosSize == 3)
      {
         mPos[0] = a0; mPos[1] = a1; mPos[2] = a2;
         mRot[0] = a3; mRot[1] = a4; mRot[2] = a5; 
      }
      else
      {
         (void)( (!!((false && "Constructor not supported for pos size"))) || (_wassert(L"(false && \"Constructor not supported for pos size\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Coord.h", 105), 0) );
      }
   }

   Coord( DataType a0, DataType a1, DataType a2, DataType a3, DataType a4, DataType a5, DataType a6 )
   {
      typedef ::gmtl::static_assert_test< sizeof(::gmtl::STATIC_ASSERTION_FAILURE< (bool)( (PosSize == 3 && RotSize == 4) || (PosSize == 4 && RotSize == 3) ) >)> gmtl_static_assert_typedef_111; 
      if(PosSize == 3)
      {
         mPos[0] = a0; mPos[1] = a1; mPos[2] = a2;
         mRot[0] = a3; mRot[1] = a4; mRot[2] = a5; mRot[3] = a6; 
      }
      else if(PosSize == 4)
      {
         mPos[0] = a0; mPos[1] = a1; mPos[2] = a2; mPos[3] = a3;
         mRot[0] = a4; mRot[1] = a5; mRot[2] = a6; 
      }
      else
      {
         (void)( (!!((false && "Constructor not supported for pos size"))) || (_wassert(L"(false && \"Constructor not supported for pos size\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Coord.h", 124), 0) );
      }

   }
  
   Coord( DataType a0, DataType a1, DataType a2, DataType a3, DataType a4, DataType a5, DataType a6, DataType a7 )
   {
      typedef ::gmtl::static_assert_test< sizeof(::gmtl::STATIC_ASSERTION_FAILURE< (bool)( PosSize == 4 ) >)> gmtl_static_assert_typedef_131;    
      typedef ::gmtl::static_assert_test< sizeof(::gmtl::STATIC_ASSERTION_FAILURE< (bool)( RotSize == 4 ) >)> gmtl_static_assert_typedef_132;    
      if(PosSize == 4)
      {
         mPos[0] = a0; mPos[1] = a1; mPos[2] = a2; mPos[3] = a3;
         mRot[0] = a4; mRot[1] = a5; mRot[2] = a6; mRot[3] = a7;   
      }
      else
      {
         (void)( (!!((false && "Constructor not supported for pos size"))) || (_wassert(L"(false && \"Constructor not supported for pos size\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Coord.h", 140), 0) );
      }
   }
   

   const POS_TYPE& getPos() const { return mPos; }
   const ROT_TYPE& getRot() const { return mRot; }
   
   
   
   
   
   POS_TYPE& pos() { return mPos; }

   
   ROT_TYPE& rot() { return mRot; }
   
   
   

   
   

public:
   POS_TYPE mPos;
   ROT_TYPE mRot;
};

typedef Coord<Vec3d, EulerAngleXYZd> CoordVec3EulerAngleXYZd;
typedef Coord<Vec3f, EulerAngleXYZf> CoordVec3EulerAngleXYZf;
typedef Coord<Vec4d, EulerAngleXYZd> CoordVec4EulerAngleXYZd;
typedef Coord<Vec4f, EulerAngleXYZf> CoordVec4EulerAngleXYZf;

typedef Coord<Vec3d, EulerAngleZYXd> CoordVec3EulerAngleZYXd;
typedef Coord<Vec3f, EulerAngleZYXf> CoordVec3EulerAngleZYXf;
typedef Coord<Vec4d, EulerAngleZYXd> CoordVec4EulerAngleZYXd;
typedef Coord<Vec4f, EulerAngleZYXf> CoordVec4EulerAngleZYXf;

typedef Coord<Vec3d, EulerAngleZXYd> CoordVec3EulerAngleZXYd;
typedef Coord<Vec3f, EulerAngleZXYf> CoordVec3EulerAngleZXYf;
typedef Coord<Vec4d, EulerAngleZXYd> CoordVec4EulerAngleZXYd;
typedef Coord<Vec4f, EulerAngleZXYf> CoordVec4EulerAngleZXYf;

typedef Coord<Vec3d, AxisAngled> CoordVec3AxisAngled;
typedef Coord<Vec3f, AxisAnglef> CoordVec3AxisAnglef;
typedef Coord<Vec4d, AxisAngled> CoordVec4AxisAngled;
typedef Coord<Vec4f, AxisAnglef> CoordVec4AxisAnglef;




typedef Coord<Vec3f, EulerAngleXYZf> Coord3fXYZ;
typedef Coord<Vec3f, EulerAngleZYXf> Coord3fZYX;
typedef Coord<Vec3f, EulerAngleZXYf> Coord3fZXY;
typedef Coord<Vec3d, EulerAngleXYZd> Coord3dXYZ;
typedef Coord<Vec3d, EulerAngleZYXd> Coord3dZYX;
typedef Coord<Vec3d, EulerAngleZXYd> Coord3dZXY;


typedef Coord<Vec4f, EulerAngleXYZf> Coord4fXYZ;
typedef Coord<Vec4f, EulerAngleZYXf> Coord4fZYX;
typedef Coord<Vec4f, EulerAngleZXYf> Coord4fZXY;
typedef Coord<Vec4d, EulerAngleXYZd> Coord4dXYZ;
typedef Coord<Vec4d, EulerAngleZYXd> Coord4dZYX;
typedef Coord<Vec4d, EulerAngleZXYd> Coord4dZXY;


typedef Coord<Vec3f, Quatf> Coord3fQuat;
typedef Coord<Vec3d, Quatd> Coord3dQuat;


typedef Coord<Vec4f, Quatf> Coord4fQuat;
typedef Coord<Vec4d, Quatd> Coord4dQuat;



typedef Coord<Vec3f, AxisAnglef> Coord3fAxisAngle;
typedef Coord<Vec3d, AxisAngled> Coord3dAxisAngle;


typedef Coord<Vec4f, AxisAnglef> Coord4fAxisAngle;
typedef Coord<Vec4d, AxisAngled> Coord4dAxisAngle;

}

#line 226 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Coord.h"
#line 21 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_CoordOps.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Coord.h"

































































































































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_CoordOps.h"

namespace gmtl
{





   




   template <typename POS_TYPE, typename ROT_TYPE>
   inline bool operator==( const Coord<POS_TYPE, ROT_TYPE>& c1, 
                           const Coord<POS_TYPE, ROT_TYPE>& c2 )
   {
      return bool( c1.getPos() == c2.getPos() &&
                   c1.getRot() == c2.getRot() );
   }

   




   template <typename POS_TYPE, typename ROT_TYPE>
   inline bool operator!=( const Coord<POS_TYPE, ROT_TYPE>& c1, 
                           const Coord<POS_TYPE, ROT_TYPE>& c2 )
   {
      return !operator==( c1, c2 );
   }

   





   template <typename POS_TYPE, typename ROT_TYPE>
   bool isEqual( const Coord<POS_TYPE, ROT_TYPE>& c1, 
                 const Coord<POS_TYPE, ROT_TYPE>& c2, 
                 typename Coord<POS_TYPE, ROT_TYPE>::DataType tol = 
                     (typename Coord<POS_TYPE, ROT_TYPE>::DataType)0.0 )
   {
      return bool( isEqual( c1.getPos(), c2.getPos(), tol ) &&
                   isEqual( c1.getRot(), c2.getRot(), tol )     );
   }


}

#line 92 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_CoordOps.h"
#line 22 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Defines.h"



































































































#line 23 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_EulerAngle.h"





























































































































































#line 24 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_EulerAngleOps.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_EulerAngle.h"





























































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_EulerAngleOps.h"

namespace gmtl
{














template<class DATA_TYPE, typename ROT_ORDER>
inline bool operator==(const EulerAngle<DATA_TYPE, ROT_ORDER>& e1,
                       const EulerAngle<DATA_TYPE, ROT_ORDER>& e2)
{
   
   if (e1[0] != e2[0]) return false;
   if (e1[1] != e2[1]) return false;
   if (e1[2] != e2[2]) return false;
   return true;
}









template<class DATA_TYPE, typename ROT_ORDER>
inline bool operator!=(const EulerAngle<DATA_TYPE, ROT_ORDER>& e1,
                       const EulerAngle<DATA_TYPE, ROT_ORDER>& e2)
{
   return(! (e1 == e2));
}













template<class DATA_TYPE, typename ROT_ORDER>
inline bool isEqual( const EulerAngle<DATA_TYPE, ROT_ORDER>& e1,
                     const EulerAngle<DATA_TYPE, ROT_ORDER>& e2,
                     const DATA_TYPE& eps = (DATA_TYPE)0 )
{
   (void)( (!!((eps >= (DATA_TYPE)0))) || (_wassert(L"(eps >= (DATA_TYPE)0)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_EulerAngleOps.h", 99), 0) );
   
   
   if (!Math::isEqual( e1[0], e2[0], eps )) return false;
   if (!Math::isEqual( e1[1], e2[1], eps )) return false;
   if (!Math::isEqual( e1[2], e2[2], eps )) return false;
   return true;
}






} 

#line 116 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_EulerAngleOps.h"
#line 25 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_Assert.h"













#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"

#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h"






































































































































#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecOps.h"
























































































































































































































































































































































































































































































































































#line 42 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Quat.h"





























































































































































































#line 43 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_QuatOps.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"






















































































































































































































































































































































































































































































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_QuatOps.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Quat.h"





























































































































































































#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_QuatOps.h"

namespace gmtl
{




       
   





   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& mult( Quat<DATA_TYPE>& result, const Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2 )
   {
      
      
      

      
      
      

      
      












      
      Quat<DATA_TYPE> temporary; 
      temporary[Xelt] = q2[Welt]*q1[Xelt] + q2[Xelt]*q1[Welt] + q2[Yelt]*q1[Zelt] - q2[Zelt]*q1[Yelt];
      temporary[Yelt] = q2[Welt]*q1[Yelt] + q2[Yelt]*q1[Welt] + q2[Zelt]*q1[Xelt] - q2[Xelt]*q1[Zelt];
      temporary[Zelt] = q2[Welt]*q1[Zelt] + q2[Zelt]*q1[Welt] + q2[Xelt]*q1[Yelt] - q2[Yelt]*q1[Xelt];
      temporary[Welt] = q2[Welt]*q1[Welt] - q2[Xelt]*q1[Xelt] - q2[Yelt]*q1[Yelt] - q2[Zelt]*q1[Zelt];

      
      result[Xelt] = temporary[Xelt];
      result[Yelt] = temporary[Yelt];
      result[Zelt] = temporary[Zelt];
      result[Welt] = temporary[Welt];

      
      
      return result;
   }

   




   template <typename DATA_TYPE>
   Quat<DATA_TYPE> operator*( const Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2 )
   {
      
      
      
      return Quat<DATA_TYPE>( q2[Welt]*q1[Xelt] + q2[Xelt]*q1[Welt] + q2[Yelt]*q1[Zelt] - q2[Zelt]*q1[Yelt],
                              q2[Welt]*q1[Yelt] + q2[Yelt]*q1[Welt] + q2[Zelt]*q1[Xelt] - q2[Xelt]*q1[Zelt],
                              q2[Welt]*q1[Zelt] + q2[Zelt]*q1[Welt] + q2[Xelt]*q1[Yelt] - q2[Yelt]*q1[Xelt],
                              q2[Welt]*q1[Welt] - q2[Xelt]*q1[Xelt] - q2[Yelt]*q1[Yelt] - q2[Zelt]*q1[Zelt] );
   }

   



   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& operator*=( Quat<DATA_TYPE>& result, const Quat<DATA_TYPE>& q2 )
   {
      return mult( result, result, q2 );
   }

   




   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& negate( Quat<DATA_TYPE>& result )
   {
      result[0] = -result[0];
      result[1] = -result[1];
      result[2] = -result[2];
      result[3] = -result[3];
      return result;
   }

   




   template <typename DATA_TYPE>
   Quat<DATA_TYPE> operator-( const Quat<DATA_TYPE>& quat )
   {
      return Quat<DATA_TYPE>( -quat[0], -quat[1], -quat[2], -quat[3] );
   }

   



   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& mult( Quat<DATA_TYPE>& result, const Quat<DATA_TYPE>& q, DATA_TYPE s )
   {
      result[0] = q[0] * s;
      result[1] = q[1] * s;
      result[2] = q[2] * s;
      result[3] = q[3] * s;
      return result;
   }

   



   template <typename DATA_TYPE>
   Quat<DATA_TYPE> operator*( const Quat<DATA_TYPE>& q, DATA_TYPE s )
   {
      Quat<DATA_TYPE> temporary;
      return mult( temporary, q, s );
   }

   



   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& operator*=( Quat<DATA_TYPE>& q, DATA_TYPE s )
   {
      return mult( q, q, s );
   }

   



   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& div( Quat<DATA_TYPE>& result, const Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2 )
   {
      Quat<DATA_TYPE> q2_inv( q2 ), r, s;

      
      conj( q2_inv );

      mult( r, q1, q2_inv );
      mult( s, q2_inv, q2_inv );

      float sw_inv = 1.0f / s[Welt];
      result[0] = r[0] * sw_inv;
      result[1] = r[1] * sw_inv;
      result[2] = r[2] * sw_inv;
      result[3] = r[3] * sw_inv;
      return result;
   }

   



   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& div( Quat<DATA_TYPE>& result, const Quat<DATA_TYPE>& q, DATA_TYPE s )
   {
      result[0] = q[0] / s;
      result[1] = q[1] / s;
      result[2] = q[2] / s;
      result[3] = q[3] / s;
      return result;
   }

   



   template <typename DATA_TYPE>
   Quat<DATA_TYPE> operator/( const Quat<DATA_TYPE>& q, DATA_TYPE s )
   {
      Quat<DATA_TYPE> temporary;
      return div( temporary, q, s );
   }

   



   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& operator/=( const Quat<DATA_TYPE>& q, DATA_TYPE s )
   {
      return div( q, q, s );
   }

   


   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& add( Quat<DATA_TYPE>& result, const Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2 )
   {
      result[0] = q1[0] + q2[0];
      result[1] = q1[1] + q2[1];
      result[2] = q1[2] + q2[2];
      result[3] = q1[3] + q2[3];
      return result;
   }

   



   template <typename DATA_TYPE>
   Quat<DATA_TYPE> operator+( const Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2 )
   {
      Quat<DATA_TYPE> temporary;
      return add( temporary, q1, q2 );
   }

   



   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& operator+=( Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2 )
   {
      return add( q1, q1, q2 );
   }

   


   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& sub( Quat<DATA_TYPE>& result, const Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2 )
   {
      result[0] = q1[0] - q2[0];
      result[1] = q1[1] - q2[1];
      result[2] = q1[2] - q2[2];
      result[3] = q1[3] - q2[3];
      return result;
   }

   



   template <typename DATA_TYPE>
   Quat<DATA_TYPE> operator-( const Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2 )
   {
      Quat<DATA_TYPE> temporary;
      return sub( temporary, q1, q2 );
   }

   



   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& operator-=( Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2 )
   {
      return sub( q1, q1, q2 );
   }

   





   template <typename DATA_TYPE>
   DATA_TYPE dot( const Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2 )
   {
      return DATA_TYPE( (q1[0] * q2[0]) +
                        (q1[1] * q2[1]) +
                        (q1[2] * q2[2]) +
                        (q1[3] * q2[3])  );
   }

   






   template <typename DATA_TYPE>
   DATA_TYPE lengthSquared( const Quat<DATA_TYPE>& q )
   {
      return dot( q, q );
   }

   





   template <typename DATA_TYPE>
   DATA_TYPE length( const Quat<DATA_TYPE>& q )
   {
      return Math::sqrt( lengthSquared( q ) );
   }

   




   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& normalize( Quat<DATA_TYPE>& result )
   {
      DATA_TYPE l = length( result );

      
      if (l < (DATA_TYPE)0.0001)
         return result;

      DATA_TYPE l_inv = ((DATA_TYPE)1.0) / l;
      result[Xelt] *= l_inv;
      result[Yelt] *= l_inv;
      result[Zelt] *= l_inv;
      result[Welt] *= l_inv;

      return result;
   }

   








   template< typename DATA_TYPE >
   bool isNormalized( const Quat<DATA_TYPE>& q1, const DATA_TYPE eps = (DATA_TYPE)0.0001f )
   {
      return Math::isEqual( lengthSquared( q1 ), DATA_TYPE(1), eps );
   }

   





   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& conj( Quat<DATA_TYPE>& result )
   {
      result[Xelt] = -result[Xelt];
      result[Yelt] = -result[Yelt];
      result[Zelt] = -result[Zelt];
      return result;
   }

   




   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& invert( Quat<DATA_TYPE>& result )
   {
      
      conj( result );

      
      DATA_TYPE l = lengthSquared( result );
      if (l < (DATA_TYPE)0.0001)
         return result;

      DATA_TYPE l_inv = ((DATA_TYPE)1.0) / l;
      result[Xelt] *= l_inv;
      result[Yelt] *= l_inv;
      result[Zelt] *= l_inv;
      result[Welt] *= l_inv;
      return result;
   }

   




   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& exp( Quat<DATA_TYPE>& result )
   {
      DATA_TYPE len1, len2;

      len1 = Math::sqrt( result[Xelt] * result[Xelt] +
                         result[Yelt] * result[Yelt] +
                         result[Zelt] * result[Zelt] );
      if (len1 > (DATA_TYPE)0.0)
         len2 = Math::sin( len1 ) / len1;
      else
         len2 = (DATA_TYPE)1.0;

      result[Xelt] = result[Xelt] * len2;
      result[Yelt] = result[Yelt] * len2;
      result[Zelt] = result[Zelt] * len2;
      result[Welt] = Math::cos( len1 );

      return result;
   }

   



   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& log( Quat<DATA_TYPE>& result )
   {
      DATA_TYPE length;

      length = Math::sqrt( result[Xelt] * result[Xelt] +
                           result[Yelt] * result[Yelt] +
                           result[Zelt] * result[Zelt] );

      
      if (Math::isEqual( result[Welt], (DATA_TYPE)0.0, (DATA_TYPE)0.00001 ) == false)
         length = Math::atan( length / result[Welt] );
      else
         length = Math::PI_OVER_2;

      result[Welt] = (DATA_TYPE)0.0;
      result[Xelt] = result[Xelt] * length;
      result[Yelt] = result[Yelt] * length;
      result[Zelt] = result[Zelt] * length;
      return result;
   }
   
   
   template <typename DATA_TYPE>
   void squad( Quat<DATA_TYPE>& result, DATA_TYPE t, const Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2, const Quat<DATA_TYPE>& a, const Quat<DATA_TYPE>& b )
   {
      (void)( (!!((false))) || (_wassert(L"(false)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_QuatOps.h", 484), 0) );
   }

   
   template <typename DATA_TYPE>
   void meanTangent( Quat<DATA_TYPE>& result, const Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2, const Quat<DATA_TYPE>& q3 )
   {
       (void)( (!!((false))) || (_wassert(L"(false)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_QuatOps.h", 491), 0) );
   }


   

   






   










   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& slerp( Quat<DATA_TYPE>& result, const DATA_TYPE t, const Quat<DATA_TYPE>& from, const Quat<DATA_TYPE>& to, bool adjustSign=true)
   {
      const Quat<DATA_TYPE>& p = from; 

      
      DATA_TYPE cosom = dot( from, to );

      
      Quat<DATA_TYPE> q;
      if (adjustSign && (cosom < (DATA_TYPE)0.0))
      {
         cosom = -cosom;
         q[0] = -to[0];   
         q[1] = -to[1];
         q[2] = -to[2];
         q[3] = -to[3];
      }
      else
      {
         q = to;
      }

      
      DATA_TYPE sclp, sclq;
      if (((DATA_TYPE)1.0 - cosom) > (DATA_TYPE)0.0001) 
      {
         
         DATA_TYPE omega, sinom;
         omega = gmtl::Math::aCos( cosom ); 
         sinom = gmtl::Math::sin( omega );
         sclp  = gmtl::Math::sin( ((DATA_TYPE)1.0 - t) * omega ) / sinom;
         sclq  = gmtl::Math::sin( t * omega ) / sinom;
      }
      else
      {
         
         sclp = (DATA_TYPE)1.0 - t;
         sclq = t;
      }

      result[Xelt] = sclp * p[Xelt] + sclq * q[Xelt];
      result[Yelt] = sclp * p[Yelt] + sclq * q[Yelt];
      result[Zelt] = sclp * p[Zelt] + sclq * q[Zelt];
      result[Welt] = sclp * p[Welt] + sclq * q[Welt];
      return result;
   }

   








   template <typename DATA_TYPE>
   Quat<DATA_TYPE>& lerp( Quat<DATA_TYPE>& result, const DATA_TYPE t, const Quat<DATA_TYPE>& from, const Quat<DATA_TYPE>& to)
   {
      
      const Quat<DATA_TYPE>& p = from;

      
      DATA_TYPE cosom = dot( from, to );

      
      Quat<DATA_TYPE> q;
      if (cosom < (DATA_TYPE)0.0)
      {
         q[0] = -to[0];   
         q[1] = -to[1];
         q[2] = -to[2];
         q[3] = -to[3];
      }
      else
      {
         q = to;
      }

      
      DATA_TYPE sclp, sclq;
      sclp = (DATA_TYPE)1.0 - t;
      sclq = t;

      result[Xelt] = sclp * p[Xelt] + sclq * q[Xelt];
      result[Yelt] = sclp * p[Yelt] + sclq * q[Yelt];
      result[Zelt] = sclp * p[Zelt] + sclq * q[Zelt];
      result[Welt] = sclp * p[Welt] + sclq * q[Welt];
      return result;
   }








   


   template <typename DATA_TYPE>
   inline bool operator==( const Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2 )
   {
      return bool( q1[0] == q2[0] &&
                   q1[1] == q2[1] &&
                   q1[2] == q2[2] &&
                   q1[3] == q2[3]  );
   }

   


   template <typename DATA_TYPE>
   inline bool operator!=( const Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2 )
   {
      return !operator==( q1, q2 );
   }

   

   template <typename DATA_TYPE>
   bool isEqual( const Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2, DATA_TYPE tol = 0.0 )
   {
      return bool( Math::isEqual( q1[0], q2[0], tol ) &&
                   Math::isEqual( q1[1], q2[1], tol ) &&
                   Math::isEqual( q1[2], q2[2], tol ) &&
                   Math::isEqual( q1[3], q2[3], tol )    );
   }

   




   template <typename DATA_TYPE>
   bool isEquiv( const Quat<DATA_TYPE>& q1, const Quat<DATA_TYPE>& q2, DATA_TYPE tol = 0.0 )
   {
      return bool( isEqual( q1, q2, tol ) || isEqual( q1, -q2, tol ) );
   }
   
   
}

#line 661 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_QuatOps.h"
#line 44 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Coord.h"

































































































































































































































#line 45 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Defines.h"



































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"






















































































































































































































































































































































































































































































































































































#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_Assert.h"













#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h"

namespace gmtl
{





























template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
class Matrix
{
public:
   

   typedef DATA_TYPE DataType;
   enum
   {
      Rows = ROWS, Cols = COLS
   };

   



   class RowAccessor
   {
   public:
      RowAccessor(Matrix<DATA_TYPE,ROWS,COLS>* mat, const unsigned row)
         : mMat(mat), mRow(row)
      {
         (void)( (!!((row < ROWS))) || (_wassert(L"(row < ROWS)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h", 95), 0) );
         (void)( (!!((0 != mat))) || (_wassert(L"(0 != mat)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h", 96), 0) );
      }

      DATA_TYPE& operator[](const unsigned column)
      {
         (void)( (!!((column < COLS))) || (_wassert(L"(column < COLS)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h", 101), 0) );
         return (*mMat)(mRow,column);
      }

      Matrix<DATA_TYPE,ROWS,COLS>*  mMat;
      unsigned                      mRow;    
   };

   
   enum XformState
   {
      IDENTITY = 1,
      ORTHOGONAL = 2,
      ORTHONORMAL = 4,
      AFFINE = 8,
      FULL = 16,
      XFORM_ERROR = 32 
   };

   
   Matrix()
   {
      
      for (unsigned int r = 0; r < ROWS; ++r)
      for (unsigned int c = 0; c < COLS; ++c)
         this->operator()( r, c ) = (DATA_TYPE)0.0;

      
      for (unsigned int x = 0; x < Math::Min( COLS, ROWS ); ++x)
         this->operator()( x, x ) = (DATA_TYPE)1.0;

      
      mState = FULL;
   };

   
   Matrix( const Matrix<DATA_TYPE, ROWS, COLS>& matrix )
   {
      this->set( matrix.getData() );
      mState = matrix.mState;
   }

   



   void set( DATA_TYPE v00, DATA_TYPE v01,
             DATA_TYPE v10, DATA_TYPE v11 )
   {
      (void)( (!!((ROWS == 2 && COLS == 2))) || (_wassert(L"(ROWS == 2 && COLS == 2)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h", 150), 0) ); 
      mData[0] = v00;
      mData[1] = v10;
      mData[2] = v01;
      mData[3] = v11;
      mState = FULL;
   }

   


   void set( DATA_TYPE v00, DATA_TYPE v01, DATA_TYPE v02,
             DATA_TYPE v10, DATA_TYPE v11, DATA_TYPE v12  )
   {
      (void)( (!!((ROWS == 2 && COLS == 3))) || (_wassert(L"(ROWS == 2 && COLS == 3)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h", 164), 0) ); 
      mData[0] = v00;
      mData[1] = v10;
      mData[2] = v01;
      mData[3] = v11;
      mData[4] = v02;
      mData[5] = v12;
      mState = FULL;
   }

   


   void set( DATA_TYPE v00, DATA_TYPE v01, DATA_TYPE v02,
             DATA_TYPE v10, DATA_TYPE v11, DATA_TYPE v12,
             DATA_TYPE v20, DATA_TYPE v21, DATA_TYPE v22)
   {
      (void)( (!!((ROWS == 3 && COLS == 3))) || (_wassert(L"(ROWS == 3 && COLS == 3)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h", 181), 0) ); 
      mData[0] = v00;
      mData[1] = v10;
      mData[2] = v20;

      mData[3] = v01;
      mData[4] = v11;
      mData[5] = v21;

      mData[6] = v02;
      mData[7] = v12;
      mData[8] = v22;
      mState = FULL;
   }

   


   void set( DATA_TYPE v00, DATA_TYPE v01, DATA_TYPE v02, DATA_TYPE v03,
             DATA_TYPE v10, DATA_TYPE v11, DATA_TYPE v12, DATA_TYPE v13,
             DATA_TYPE v20, DATA_TYPE v21, DATA_TYPE v22, DATA_TYPE v23)
   {
      (void)( (!!((ROWS == 3 && COLS == 4))) || (_wassert(L"(ROWS == 3 && COLS == 4)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h", 203), 0) );
      mData[0] = v00;
      mData[1] = v10;
      mData[2] = v20;
      mData[3] = v01;
      mData[4] = v11;
      mData[5] = v21;
      mData[6] = v02;
      mData[7] = v12;
      mData[8] = v22;

      
      mData[9]  = v03;
      mData[10] = v13;
      mData[11] = v23;
      mState = FULL;
   }

   


   void set( DATA_TYPE v00, DATA_TYPE v01, DATA_TYPE v02, DATA_TYPE v03,
             DATA_TYPE v10, DATA_TYPE v11, DATA_TYPE v12, DATA_TYPE v13,
             DATA_TYPE v20, DATA_TYPE v21, DATA_TYPE v22, DATA_TYPE v23,
             DATA_TYPE v30, DATA_TYPE v31, DATA_TYPE v32, DATA_TYPE v33 )
   {
      (void)( (!!((ROWS == 4 && COLS == 4))) || (_wassert(L"(ROWS == 4 && COLS == 4)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h", 229), 0) );
      mData[0]  = v00;
      mData[1]  = v10;
      mData[2]  = v20;
      mData[4]  = v01;
      mData[5]  = v11;
      mData[6]  = v21;
      mData[8]  = v02;
      mData[9]  = v12;
      mData[10] = v22;

      
      mData[12] = v03;
      mData[13] = v13;
      mData[14] = v23;

      
      mData[3]  = v30;
      mData[7]  = v31;
      mData[11] = v32;
      mData[15] = v33;
      mState = FULL;
   }

   


   

   

















   void set( const DATA_TYPE* data )
   {
      
      for (unsigned int x = 0; x < ROWS * COLS; ++x)
         mData[x] = data[x];
      mState = FULL;
   }

   





















   void setTranspose( const DATA_TYPE* data )
   {
      
      for (unsigned int r = 0; r < ROWS; ++r)
      for (unsigned int c = 0; c < COLS; ++c)
         this->operator()( r, c ) = data[(r * COLS) + c];
      mState = FULL;
   }

   
   DATA_TYPE& operator()( const unsigned row, const unsigned column )
   {
      (void)( (!!(((row < ROWS) && (column < COLS)))) || (_wassert(L"((row < ROWS) && (column < COLS))", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h", 318), 0) );
      return mData[column*ROWS + row];
   }

   
   const DATA_TYPE&  operator()( const unsigned row, const unsigned column ) const
   {
      (void)( (!!(((row < ROWS) && (column < COLS)))) || (_wassert(L"((row < ROWS) && (column < COLS))", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h", 325), 0) );
      return mData[column*ROWS + row];
   }

   
   RowAccessor operator[]( const unsigned row )
   {
      return RowAccessor(this, row);
   }

   








   


   const DATA_TYPE*  getData() const { return (DATA_TYPE*)mData; }

   bool isError()
   {
      return mState & XFORM_ERROR;
   }
   void setError()
   {
      mState |= XFORM_ERROR;
   }

public:
   


   DATA_TYPE mData[COLS*ROWS];

   
   char mState;
};

typedef Matrix<float, 2, 2> Matrix22f;
typedef Matrix<double, 2, 2> Matrix22d;
typedef Matrix<float, 2, 3> Matrix23f;
typedef Matrix<double, 2, 3> Matrix23d;
typedef Matrix<float, 3, 3> Matrix33f;
typedef Matrix<double, 3, 3> Matrix33d;
typedef Matrix<float, 3, 4> Matrix34f;
typedef Matrix<double, 3, 4> Matrix34d;
typedef Matrix<float, 4, 4> Matrix44f;
typedef Matrix<double, 4, 4> Matrix44d;


const Matrix22f MAT_IDENTITY22F = Matrix22f();


const Matrix22d MAT_IDENTITY22D = Matrix22d();


const Matrix23f MAT_IDENTITY23F = Matrix23f();


const Matrix23d MAT_IDENTITY23D = Matrix23d();


const Matrix33f MAT_IDENTITY33F = Matrix33f();


const Matrix33d MAT_IDENTITY33D = Matrix33d();


const Matrix34f MAT_IDENTITY34F = Matrix34f();


const Matrix34d MAT_IDENTITY34D = Matrix34d();


const Matrix44f MAT_IDENTITY44F = Matrix44f();


const Matrix44d MAT_IDENTITY44D = Matrix44d();


} 



#line 415 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h"
#line 46 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_Meta.h"

























































































#line 47 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"






















































































































































































































































































































































































































































































































































































#line 48 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Xforms.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Point.h"






































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Xforms.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h"






































































































































#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Xforms.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h"






























































































































































































































































































































































































































#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Xforms.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_MatrixOps.h"





































#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iostream"

#pragma once






#pragma pack(push,8)
#pragma warning(push,3)
#line 12 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iostream"
namespace std {

		

 extern __declspec(dllimport) istream *_Ptr_cin;
 extern __declspec(dllimport) ostream *_Ptr_cout;
 extern __declspec(dllimport) ostream *_Ptr_cerr;
 extern __declspec(dllimport) ostream *_Ptr_clog;
#line 21 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iostream"


		
class __declspec(dllimport) _Winit {
public:
	__thiscall _Winit();
	__thiscall ~_Winit();
private:
	 static int _Init_cnt;
	};
#line 32 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iostream"

		

 extern __declspec(dllimport) wistream *_Ptr_wcin;
 extern __declspec(dllimport) wostream *_Ptr_wcout;
 extern __declspec(dllimport) wostream *_Ptr_wcerr;
 extern __declspec(dllimport) wostream *_Ptr_wclog;
#line 40 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iostream"












 extern __declspec(dllimport) istream cin;
 extern __declspec(dllimport) ostream cout;
 extern __declspec(dllimport) ostream cerr;
 extern __declspec(dllimport) ostream clog;

 extern __declspec(dllimport) wistream wcin;
 extern __declspec(dllimport) wostream wcout;
 extern __declspec(dllimport) wostream wcerr;
 extern __declspec(dllimport) wostream wclog;
#line 62 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iostream"
}


#pragma warning(pop)
#pragma pack(pop)
#line 68 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iostream"

#line 70 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iostream"
#line 71 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\iostream"





#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_MatrixOps.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

#pragma once






#pragma pack(push,8)
#pragma warning(push,3)
 #pragma warning(disable: 4244)
#line 13 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

namespace std {

		
const int _ISORT_MAX = 32;	

		
template<class _InIt,
	class _Fn1> inline
	_Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 24);
	_Debug_pointer(_Func, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",25);
	typename ::std:: _Checked_iterator_base_helper<_InIt>::_Checked_iterator_base_type _ChkFirst(::std:: _Checked_base(_First));
	typename ::std:: _Checked_iterator_base_helper<_InIt>::_Checked_iterator_base_type _ChkLast(::std:: _Checked_base(_Last));
	for (; _ChkFirst != _ChkLast; ++_ChkFirst)
		_Func(*_ChkFirst);
	return (_Func);
	}

		
template<class _InIt, class _Ty>
inline
	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 38);
	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			break;
	return (_First);
	}

inline const char *_Find(const char *_First, const char *_Last, int _Val)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 47);
	_First = (const char *)::memchr(_First, _Val, _Last - _First);
	return (_First == 0 ? _Last : _First);
	}

inline const signed char *_Find(const signed char *_First,
	const signed char *_Last, int _Val)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 55);
	_First = (const signed char *)::memchr(_First, _Val,
		_Last - _First);
	return (_First == 0 ? _Last : _First);
	}

inline const unsigned char *_Find(const unsigned char *_First,
	const unsigned char *_Last, int _Val)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 64);
	_First = (const unsigned char *)::memchr(_First, _Val,
		_Last - _First);
	return (_First == 0 ? _Last : _First);
	}

template<class _InIt, class _Ty>
inline
	_InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	::std:: _Checked_assign_from_base(_First, _Find(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val));
#line 76 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return (_First);
	}

		
template<class _InIt,
	class _Pr> inline
	_InIt _Find_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 84);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",85);
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			break;
	return (_First);
	}

template<class _InIt,
	class _Pr> inline
	_InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	::std:: _Checked_assign_from_base(_First, _Find_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred));
#line 98 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return (_First);
	}

		
template<class _FwdIt> inline
	_FwdIt _Adjacent_find(_FwdIt _First, _FwdIt _Last)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 105);
	for (_FwdIt _Firstb; (_Firstb = _First) != _Last && ++_First != _Last; )
		if (*_Firstb == *_First)
			return (_Firstb);
	return (_Last);
	}

template<class _FwdIt> inline
	_FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last)
	{	
	::std:: _Checked_assign_from_base(_First, _Adjacent_find(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last)));
#line 117 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return (_First);
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 125);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",126);
	for (_FwdIt _Firstb; (_Firstb = _First) != _Last && ++_First != _Last; )
		if (_Pred(*_Firstb, *_First))
			return (_Firstb);
	return (_Last);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	::std:: _Checked_assign_from_base(_First, _Adjacent_find(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred));
#line 139 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return (_First);
	}

		
template<class _InIt,
	class _Ty> inline
	typename iterator_traits<_InIt>::difference_type
		_Count(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 148);
	typename iterator_traits<_InIt>::difference_type _Cnt = 0;

	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			++_Cnt;
	return (_Cnt);
	}

template<class _InIt,
	class _Ty> inline
	typename iterator_traits<_InIt>::difference_type
		count(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	return _Count(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val);
	}

		
template<class _InIt,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		_Count_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 171);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",172);
	typename iterator_traits<_InIt>::difference_type _Count = 0;

	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			++_Count;
	return (_Count);
	}

template<class _InIt,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		count_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	return _Count_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred);
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2> inline
	_FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Diff1 *, _Diff2 *)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 197);
	_Debug_range(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 198);
	_Diff1 _Count1 = 0;
	_Distance(_First1, _Last1, _Count1);
	_Diff2 _Count2 = 0;
	_Distance(_First2, _Last2, _Count2);

	for (; _Count2 <= _Count1; ++_First1, --_Count1)
		{	
		_FwdIt1 _Mid1 = _First1;
		for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, ++_Mid2)
			if (_Mid2 == _Last2)
				return (_First1);
			else if (!(*_Mid1 == *_Mid2))
				break;
		}
	return (_Last1);
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	::std:: _Checked_assign_from_base(_First1, _Search(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dist_type(_First1), _Dist_type(_First2)));
#line 225 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return _First1;
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2,
	class _Pr> inline
	_FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 237);
	_Debug_range(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 238);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",239);
	_Diff1 _Count1 = 0;
	_Distance(_First1, _Last1, _Count1);
	_Diff2 _Count2 = 0;
	_Distance(_First2, _Last2, _Count2);

	for (; _Count2 <= _Count1; ++_First1, --_Count1)
		{	
		_FwdIt1 _Mid1 = _First1;
		for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, ++_Mid2)
			if (_Mid2 == _Last2)
				return (_First1);
			else if (!_Pred(*_Mid1, *_Mid2))
				break;
		}
	return (_Last1);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	::std:: _Checked_assign_from_base(_First1, _Search(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Pred, _Dist_type(_First1), _Dist_type(_First2)));
#line 267 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return _First1;
	}

		
template<class _FwdIt1,
	class _Diff2,
	class _Ty> inline
	_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val, forward_iterator_tag)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 277);
	_FwdIt1 _Mid1;

	if (_Count == 0)
		return (_First1);

	for (;; _First1 = ++_Mid1)
		{	
		_Diff2 _Count1 = _Count;

		for (; _First1 != _Last1; ++_First1)
			if (*_First1 == _Val)
				break;	

		for (_Mid1 = _First1;; )
			if (--_Count1 == 0)
				return (_First1);	
			else if (_Mid1 == _Last1 || !(*++_Mid1 == _Val))
				break;
		if (_Mid1 == _Last1)
			return (_Last1);
		}
	}

template<class _FwdIt1,
	class _Diff2,
	class _Ty> inline
	_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val, random_access_iterator_tag)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 307);
	_FwdIt1 _Mid1;

	if (_Count == 0)
		return (_First1);

	for (;; _First1 = ++_Mid1)
		{	
		_FwdIt1 _Oldfirst1 = _First1;
		_Diff2 _Count1 = _Count;

		for (;; _First1 += _Count)
			if (_First1 == _Last1)
				return (_Last1);	
			else if (*_First1 == _Val)
				break;	
			else if (_Last1 - _First1 < _Count)
				return (_Last1);	

		_Mid1 = _First1;
		if (_Oldfirst1 != _First1)
			for (++_Oldfirst1; _Oldfirst1 != _First1; --_First1, --_Count1)
				if (!(_First1[-1] == _Val))
					break;	

		for (;;)
			if (--_Count1 == 0)
				return (_First1);	
			else if (_Mid1 == _Last1 || !(*++_Mid1 == _Val))
				break;
		if (_Mid1 == _Last1)
			return (_Last1);
		}
	}

template<class _FwdIt1,
	class _Diff2,
	class _Ty> inline
	_FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val)
	{	
	::std:: _Checked_assign_from_base(_First1, _Search_n(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _Count, _Val, _Iter_cat(_First1)));
#line 351 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return _First1;
	}

		
template<class _FwdIt1,
	class _Diff2,
	class _Ty,
	class _Pr> inline
	_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val, _Pr _Pred, forward_iterator_tag)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 362);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",363);
	_FwdIt1 _Mid1;

	if (_Count == 0)
		return (_First1);

	for (;; _First1 = ++_Mid1)
		{	
		_Diff2 _Count1 = _Count;

		for (; _First1 != _Last1; ++_First1)
			if (_Pred(*_First1, _Val))
				break;	

		for (_Mid1 = _First1;; )
			if (--_Count1 == 0)
				return (_First1);	
			else if (_Mid1 == _Last1 || !_Pred(*++_Mid1, _Val))
				break;
		if (_Mid1 == _Last1)
			return (_Last1);
		}
	}

template<class _FwdIt1,
	class _Diff2,
	class _Ty,
	class _Pr> inline
	_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val, _Pr _Pred, random_access_iterator_tag)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 394);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",395);
	_FwdIt1 _Mid1;

	if (_Count == 0)
		return (_First1);

	for (;; _First1 = ++_Mid1)
		{	
		_FwdIt1 _Oldfirst1 = _First1;
		_Diff2 _Count1 = _Count;

		for (;; _First1 += _Count)
			if (_First1 == _Last1)
				return (_Last1);	
			else if (_Pred(*_First1, _Val))
				break;	
			else if (_Last1 - _First1 < _Count)
				return (_Last1);	

		if (_Oldfirst1 != _First1)
			for (++_Oldfirst1; _Oldfirst1 != _First1; --_First1, --_Count1)
				if (!_Pred(_First1[-1], _Val))
					break;	

		for (_Mid1 = _First1;; )
			if (--_Count1 == 0)
				return (_First1);	
			else if (_Mid1 == _Last1 || !_Pred(*++_Mid1, _Val))
				break;
		if (_Mid1 == _Last1)
			return (_Last1);
		}
	}

template<class _FwdIt1,
	class _Diff2,
	class _Ty,
	class _Pr> inline
	_FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val, _Pr _Pred)
	{	
	::std:: _Checked_assign_from_base(_First1, _Search_n(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _Count, _Val, _Pred, _Iter_cat(_First1)));
#line 439 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return _First1;
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2> inline
	_FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Diff1 *, _Diff2 *)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 450);
	_Debug_range(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 451);
	_Diff1 _Count1 = 0;
	_Distance(_First1, _Last1, _Count1);
	_Diff2 _Count2 = 0;
	_Distance(_First2, _Last2, _Count2);
	_FwdIt1 _Ans = _Last1;

	if (0 < _Count2)
		for (; _Count2 <= _Count1; ++_First1, --_Count1)
			{	
			_FwdIt1 _Mid1 = _First1;
			for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1)
				if (!(*_Mid1 == *_Mid2))
					break;
				else if (++_Mid2 == _Last2)
					{	
					_Ans = _First1;
					break;
					}
			}
	return (_Ans);
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	::std:: _Checked_assign_from_base(_First1, _Find_end(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dist_type(_First1), _Dist_type(_First2)));
#line 483 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return _First1;
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2,
	class _Pr> inline
	_FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 495);
	_Debug_range(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 496);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",497);
	_Diff1 _Count1 = 0;
	_Distance(_First1, _Last1, _Count1);
	_Diff2 _Count2 = 0;
	_Distance(_First2, _Last2, _Count2);
	_FwdIt1 _Ans = _Last1;

	if (0 < _Count2)
		for (; _Count2 <= _Count1; ++_First1, --_Count1)
			{	
			_FwdIt1 _Mid1 = _First1;
			for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1)
				if (!_Pred(*_Mid1, *_Mid2))
					break;
				else if (++_Mid2 == _Last2)
					{	
					_Ans = _First1;
					break;
					}
			}
	return (_Ans);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	::std:: _Checked_assign_from_base(_First1, _Find_end(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Pred, _Dist_type(_First1), _Dist_type(_First2)));
#line 530 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return _First1;
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 _Find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 539);
	_Debug_range(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 540);
	for (; _First1 != _Last1; ++_First1)
		for (_FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2)
			if (*_First1 == *_Mid2)
				return (_First1);
	return (_First1);
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 553);
	_Debug_range(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 554);
	::std:: _Checked_assign_from_base(_First1, _Find_first_of(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2)));
#line 558 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return _First1;
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 _Find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",568);
	for (; _First1 != _Last1; ++_First1)
		for (_FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2)
			if (_Pred(*_First1, *_Mid2))
				return (_First1);
	return (_First1);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	::std:: _Checked_assign_from_base(_First1, _Find_first_of(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Pred));
#line 585 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return (_First1);
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
	{	
	std::swap(*_Left, *_Right);
	}

		
template<class _FwdIt1, class _FwdIt2, class _FwdItCats>
inline
	_FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
		_FwdItCats, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 602);
	for (; _First1 != _Last1; ++_First1, ++_First2)
		std::iter_swap(_First1, _First2);
	return (_First2);
	}


template<class _FwdIt1, class _FwdIt2>
inline
	_FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
		random_access_iterator_tag, _Range_checked_iterator_tag)
	{	
	
	_FwdIt2 _Result = _First2 + (_Last1 - _First1);
	_Swap_ranges(_First1, _Last1, ::std:: _Checked_base(_First2),
		forward_iterator_tag(), _Range_checked_iterator_tag());
	return (_Result);
	}
#line 621 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"



template<class _FwdIt1, class _FwdIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt2 >::_Result, _FwdIt2 >::_Result swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
	{
		return _Swap_ranges(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
			_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	}

template<class _FwdIt1, class _FwdElem2, size_t _Size>
inline
_FwdElem2* swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdElem2 (&_First2)[_Size])
	{
		return (swap_ranges(_First1, _Last1, ::stdext:: make_checked_array_iterator(_First2, _Size)).base());
	}

template<class _FwdIt1, class _FwdIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt2 >::_Result, _FwdIt2 >::_Result swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
	{
		return _Swap_ranges(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
			_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	}











#line 659 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _InIt, class _OutIt, class _Fn1, class _InOutItCat>
inline
	_OutIt _Transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func,
		_InOutItCat, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 666);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",667);
	_Debug_pointer(_Func, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",668);
	for (; _First != _Last; ++_First, ++_Dest)
		*_Dest = _Func(*_First);
	return (_Dest);
	}


template<class _InIt, class _OutIt, class _Fn1>
inline
	_OutIt _Transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func,
		random_access_iterator_tag, _Range_checked_iterator_tag)
	{	
	
	_OutIt _Result = _Dest + (_Last - _First);
	_Transform(_First, _Last, ::std:: _Checked_base(_Dest), _Func,
		forward_iterator_tag(), _Range_checked_iterator_tag());
	return (_Result);
	}
#line 687 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"



template<class _InIt, class _OutIt, class _Fn1>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
	{
	return _Transform(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Func,
		_Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt, class _OutElem, class _Fn1, size_t _Size>
inline
_OutElem* transform(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size], _Fn1 _Func)
	{
	return (transform(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Func).base());
	}

template<class _InIt, class _OutIt, class _Fn1>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
	{
	return _Transform(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Func,
		_Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}











#line 726 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats, class _InOutItCat>
inline
	_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
		_OutIt _Dest, _Fn2 _Func,
		_InItCats, _InOutItCat,
		_Range_checked_iterator_tag, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 735);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",736);
	_Debug_pointer(_Func, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",737);
	for (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest)
		*_Dest = _Func(*_First1, *_First2);
	return (_Dest);
	}


template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
inline
	_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
		_OutIt _Dest, _Fn2 _Func,
		random_access_iterator_tag, random_access_iterator_tag,
		_Range_checked_iterator_tag, _Range_checked_iterator_tag)
	{	
	
	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);
	_OutIt _Result = _Dest + (_Last1 - _First1);
	_Transform(_First1, _Last1, ::std:: _Checked_base(_First2),
		::std:: _Checked_base(_Dest), _Func,
		forward_iterator_tag(), forward_iterator_tag(),
		_Range_checked_iterator_tag(), _Range_checked_iterator_tag());
	return _Result;
	}

template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InOutItCat>
inline
	_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
		_OutIt _Dest, _Fn2 _Func,
		random_access_iterator_tag, _InOutItCat,
		_Range_checked_iterator_tag, _Range_checked_iterator_tag)
	{	
	
	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);
	return _Transform(_First1, _Last1, ::std:: _Checked_base(_First2),
		_Dest, _Func,
		forward_iterator_tag(), forward_iterator_tag(),
		_Range_checked_iterator_tag(), _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats>
inline
	_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
		_OutIt _Dest, _Fn2 _Func,
		_InItCats, random_access_iterator_tag,
		_Range_checked_iterator_tag, _Range_checked_iterator_tag)
	{	
	
	_OutIt _Result = _Dest + (_Last1 - _First1);
	_Transform(_First1, _Last1, _First2,
		::std:: _Checked_base(_Dest), _Func,
		forward_iterator_tag(), forward_iterator_tag(),
		_Range_checked_iterator_tag(), _Range_checked_iterator_tag());
	return _Result;
	}
#line 792 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"



template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result && ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
		_OutIt _Dest, _Fn2 _Func)
	{
	return _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Dest, _Func,
		_Iter_random(_First1, _First2), _Iter_random(_First1, _Dest),
		::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InElem2, class _OutElem, class _Fn2, size_t _SizeFirst2, size_t _SizeDest>
inline
_OutElem* transform(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_SizeFirst2],
		_OutElem (&_Dest)[_SizeDest], _Fn2 _Func)
	{
	return (transform(_First1, _Last1,
		::stdext:: make_checked_array_iterator(_First2, _SizeFirst2),
		::stdext:: make_checked_array_iterator(_Dest, _SizeDest),
		_Func).base());
	}

template<class _InIt1, class _InIt2, class _OutElem, class _Fn2, size_t _SizeDest>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, _OutElem* >::_Result transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
		_OutElem (&_Dest)[_SizeDest], _Fn2 _Func)
	{
	return (_Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
		::stdext:: make_checked_array_iterator(_Dest, _SizeDest), _Func,
		_Iter_random(_First1, _First2), _Iter_cat(_First1),
		::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()).base());
	}

template<class _InIt1, class _InIt2, class _OutElem, class _Fn2, size_t _SizeDest>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, _OutElem* >::_Result transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
		_OutElem (&_Dest)[_SizeDest], _Fn2 _Func)
	{
	return (_Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
		::stdext:: make_checked_array_iterator(_Dest, _SizeDest), _Func,
		_Iter_random(_First1, _First2), _Iter_cat(_First1),
		::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()).base());
	}

template<class _InIt1, class _InElem2, class _OutIt, class _Fn2, size_t _SizeFirst2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result transform(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_SizeFirst2],
		_OutIt _Dest, _Fn2 _Func)
	{
	return (_Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::stdext:: make_checked_array_iterator(_First2, _SizeFirst2),
		_Dest, _Func,
		_Iter_cat(_First1), _Iter_random(_First1, _Dest),
		::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt1, class _InElem2, class _OutIt, class _Fn2, size_t _SizeFirst2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result transform(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_SizeFirst2],
		_OutIt _Dest, _Fn2 _Func)
	{
	return (_Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::stdext:: make_checked_array_iterator(_First2, _SizeFirst2),
		_Dest, _Func,
		_Iter_cat(_First1), _Iter_random(_First1, _Dest),
		::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result || !::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
		_OutIt _Dest, _Fn2 _Func)
	{
	return _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Dest, _Func,
		_Iter_random(_First1, _First2), _Iter_random(_First1, _Dest),
		::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag());
	}













#line 888 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _FwdIt,
	class _Ty> inline
	void _Replace(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 895);
	for (; _First != _Last; ++_First)
		if (*_First == _Oldval)
			*_First = _Newval;
	}

template<class _FwdIt,
	class _Ty> inline
	void replace(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	
	_Replace(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Oldval, _Newval);
	}

		
template<class _FwdIt,
	class _Pr,
	class _Ty> inline
	void _Replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 915);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",916);
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			*_First = _Val;
	}

template<class _FwdIt,
	class _Pr,
	class _Ty> inline
	void replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
	{	
	_Replace_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred, _Val);
	}

		
template<class _InIt, class _OutIt, class _Ty, class _InOutItCat>
inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
		const _Ty& _Oldval, const _Ty& _Newval,
		_InOutItCat, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 937);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",938);
	for (; _First != _Last; ++_First, ++_Dest)
		*_Dest = *_First == _Oldval ? _Newval : *_First;
	return (_Dest);
	}


template<class _InIt, class _OutIt, class _Ty>
inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
		const _Ty& _Oldval, const _Ty& _Newval,
		random_access_iterator_tag, _Range_checked_iterator_tag)
	{	
	
	_OutIt _Result = _Dest + (_Last - _First);
	_Replace_copy(_First, _Last, ::std:: _Checked_base(_Dest),
		_Oldval, _Newval,
		forward_iterator_tag(), _Range_checked_iterator_tag());
	return (_Result);
	}
#line 959 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"



template<class _InIt,
	class _OutIt,
	class _Ty> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	
	return _Replace_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Oldval, _Newval,
		_Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt, class _OutElem, class _Ty, size_t _Size>
inline
_OutElem* replace_copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size],
		const _Ty& _Oldval, const _Ty& _Newval)
	{	
	return (replace_copy(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size),
		_Oldval, _Newval).base());
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	
	return _Replace_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Oldval, _Newval,
		_Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}













#line 1006 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _InIt, class _OutIt, class _Pr, class _Ty, class _InOutItCat>
inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred, const _Ty& _Val, _InOutItCat, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1013);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1014);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1015);
	for (; _First != _Last; ++_First, ++_Dest)
		*_Dest = _Pred(*_First) ? _Val : *_First;
	return (_Dest);
	}


template<class _InIt, class _OutIt, class _Pr, class _Ty>
inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred, const _Ty& _Val,
		random_access_iterator_tag, _Range_checked_iterator_tag)
	{	
	
	_OutIt _Result = _Dest + (_Last - _First);
	_Replace_copy_if(_First, _Last, ::std:: _Checked_base(_Dest),
		_Pred, _Val,
		forward_iterator_tag(), _Range_checked_iterator_tag());
	return (_Result);
	}
#line 1036 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"



template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred, const _Ty& _Val)
	{	
	return _Replace_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, _Val,
		_Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt, class _OutElem, class _Pr, class _Ty, size_t _Size>
inline
_OutElem* replace_copy_if(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size],
		_Pr _Pred, const _Ty& _Val)
	{	
	return (replace_copy_if(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size),
		_Pred, _Val).base());
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred, const _Ty& _Val)
	{	
	return _Replace_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, _Val,
		_Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}














#line 1086 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _FwdIt,
	class _Fn0> inline
	void _Generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1092);
	_Debug_pointer(_Func, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1093);
	for (; _First != _Last; ++_First)
		*_First = _Func();
	}

template<class _FwdIt,
	class _Fn0> inline
	void generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
	{	
	_Generate(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Func);
	}

		
template<class _OutIt, class _Diff, class _Fn0, class _OutItCat>
inline
	void _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
		_OutItCat, _Range_checked_iterator_tag)
	{	
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1111);
	_Debug_pointer(_Func, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1112);
	for (; 0 < _Count; --_Count, ++_Dest)
		*_Dest = _Func();
	}


template<class _OutIt, class _Diff, class _Fn0>
inline
	void _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
		random_access_iterator_tag, _Range_checked_iterator_tag)
	{	
	
	_OutIt _Result = _Dest + _Count;
	_Generate_n(::std:: _Checked_base(_Dest), _Count, _Func,
		forward_iterator_tag(), _Range_checked_iterator_tag());
	}
#line 1129 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"



template<class _OutIt,
	class _Diff,
	class _Fn0> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{	
	_Generate_n(_Dest, _Count, _Func,
		_Iter_cat(_Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _OutElem, class _Diff, class _Fn0, size_t _Size>
inline
void generate_n(_OutElem (&_Dest)[_Size], _Diff _Count, _Fn0 _Func)
	{	
	generate_n(::stdext:: make_checked_array_iterator(_Dest, _Size), _Count, _Func);
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{	
	_Generate_n(_Dest, _Count, _Func,
		_Iter_cat(_Dest), ::std:: _Range_checked_iterator_tag());
	}












#line 1170 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1178);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1179);
	for (; _First != _Last; ++_First)
		if (!(*_First == _Val))
			*_Dest++ = *_First;
	return (_Dest);
	}



template<class _InIt,
	class _OutIt,
	class _Ty> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	
	return _Remove_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Val, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt, class _OutElem, class _Ty, size_t _Size>
inline
_OutElem* remove_copy(_InIt _First, _InIt _Last,
		_OutElem (&_Dest)[_Size], const _Ty& _Val)
	{	
	return (remove_copy(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size),
		_Val).base());
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	
	return _Remove_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Val, ::std:: _Range_checked_iterator_tag());
	}












#line 1229 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1236);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1237);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1238);
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			*_Dest++ = *_First;
	return (_Dest);
	}



template<class _InIt,
	class _OutIt,
	class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{	
	return _Remove_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* remove_copy_if(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size], _Pr _Pred)
	{	
	return (remove_copy_if(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{	
	return _Remove_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}











#line 1283 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _FwdIt,
	class _Ty> inline
	_FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_First = find(_First, _Last, _Val);
	if (_First == _Last)
		return (_First);	
	else
		{	
		_FwdIt _First1 = _First;
		return (::stdext:: unchecked_remove_copy(++_First1, _Last, _First, _Val));
		}
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_First = std::find_if(_First, _Last, _Pred);
	if (_First == _Last)
		return (_First);	
	else
		{	
		_FwdIt _First1 = _First;
		return (::stdext:: unchecked_remove_copy_if(++_First1, _Last, _First, _Pred));
		}
	}

		
template<class _FwdIt> inline
	_FwdIt _Unique(_FwdIt _First, _FwdIt _Last)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1318);
	for (_FwdIt _Firstb; (_Firstb = _First) != _Last && ++_First != _Last; )
		if (*_Firstb == *_First)
			{	
			for (; ++_First != _Last; )
				if (!(*_Firstb == *_First))
					*++_Firstb = *_First;
			return (++_Firstb);
			}
	return (_Last);
	}

template<class _FwdIt> inline
	_FwdIt unique(_FwdIt _First, _FwdIt _Last)
	{	
	::std:: _Checked_assign_from_base(_Last, _Unique(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last)));
#line 1335 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return (_Last);
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1343);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1344);
	for (_FwdIt _Firstb; (_Firstb = _First) != _Last && ++_First != _Last; )
		if (_Pred(*_Firstb, *_First))
			{	
			for (; ++_First != _Last; )
				if (!_Pred(*_Firstb, *_First))
					*++_Firstb = *_First;
			return (++_Firstb);
			}
	return (_Last);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	::std:: _Checked_assign_from_base(_Last, _Unique(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred));
#line 1362 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return (_Last);
	}

		
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Ty *, _Range_checked_iterator_tag)
	{	
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1371);
	_Ty _Val = *_First;

	for (*_Dest++ = _Val; ++_First != _Last; )
		if (!(_Val == *_First))
			_Val = *_First, *_Dest++ = _Val;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
		input_iterator_tag, _Range_checked_iterator_tag)
	{	
	return (_Unique_copy(_First, _Last, _Dest, _Val_type(_First), _Range_checked_iterator_tag()));
	}

template<class _FwdIt,
	class _OutIt> inline
	_OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last, _OutIt _Dest,
		forward_iterator_tag, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1393);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1394);
	_FwdIt _Firstb = _First;
	for (*_Dest++ = *_Firstb; ++_First != _Last; )
		if (!(*_Firstb == *_First))
			_Firstb = _First, *_Dest++ = *_Firstb;
	return (_Dest);
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt _Unique_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		bidirectional_iterator_tag, _Range_checked_iterator_tag)
	{	
	return (_Unique_copy(_First, _Last, _Dest, forward_iterator_tag(), _Range_checked_iterator_tag()));
	}

template<class _RanIt,
	class _OutIt> inline
	_OutIt _Unique_copy(_RanIt _First, _RanIt _Last, _OutIt _Dest,
		random_access_iterator_tag, _Range_checked_iterator_tag)
	{	
	return (_Unique_copy(_First, _Last, _Dest, forward_iterator_tag(), _Range_checked_iterator_tag()));
	}



template<class _InIt,
	class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
	return (_First == _Last ? _Dest :
		_Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt, class _OutElem, size_t _Size>
inline
_OutElem* unique_copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size])
	{	
	return (_First == _Last ? _Dest :
		(unique_copy(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size)).base()));
	}

template<class _InIt,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
	return (_First == _Last ? _Dest :
		_Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
	}











#line 1456 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Ty,
	class _Pr> inline
	_OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred,
		_Ty *, _Range_checked_iterator_tag)
	{	
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1465);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1466);
	_Ty _Val = *_First;

	for (*_Dest++ = _Val; ++_First != _Last; )
		if (!_Pred(_Val, *_First))
			_Val = *_First, *_Dest++ = _Val;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred,
		input_iterator_tag, _Range_checked_iterator_tag)
	{	
	return (_Unique_copy(_First, _Last, _Dest, _Pred, _Val_type(_First)), _Range_checked_iterator_tag());
	}

template<class _FwdIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last, _OutIt _Dest, _Pr _Pred,
		forward_iterator_tag, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1490);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1491);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1492);
	_FwdIt _Firstb = _First;

	for (*_Dest++ = *_Firstb; ++_First != _Last; )
		if (!_Pred(*_Firstb, *_First))
			_Firstb = _First, *_Dest++ = *_Firstb;
	return (_Dest);
	}

template<class _BidIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Pr _Pred,
		bidirectional_iterator_tag, _Range_checked_iterator_tag)
	{	
	return (_Unique_copy(_First, _Last, _Dest, _Pred,
		forward_iterator_tag(), _Range_checked_iterator_tag()));
	}

template<class _RanIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy(_RanIt _First, _RanIt _Last, _OutIt _Dest, _Pr _Pred,
		random_access_iterator_tag, _Range_checked_iterator_tag)
	{	
	return (_Unique_copy(_First, _Last, _Dest, _Pred,
		forward_iterator_tag(), _Range_checked_iterator_tag()));
	}



template<class _InIt,
	class _OutIt,
	class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{	
	return (_First == _Last ? _Dest
		: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* unique_copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size], _Pr _Pred)
	{	
	return (_First == _Last ? _Dest
		: (unique_copy(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base()));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{	
	return (_First == _Last ? _Dest
		: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
	}












#line 1562 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _BidIt> inline
	void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
	{	
	for (; _First != _Last && _First != --_Last; ++_First)
		std::iter_swap(_First, _Last);
	}

template<class _RanIt> inline
	void _Reverse(_RanIt _First, _RanIt _Last, random_access_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1574);
	for (; _First < _Last; ++_First)
		std::iter_swap(_First, --_Last);
	}

template<class _BidIt> inline
	void reverse(_BidIt _First, _BidIt _Last)
	{	
	_Reverse(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Iter_cat(_First));
	}

		
template<class _BidIt, class _OutIt, class _InOutItCat>
inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_InOutItCat, _Range_checked_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1591);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1592);
	for (; _First != _Last; ++_Dest)
		*_Dest = *--_Last;
	return (_Dest);
	}


template<class _BidIt, class _OutIt>
inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		random_access_iterator_tag, _Range_checked_iterator_tag)
	{	
	
	_OutIt _Result = _Dest + (_Last - _First);
	_Reverse_copy(_First, _Last, ::std:: _Checked_base(_Dest),
		forward_iterator_tag(), _Range_checked_iterator_tag());
	return (_Result);
	}
#line 1611 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"



template<class _BidIt,
	class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
	{	
	return _Reverse_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt, class _OutElem, size_t _Size>
inline
_OutElem* reverse_copy(_BidIt _First, _BidIt _Last, _OutElem (&_Dest)[_Size])
	{	
	return (reverse_copy(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _BidIt,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
	{	
	return _Reverse_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}










#line 1646 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _FwdIt> inline
	void _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		forward_iterator_tag)
	{	
	for (_FwdIt _Next = _Mid; ; )
		{	
		std::iter_swap(_First, _Next);
		if (++_First == _Mid)
			if (++_Next == _Last)
				break;	
			else
				_Mid = _Next;	
		else if (++_Next == _Last)
			_Next = _Mid;	
		}
	}

template<class _BidIt> inline
	void _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		bidirectional_iterator_tag)
	{	
	std::reverse(_First, _Mid);
	std::reverse(_Mid, _Last);
	std::reverse(_First, _Last);
	}

template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff *, _Ty *)
	{	
	_Debug_range(_First, _Mid, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1679);
	_Debug_range(_Mid, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1680);
	_Diff _Shift = _Mid - _First;
	_Diff _Count = _Last - _First;

	for (_Diff _Factor = _Shift; _Factor != 0; )
		{	
		_Diff _Tmp = _Count % _Factor;
		_Count = _Factor, _Factor = _Tmp;
		}

	if (_Count < _Last - _First)
		for (; 0 < _Count; --_Count)
			{	
			_RanIt _Hole = _First + _Count;
			_RanIt _Next = _Hole;
			_Ty _Holeval = *_Hole;
			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;
			while (_Next1 != _Hole)
				{	
				*_Next = *_Next1;
				_Next = _Next1;
				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
					: _First + (_Shift - (_Last - _Next1));
				}
			*_Next = _Holeval;
			}
	}

template<class _RanIt> inline
	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,
			random_access_iterator_tag)
	{	
	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));
	}

template<class _FwdIt> inline
	void rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{	
	if (_First != _Mid && _Mid != _Last)
		_Rotate(::std:: _Checked_base(_First), ::std:: _Checked_base(_Mid), ::std:: _Checked_base(_Last), _Iter_cat(_First));
	}

		
template<class _FwdIt,
	class _OutIt> inline
	_OutIt _Rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest, _Range_checked_iterator_tag)
	{	
	_Dest = ::stdext:: unchecked_copy(_Mid, _Last, _Dest);
	return (::stdext:: unchecked_copy(_First, _Mid, _Dest));
	}



template<class _FwdIt, class _OutIt>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
	{
		return _Rotate_copy(_First, _Mid, _Last, _Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _FwdIt, class _OutElem, size_t _Size>
inline
_OutElem* rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutElem (&_Dest)[_Size])
	{
		return (rotate_copy(_First, _Mid, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _FwdIt, class _OutIt>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
	{
		return _Rotate_copy(_First, _Mid, _Last, _Dest, ::std:: _Range_checked_iterator_tag());
	}










#line 1765 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _RanIt,
	class _Diff> inline
	void _Random_shuffle(_RanIt _First, _RanIt _Last, _Diff *)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1771);
	const int _RANDOM_BITS = 15;	
	const int _RANDOM_MAX = (1U << _RANDOM_BITS) - 1;

	_RanIt _Next = _First;
	for (unsigned long _Index = 2; ++_Next != _Last; ++_Index)
		{	
		unsigned long _Rm = _RANDOM_MAX;
		unsigned long _Rn = ::rand() & _RANDOM_MAX;
		for (; _Rm < _Index && _Rm != ~0UL;
			_Rm = _Rm << _RANDOM_BITS | _RANDOM_MAX)
			_Rn = _Rn << _RANDOM_BITS
				| (::rand() & _RANDOM_MAX);	

		std::iter_swap(_Next, _First + _Diff(_Rn % _Index));	
		}
	}

template<class _RanIt> inline
	void random_shuffle(_RanIt _First, _RanIt _Last)
	{	
	if (_First != _Last)
		_Random_shuffle(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dist_type(_First));
	}

		
template<class _RanIt,
	class _Fn1,
	class _Diff> inline
	void _Random_shuffle(_RanIt _First, _RanIt _Last, _Fn1& _Func, _Diff *)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1802);
	_Debug_pointer(_Func, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1803);
	_RanIt _Next = _First;

	for (_Diff _Index = 2; ++_Next != _Last; ++_Index)
		std::iter_swap(_Next, _First + _Diff(_Func(_Index) % _Index));
	}

template<class _RanIt,
	class _Fn1> inline
	void random_shuffle(_RanIt _First, _RanIt _Last, _Fn1& _Func)
	{	
	if (_First != _Last)
		_Random_shuffle(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Func, _Dist_type(_First));
	}

		
template<class _BidIt,
	class _Pr> inline
	_BidIt _Partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1823);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1824);
	for (; ; ++_First)
		{	
		for (; _First != _Last && _Pred(*_First); ++_First)
			;	
		if (_First == _Last)
			break;	

		for (; _First != --_Last && !_Pred(*_Last); )
			;	
		if (_First == _Last)
			break;	

		std::iter_swap(_First, _Last);	
		}
	return (_First);
	}

template<class _BidIt,
	class _Pr> inline
	_BidIt partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	::std:: _Checked_assign_from_base(_First, _Partition(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred));
#line 1848 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return (_First);
	}

		
template<class _BidIt,
	class _Pr,
	class _Diff,
	class _Ty> inline
	_BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
		_Diff _Count, _Temp_iterator<_Ty>& _Tempbuf)
	{	
	if (_Count == 0)
		return (_First);
	else if (_Count == 1)
		return (_Pred(*_First) ? _Last : _First);
	else if (_Count <= _Tempbuf._Maxlen())
		{	
		_BidIt _Next = _First;
		for (_Tempbuf._Init(); _First != _Last; ++_First)
			if (_Pred(*_First))
				*_Next++ = *_First;
			else
				*_Tempbuf++ = *_First;

		::stdext:: unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _Next);	
		return (_Next);
		}
	else
		{	
		_BidIt _Mid = _First;
		std::advance(_Mid, _Count / 2);

		_BidIt _Left = _Stable_partition(_First, _Mid, _Pred,
			_Count / 2, _Tempbuf);	
		_BidIt _Right = _Stable_partition(_Mid, _Last, _Pred,
			_Count - _Count / 2, _Tempbuf);	

		_Diff _Count1 = 0;
		_Distance(_Left, _Mid, _Count1);
		_Diff _Count2 = 0;
		_Distance(_Mid, _Right, _Count2);

		return (_Buffered_rotate(_Left, _Mid, _Right,
			_Count1, _Count2, _Tempbuf));	
		}
	}

template<class _BidIt,
	class _Pr,
	class _Diff,
	class _Ty> inline
	_BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
		_Diff *, _Ty *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	_Temp_iterator<_Ty> _Tempbuf(_Count);
	return (_Stable_partition(_First, _Last, _Pred, _Count, _Tempbuf));
	}

template<class _BidIt,
	class _Pr> inline
	_BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	if (_First != _Last)
		{
		::std:: _Checked_assign_from_base(_First, _Stable_partition(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred, _Dist_type(_First), _Val_type(_First)));
#line 1917 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
		}
	return _First;
	}


 
#line 1924 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

 
		
template<class _RanIt> inline
	void _Debug_heap(_RanIt _First, _RanIt _Last)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1930);

	if (_First != _Last)
		for (_RanIt _Root = _First; ++_First != _Last; ++_Root)
			if (_Debug_lt(*_Root, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1934))
				_Debug_message(L"invalid heap", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1935);
			else if (++_First == _Last)
				break;
			else if (_Debug_lt(*_Root, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1938))
				_Debug_message(L"invalid heap", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1939);
	}

		
template<class _RanIt,
	class _Pr> inline
	void _Debug_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1947);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",1948);

	if (_First != _Last)
		for (_RanIt _Root = _First; ++_First != _Last; ++_Root)
			if (_Debug_lt_pred(_Pred, *_Root, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1952))
				_Debug_message(L"invalid heap", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1953);
			else if (++_First == _Last)
				break;
			else if (_Debug_lt_pred(_Pred, *_Root, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1956))
				_Debug_message(L"invalid heap", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1957);
	}

 

 


 


#line 1969 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Push_heap(_RanIt _First, _Diff _Hole,
		_Diff _Top, _Ty _Val)
	{	
	for (_Diff _Idx = (_Hole - 1) / 2;
		_Top < _Hole && _Debug_lt(*(_First + _Idx), _Val, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 1978);
		_Idx = (_Hole - 1) / 2)
		{	
		*(_First + _Hole) = *(_First + _Idx);
		_Hole = _Idx;
		}

	*(_First + _Hole) = _Val;	
	}

template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Push_heap_0(_RanIt _First, _RanIt _Last, _Diff *, _Ty *)
	{	
	_Debug_heap(_First, _Last);
	_Diff _Count = _Last - _First;
	if (0 < _Count)
		_Push_heap(_First, _Count, _Diff(0), _Ty(*_Last));
	}

template<class _RanIt> inline
	void push_heap(_RanIt _First, _RanIt _Last)
	{	

 
	if (_First == _Last)
		_Debug_message(L"empty push_heap sequence", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2005);
	else

 

#line 2011 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		_Push_heap_0(::std:: _Checked_base(_First), ::std:: _Checked_base(--_Last),
			_Dist_type(_First), _Val_type(_First));
	}

		
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Push_heap(_RanIt _First, _Diff _Hole,
		_Diff _Top, _Ty _Val, _Pr _Pred)
	{	
	for (_Diff _Idx = (_Hole - 1) / 2;
		_Top < _Hole && _Debug_lt_pred(_Pred, *(_First + _Idx), _Val, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2025);
		_Idx = (_Hole - 1) / 2)
		{	
		*(_First + _Hole) = *(_First + _Idx);
		_Hole = _Idx;
		}

	*(_First + _Hole) = _Val;	
	}

template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Push_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *)
	{	
	_Debug_heap(_First, _Last, _Pred);
	_Diff _Count = _Last - _First;
	if (0 < _Count)
		_Push_heap(_First, _Count, _Diff(0), _Ty(*_Last), _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	

 
	if (_First == _Last)
		_Debug_message(L"empty push_heap sequence", L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2054);
	else

 

#line 2060 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		_Push_heap_0(::std:: _Checked_base(_First), ::std:: _Checked_base(--_Last), _Pred,
			_Dist_type(_First), _Val_type(_First));
	}

		
template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom, _Ty _Val)
	{	
	_Diff _Top = _Hole;
	_Diff _Idx = 2 * _Hole + 2;

	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)
		{	
		if (_Debug_lt(*(_First + _Idx), *(_First + (_Idx - 1)), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2076))
			--_Idx;
		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;
		}

	if (_Idx == _Bottom)
		{	
		*(_First + _Hole) = *(_First + (_Bottom - 1));
		_Hole = _Bottom - 1;
		}
	_Push_heap(_First, _Hole, _Top, _Val);
	}

template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest,
		_Ty _Val, _Diff *)
	{	
	*_Dest = *_First;
	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);
	}

template<class _RanIt,
	class _Ty> inline
	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Ty *)
	{	
	_Pop_heap(_First, _Last - 1, _Last - 1,
		_Ty(*(_Last - 1)), _Dist_type(_First));
	}

template<class _RanIt> inline
	void pop_heap(_RanIt _First, _RanIt _Last)
	{	
	_Debug_heap(_First, _Last);
	if (1 < _Last - _First)
		_Pop_heap_0(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val_type(_First));
	}

		
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom,
		_Ty _Val, _Pr _Pred)
	{	
	_Diff _Top = _Hole;
	_Diff _Idx = 2 * _Hole + 2;

	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)
		{	
		if (_Debug_lt_pred(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)), L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2128))
			--_Idx;
		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;
		}

	if (_Idx == _Bottom)
		{	
		*(_First + _Hole) = *(_First + (_Bottom - 1));
		_Hole = _Bottom - 1;
		}
	_Push_heap(_First, _Hole, _Top, _Val, _Pred);
	}

template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest,
		_Ty _Val, _Pr _Pred, _Diff *)
	{	
	*_Dest = *_First;
	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val, _Pred);
	}

template<class _RanIt,
	class _Ty,
	class _Pr> inline
	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
	{	
	_Pop_heap(_First, _Last - 1, _Last - 1,
		_Ty(*(_Last - 1)), _Pred, _Dist_type(_First));
	}

template<class _RanIt,
	class _Pr> inline
	void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_heap(_First, _Last, _Pred);
	if (1 < _Last - _First)
		_Pop_heap_0(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred, _Val_type(_First));
	}

		
template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Make_heap(_RanIt _First, _RanIt _Last, _Diff *, _Ty *)
	{	
	_Diff _Bottom = _Last - _First;

	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )
		{	
		--_Hole;
		_Adjust_heap(_First, _Hole, _Bottom, _Ty(*(_First + _Hole)));
		}
	}

template<class _RanIt> inline
	void make_heap(_RanIt _First, _RanIt _Last)
	{	
	if (1 < _Last - _First)
		_Make_heap(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last),
			_Dist_type(_First), _Val_type(_First));
	}

		
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *)
	{	
	_Diff _Bottom = _Last - _First;
	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )
		{	
		--_Hole;
		_Adjust_heap(_First, _Hole, _Bottom,
			_Ty(*(_First + _Hole)), _Pred);
		}
	}

template<class _RanIt,
	class _Pr> inline
	void make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	if (1 < _Last - _First)
		_Make_heap(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred,
			_Dist_type(_First), _Val_type(_First));
	}

		
template<class _RanIt> inline
	void _Sort_heap(_RanIt _First, _RanIt _Last)
	{	
	_Debug_heap(_First, _Last);
	for (; 1 < _Last - _First; --_Last)
		std::pop_heap(_First, _Last);
	}

template<class _RanIt> inline
	void sort_heap(_RanIt _First, _RanIt _Last)
	{	
	_Debug_heap(_First, _Last);
	_Sort_heap(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last));
	}

		
template<class _RanIt,
	class _Pr> inline
	void _Sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	for (; 1 < _Last - _First; --_Last)
		std::pop_heap(_First, _Last, _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_heap(_First, _Last, _Pred);
	_Sort_heap(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred);
	}

		
template<class _FwdIt,
	class _Ty,
	class _Diff> inline
	_FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Diff *)
	{	
	_Debug_order_single(_First, _Last, true, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2257);
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);

	for (; 0 < _Count; )
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		std::advance(_Mid, _Count2);
		_Debug_order_single(_Mid, _Last, false, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2266);

		if (_Debug_lt(*_Mid, _Val, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2268))
			_First = ++_Mid, _Count -= _Count2 + 1;
		else
			_Count = _Count2;
		}
	return (_First);
	}

template<class _FwdIt,
	class _Ty> inline
	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	::std:: _Checked_assign_from_base(_First, _Lower_bound(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val, _Dist_type(_First)));
#line 2282 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return _First;
	}

		
template<class _FwdIt,
	class _Ty,
	class _Diff,
	class _Pr> inline
	_FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred, _Diff *)
	{	
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",2293);
	_Debug_order_single(_First, _Last, _Pred, true, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2294);
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	for (; 0 < _Count; )
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		std::advance(_Mid, _Count2);
		_Debug_order_single(_Mid, _Last, _Pred, false, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2302);

		if (_Debug_lt_pred(_Pred, *_Mid, _Val, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2304))
			_First = ++_Mid, _Count -= _Count2 + 1;
		else
			_Count = _Count2;
		}
	return (_First);
	}

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	
	::std:: _Checked_assign_from_base(_First, _Lower_bound(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val, _Pred, _Dist_type(_First)));
#line 2320 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return _First;
	}

		
template<class _FwdIt,
	class _Ty,
	class _Diff> inline
	_FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Diff *)
	{	
	_Debug_order_single(_First, _Last, true, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2329);
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	for (; 0 < _Count; )
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		std::advance(_Mid, _Count2);
		_Debug_order_single(_Mid, _Last, false, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2337);

		if (!_Debug_lt(_Val, *_Mid, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2339))
			_First = ++_Mid, _Count -= _Count2 + 1;
		else
			_Count = _Count2;
		}
	return (_First);
	}

template<class _FwdIt,
	class _Ty> inline
	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	::std:: _Checked_assign_from_base(_First, _Upper_bound(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val, _Dist_type(_First)));
#line 2353 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return _First;
	}

		
template<class _FwdIt,
	class _Ty,
	class _Diff,
	class _Pr> inline
	_FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred, _Diff *)
	{	
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",2364);
	_Debug_order_single(_First, _Last, _Pred, true, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2365);
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	for (; 0 < _Count; )
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		std::advance(_Mid, _Count2);
		_Debug_order_single(_Mid, _Last, _Pred, false, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2373);

		if (!_Debug_lt_pred(_Pred, _Val, *_Mid, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2375))
			_First = ++_Mid, _Count -= _Count2 + 1;
		else
			_Count = _Count2;
		}
	return (_First);
	}

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	
	::std:: _Checked_assign_from_base(_First, _Upper_bound(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val, _Pred, _Dist_type(_First)));
#line 2391 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return _First;
	}

		
template<class _FwdIt,
	class _Ty,
	class _Diff> inline
	pair<_FwdIt, _FwdIt> _Equal_range(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Diff *)
	{	
	_Debug_order_single(_First, _Last, true, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2401);
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);

	for (; 0 < _Count; )
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		std::advance(_Mid, _Count2);
		_Debug_order_single(_Mid, _Last, false, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2410);

		if (_Debug_lt(*_Mid, _Val, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2412))
			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else if (_Val < *_Mid)
			_Count = _Count2;	
		else
			{	
			_FwdIt _First2 = lower_bound(_First, _Mid, _Val);
			std::advance(_First, _Count);
			_FwdIt _Last2 = upper_bound(++_Mid, _First, _Val);
			return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
			}
		}

	return (pair<_FwdIt, _FwdIt>(_First, _First));	
	}

template<class _FwdIt,
	class _Ty> inline
	pair<_FwdIt, _FwdIt> equal_range(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val)
	{	
	return (_Equal_range(_First, _Last, _Val, _Dist_type(_First)));
	}

		
template<class _FwdIt,
	class _Ty,
	class _Diff,
	class _Pr> inline
	pair<_FwdIt, _FwdIt> _Equal_range(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred, _Diff *)
	{	
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",2447);
	_Debug_order_single(_First, _Last, _Pred, true, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2448);
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);

	for (; 0 < _Count; )
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		std::advance(_Mid, _Count2);
		_Debug_order_single(_Mid, _Last, _Pred, false, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2457);

		if (_Debug_lt_pred(_Pred, *_Mid, _Val, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2459))
			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else if (_Pred(_Val, *_Mid))
			_Count = _Count2;	
		else
			{	
			_FwdIt _First2 = lower_bound(_First, _Mid, _Val, _Pred);
			std::advance(_First, _Count);
			_FwdIt _Last2 = upper_bound(++_Mid, _First, _Val, _Pred);
			return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
			}
		}

	return (pair<_FwdIt, _FwdIt>(_First, _First));	
	}

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	pair<_FwdIt, _FwdIt> equal_range(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	
	return (_Equal_range(_First, _Last, _Val, _Pred, _Dist_type(_First)));
	}

		
template<class _FwdIt,
	class _Ty> inline
	bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_First = std::lower_bound(_First, _Last, _Val);
	return (_First != _Last && !(_Val < *_First));
	}

		
template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	bool binary_search(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	
	_First = std::lower_bound(_First, _Last, _Val, _Pred);
	return (_First != _Last && !_Pred(_Val, *_First));
	}

		
template<class _InIt1, class _InIt2, class _OutIt, class _InOutItCat>
inline
	_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest,
		_InOutItCat, _Range_checked_iterator_tag)
	{	
	_Debug_order(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2514);
	_Debug_order(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2515);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",2516);
	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)
		if (_Debug_lt(*_First2, *_First1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2518))
			*_Dest = *_First2, ++_First2;
		else
			*_Dest = *_First1, ++_First1;

	_Dest = ::stdext:: unchecked_copy(_First1, _Last1, _Dest);	
	return (::stdext:: unchecked_copy(_First2, _Last2, _Dest));
	}


template<class _InIt1, class _InIt2, class _OutIt>
inline
	_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest,
		random_access_iterator_tag, _Range_checked_iterator_tag)
	{	
	
	_OutIt _Result = _Dest + (_Last1 - _First1) + (_Last2 - _First2);
	_Merge(_First1, _Last1, _First2, _Last2, ::std:: _Checked_base(_Dest),
		forward_iterator_tag(), _Range_checked_iterator_tag());
	return _Result;
	}
#line 2541 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"



template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
		_Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
	{	
	return (merge(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
		_Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
	}














#line 2590 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _InIt1, class _InIt2, class _OutIt, class _Pr, class _InOutItCat>
inline
	_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred,
		_InOutItCat, _Range_checked_iterator_tag)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2598);
	_Debug_order(_First2, _Last2, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2599);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",2600);
	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)
		if (_Debug_lt_pred(_Pred, *_First2, *_First1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2602))
			*_Dest = *_First2, ++_First2;
		else
			*_Dest = *_First1, ++_First1;

	_Dest = ::stdext:: unchecked_copy(_First1, _Last1, _Dest);	
	return (::stdext:: unchecked_copy(_First2, _Last2, _Dest));
	}


template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline
	_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred,
		random_access_iterator_tag, _Range_checked_iterator_tag)
	{	
	
	_OutIt _Result = _Dest + (_Last1 - _First1) + (_Last2 - _First2);
	_Merge(_First1, _Last1, _First2, _Last2, ::std:: _Checked_base(_Dest), _Pred, 
		forward_iterator_tag(), _Range_checked_iterator_tag());
	return _Result;
	}
#line 2625 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"



template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred,
		_Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
	{	
	return (merge(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred,
		_Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
	}
















#line 2680 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _BidIt,
	class _Diff,
	class _Ty> inline
	_BidIt _Buffered_rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff _Count1, _Diff _Count2, _Temp_iterator<_Ty>& _Tempbuf)
	{	
	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
		{	
		::stdext:: unchecked_copy(_First, _Mid, _Tempbuf._Init());
		::stdext:: unchecked_copy(_Mid, _Last, _First);
		return (::stdext:: unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
			_Last));
		}
	else if (_Count2 <= _Tempbuf._Maxlen())
		{	
		::stdext:: unchecked_copy(_Mid, _Last, _Tempbuf._Init());
		::stdext:: unchecked_copy_backward(_First, _Mid, _Last);
		return (::stdext:: unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));
		}
	else
		{	
		std::rotate(_First, _Mid, _Last);
		std::advance(_First, _Count2);
		return (_First);
		}
	}

template<class _BidIt1,
	class _BidIt2,
	class _BidIt3> inline
	_BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Range_checked_iterator_tag)
	{	
	for (; ; )
		if (_First1 == _Last1)
			return (::stdext:: unchecked_copy_backward(_First2, _Last2, _Dest));
		else if (_First2 == _Last2)
			return (::stdext:: unchecked_copy_backward(_First1, _Last1, _Dest));
		else if (_Debug_lt(*--_Last2, *--_Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2720))
			*--_Dest = *_Last1, ++_Last2;
		else
			*--_Dest = *_Last2, ++_Last1;
	}



template<class _BidIt1, class _BidIt2, class _BidIt3>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
	{
		return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt1, class _BidIt2, class _BidIt3>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
	{
		return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std:: _Range_checked_iterator_tag());
	}











#line 2756 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

template<class _BidIt,
	class _Diff,
	class _Ty> inline
	void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff _Count1, _Diff _Count2,
			_Temp_iterator<_Ty>& _Tempbuf)
	{	
	if (_Count1 + _Count2 == 2)
		{	
		if (_Debug_lt(*_Mid, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2766))
			std::iter_swap(_First, _Mid);
		}
	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
		{	
		::stdext:: unchecked_copy(_First, _Mid, _Tempbuf._Init());
		::stdext:: unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);
		}
	else if (_Count2 <= _Tempbuf._Maxlen())
		{	
		::stdext:: unchecked_copy(_Mid, _Last, _Tempbuf._Init());
		::stdext:: _Unchecked_merge_backward(_First, _Mid,
			_Tempbuf._First(), _Tempbuf._Last(), _Last);
		}
	else
		{	
		_BidIt _Firstn, _Lastn;
		_Diff _Count1n, _Count2n;

		if (_Count2 < _Count1)
			{	
			_Count1n = _Count1 / 2, _Count2n = 0;
			_Firstn = _First;
			std::advance(_Firstn, _Count1n);
			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);
			_Distance(_Mid, _Lastn, _Count2n);
			}
		else
			{	
			_Count1n = 0, _Count2n = _Count2 / 2;
			_Lastn = _Mid;
			std::advance(_Lastn, _Count2n);
			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);
			_Distance(_First, _Firstn, _Count1n);
			}

		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
			_Count1 - _Count1n, _Count2n, _Tempbuf);	
		_Buffered_merge(_First, _Firstn, _Midn,
			_Count1n, _Count2n, _Tempbuf);	
		_Buffered_merge(_Midn, _Lastn, _Last,
			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty> inline
	void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff *, _Ty *)
	{	
	_Debug_order(_First, _Mid, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2817);
	_Debug_order(_Mid, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2818);
	_Diff _Count1 = 0;
	_Distance(_First, _Mid, _Count1);
	_Diff _Count2 = 0;
	_Distance(_Mid, _Last, _Count2);
	_Temp_iterator<_Ty> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
	_Buffered_merge(_First, _Mid, _Last,
		_Count1, _Count2, _Tempbuf);
	}

template<class _BidIt> inline
	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
	{	
	if (_First != _Mid && _Mid != _Last)
		_Inplace_merge(::std:: _Checked_base(_First), ::std:: _Checked_base(_Mid), ::std:: _Checked_base(_Last),
			_Dist_type(_First), _Val_type(_First));
	}

		
template<class _BidIt1,
	class _BidIt2,
	class _BidIt3,
	class _Pr> inline
	_BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{	
	for (; ; )
		if (_First1 == _Last1)
			return (::stdext:: unchecked_copy_backward(_First2, _Last2, _Dest));
		else if (_First2 == _Last2)
			return (::stdext:: unchecked_copy_backward(_First1, _Last1, _Dest));
		else if (_Debug_lt_pred(_Pred, *--_Last2, *--_Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2849))
			*--_Dest = *_Last1, ++_Last2;
		else
			*--_Dest = *_Last2, ++_Last1;
	}



template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
	{
		return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
	{
		return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}











#line 2885 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff _Count1, _Diff _Count2,
			_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
	{	
	if (_Count1 + _Count2 == 2)
		{	
		if (_Debug_lt_pred(_Pred, *_Mid, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2896))
			std::iter_swap(_First, _Mid);
		}
	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
		{	
		::stdext:: unchecked_copy(_First, _Mid, _Tempbuf._Init());
		::stdext:: unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(),
			_Mid, _Last, _First, _Pred);
		}
	else if (_Count2 <= _Tempbuf._Maxlen())
		{	
		::stdext:: unchecked_copy(_Mid, _Last, _Tempbuf._Init());
		::stdext:: _Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
			_Last, _Pred);
		}
	else
		{	
		_BidIt _Firstn, _Lastn;
		_Diff _Count1n, _Count2n;
		if (_Count2 < _Count1)
			{	
			_Count1n = _Count1 / 2, _Count2n = 0;
			_Firstn = _First;
			std::advance(_Firstn, _Count1n);
			_Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);
			_Distance(_Mid, _Lastn, _Count2n);
			}
		else
			{	
			_Count1n = 0, _Count2n = _Count2 / 2;
			_Lastn = _Mid;
			std::advance(_Lastn, _Count2n);
			_Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);
			_Distance(_First, _Firstn, _Count1n);
			}
		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
			_Count1 - _Count1n, _Count2n, _Tempbuf);	
		_Buffered_merge(_First, _Firstn, _Midn,
			_Count1n, _Count2n, _Tempbuf, _Pred);	
		_Buffered_merge(_Midn, _Lastn, _Last,
			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred,
		_Diff *, _Ty *)
	{	
	_Debug_order(_First, _Mid, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2947);
	_Debug_order(_Mid, _Last, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2948);
	_Diff _Count1 = 0;
	_Distance(_First, _Mid, _Count1);
	_Diff _Count2 = 0;
	_Distance(_Mid, _Last, _Count2);
	_Temp_iterator<_Ty> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
	_Buffered_merge(_First, _Mid, _Last,
		_Count1, _Count2, _Tempbuf, _Pred);
	}

template<class _BidIt,
	class _Pr> inline
	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
	{	
	if (_First != _Mid && _Mid != _Last)
		_Inplace_merge(::std:: _Checked_base(_First), ::std:: _Checked_base(_Mid), ::std:: _Checked_base(_Last), _Pred,
			_Dist_type(_First), _Val_type(_First));
	}

		
template<class _BidIt,
	class _Ty> inline
	void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Ty *)
	{	
	if (_First != _Last)
		for (_BidIt _Next = _First; ++_Next != _Last; )
			{	
			_BidIt _Next1 = _Next;
			_Ty _Val = *_Next;

			if (_Debug_lt(_Val, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2978))
				{	
				::stdext:: unchecked_copy_backward(_First, _Next, ++_Next1);
				*_First = _Val;
				}
			else
				{	
				for (_BidIt _First1 = _Next1;
					_Debug_lt(_Val, *--_First1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 2986);
					_Next1 = _First1)
					*_Next1 = *_First1;	
				*_Next1 = _Val;	
				}
			}
	}

template<class _BidIt> inline
	void _Insertion_sort(_BidIt _First, _BidIt _Last)
	{	
	_Insertion_sort1(_First, _Last, _Val_type(_First));
	}

template<class _RanIt> inline
	void _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{	
	if (_Debug_lt(*_Mid, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3003))
		std::iter_swap(_Mid, _First);
	if (_Debug_lt(*_Last, *_Mid, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3005))
		std::iter_swap(_Last, _Mid);
	if (_Debug_lt(*_Mid, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3007))
		std::iter_swap(_Mid, _First);
	}

template<class _RanIt> inline
	void _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{	
	if (40 < _Last - _First)
		{	
		size_t _Step = (_Last - _First + 1) / 8;
		_Med3(_First, _First + _Step, _First + 2 * _Step);
		_Med3(_Mid - _Step, _Mid, _Mid + _Step);
		_Med3(_Last - 2 * _Step, _Last - _Step, _Last);
		_Med3(_First + _Step, _Mid, _Last - _Step);
		}
	else
		_Med3(_First, _Mid, _Last);
	}

template<class _RanIt> inline
	pair<_RanIt, _RanIt> _Unguarded_partition(_RanIt _First, _RanIt _Last)
	{	
	_RanIt _Mid = _First + (_Last - _First) / 2;	
	_Median(_First, _Mid, _Last - 1);
	_RanIt _Pfirst = _Mid;
	_RanIt _Plast = _Pfirst + 1;

	while (_First < _Pfirst
		&& !_Debug_lt(*(_Pfirst - 1), *_Pfirst, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3035)
		&& !(*_Pfirst < *(_Pfirst - 1)))
		--_Pfirst;
	while (_Plast < _Last
		&& !_Debug_lt(*_Plast, *_Pfirst, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3039)
		&& !(*_Pfirst < *_Plast))
		++_Plast;

	_RanIt _Gfirst = _Plast;
	_RanIt _Glast = _Pfirst;

	for (; ; )
		{	
		for (; _Gfirst < _Last; ++_Gfirst)
			if (_Debug_lt(*_Pfirst, *_Gfirst, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3049))
				;
			else if (*_Gfirst < *_Pfirst)
				break;
			else
				std::iter_swap(_Plast++, _Gfirst);
		for (; _First < _Glast; --_Glast)
			if (_Debug_lt(*(_Glast - 1), *_Pfirst, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3056))
				;
			else if (*_Pfirst < *(_Glast - 1))
				break;
			else
				std::iter_swap(--_Pfirst, _Glast - 1);
		if (_Glast == _First && _Gfirst == _Last)
			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

		if (_Glast == _First)
			{	
			if (_Plast != _Gfirst)
				std::iter_swap(_Pfirst, _Plast);
			++_Plast;
			std::iter_swap(_Pfirst++, _Gfirst++);
			}
		else if (_Gfirst == _Last)
			{	
			if (--_Glast != --_Pfirst)
				std::iter_swap(_Glast, _Pfirst);
			std::iter_swap(_Pfirst, --_Plast);
			}
		else
			std::iter_swap(_Gfirst++, --_Glast);
		}
	}

template<class _RanIt,
	class _Diff> inline
	void _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal)
	{	
	_Diff _Count;
	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )
		{	
		pair<_RanIt, _RanIt> _Mid = _Unguarded_partition(_First, _Last);
		_Ideal /= 2, _Ideal += _Ideal / 2;	

		if (_Mid.first - _First < _Last - _Mid.second)	
			_Sort(_First, _Mid.first, _Ideal), _First = _Mid.second;
		else
			_Sort(_Mid.second, _Last, _Ideal), _Last = _Mid.first;
		}

	if (_ISORT_MAX < _Count)
		{	
		std::make_heap(_First, _Last);
		std::sort_heap(_First, _Last);
		}
	else if (1 < _Count)
		_Insertion_sort(_First, _Last);	
	}

template<class _RanIt> inline
	void sort(_RanIt _First, _RanIt _Last)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3111);
	_Sort(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Last - _First);
	}

		
template<class _BidIt,
	class _Pr> inline
	void _Insertion_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	if (_First != _Last)
		for (_BidIt _Next = _First; ++_Next != _Last; )
			if (_Debug_lt_pred(_Pred, *_Next, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3122))
				{	
				_BidIt _Next1 = _Next;
				std::rotate(_First, _Next, ++_Next1);
				}
			else
				{	
				_BidIt _Dest = _Next;
				for (_BidIt _Dest0 = _Dest;
					_Debug_lt_pred(_Pred, *_Next, *--_Dest0, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3131); )
					_Dest = _Dest0;
				if (_Dest != _Next)
					{	
					_BidIt _Next1 = _Next;
					std::rotate(_Dest, _Next, ++_Next1);
					}
				}
	}

template<class _RanIt,
	class _Pr> inline
	void _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	
	if (_Debug_lt_pred(_Pred, *_Mid, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3145))
		std::iter_swap(_Mid, _First);
	if (_Debug_lt_pred(_Pred, *_Last, *_Mid, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3147))
		std::iter_swap(_Last, _Mid);
	if (_Debug_lt_pred(_Pred, *_Mid, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3149))
		std::iter_swap(_Mid, _First);
	}

template<class _RanIt,
	class _Pr> inline
	void _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	
	if (40 < _Last - _First)
		{	
		size_t _Step = (_Last - _First + 1) / 8;
		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);
		_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);
		_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);
		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);
		}
	else
		_Med3(_First, _Mid, _Last, _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	pair<_RanIt, _RanIt> _Unguarded_partition(_RanIt _First, _RanIt _Last,
		_Pr _Pred)
	{	
	_RanIt _Mid = _First + (_Last - _First) / 2;
	_Median(_First, _Mid, _Last - 1, _Pred);
	_RanIt _Pfirst = _Mid;
	_RanIt _Plast = _Pfirst + 1;

	while (_First < _Pfirst
		&& !_Debug_lt_pred(_Pred, *(_Pfirst - 1), *_Pfirst, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3180)
		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))
		--_Pfirst;
	while (_Plast < _Last
		&& !_Debug_lt_pred(_Pred, *_Plast, *_Pfirst, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3184)
		&& !_Pred(*_Pfirst, *_Plast))
		++_Plast;

	_RanIt _Gfirst = _Plast;
	_RanIt _Glast = _Pfirst;

	for (; ; )
		{	
		for (; _Gfirst < _Last; ++_Gfirst)
			if (_Debug_lt_pred(_Pred, *_Pfirst, *_Gfirst, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3194))
				;
			else if (_Pred(*_Gfirst, *_Pfirst))
				break;
			else
				std::iter_swap(_Plast++, _Gfirst);
		for (; _First < _Glast; --_Glast)
			if (_Debug_lt_pred(_Pred, *(_Glast - 1), *_Pfirst, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3201))
				;
			else if (_Pred(*_Pfirst, *(_Glast - 1)))
				break;
			else
				std::iter_swap(--_Pfirst, _Glast - 1);
		if (_Glast == _First && _Gfirst == _Last)
			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

		if (_Glast == _First)
			{	
			if (_Plast != _Gfirst)
				std::iter_swap(_Pfirst, _Plast);
			++_Plast;
			std::iter_swap(_Pfirst++, _Gfirst++);
			}
		else if (_Gfirst == _Last)
			{	
			if (--_Glast != --_Pfirst)
				std::iter_swap(_Glast, _Pfirst);
			std::iter_swap(_Pfirst, --_Plast);
			}
		else
			std::iter_swap(_Gfirst++, --_Glast);
		}
	}

template<class _RanIt,
	class _Diff,
	class _Pr> inline
	void _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr _Pred)
	{	
	_Diff _Count;
	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )
		{	
		pair<_RanIt, _RanIt> _Mid =
			_Unguarded_partition(_First, _Last, _Pred);
		_Ideal /= 2, _Ideal += _Ideal / 2;	

		if (_Mid.first - _First < _Last - _Mid.second)	
			_Sort(_First, _Mid.first, _Ideal, _Pred), _First = _Mid.second;
		else
			_Sort(_Mid.second, _Last, _Ideal, _Pred), _Last = _Mid.first;
		}

	if (_ISORT_MAX < _Count)
		{	
		std::make_heap(_First, _Last, _Pred);
		std::sort_heap(_First, _Last, _Pred);
		}
	else if (1 < _Count)
		_Insertion_sort(_First, _Last, _Pred);	
	}

template<class _RanIt,
	class _Pr> inline
	void sort(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3259);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",3260);
	_Sort(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Last - _First, _Pred);
	}

		
template<class _BidIt,
	class _OutIt,
	class _Diff> inline
	void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count, _Range_checked_iterator_tag)
	{	
	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)
		{	
		_BidIt _Mid1 = _First;
		std::advance(_Mid1, _Chunk);
		_BidIt _Mid2 = _Mid1;
		std::advance(_Mid2, _Chunk);

		_Dest = ::stdext:: unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);
		_First = _Mid2;
		}

	if (_Count <= _Chunk)
		::stdext:: unchecked_copy(_First, _Last, _Dest);	
	else
		{	
		_BidIt _Mid = _First;
		std::advance(_Mid, _Chunk);

		::stdext:: unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);
		}
	}



template<class _BidIt, class _OutIt, class _Diff>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count)
	{
		_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt, class _OutElem, class _Diff, size_t _Size>
inline
void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutElem (&_Dest)[_Size],
		_Diff _Chunk, _Diff _Count)
	{
		_Chunked_merge(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size), _Chunk, _Count, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt, class _OutIt, class _Diff>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count)
	{
		_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std:: _Range_checked_iterator_tag());
	}











#line 3331 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

template<class _BidIt,
	class _Diff,
	class _Ty> inline
	void _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf)
	{	
	_BidIt _Mid = _First;
	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)
		{	
		_BidIt _Midend = _Mid;
		std::advance(_Midend, (int)_ISORT_MAX);

		_Insertion_sort(_Mid, _Midend);
		_Mid = _Midend;
		}
	_Insertion_sort(_Mid, _Last);	

	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)
		{	
		::stdext:: _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
			_Chunk, _Count);
		::stdext:: _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
			_Chunk *= 2, _Count);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty> inline
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf)
	{	
	if (_Count <= _ISORT_MAX)
		_Insertion_sort(_First, _Last);	
	else
		{	
		_Diff _Count2 = (_Count + 1) / 2;
		_BidIt _Mid = _First;
		std::advance(_Mid, _Count2);

		if (_Count2 <= _Tempbuf._Maxlen())
			{	
			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);
			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);
			}
		else
			{	
			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);
			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);
			}

		_Buffered_merge(_First, _Mid, _Last,
			_Count2, _Count - _Count2, _Tempbuf);	
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty> inline
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff *, _Ty *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);
	_Stable_sort(_First, _Last, _Count, _Tempbuf);
	}

template<class _BidIt> inline
	void stable_sort(_BidIt _First, _BidIt _Last)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3402);
	if (_First != _Last)
		{
		_Stable_sort(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dist_type(_First), _Val_type(_First));
		}
	}

		
template<class _BidIt,
	class _OutIt,
	class _Diff,
	class _Pr> inline
	void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count, _Pr _Pred, _Range_checked_iterator_tag)
	{	
	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)
		{	
		_BidIt _Mid1 = _First;
		std::advance(_Mid1, _Chunk);
		_BidIt _Mid2 = _Mid1;
		std::advance(_Mid2, _Chunk);

		_Dest = ::stdext:: unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);
		_First = _Mid2;
		}

	if (_Count <= _Chunk)
		::stdext:: unchecked_copy(_First, _Last, _Dest);	
	else
		{	
		_BidIt _Mid1 = _First;
		std::advance(_Mid1, _Chunk);

		::stdext:: unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);
		}
	}



template<class _BidIt, class _OutIt, class _Diff, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count, _Pr _Pred)
	{
		_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt, class _OutElem, class _Diff, class _Pr, size_t _Size>
inline
void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutElem (&_Dest)[_Size],
		_Diff _Chunk, _Diff _Count, _Pr _Pred)
	{
		_Chunked_merge(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size), _Chunk, _Count, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt, class _OutIt, class _Diff, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count, _Pr _Pred)
	{
		_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std:: _Range_checked_iterator_tag());
	}











#line 3477 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
	{	
	_BidIt _Mid = _First;
	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)
		{	
		_BidIt _Midn = _Mid;
		std::advance(_Midn, (int)_ISORT_MAX);

		_Insertion_sort(_Mid, _Midn, _Pred);
		_Mid = _Midn;
		}
	_Insertion_sort(_Mid, _Last, _Pred);	

	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)
		{	
		::stdext:: _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
			_Chunk, _Count, _Pred);
		::stdext:: _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
			_Chunk *= 2, _Count, _Pred);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
	{	
	if (_Count <= _ISORT_MAX)
		_Insertion_sort(_First, _Last, _Pred);	
	else
		{	
		_Diff _Count2 = (_Count + 1) / 2;
		_BidIt _Mid = _First;
		std::advance(_Mid, _Count2);

		if (_Count2 <= _Tempbuf._Maxlen())
			{	
			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
				_Tempbuf, _Pred);
			}
		else
			{	
			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);
			}

		_Buffered_merge(_First, _Mid, _Last,
			_Count2, _Count - _Count2, _Tempbuf, _Pred);	
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff *, _Ty *, _Pr _Pred)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);
	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);
	}

template<class _BidIt,
	class _Pr> inline
	void stable_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3553);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",3554);
	if (_First != _Last)
		{
		_Stable_sort(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last),
			_Dist_type(_First), _Val_type(_First), _Pred);
		}
	}

		
template<class _RanIt,
	class _Ty> inline
	void _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Ty *)
	{	
	_Debug_range(_First, _Mid, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3567);
	_Debug_range(_Mid, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3568);
	std::make_heap(_First, _Mid);

	for (_RanIt _Next = _Mid; _Next < _Last; ++_Next)
		if (_Debug_lt(*_Next, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3572))
			_Pop_heap(_First, _Mid, _Next, _Ty(*_Next),
				_Dist_type(_First));	
	std::sort_heap(_First, _Mid);
	}

template<class _RanIt> inline
	void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{	
	_Partial_sort(::std:: _Checked_base(_First), ::std:: _Checked_base(_Mid), ::std:: _Checked_base(_Last), _Val_type(_First));
	}

		
template<class _RanIt,
	class _Ty,
	class _Pr> inline
	void _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last,
		_Pr _Pred, _Ty *)
	{	
	_Debug_range(_First, _Mid, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3591);
	_Debug_range(_Mid, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3592);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",3593);
	std::make_heap(_First, _Mid, _Pred);

	for (_RanIt _Next = _Mid; _Next < _Last; ++_Next)
		if (_Debug_lt_pred(_Pred, *_Next, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3597))
			_Pop_heap(_First, _Mid, _Next, _Ty(*_Next), _Pred,
				_Dist_type(_First));	
	std::sort_heap(_First, _Mid, _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	
	_Partial_sort(::std:: _Checked_base(_First), ::std:: _Checked_base(_Mid), ::std:: _Checked_base(_Last), _Pred, _Val_type(_First));
	}

		
template<class _InIt,
	class _RanIt,
	class _Diff,
	class _Ty> inline
	_RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Diff *, _Ty *)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3618);
	_Debug_range(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3619);
	_RanIt _Mid2 = _First2;
	for (; _First1 != _Last1 && _Mid2 != _Last2; ++_First1, ++_Mid2)
		*_Mid2 = *_First1;	
	std::make_heap(_First2, _Mid2);

	for (; _First1 != _Last1; ++_First1)
		if (_Debug_lt(*_First1, *_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3626))
			_Adjust_heap(_First2, _Diff(0), _Diff(_Mid2 - _First2),
				_Ty(*_First1));	

	std::sort_heap(_First2, _Mid2);
	return (_Mid2);
	}

template<class _InIt,
	class _RanIt> inline
	_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2)
	{	
	if (_First1 != _Last1 && _First2 != _Last2)
        	::std:: _Checked_assign_from_base(_First2, _Partial_sort_copy(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dist_type(_First2), _Val_type(_First1)));
#line 3643 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return (_First2);
	}

		
template<class _InIt,
	class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Pr _Pred, _Diff *, _Ty *)
	{	
	_Debug_range(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3655);
	_Debug_range(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3656);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",3657);
	_RanIt _Mid2 = _First2;
	for (; _First1 != _Last1 && _Mid2 != _Last2; ++_First1, ++_Mid2)
		*_Mid2 = *_First1;	
	std::make_heap(_First2, _Mid2, _Pred);

	for (; _First1 != _Last1; ++_First1)
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3664))
			_Adjust_heap(_First2, _Diff(0), _Diff(_Mid2 - _First2),
				_Ty(*_First1), _Pred);	

	std::sort_heap(_First2, _Mid2, _Pred);
	return (_Mid2);
	}

template<class _InIt,
	class _RanIt,
	class _Pr> inline
	_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Pr _Pred)
	{	
	if (_First1 != _Last1 && _First2 != _Last2)
		::std:: _Checked_assign_from_base(_First2, _Partial_sort_copy(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Pred, _Dist_type(_First2), _Val_type(_First1)));
#line 3682 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return (_First2);
	}

		
template<class _RanIt> inline
	void _Nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3689);
	for (; _ISORT_MAX < _Last - _First; )
		{	
		pair<_RanIt, _RanIt> _Mid =
			_Unguarded_partition(_First, _Last);

		if (_Mid.second <= _Nth)
			_First = _Mid.second;
		else if (_Mid.first <= _Nth)
			return;	
		else
			_Last = _Mid.first;
		}

	_Insertion_sort(_First, _Last);	
	}

template<class _RanIt> inline
	void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
	{	
	_Nth_element(::std:: _Checked_base(_First), ::std:: _Checked_base(_Nth), ::std:: _Checked_base(_Last));
	}

		
template<class _RanIt,
	class _Pr> inline
	void _Nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3717);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",3718);
	for (; _ISORT_MAX < _Last - _First; )
		{	
		pair<_RanIt, _RanIt> _Mid =
			_Unguarded_partition(_First, _Last, _Pred);

		if (_Mid.second <= _Nth)
			_First = _Mid.second;
		else if (_Mid.first <= _Nth)
			return;	
		else
			_Last = _Mid.first;
		}

	_Insertion_sort(_First, _Last, _Pred);	
	}

template<class _RanIt,
	class _Pr> inline
	void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{	
	_Nth_element(::std:: _Checked_base(_First), ::std:: _Checked_base(_Nth), ::std:: _Checked_base(_Last), _Pred);
	}

		
template<class _InIt1,
	class _InIt2> inline
	bool _Includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	_Debug_order(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3748);
	_Debug_order(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3749);
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt(*_First2, *_First1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3751))
			return (false);
		else if (*_First1 < *_First2)
			++_First1;
		else
			++_First1, ++_First2;
	return (_First2 == _Last2);
	}

template<class _InIt1,
	class _InIt2> inline
	bool includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	return _Includes(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2));
	}

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3776);
	_Debug_order(_First2, _Last2, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3777);
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt_pred(_Pred, *_First2, *_First1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3779))
			return (false);
		else if (_Pred(*_First1, *_First2))
			++_First1;
		else
			++_First1, ++_First2;
	return (_First2 == _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	return _Includes(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Pred);
	}

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
	{	
	_Debug_order(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3805);
	_Debug_order(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3806);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",3807);
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt(*_First1, *_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3809))
			*_Dest++ = *_First1, ++_First1;
		else if (*_First2 < *_First1)
			*_Dest++ = *_First2, ++_First2;
		else
			*_Dest++ = *_First1, ++_First1, ++_First2;
	_Dest = ::stdext:: unchecked_copy(_First1, _Last1, _Dest);
	return (::stdext:: unchecked_copy(_First2, _Last2, _Dest));
	}



template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
	{	
	return (set_union(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}














#line 3867 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3876);
	_Debug_order(_First2, _Last2, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3877);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",3878);
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3880))
			*_Dest++ = *_First1, ++_First1;
		else if (_Pred(*_First2, *_First1))
			*_Dest++ = *_First2, ++_First2;
		else
			*_Dest++ = *_First1, ++_First1, ++_First2;
	_Dest = ::stdext:: unchecked_copy(_First1, _Last1, _Dest);
	return (::stdext:: unchecked_copy(_First2, _Last2, _Dest));
	}



template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
	{	
	return (set_union(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}















#line 3941 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
	{	
	_Debug_order(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3949);
	_Debug_order(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3950);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",3951);
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt(*_First1, *_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 3953))
			++_First1;
		else if (*_First2 < *_First1)
			++_First2;
		else
			*_Dest++ = *_First1++, ++_First2;
	return (_Dest);
	}



template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
	{	
	return (set_intersection(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}














#line 4010 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4019);
	_Debug_order(_First2, _Last2, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4020);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",4021);
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4023))
			++_First1;
		else if (_Pred(*_First2, *_First1))
			++_First2;
		else
			*_Dest++ = *_First1++, ++_First2;
	return (_Dest);
	}



template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
	{	
	return (set_intersection(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}















#line 4083 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
	{	
	_Debug_order(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4091);
	_Debug_order(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4092);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",4093);
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt(*_First1, *_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4095))
			*_Dest++ = *_First1, ++_First1;
		else if (*_First2 < *_First1)
			++_First2;
		else
			++_First1, ++_First2;
	return (::stdext:: unchecked_copy(_First1, _Last1, _Dest));
	}



template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
	{	
	return (set_difference(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}














#line 4152 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4161);
	_Debug_order(_First2, _Last2, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4162);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",4163);
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4165))
			*_Dest++ = *_First1, ++_First1;
		else if (_Pred(*_First2, *_First1))
			++_First2;
		else
			++_First1, ++_First2;
	return (::stdext:: unchecked_copy(_First1, _Last1, _Dest));
	}



template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
	{	
	return (set_difference(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}















#line 4225 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
	{	
	_Debug_order(_First1, _Last1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4233);
	_Debug_order(_First2, _Last2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4234);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",4235);
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt(*_First1, *_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4237))
			*_Dest++ = *_First1, ++_First1;
		else if (*_First2 < *_First1)
			*_Dest++ = *_First2, ++_First2;
		else
			++_First1, ++_First2;
	_Dest = ::stdext:: unchecked_copy(_First1, _Last1, _Dest);
	return (::stdext:: unchecked_copy(_First2, _Last2, _Dest));
	}



template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
	{	
	return (set_symmetric_difference(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}














#line 4295 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4304);
	_Debug_order(_First2, _Last2, _Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4305);
	_Debug_pointer(_Dest, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",4306);
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4308))
			*_Dest++ = *_First1, ++_First1;
		else if (_Pred(*_First2, *_First1))
			*_Dest++ = *_First2, ++_First2;
		else
			++_First1, ++_First2;
	_Dest = ::stdext:: unchecked_copy(_First1, _Last1, _Dest);
	return (::stdext:: unchecked_copy(_First2, _Last2, _Dest));
	}



template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
	{	
	return (set_symmetric_difference(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}















#line 4369 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

		
template<class _FwdIt> inline
	_FwdIt _Max_element(_FwdIt _First, _FwdIt _Last)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4374);
	_FwdIt _Found = _First;
	if (_First != _Last)
		for (; ++_First != _Last; )
			if (_Debug_lt(*_Found, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4378))
				_Found = _First;
	return (_Found);
	}

template<class _FwdIt> inline
	_FwdIt max_element(_FwdIt _First, _FwdIt _Last)
	{	
	::std:: _Checked_assign_from_base(_First, _Max_element(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last)));
#line 4388 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return (_First);
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4396);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",4397);
	_FwdIt _Found = _First;
	if (_First != _Last)
		for (; ++_First != _Last; )
			if (_Debug_lt_pred(_Pred, *_Found, *_First, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4401))
				_Found = _First;
	return (_Found);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	::std:: _Checked_assign_from_base(_First, _Max_element(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred));
#line 4412 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return (_First);
	}

		
template<class _FwdIt> inline
	_FwdIt _Min_element(_FwdIt _First, _FwdIt _Last)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4419);
	_FwdIt _Found = _First;
	if (_First != _Last)
		for (; ++_First != _Last; )
			if (_Debug_lt(*_First, *_Found, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4423))
				_Found = _First;
	return (_Found);
	}

template<class _FwdIt> inline
	_FwdIt min_element(_FwdIt _First, _FwdIt _Last)
	{	
	::std:: _Checked_assign_from_base(_First, _Min_element(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last)));
#line 4433 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return (_First);
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4441);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",4442);
	_FwdIt _Found = _First;
	if (_First != _Last)
		for (; ++_First != _Last; )
			if (_Debug_lt_pred(_Pred, *_First, *_Found, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4446))
				_Found = _First;
	return (_Found);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	::std:: _Checked_assign_from_base(_First, _Min_element(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred));
#line 4457 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
	return (_First);
	}

		
template<class _BidIt> inline
	bool _Next_permutation(_BidIt _First, _BidIt _Last)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4464);
	_BidIt _Next = _Last;
	if (_First == _Last || _First == --_Next)
		return (false);

	for (; ; )
		{	
		_BidIt _Next1 = _Next;
		if (_Debug_lt(*--_Next, *_Next1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4472))
			{	
			_BidIt _Mid = _Last;
			for (; !_Debug_lt(*_Next, *--_Mid, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4475); )
				;
			std::iter_swap(_Next, _Mid);
			std::reverse(_Next1, _Last);
			return (true);
			}

		if (_Next == _First)
			{	
			std::reverse(_First, _Last);
			return (false);
			}
		}
	}

template<class _BidIt> inline
	bool next_permutation(_BidIt _First, _BidIt _Last)
	{	
	return _Next_permutation(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last));
	}

		
template<class _BidIt,
	class _Pr> inline
	bool _Next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4501);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",4502);
	_BidIt _Next = _Last;
	if (_First == _Last || _First == --_Next)
		return (false);

	for (; ; )
		{	
		_BidIt _Next1 = _Next;
		if (_Debug_lt_pred(_Pred, *--_Next, *_Next1, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4510))
			{	
			_BidIt _Mid = _Last;
			for (; !_Debug_lt_pred(_Pred, *_Next, *--_Mid, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4513); )
				;
			std::iter_swap(_Next, _Mid);
			std::reverse(_Next1, _Last);
			return (true);
			}

		if (_Next == _First)
			{	
			std::reverse(_First, _Last);
			return (false);
			}
		}
	}

template<class _BidIt,
	class _Pr> inline
	bool next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	return _Next_permutation(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred);
	}

		
template<class _BidIt> inline
	bool _Prev_permutation(_BidIt _First, _BidIt _Last)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4539);
	_BidIt _Next = _Last;
	if (_First == _Last || _First == --_Next)
		return (false);
	for (; ; )
		{	
		_BidIt _Next1 = _Next;
		if (_Debug_lt(*_Next1, *--_Next, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4546))
			{	
			_BidIt _Mid = _Last;
			for (; !_Debug_lt(*--_Mid, *_Next, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4549); )
				;
			std::iter_swap(_Next, _Mid);
			std::reverse(_Next1, _Last);
			return (true);
			}

		if (_Next == _First)
			{	
			std::reverse(_First, _Last);
			return (false);
			}
		}
	}

template<class _BidIt> inline
	bool prev_permutation(_BidIt _First, _BidIt _Last)
	{	
	return _Prev_permutation(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last));
	}

		
template<class _BidIt,
	class _Pr> inline
	bool _Prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4575);
	_Debug_pointer(_Pred, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm",4576);
	_BidIt _Next = _Last;
	if (_First == _Last || _First == --_Next)
		return (false);

	for (; ; )
		{	
		_BidIt _Next1 = _Next;
		if (_Debug_lt_pred(_Pred, *_Next1, *--_Next, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4584))
			{	
			_BidIt _Mid = _Last;
			for (; !_Debug_lt_pred(_Pred, *--_Mid, *_Next, L"C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm", 4587); )
				;
			std::iter_swap(_Next, _Mid);
			std::reverse(_Next1, _Last);
			return (true);
			}

		if (_Next == _First)
			{	
			std::reverse(_First, _Last);
			return (false);
			}
		}
	}

template<class _BidIt,
	class _Pr> inline
	bool prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	return _Prev_permutation(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred);
	}

}

namespace stdext {

template<class _InIt, class _OutIt, class _Fn1>
inline
	_OutIt unchecked_transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
	{
		return ::std:: _Transform(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Func,
			::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt, class _OutIt, class _Fn1>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
	{
	return ::std:: _Transform(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Func,
		::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt, class _OutElem, class _Fn1, size_t _Size>
inline
_OutElem* checked_transform(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size], _Fn1 _Func)
	{
	return (checked_transform(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Func).base());
	}

template<class _InIt, class _OutIt, class _Fn1>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
	{
	return ::std:: _Transform(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Func,
		::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
inline
	_OutIt unchecked_transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
		_OutIt _Dest, _Fn2 _Func)
	{
		return ::std:: _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Dest, _Func,
			::std:: _Iter_random(_First1, _First2), ::std:: _Iter_random(_First1, _Dest), 
			::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result && ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
		_OutIt _Dest, _Fn2 _Func)
	{
	return ::std:: _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Dest, _Func,
		::std:: _Iter_random(_First1, _First2), ::std:: _Iter_random(_First1, _Dest),
		::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InElem2, class _OutElem, class _Fn2, size_t _SizeFirst2, size_t _SizeDest>
inline
_OutElem* checked_transform(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_SizeFirst2],
		_OutElem (&_Dest)[_SizeDest], _Fn2 _Func)
	{
	return (checked_transform(_First1, _Last1,
		::stdext:: make_checked_array_iterator(_First2, _SizeFirst2),
		::stdext:: make_checked_array_iterator(_Dest, _SizeDest),
		_Func).base());
	}

template<class _InIt1, class _InIt2, class _OutElem, class _Fn2, size_t _SizeDest>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, _OutElem* >::_Result checked_transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
		_OutElem (&_Dest)[_SizeDest], _Fn2 _Func)
	{
	return (::std:: _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
		::stdext:: make_checked_array_iterator(_Dest, _SizeDest), _Func,
		::std:: _Iter_random(_First1, _First2), ::std:: _Iter_cat(_First1),
		::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()).base());
	}

template<class _InIt1, class _InIt2, class _OutElem, class _Fn2, size_t _SizeDest>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, _OutElem* >::_Result checked_transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
		_OutElem (&_Dest)[_SizeDest], _Fn2 _Func)
	{
	return (::std:: _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
		::stdext:: make_checked_array_iterator(_Dest, _SizeDest), _Func,
		::std:: _Iter_random(_First1, _First2), ::std:: _Iter_cat(_First1),
		::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()).base());
	}

template<class _InIt1, class _InElem2, class _OutIt, class _Fn2, size_t _SizeFirst2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_transform(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_SizeFirst2],
		_OutIt _Dest, _Fn2 _Func)
	{
	return (::std:: _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::stdext:: make_checked_array_iterator(_First2, _SizeFirst2),
		_Dest, _Func,
		::std:: _Iter_cat(_First1), ::std:: _Iter_random(_First1, _Dest),
		::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt1, class _InElem2, class _OutIt, class _Fn2, size_t _SizeFirst2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_transform(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_SizeFirst2],
		_OutIt _Dest, _Fn2 _Func)
	{
	return (::std:: _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::stdext:: make_checked_array_iterator(_First2, _SizeFirst2),
		_Dest, _Func,
		::std:: _Iter_cat(_First1), ::std:: _Iter_random(_First1, _Dest),
		::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result || !::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
		_OutIt _Dest, _Fn2 _Func)
	{
	return ::std:: _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Dest, _Func,
		::std:: _Iter_random(_First1, _First2), ::std:: _Iter_random(_First1, _Dest),
		::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag());
	}

template<class _FwdIt1, class _FwdIt2>
inline
	_FwdIt2 unchecked_swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
	{
		return ::std:: _Swap_ranges(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
			::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	}

template<class _FwdIt1, class _FwdIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt2 >::_Result, _FwdIt2 >::_Result checked_swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
	{
		return ::std:: _Swap_ranges(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
			::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	}

template<class _FwdIt1, class _FwdElem2, size_t _Size>
inline
_FwdElem2* checked_swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdElem2 (&_First2)[_Size])
	{
		return (checked_swap_ranges(_First1, _Last1, ::stdext:: make_checked_array_iterator(_First2, _Size)).base());
	}

template<class _FwdIt1, class _FwdIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt2 >::_Result, _FwdIt2 >::_Result checked_swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
	{
		return ::std:: _Swap_ranges(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
			::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt unchecked_replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	
		return ::std:: _Replace_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Oldval, _Newval,
			::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	
	return ::std:: _Replace_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Oldval, _Newval,
		::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt, class _OutElem, class _Ty, size_t _Size>
inline
_OutElem* checked_replace_copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size],
		const _Ty& _Oldval, const _Ty& _Newval)
	{	
	return (checked_replace_copy(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size),
		_Oldval, _Newval).base());
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	
	return ::std:: _Replace_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Oldval, _Newval,
		::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt unchecked_replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred, const _Ty& _Val)
	{	
		return ::std:: _Replace_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, _Val,
			::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred, const _Ty& _Val)
	{	
	return ::std:: _Replace_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, _Val,
		::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt, class _OutElem, class _Pr, class _Ty, size_t _Size>
inline
_OutElem* checked_replace_copy_if(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size],
		_Pr _Pred, const _Ty& _Val)
	{	
	return (checked_replace_copy_if(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size),
		_Pred, _Val).base());
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred, const _Ty& _Val)
	{	
	return ::std:: _Replace_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, _Val,
		::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	void unchecked_generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{	
		::std:: _Generate_n(_Dest, _Count, _Func,
			::std:: _Iter_cat(_Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
void checked_generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func, typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _Diff >::_Result = 0)
	{	
	::std:: _Generate_n(_Dest, _Count, _Func,
		::std:: _Iter_cat(_Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _OutElem, class _Diff, class _Fn0, size_t _Size>
inline
void checked_generate_n(_OutElem (&_Dest)[_Size], _Diff _Count, _Fn0 _Func)
	{	
	checked_generate_n(::stdext:: make_checked_array_iterator(_Dest, _Size), _Count, _Func);
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
void checked_generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func, typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _Diff >::_Result = 0)
	{	
	::std:: _Generate_n(_Dest, _Count, _Func,
		::std:: _Iter_cat(_Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt unchecked_remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	
		return ::std:: _Remove_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Val,
			::std:: _Range_checked_iterator_tag());
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	
	return ::std:: _Remove_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Val, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt, class _OutElem, class _Ty, size_t _Size>
inline
_OutElem* checked_remove_copy(_InIt _First, _InIt _Last,
		_OutElem (&_Dest)[_Size], const _Ty& _Val)
	{	
	return (checked_remove_copy(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size),
		_Val).base());
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	
	return ::std:: _Remove_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Val, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt unchecked_remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{	
		return ::std:: _Remove_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred,
			::std:: _Range_checked_iterator_tag());
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{	
	return ::std:: _Remove_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* checked_remove_copy_if(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size], _Pr _Pred)
	{	
	return (checked_remove_copy_if(_First, _Last,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{	
	return ::std:: _Remove_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt unchecked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
	return (_First == _Last ? _Dest :
		::std:: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
			::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt,
	class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
	return (_First == _Last ? _Dest :
		::std:: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, ::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt, class _OutElem, size_t _Size>
inline
_OutElem* checked_unique_copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size])
	{	
	return (_First == _Last ? _Dest :
		(checked_unique_copy(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size)).base()));
	}

template<class _InIt,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
	return (_First == _Last ? _Dest :
		::std:: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, ::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt unchecked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{	
	return (_First == _Last ? _Dest
		: ::std:: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred,
			::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{	
	return (_First == _Last ? _Dest
		: ::std:: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, ::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
	}

template<class _InIt, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* checked_unique_copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size], _Pr _Pred)
	{	
	return (_First == _Last ? _Dest
		: (checked_unique_copy(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base()));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{	
	return (_First == _Last ? _Dest
		: ::std:: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, ::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt unchecked_reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
	{	
		return ::std:: _Reverse_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
			::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt,
	class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
	{	
	return ::std:: _Reverse_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, ::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt, class _OutElem, size_t _Size>
inline
_OutElem* checked_reverse_copy(_BidIt _First, _BidIt _Last, _OutElem (&_Dest)[_Size])
	{	
	return (checked_reverse_copy(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _BidIt,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
	{	
	return ::std:: _Reverse_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, ::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _FwdIt,
	class _OutIt> inline
	_OutIt unchecked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
	{	
		return ::std:: _Rotate_copy(_First, _Mid, _Last, _Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _FwdIt, class _OutIt>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
	{
		return ::std:: _Rotate_copy(_First, _Mid, _Last, _Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _FwdIt, class _OutElem, size_t _Size>
inline
_OutElem* checked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutElem (&_Dest)[_Size])
	{
		return (checked_rotate_copy(_First, _Mid, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _FwdIt, class _OutIt>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
	{
		return ::std:: _Rotate_copy(_First, _Mid, _Last, _Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt unchecked_merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
		return ::std:: _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
			::std:: _Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return ::std:: _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
		::std:: _Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* checked_merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
	{	
	return (checked_merge(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return ::std:: _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
		::std:: _Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt unchecked_merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
		return ::std:: _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest, _Pred,
			::std:: _Iter_random(_First1, _First2,_Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return ::std:: _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred,
		::std:: _Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* checked_merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
	{	
	return (checked_merge(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return ::std:: _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred,
		::std:: _Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt1, class _BidIt2, class _BidIt3>
inline
	_BidIt3 _Unchecked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
	{
		return ::std:: _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt1, class _BidIt2, class _BidIt3>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
	{
		return ::std:: _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt1, class _BidIt2, class _BidIt3>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
	{
		return ::std:: _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
inline
	_BidIt3 _Unchecked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
	{
		return ::std:: _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
	{
		return ::std:: _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
	{
		return ::std:: _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt, class _OutIt, class _Diff>
inline
	void _Unchecked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count)
	{
		::std:: _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt, class _OutIt, class _Diff>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count)
	{
		::std:: _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt, class _OutElem, class _Diff, size_t _Size>
inline
void _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutElem (&_Dest)[_Size],
		_Diff _Chunk, _Diff _Count)
	{
		::std:: _Chunked_merge(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size), _Chunk, _Count, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt, class _OutIt, class _Diff>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count)
	{
		::std:: _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt, class _OutIt, class _Diff, class _Pr>
inline
	void _Unchecked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count, _Pr _Pred)
	{
		::std:: _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt, class _OutIt, class _Diff, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count, _Pr _Pred)
	{
		::std:: _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt, class _OutElem, class _Diff, class _Pr, size_t _Size>
inline
void _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutElem (&_Dest)[_Size],
		_Diff _Chunk, _Diff _Count, _Pr _Pred)
	{
		::std:: _Chunked_merge(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size), _Chunk, _Count, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _BidIt, class _OutIt, class _Diff, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count, _Pr _Pred)
	{
		::std:: _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt unchecked_set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
		return ::std:: _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
			::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return ::std:: _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* checked_set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
	{	
	return (checked_set_union(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return ::std:: _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt unchecked_set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
		return ::std:: _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest, _Pred,
			::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return ::std:: _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* checked_set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
	{	
	return (checked_set_union(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return ::std:: _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt unchecked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
		return ::std:: _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
			::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return ::std:: _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* checked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
	{	
	return (checked_set_intersection(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return ::std:: _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt unchecked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
		return ::std:: _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest, _Pred,
			::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return ::std:: _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* checked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
	{	
	return (checked_set_intersection(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return ::std:: _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt unchecked_set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
		return ::std:: _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
			::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return ::std:: _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* checked_set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
	{	
	return (checked_set_difference(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return ::std:: _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt unchecked_set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
		return ::std:: _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest, _Pred,
			::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return ::std:: _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* checked_set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
	{	
	return (checked_set_difference(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return ::std:: _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt unchecked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
		return ::std:: _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
			::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return ::std:: _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
	{	
	return (checked_set_symmetric_difference(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return ::std:: _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt unchecked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
		return ::std:: _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest, _Pred,
			::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return ::std:: _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
	{	
	return (checked_set_symmetric_difference(_First1, _Last1, _First2, _Last2,
		::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return ::std:: _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
		::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
		_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
	}

}


  #pragma warning(default: 4244)

#pragma warning(pop)
#pragma pack(pop)
#line 5652 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"

#line 5654 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"
#line 5655 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\algorithm"























#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_MatrixOps.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h"






























































































































































































































































































































































































































#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_MatrixOps.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"






















































































































































































































































































































































































































































































































































































#line 42 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_MatrixOps.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h"






































































































































#line 43 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_MatrixOps.h"

namespace gmtl
{





   


   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Matrix<DATA_TYPE, ROWS, COLS>& identity( Matrix<DATA_TYPE, ROWS, COLS>& result )
   {
      if(result.mState != Matrix<DATA_TYPE, ROWS, COLS>::IDENTITY)   
      {
         
         for (unsigned int r = 0; r < ROWS; ++r)
         for (unsigned int c = 0; c < COLS; ++c)
            result( r, c ) = (DATA_TYPE)0.0;

         
         for (unsigned int x = 0; x < Math::Min( COLS, ROWS ); ++x)
            result( x, x ) = (DATA_TYPE)1.0;


         result.mState = Matrix<DATA_TYPE, ROWS, COLS>::FULL;
      }

      return result;
   }


   


   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Matrix<DATA_TYPE, ROWS, COLS>& zero( Matrix<DATA_TYPE, ROWS, COLS>& result )
   {
      if (result.mState == Matrix<DATA_TYPE, ROWS, COLS>::IDENTITY)
      {
         for (unsigned int x = 0; x < Math::Min( ROWS, COLS ); ++x)
         {
            result( x, x ) = (DATA_TYPE)0;
         }
      }
      else
      {
         for (unsigned int x = 0; x < ROWS*COLS; ++x)
         {
            result.mData[x] = (DATA_TYPE)0;
         }
      }
      return result;
   }


   



   template <typename DATA_TYPE, unsigned ROWS, unsigned INTERNAL, unsigned COLS>
   inline Matrix<DATA_TYPE, ROWS, COLS>& mult( Matrix<DATA_TYPE, ROWS, COLS>& result,
                 const Matrix<DATA_TYPE, ROWS, INTERNAL>& lhs,
                 const Matrix<DATA_TYPE, INTERNAL, COLS>& rhs )
   {
      Matrix<DATA_TYPE, ROWS, COLS> ret_mat; 
      zero( ret_mat );

      
      
      
      for (unsigned int i = 0; i < ROWS; ++i)           
      for (unsigned int j = 0; j < COLS; ++j)           
      for (unsigned int k = 0; k < INTERNAL; ++k)       
         ret_mat( i, j ) += lhs( i, k ) * rhs( k, j );

      return result = ret_mat;
   }

   




   template <typename DATA_TYPE, unsigned ROWS, unsigned INTERNAL, unsigned COLS>
   inline Matrix<DATA_TYPE, ROWS, COLS> operator*( const Matrix<DATA_TYPE, ROWS, INTERNAL>& lhs,
                                                   const Matrix<DATA_TYPE, INTERNAL, COLS>& rhs )
   {
      Matrix<DATA_TYPE, ROWS, COLS> temporary;
      return mult( temporary, lhs, rhs );
   }

   




   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Matrix<DATA_TYPE, ROWS, COLS>& sub( Matrix<DATA_TYPE, ROWS, COLS>& result,
                 const Matrix<DATA_TYPE, ROWS, COLS>& lhs,
                 const Matrix<DATA_TYPE, ROWS, COLS>& rhs )
   {
      
      
      
      for (unsigned int i = 0; i < ROWS; ++i)           
      for (unsigned int j = 0; j < COLS; ++j)           
         result( i, j ) = lhs( i, j ) - rhs( i, j );

      return result;
   }

   




   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Matrix<DATA_TYPE, ROWS, COLS>& add( Matrix<DATA_TYPE, ROWS, COLS>& result,
                 const Matrix<DATA_TYPE, ROWS, COLS>& lhs,
                 const Matrix<DATA_TYPE, ROWS, COLS>& rhs )
   {
      
      
      
      for (unsigned int i = 0; i < ROWS; ++i)           
      for (unsigned int j = 0; j < COLS; ++j)           
         result( i, j ) = lhs( i, j ) + rhs( i, j );

      return result;
   }

   



   template <typename DATA_TYPE, unsigned SIZE>
   inline Matrix<DATA_TYPE, SIZE, SIZE>& postMult( Matrix<DATA_TYPE, SIZE, SIZE>& result,
                                                     const Matrix<DATA_TYPE, SIZE, SIZE>& operand )
   {
      return mult( result, result, operand );
   }

   



   template <typename DATA_TYPE, unsigned SIZE>
   inline Matrix<DATA_TYPE, SIZE, SIZE>& preMult( Matrix<DATA_TYPE, SIZE, SIZE>& result,
                                                  const Matrix<DATA_TYPE, SIZE, SIZE>& operand )
   {
      return mult( result, operand, result );
   }

   




   template <typename DATA_TYPE, unsigned SIZE>
   inline Matrix<DATA_TYPE, SIZE, SIZE>& operator*=( Matrix<DATA_TYPE, SIZE, SIZE>& result,
                                                     const Matrix<DATA_TYPE, SIZE, SIZE>& operand )
   {
      return postMult( result, operand );
   }

   



   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Matrix<DATA_TYPE, ROWS, COLS>& mult( Matrix<DATA_TYPE, ROWS, COLS>& result, const Matrix<DATA_TYPE, ROWS, COLS>& mat, float scalar )
   {
      for (unsigned i = 0; i < ROWS * COLS; ++i)
         result.mData[i] = mat.mData[i] * scalar;
      return result;
   }

   



   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Matrix<DATA_TYPE, ROWS, COLS>& mult( Matrix<DATA_TYPE, ROWS, COLS>& result, DATA_TYPE scalar )
   {
      for (unsigned i = 0; i < ROWS * COLS; ++i)
         result.mData[i] *= scalar;
      return result;
   }

   



   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Matrix<DATA_TYPE, ROWS, COLS>& operator*=( Matrix<DATA_TYPE, ROWS, COLS>& result, DATA_TYPE scalar )
   {
      return mult( result, scalar );
   }

   



   template <typename DATA_TYPE, unsigned SIZE>
   Matrix<DATA_TYPE, SIZE, SIZE>& transpose( Matrix<DATA_TYPE, SIZE, SIZE>& result )
   {
      
      for (unsigned c = 0; c < SIZE; ++c)
         for (unsigned r = c + 1; r < SIZE; ++r)
            std::swap( result( r, c ), result( c, r ) );

      return result;
   }

   



   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   Matrix<DATA_TYPE, ROWS, COLS>& transpose( Matrix<DATA_TYPE, ROWS, COLS>& result, const Matrix<DATA_TYPE, COLS, ROWS>& source )
   {
      
      Matrix<DATA_TYPE, COLS, ROWS> temp = source;

      
      for (unsigned i = 0; i < ROWS; ++i)
      {
         for (unsigned j = 0; j < COLS; ++j)
         {
            result( i, j ) = temp( j, i );
         }
      }

      return result;
   }


   




   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Matrix<DATA_TYPE, ROWS, COLS>& invertFull( Matrix<DATA_TYPE, ROWS, COLS>& result, const Matrix<DATA_TYPE, ROWS, COLS>& src )
   {
      










      const DATA_TYPE* a = src.getData();
      DATA_TYPE* b = result.mData;

      int   n = 4;
      int    i, j, k;
      int    r[ 4], c[ 4], row[ 4], col[ 4];
      DATA_TYPE  m[ 4][ 4*2], pivot, max_m, tmp_m, fac;

      
      for ( i = 0; i < n; i ++ )
      {
         r[ i] = c[ i] = 0;
         row[ i] = col[ i] = 0;
      }

      
      for ( i = 0; i < n; i++ )
      {
         for ( j = 0; j < n; j++ )
         {
            m[ i][ j] = a[ i * n + j];
            m[ i][ j + n] = ( i == j ) ? (DATA_TYPE)1.0 : (DATA_TYPE)0.0 ;
         }
      }

      
      for ( k = 0; k < n; k++ )
      {
         
         for ( i = 0, max_m = 0; i < n; i++ )
         {
            if ( row[ i]  )
               continue;
            for ( j = 0; j < n; j++ )
            {
               if ( col[ j] )
                  continue;
               tmp_m = gmtl::Math::abs( m[ i][ j]);
               if ( tmp_m > max_m)
               {
                  max_m = tmp_m;
                  r[ k] = i;
                  c[ k] = j;
               }
            }
         }
         row[ r[k] ] = col[ c[k] ] = 1;
         pivot = m[ r[ k] ][ c[ k] ];


         if ( gmtl::Math::abs( pivot) <= 1e-20)
         {
            std::cerr << "*** pivot = " << pivot << " in mat_inv. ***\n";
            result.setError();
            return result;
         }

         
         for ( j = 0; j < 2*n; j++ )
         {
            if ( j == c[ k] )
               m[ r[ k]][ j] = (DATA_TYPE)1.0;
            else
               m[ r[ k]][ j] /= pivot;
         }

         
         for ( i = 0; i < n; i++ )
         {
            if ( i == r[ k] )
               continue;

            for ( j=0, fac = m[ i][ c[k]]; j < 2*n; j++ )
            {
               if ( j == c[ k] )
                  m[ i][ j] = (DATA_TYPE)0.0;
               else
                  m[ i][ j] -= fac * m[ r[k]][ j];
            }
         }
      }

      
      for ( i = 0; i < n; i++ )
         for ( j = 0; j < n; j++ )
            row[ i] = ( c[ j] == i ) ? r[ j] : row[ i];

      for ( i = 0; i < n; i++ )
         for ( j = 0; j < n; j++ )
            b[ i * n +  j] = m[ row[ i]][ j + n];

      
      return result;
   }

   









   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Matrix<DATA_TYPE, ROWS, COLS>& invert( Matrix<DATA_TYPE, ROWS, COLS>& result, const Matrix<DATA_TYPE, ROWS, COLS>& src )
   {
      if (src.mState == Matrix<DATA_TYPE, ROWS, COLS>::IDENTITY )
         return result = src;
      else
         return invertFull( result, src );
   }

   









   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Matrix<DATA_TYPE, ROWS, COLS>& invert( Matrix<DATA_TYPE, ROWS, COLS>& result )
   {
      return invert( result, result );
   }








   





   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline bool operator==( const Matrix<DATA_TYPE, ROWS, COLS>& lhs, const Matrix<DATA_TYPE, ROWS, COLS>& rhs )
   {
      for (unsigned int i = 0; i < ROWS*COLS; ++i)
      {
         if (lhs.mData[i] != rhs.mData[i])
         {
            return false;
         }
      }

      return true;

      




   }

   





   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline bool operator!=( const Matrix<DATA_TYPE, ROWS, COLS>& lhs, const Matrix<DATA_TYPE, ROWS, COLS>& rhs )
   {
      return bool( !(lhs == rhs) );
   }

   






   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline bool isEqual( const Matrix<DATA_TYPE, ROWS, COLS>& lhs, const Matrix<DATA_TYPE, ROWS, COLS>& rhs, const DATA_TYPE& eps = (DATA_TYPE)0 )
   {
      (void)( (!!((eps >= (DATA_TYPE)0))) || (_wassert(L"(eps >= (DATA_TYPE)0)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_MatrixOps.h", 486), 0) );

      for (unsigned int i = 0; i < ROWS*COLS; ++i)
      {
         if (!Math::isEqual( lhs.mData[i], rhs.mData[i], eps ))
            return false;
      }
      return true;
   }



} 

#line 501 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_MatrixOps.h"
#line 42 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Xforms.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Quat.h"





























































































































































































#line 43 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Xforms.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_QuatOps.h"




















































































































































































































































































































































































































































































































































































































































































#line 44 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Xforms.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 45 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Xforms.h"

namespace gmtl
{
   



   
   












   template <typename DATA_TYPE>
   inline VecBase<DATA_TYPE, 3>& xform( VecBase<DATA_TYPE, 3>& result, const Quat<DATA_TYPE>& rot, const VecBase<DATA_TYPE, 3>& vector )
   {
      
      (void)( (!!((Math::isEqual( length( rot ), (DATA_TYPE)1.0, (DATA_TYPE)0.0001 ) && "must pass a rotation quaternion to xform(result,quat,vec) - by definition, a rotation quaternion is normalized).  if you need non-rotation quaternion support, let us know."))) || (_wassert(L"(Math::isEqual( length( rot ), (DATA_TYPE)1.0, (DATA_TYPE)0.0001 ) && \"must pass a rotation quaternion to xform(result,quat,vec) - by definition, a rotation quaternion is normalized).  if you need non-rotation quaternion support, let us know.\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Xforms.h", 70), 0) );

      
      

      
      
      
      Quat<DATA_TYPE> rot_conj( -rot[Xelt], -rot[Yelt], -rot[Zelt], rot[Welt] );
      Quat<DATA_TYPE> pure( vector[0], vector[1], vector[2], (DATA_TYPE)0.0 );
      Quat<DATA_TYPE> temp(
         pure[Welt]*rot_conj[Xelt] + pure[Xelt]*rot_conj[Welt] + pure[Yelt]*rot_conj[Zelt] - pure[Zelt]*rot_conj[Yelt],
         pure[Welt]*rot_conj[Yelt] + pure[Yelt]*rot_conj[Welt] + pure[Zelt]*rot_conj[Xelt] - pure[Xelt]*rot_conj[Zelt],
         pure[Welt]*rot_conj[Zelt] + pure[Zelt]*rot_conj[Welt] + pure[Xelt]*rot_conj[Yelt] - pure[Yelt]*rot_conj[Xelt],
         pure[Welt]*rot_conj[Welt] - pure[Xelt]*rot_conj[Xelt] - pure[Yelt]*rot_conj[Yelt] - pure[Zelt]*rot_conj[Zelt] );

      result.set(
         rot[Welt]*temp[Xelt] + rot[Xelt]*temp[Welt] + rot[Yelt]*temp[Zelt] - rot[Zelt]*temp[Yelt],
         rot[Welt]*temp[Yelt] + rot[Yelt]*temp[Welt] + rot[Zelt]*temp[Xelt] - rot[Xelt]*temp[Zelt],
         rot[Welt]*temp[Zelt] + rot[Zelt]*temp[Welt] + rot[Xelt]*temp[Yelt] - rot[Yelt]*temp[Xelt] );
      return result;
   }

   






   template <typename DATA_TYPE>
   inline VecBase<DATA_TYPE, 3> operator*( const Quat<DATA_TYPE>& rot, const VecBase<DATA_TYPE, 3>& vector )
   {
      VecBase<DATA_TYPE, 3> temporary;
      return xform( temporary, rot, vector );
   }


   




   
   template <typename DATA_TYPE>
   inline VecBase<DATA_TYPE, 3> operator*=(VecBase<DATA_TYPE, 3>& vector, const Quat<DATA_TYPE>& rot)
   {
      VecBase<DATA_TYPE, 3> temporary = vector;
      return xform( vector, rot, temporary);
   }


   

   




   









   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Vec<DATA_TYPE, COLS>& xform( Vec<DATA_TYPE, COLS>& result, const Matrix<DATA_TYPE, ROWS, COLS>& matrix, const Vec<DATA_TYPE, COLS>& vector )
   {
      

      
      result = Vec<DATA_TYPE, COLS>();

      for (unsigned iRow = 0; iRow < ROWS; ++iRow)
      for (unsigned iCol = 0; iCol < COLS; ++iCol)
         result[iRow] += matrix( iRow, iCol ) * vector[iCol];

      return result;
   }


   









   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Vec<DATA_TYPE, COLS> operator*( const Matrix<DATA_TYPE, ROWS, COLS>& matrix, const Vec<DATA_TYPE, COLS>& vector )
   {
      
      Vec<DATA_TYPE, COLS> temporary;
      return xform( temporary, matrix, vector );
   }




   







   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS, unsigned VEC_SIZE>
   inline Vec<DATA_TYPE, VEC_SIZE>& xform( Vec<DATA_TYPE, VEC_SIZE >& result, const Matrix<DATA_TYPE, ROWS, COLS>& matrix, const Vec<DATA_TYPE, VEC_SIZE >& vector )
   {
      (void)( (!!((VEC_SIZE == COLS - 1))) || (_wassert(L"(VEC_SIZE == COLS - 1)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Xforms.h", 187), 0) );
      

      
      Vec<DATA_TYPE, COLS> temp_vector, temp_result;
      for (unsigned x = 0; x < VEC_SIZE; ++x)
         temp_vector[x] = vector[x];
      temp_vector[COLS-1] = (DATA_TYPE)0.0; 

      
      xform<DATA_TYPE, ROWS, COLS>( temp_result, matrix, temp_vector );

      
      
      
      if (Math::isEqual( temp_result[VEC_SIZE], (DATA_TYPE)0, (DATA_TYPE)0.0001 ) == false)
      {
         DATA_TYPE w_coord_div = DATA_TYPE( 1.0 ) / temp_result[VEC_SIZE];
         for (unsigned x = 0; x < VEC_SIZE; ++x)
            result[x] = temp_result[x] * w_coord_div;
      }
      else
      {
         for (unsigned x = 0; x < VEC_SIZE; ++x)
            result[x] = temp_result[x];
      }

      return result;
   }

   







   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS, unsigned COLS_MINUS_ONE>
   inline Vec<DATA_TYPE, COLS_MINUS_ONE> operator*( const Matrix<DATA_TYPE, ROWS, COLS>& matrix, const Vec<DATA_TYPE, COLS_MINUS_ONE>& vector )
   {
      Vec<DATA_TYPE, COLS_MINUS_ONE> temporary;
      return xform( temporary, matrix, vector );
   }

   

   





   







   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Point<DATA_TYPE, COLS>& xform( Point<DATA_TYPE, COLS>& result, const Matrix<DATA_TYPE, ROWS, COLS>& matrix, const Point<DATA_TYPE, COLS>& point )
   {
      

      
      result = Point<DATA_TYPE, COLS>();

      for (unsigned iRow = 0; iRow < ROWS; ++iRow)
      for (unsigned iCol = 0; iCol < COLS; ++iCol)
         result[iRow] += matrix( iRow, iCol ) * point[iCol];

      return result;
   }

   







   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Point<DATA_TYPE, COLS> operator*( const Matrix<DATA_TYPE, ROWS, COLS>& matrix, const Point<DATA_TYPE, COLS>& point )
   {
      Point<DATA_TYPE, COLS> temporary;
      return xform( temporary, matrix, point );
   }




   








   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS, unsigned PNT_SIZE>
   inline Point<DATA_TYPE, PNT_SIZE>& xform( Point<DATA_TYPE, PNT_SIZE>& result, const Matrix<DATA_TYPE, ROWS, COLS>& matrix, const Point<DATA_TYPE, PNT_SIZE>& point )
   {
      (void)( (!!((PNT_SIZE == COLS - 1 && "The precondition of this method is that the vector size must be one less than the number of columns in the matrix.  eg. if Mat<n,k>, then Vec<k-1>."))) || (_wassert(L"(PNT_SIZE == COLS - 1 && \"The precondition of this method is that the vector size must be one less than the number of columns in the matrix.  eg. if Mat<n,k>, then Vec<k-1>.\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Xforms.h", 293), 0) );

      
      Point<DATA_TYPE, PNT_SIZE+1> temp_point, temp_result;
      for (unsigned x = 0; x < PNT_SIZE; ++x)
         temp_point[x] = point[x];
      temp_point[PNT_SIZE] = (DATA_TYPE)1.0; 

      
      xform<DATA_TYPE, ROWS, COLS>( temp_result, matrix, temp_point );

      
      
      
      if (Math::isEqual( temp_result[PNT_SIZE], (DATA_TYPE)0, (DATA_TYPE)0.0001 ) == false)
      {
         DATA_TYPE w_coord_div = DATA_TYPE( 1.0 ) / temp_result[PNT_SIZE];
         for (unsigned x = 0; x < PNT_SIZE; ++x)
            result[x] = temp_result[x] * w_coord_div;
      }
      else
      {
         for (unsigned x = 0; x < PNT_SIZE; ++x)
            result[x] = temp_result[x];
      }

      return result;
   }

   







   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS, unsigned COLS_MINUS_ONE>
   inline Point<DATA_TYPE, COLS_MINUS_ONE> operator*( const Matrix<DATA_TYPE, ROWS, COLS>& matrix, const Point<DATA_TYPE, COLS_MINUS_ONE>& point )
   {
      Point<DATA_TYPE, COLS_MINUS_ONE> temporary;
      return xform( temporary, matrix, point );
   }

   






   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Point<DATA_TYPE, COLS> operator*( const Point<DATA_TYPE, COLS>& point, const Matrix<DATA_TYPE, ROWS, COLS>& matrix )
   {
      Point<DATA_TYPE, COLS> temporary;
      return xform( temporary, matrix, point );
   }


   






   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Point<DATA_TYPE, COLS> operator*=(Point<DATA_TYPE, COLS>& point, const Matrix<DATA_TYPE, ROWS, COLS>& matrix)
   {
      Point<DATA_TYPE, COLS> temporary = point;
      return xform( point, matrix, temporary);
   }

   







   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS, unsigned COLS_MINUS_ONE>
   inline Point<DATA_TYPE, COLS_MINUS_ONE> operator*=(Point<DATA_TYPE, COLS_MINUS_ONE>& point, const Matrix<DATA_TYPE, ROWS, COLS>& matrix)
   {
      Point<DATA_TYPE, COLS_MINUS_ONE> temporary = point;
      return xform( point, matrix, temporary);
   }


   
   

   


















































};

#line 439 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Xforms.h"
#line 49 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"

#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_EulerAngle.h"





























































































































































#line 51 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AxisAngle.h"


























































































































































#line 52 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"

namespace gmtl
{
   




   








   template <typename TARGET_TYPE, typename SOURCE_TYPE>
   inline TARGET_TYPE make( const SOURCE_TYPE& src,
                           Type2Type< TARGET_TYPE > t = Type2Type< TARGET_TYPE >() )
   {
      gmtl::ignore_unused_variable_warning(t);
      TARGET_TYPE target;
      return gmtl::set( target, src );
   }

   



   template <typename ROTATION_TYPE, typename SOURCE_TYPE >
   inline ROTATION_TYPE makeRot( const SOURCE_TYPE& coord,
                                Type2Type< ROTATION_TYPE > t = Type2Type< ROTATION_TYPE >() )
   {
      gmtl::ignore_unused_variable_warning(t);
      ROTATION_TYPE temporary;
      return gmtl::set( temporary, coord );
   }

   










   template< typename ROTATION_TYPE >
   inline ROTATION_TYPE makeDirCos( const Vec<typename ROTATION_TYPE::DataType, 3>& xDestAxis,
                                  const Vec<typename ROTATION_TYPE::DataType, 3>& yDestAxis,
                                  const Vec<typename ROTATION_TYPE::DataType, 3>& zDestAxis,
                                  const Vec<typename ROTATION_TYPE::DataType, 3>& xSrcAxis = Vec<typename ROTATION_TYPE::DataType, 3>(1,0,0),
                                  const Vec<typename ROTATION_TYPE::DataType, 3>& ySrcAxis = Vec<typename ROTATION_TYPE::DataType, 3>(0,1,0),
                                  const Vec<typename ROTATION_TYPE::DataType, 3>& zSrcAxis = Vec<typename ROTATION_TYPE::DataType, 3>(0,0,1),
                               Type2Type< ROTATION_TYPE > t = Type2Type< ROTATION_TYPE >() )
   {
      gmtl::ignore_unused_variable_warning(t);
      ROTATION_TYPE temporary;
      return setDirCos( temporary, xDestAxis, yDestAxis, zDestAxis, xSrcAxis, ySrcAxis, zSrcAxis );
   }

   














   template<typename TRANS_TYPE, typename SRC_TYPE >
   inline TRANS_TYPE makeTrans( const SRC_TYPE& arg,
                             Type2Type< TRANS_TYPE > t = Type2Type< TRANS_TYPE >())
   {
      gmtl::ignore_unused_variable_warning(t);
      TRANS_TYPE temporary;
      return setTrans( temporary, arg );
   }

   



   template< typename ROTATION_TYPE >
   inline ROTATION_TYPE makeRot( const Vec<typename ROTATION_TYPE::DataType, 3>& from,
                                 const Vec<typename ROTATION_TYPE::DataType, 3>& to )
   {
      ROTATION_TYPE temporary;
      return setRot( temporary, from, to );
   }

   




   template <typename DEST_TYPE, typename DATA_TYPE>
   inline DEST_TYPE& setRot( DEST_TYPE& result, const Vec<DATA_TYPE, 3>& from, const Vec<DATA_TYPE, 3>& to )
   {
      
      const DATA_TYPE epsilon = (DATA_TYPE)0.00001;

      (void)( (!!((gmtl::Math::isEqual( gmtl::length( from ), (DATA_TYPE)1.0, epsilon ) && gmtl::Math::isEqual( gmtl::length( to ), (DATA_TYPE)1.0, epsilon ) && "input params not normalized"))) || (_wassert(L"(gmtl::Math::isEqual( gmtl::length( from ), (DATA_TYPE)1.0, epsilon ) && gmtl::Math::isEqual( gmtl::length( to ), (DATA_TYPE)1.0, epsilon ) && \"input params not normalized\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 165), 0) );
#line 166 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"

      DATA_TYPE cosangle = dot( from, to );

      
      
      
      if ( Math::isEqual( cosangle, (DATA_TYPE)1.0, epsilon ) )
      {
         return result = DEST_TYPE();
      }

      
      else if ( Math::isEqual( cosangle, (DATA_TYPE)-1.0, epsilon ) )
      {
         Vec<DATA_TYPE, 3> to_rot( to[0] + (DATA_TYPE)0.3, to[1] - (DATA_TYPE)0.15, to[2] - (DATA_TYPE)0.15 ), axis;
         normalize( cross( axis, from, to_rot ) ); 
         DATA_TYPE angle = Math::aCos( cosangle );
         return setRot( result, gmtl::AxisAngle<DATA_TYPE>( angle, axis ) );
      }

      
      
      else
      {
         Vec<DATA_TYPE, 3> axis;
         normalize( cross( axis, from, to ) ); 
         DATA_TYPE angle = Math::aCos( cosangle );
         return setRot( result, gmtl::AxisAngle<DATA_TYPE>( angle, axis ) );
      }
   }

   

   




   


   template <typename DATA_TYPE>
   inline Vec<DATA_TYPE, 3> makeVec( const Quat<DATA_TYPE>& quat )
   {
      return Vec<DATA_TYPE, 3>( quat[Xelt], quat[Yelt], quat[Zelt] );
   }

   

   template <typename DATA_TYPE, unsigned SIZE>
   inline Vec<DATA_TYPE, SIZE> makeNormal( Vec<DATA_TYPE, SIZE> vec )
   {
      normalize( vec );
      return vec;
   }

   








   template<typename VEC_TYPE, typename DATA_TYPE, unsigned ROWS, unsigned COLS >
   inline VEC_TYPE& setTrans( VEC_TYPE& result, const Matrix<DATA_TYPE, ROWS, COLS>& arg )
   {
      

      
      
      (void)( (!!((((ROWS == COLS && ( VEC_TYPE::Size == (ROWS-1) || VEC_TYPE::Size == ROWS)) || (COLS == (ROWS+1) && ( VEC_TYPE::Size == ROWS || VEC_TYPE::Size == (ROWS+1)))) && "preconditions not met for vector size in call to makeTrans.  Read your documentation."))) || (_wassert(L"(((ROWS == COLS && ( VEC_TYPE::Size == (ROWS-1) || VEC_TYPE::Size == ROWS)) || (COLS == (ROWS+1) && ( VEC_TYPE::Size == ROWS || VEC_TYPE::Size == (ROWS+1)))) && \"preconditions not met for vector size in call to makeTrans.  Read your documentation.\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 240), 0) );
#line 241 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"

      
      if ((ROWS == COLS &&  VEC_TYPE::Size == ROWS)              
          || (COLS == (ROWS+1) &&  VEC_TYPE::Size == (ROWS+1)))  
      {
         result[VEC_TYPE::Size-1] = 1.0f;
      }

      
      
      

      for (unsigned x = 0; x < COLS - 1; ++x)
      {
         result[x] = arg( x, COLS - 1 );
      }

      return result;
   }

   

   




   





   template <typename DATA_TYPE>
   inline Quat<DATA_TYPE>& setPure( Quat<DATA_TYPE>& quat, const Vec<DATA_TYPE, 3>& vec )
   {
      quat.set( vec[0], vec[1], vec[2], 0 );
      return quat;
   }

   





   template <typename DATA_TYPE>
   inline Quat<DATA_TYPE> makePure( const Vec<DATA_TYPE, 3>& vec )
   {
      return Quat<DATA_TYPE>( vec[0], vec[1], vec[2], 0 );
   }

   



   template <typename DATA_TYPE>
   inline Quat<DATA_TYPE> makeNormal( const Quat<DATA_TYPE>& quat )
   {
      Quat<DATA_TYPE> temporary( quat );
      return normalize( temporary );
   }

   





   template <typename DATA_TYPE>
   inline Quat<DATA_TYPE> makeConj( const Quat<DATA_TYPE>& quat )
   {
      Quat<DATA_TYPE> temporary( quat );
      return conj( temporary );
   }

   




   template <typename DATA_TYPE>
   inline Quat<DATA_TYPE> makeInvert( const Quat<DATA_TYPE>& quat )
   {
      Quat<DATA_TYPE> temporary( quat );
      return invert( temporary );
   }

   



   template <typename DATA_TYPE>
   inline Quat<DATA_TYPE>& set( Quat<DATA_TYPE>& result, const AxisAngle<DATA_TYPE>& axisAngle )
   {
      (void)( (!!(((Math::isEqual( lengthSquared( axisAngle.getAxis() ), (DATA_TYPE)1.0, (DATA_TYPE)0.0001 )) && "you must pass in a normalized vector to setRot( quat, rad, vec )"))) || (_wassert(L"((Math::isEqual( lengthSquared( axisAngle.getAxis() ), (DATA_TYPE)1.0, (DATA_TYPE)0.0001 )) && \"you must pass in a normalized vector to setRot( quat, rad, vec )\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 337), 0) );
#line 338 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"

      DATA_TYPE half_angle = axisAngle.getAngle() * (DATA_TYPE)0.5;
      DATA_TYPE sin_half_angle = Math::sin( half_angle );

      result[Welt] = Math::cos( half_angle );
      result[Xelt] = sin_half_angle * axisAngle.getAxis()[0];
      result[Yelt] = sin_half_angle * axisAngle.getAxis()[1];
      result[Zelt] = sin_half_angle * axisAngle.getAxis()[2];

      
      return result;
   }

   


   template <typename DATA_TYPE>
   inline Quat<DATA_TYPE>& setRot( Quat<DATA_TYPE>& result, const AxisAngle<DATA_TYPE>& axisAngle )
   {
      return gmtl::set( result, axisAngle );
   }

   



   template <typename DATA_TYPE, typename ROT_ORDER>
   inline Quat<DATA_TYPE>& set( Quat<DATA_TYPE>& result, const EulerAngle<DATA_TYPE, ROT_ORDER>& euler )
   {
      
      const int& order = ROT_ORDER::ID;
      const DATA_TYPE xRot = (order == XYZ::ID) ? euler[0] : ((order == ZXY::ID) ? euler[1] : euler[2]);
      const DATA_TYPE yRot = (order == XYZ::ID) ? euler[1] : ((order == ZXY::ID) ? euler[2] : euler[1]);
      const DATA_TYPE zRot = (order == XYZ::ID) ? euler[2] : ((order == ZXY::ID) ? euler[0] : euler[0]);

      
      Quat<DATA_TYPE> qx, qy, qz;

      
      DATA_TYPE xOver2 = xRot * (DATA_TYPE)0.5;
      DATA_TYPE yOver2 = yRot * (DATA_TYPE)0.5;
      DATA_TYPE zOver2 = zRot * (DATA_TYPE)0.5;

      
      qx[Xelt] = Math::sin( xOver2 );
      qx[Yelt] = (DATA_TYPE)0.0;
      qx[Zelt] = (DATA_TYPE)0.0;
      qx[Welt] = Math::cos( xOver2 );

      
      qy[Xelt] = (DATA_TYPE)0.0;
      qy[Yelt] = Math::sin( yOver2 );
      qy[Zelt] = (DATA_TYPE)0.0;
      qy[Welt] = Math::cos( yOver2 );

      
      qz[Xelt] = (DATA_TYPE)0.0;
      qz[Yelt] = (DATA_TYPE)0.0;
      qz[Zelt] = Math::sin( zOver2 );
      qz[Welt] = Math::cos( zOver2 );

      
      switch (order)
      {
      case XYZ::ID: result = qx * qy * qz; break;
      case ZYX::ID: result = qz * qy * qx; break;
      case ZXY::ID: result = qz * qx * qy; break;
      default:
         (void)( (!!((false && "unknown rotation order passed to setRot"))) || (_wassert(L"(false && \"unknown rotation order passed to setRot\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 406), 0) );
         break;
      }

      
      normalize( result );
      return result;
   }

   


   template <typename DATA_TYPE, typename ROT_ORDER>
   inline Quat<DATA_TYPE>& setRot( Quat<DATA_TYPE>& result, const EulerAngle<DATA_TYPE, ROT_ORDER>& euler )
   {
      return gmtl::set( result, euler );
   }

   



   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Quat<DATA_TYPE>& set( Quat<DATA_TYPE>& quat, const Matrix<DATA_TYPE, ROWS, COLS>& mat  )
   {
      (void)( (!!((((ROWS == 3 && COLS == 3) || (ROWS == 3 && COLS == 4) || (ROWS == 4 && COLS == 3) || (ROWS == 4 && COLS == 4)) && "pre conditions not met on set( quat, pos, mat ) which only sets a quaternion to the rotation part of a 3x3, 3x4, 4x3, or 4x4 matrix."))) || (_wassert(L"(((ROWS == 3 && COLS == 3) || (ROWS == 3 && COLS == 4) || (ROWS == 4 && COLS == 3) || (ROWS == 4 && COLS == 4)) && \"pre conditions not met on set( quat, pos, mat ) which only sets a quaternion to the rotation part of a 3x3, 3x4, 4x3, or 4x4 matrix.\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 435), 0) );
#line 436 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"

      DATA_TYPE tr( mat( 0, 0 ) + mat( 1, 1 ) + mat( 2, 2 ) ), s( 0.0f );

      
      if (tr > (DATA_TYPE)0.0)
      {
         s = Math::sqrt( tr + (DATA_TYPE)1.0 );
         quat[Welt] = s * (DATA_TYPE)0.5;
         s = DATA_TYPE(0.5) / s;

         quat[Xelt] = (mat( 2, 1 ) - mat( 1, 2 )) * s;
         quat[Yelt] = (mat( 0, 2 ) - mat( 2, 0 )) * s;
         quat[Zelt] = (mat( 1, 0 ) - mat( 0, 1 )) * s;
      }

      
      else
      {
         static const unsigned int nxt[3] = { 1, 2, 0 };
         unsigned int i( Xelt ), j, k;

         if (mat( 1, 1 ) > mat( 0, 0 ))
            i = 1;

         if (mat( 2, 2 ) > mat( i, i ))
            i = 2;

         j = nxt[i];
         k = nxt[j];

         s = Math::sqrt( (mat( i, i )-(mat( j, j )+mat( k, k ))) + (DATA_TYPE)1.0 );

         DATA_TYPE q[4];
         q[i] = s * (DATA_TYPE)0.5;

         if (s != (DATA_TYPE)0.0)
            s = DATA_TYPE(0.5) / s;

         q[3] = (mat( k, j ) - mat( j, k )) * s;
         q[j] = (mat( j, i ) + mat( i, j )) * s;
         q[k] = (mat( k, i ) + mat( i, k )) * s;

         quat[Xelt] = q[0];
         quat[Yelt] = q[1];
         quat[Zelt] = q[2];
         quat[Welt] = q[3];
      }

      return quat;
   }

   


   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   inline Quat<DATA_TYPE>& setRot( Quat<DATA_TYPE>& result, const Matrix<DATA_TYPE, ROWS, COLS>& mat )
   {
      return gmtl::set( result, mat );
   }
   

   




   









   template <typename DATA_TYPE>
   inline AxisAngle<DATA_TYPE>& set( AxisAngle<DATA_TYPE>& axisAngle, Quat<DATA_TYPE> quat )
   {
      
      if (Math::abs( quat[Welt] ) > (DATA_TYPE)1.0)
      {
         gmtl::normalize( quat );
      }
      (void)( (!!((Math::abs( quat[Welt] ) <= (DATA_TYPE)1.0 && "acos returns NaN when quat[Welt] > 1, try normalizing your quat."))) || (_wassert(L"(Math::abs( quat[Welt] ) <= (DATA_TYPE)1.0 && \"acos returns NaN when quat[Welt] > 1, try normalizing your quat.\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 520), 0) );

      

      
      DATA_TYPE rad = Math::aCos( quat[Welt] ) * (DATA_TYPE)2.0;
      axisAngle.setAngle( rad );

      
      DATA_TYPE sin_half_angle = Math::sin( rad * (DATA_TYPE)0.5 );
      if (sin_half_angle >= (DATA_TYPE)0.0001) 
      {
         DATA_TYPE sin_half_angle_inv = DATA_TYPE(1.0) / sin_half_angle;
         Vec3f axis( quat[Xelt] * sin_half_angle_inv,
                     quat[Yelt] * sin_half_angle_inv,
                     quat[Zelt] * sin_half_angle_inv );
         normalize( axis );
         axisAngle.setAxis( axis );
      }

      
      else
      {
         
         
         
         axisAngle.setAxis( gmtl::Vec3f(
                             DATA_TYPE( 1.0 ) ,
                            (DATA_TYPE)0.0,
                            (DATA_TYPE)0.0 ) );
      }
      return axisAngle;
   }

   


   template <typename DATA_TYPE>
   inline AxisAngle<DATA_TYPE>& setRot( AxisAngle<DATA_TYPE>& result, Quat<DATA_TYPE> quat )
   {
      return gmtl::set( result, quat );
   }

   
   template <typename DATA_TYPE>
   AxisAngle<DATA_TYPE> makeNormal( const AxisAngle<DATA_TYPE>& a )
   {
      return AxisAngle<DATA_TYPE>( a.getAngle(), makeNormal( a.getAxis() ) );
   }
   

   




   









   template< typename DATA_TYPE, unsigned ROWS, unsigned COLS, typename ROT_ORDER >
   inline EulerAngle<DATA_TYPE, ROT_ORDER>& set( EulerAngle<DATA_TYPE, ROT_ORDER>& euler,
                    const Matrix<DATA_TYPE, ROWS, COLS>& mat )
   {
      
      (void)( (!!((ROWS >= 3 && COLS >= 3 && ROWS <= 4 && COLS <= 4 && "this is undefined for Matrix smaller than 3x3 or bigger than 4x4"))) || (_wassert(L"(ROWS >= 3 && COLS >= 3 && ROWS <= 4 && COLS <= 4 && \"this is undefined for Matrix smaller than 3x3 or bigger than 4x4\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 592), 0) );
#line 593 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"

      DATA_TYPE sx;
      DATA_TYPE cz;

      
      const int& order = ROT_ORDER::ID;
      switch (order)
      {
      case XYZ::ID:
         {
            euler[2] = Math::aTan2( -mat(0,1), mat(0,0) );       
            euler[0] = Math::aTan2( -mat(1,2), mat(2,2) );       
            cz = Math::cos( euler[2] );
            euler[1] = Math::aTan2( mat(0,2), mat(0,0) / cz );   
         }
         break;
      case ZYX::ID:
         {
            euler[0] = Math::aTan2( mat(1,0), mat(0,0) );        
            euler[2] = Math::aTan2( mat(2,1), mat(2,2) );        
            sx = Math::sin( euler[2] );
            euler[1] = Math::aTan2( -mat(2,0), mat(2,1) / sx );  
         }
         break;
      case ZXY::ID:
         {
            
            DATA_TYPE x_angle;
            DATA_TYPE y_angle;
            DATA_TYPE z_angle;
            DATA_TYPE cos_y, sin_y;
            DATA_TYPE cos_x, sin_x;
            DATA_TYPE cos_z, sin_z;

            sin_x = mat(2,1);
            x_angle = Math::aSin( sin_x );     
            cos_x = Math::cos( x_angle );

            
            if (cos_x != 0.0f)     
            {
                  
               cos_y = mat(2,2) / cos_x;
               sin_y = -mat(2,0) / cos_x;
               y_angle = Math::aTan2( cos_y, sin_y );

                  
               cos_z = mat(1,1) / cos_x;
               sin_z = -mat(0,1) / cos_x;
               z_angle = Math::aTan2( cos_z, sin_z );
            }
            else
            {
               
               z_angle = 0;

                  
               cos_y = mat(0,0);
               sin_y = mat(1,0);
               y_angle = Math::aTan2( cos_y, sin_y );
            }

            euler[1] = x_angle;
            euler[2] = y_angle;
            euler[0] = z_angle;
         }
         break;
      default:
         (void)( (!!((false && "unknown rotation order passed to setRot"))) || (_wassert(L"(false && \"unknown rotation order passed to setRot\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 661), 0) );
         break;
      }
      return euler;
   }

   


   template< typename DATA_TYPE, unsigned ROWS, unsigned COLS, typename ROT_ORDER >
   inline EulerAngle<DATA_TYPE, ROT_ORDER>& setRot( EulerAngle<DATA_TYPE, ROT_ORDER>& result, const Matrix<DATA_TYPE, ROWS, COLS>& mat )
   {
      return gmtl::set( result, mat );
   }
   

   




   








   template< typename DATA_TYPE, unsigned ROWS, unsigned COLS, unsigned SIZE >
   inline Matrix<DATA_TYPE, ROWS, COLS>& setTrans( Matrix<DATA_TYPE, ROWS, COLS>& result,
                                                   const Vec<DATA_TYPE, SIZE>& trans )
   {
      
      
      
      (void)( (!!((((ROWS == COLS && (SIZE == (ROWS-1) || SIZE == ROWS)) || (COLS == (ROWS+1) && (SIZE == ROWS || SIZE == (ROWS+1)))) && "preconditions not met for vector size in call to makeTrans.  Read your documentation."))) || (_wassert(L"(((ROWS == COLS && (SIZE == (ROWS-1) || SIZE == ROWS)) || (COLS == (ROWS+1) && (SIZE == ROWS || SIZE == (ROWS+1)))) && \"preconditions not met for vector size in call to makeTrans.  Read your documentation.\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 700), 0) );
#line 701 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"

      
      if ((ROWS == COLS && SIZE == ROWS) 
          || (COLS == (ROWS+1) && SIZE == (ROWS+1)))  
      {
         for (unsigned x = 0; x < COLS - 1; ++x)
            result( x, COLS - 1 ) = trans[x] / trans[SIZE-1];
      }

      
      else
      {
         for (unsigned x = 0; x < COLS - 1; ++x)
            result( x, COLS - 1 ) = trans[x];
      }
      return result;
   }

   

   template< typename DATA_TYPE, unsigned ROWS, unsigned COLS, unsigned SIZE >
   inline Matrix<DATA_TYPE, ROWS, COLS>& setScale( Matrix<DATA_TYPE, ROWS, COLS>& result, const Vec<DATA_TYPE, SIZE>& scale )
   {
      (void)( (!!((((SIZE == (ROWS-1) && SIZE == (COLS-1)) || (SIZE == (ROWS-1) && SIZE == COLS) || (SIZE == (COLS-1) && SIZE == ROWS)) && "the scale params must fit within the matrix, check your sizes."))) || (_wassert(L"(((SIZE == (ROWS-1) && SIZE == (COLS-1)) || (SIZE == (ROWS-1) && SIZE == COLS) || (SIZE == (COLS-1) && SIZE == ROWS)) && \"the scale params must fit within the matrix, check your sizes.\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 724), 0) );
      for (unsigned x = 0; x < SIZE; ++x)
         result( x, x ) = scale[x];
      return result;
   }

   

   template <typename MATRIX_TYPE, unsigned SIZE>
   inline MATRIX_TYPE makeScale( const Vec<typename MATRIX_TYPE::DataType, SIZE>& scale,
                               Type2Type< MATRIX_TYPE > t = Type2Type< MATRIX_TYPE >() )
   {
      gmtl::ignore_unused_variable_warning(t);
      MATRIX_TYPE temporary;
      return setScale( temporary, scale );
   }



   

   template< typename DATA_TYPE, unsigned ROWS, unsigned COLS >
   inline Matrix<DATA_TYPE, ROWS, COLS>& setScale( Matrix<DATA_TYPE, ROWS, COLS>& result, const DATA_TYPE scale )
   {
      for (unsigned x = 0; x < Math::Min( ROWS, COLS, Math::Max( ROWS, COLS ) - 1 ); ++x) 
         result( x, x ) = scale;
      return result;
   }

   

   template <typename MATRIX_TYPE>
   inline MATRIX_TYPE makeScale( const typename MATRIX_TYPE::DataType scale,
                               Type2Type< MATRIX_TYPE > t = Type2Type< MATRIX_TYPE >() )
   {
      gmtl::ignore_unused_variable_warning(t);
      MATRIX_TYPE temporary;
      return setScale( temporary, scale );
   }



   




   template< typename DATA_TYPE, unsigned ROWS, unsigned COLS >
   inline Matrix<DATA_TYPE, ROWS, COLS>& setRot( Matrix<DATA_TYPE, ROWS, COLS>& result, const AxisAngle<DATA_TYPE>& axisAngle )
   {
      
      (void)( (!!((ROWS >= 3 && COLS >= 3 && ROWS <= 4 && COLS <= 4 && "this func is undefined for Matrix smaller than 3x3 or bigger than 4x4"))) || (_wassert(L"(ROWS >= 3 && COLS >= 3 && ROWS <= 4 && COLS <= 4 && \"this func is undefined for Matrix smaller than 3x3 or bigger than 4x4\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 776), 0) );
#line 777 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"
      (void)( (!!((Math::isEqual( lengthSquared( axisAngle.getAxis() ), (DATA_TYPE)1.0, (DATA_TYPE)0.001 ) && "you must pass in a normalized vector to setRot( mat, rad, vec )"))) || (_wassert(L"(Math::isEqual( lengthSquared( axisAngle.getAxis() ), (DATA_TYPE)1.0, (DATA_TYPE)0.001 ) && \"you must pass in a normalized vector to setRot( mat, rad, vec )\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 778), 0) );
#line 779 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"

      
      DATA_TYPE s = Math::sin( axisAngle.getAngle() );
      DATA_TYPE c = Math::cos( axisAngle.getAngle() );
      DATA_TYPE t = DATA_TYPE( 1.0 ) - c;
      DATA_TYPE x = axisAngle.getAxis()[0];
      DATA_TYPE y = axisAngle.getAxis()[1];
      DATA_TYPE z = axisAngle.getAxis()[2];

      
      result( 0, 0 ) = (t*x*x)+c;     result( 0, 1 ) = (t*x*y)-(s*z); result( 0, 2 ) = (t*x*z)+(s*y);
      result( 1, 0 ) = (t*x*y)+(s*z); result( 1, 1 ) = (t*y*y)+c;     result( 1, 2 ) = (t*y*z)-(s*x);
      result( 2, 0 ) = (t*x*z)-(s*y); result( 2, 1 ) = (t*y*z)+(s*x); result( 2, 2 ) = (t*z*z)+c;

      return result;
   }


   



   template< typename DATA_TYPE, unsigned ROWS, unsigned COLS >
   inline Matrix<DATA_TYPE, ROWS, COLS>& set( Matrix<DATA_TYPE, ROWS, COLS>& result, const AxisAngle<DATA_TYPE>& axisAngle )
   {
      gmtl::identity( result );
      return setRot( result, axisAngle );
   }

   



   template< typename DATA_TYPE, unsigned ROWS, unsigned COLS, typename ROT_ORDER >
   inline Matrix<DATA_TYPE, ROWS, COLS>& setRot( Matrix<DATA_TYPE, ROWS, COLS>& result, const EulerAngle<DATA_TYPE, ROT_ORDER>& euler )
   {
      
      (void)( (!!((ROWS >= 3 && COLS >= 3 && ROWS <= 4 && COLS <= 4 && "this is undefined for Matrix smaller than 3x3 or bigger than 4x4"))) || (_wassert(L"(ROWS >= 3 && COLS >= 3 && ROWS <= 4 && COLS <= 4 && \"this is undefined for Matrix smaller than 3x3 or bigger than 4x4\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 816), 0) );

      
      const int& order = ROT_ORDER::ID;
      const float xRot = (order == XYZ::ID) ? euler[0] : ((order == ZXY::ID) ? euler[1] : euler[2]);
      const float yRot = (order == XYZ::ID) ? euler[1] : ((order == ZXY::ID) ? euler[2] : euler[1]);
      const float zRot = (order == XYZ::ID) ? euler[2] : ((order == ZXY::ID) ? euler[0] : euler[0]);

      float sx = Math::sin( xRot );  float cx = Math::cos( xRot );
      float sy = Math::sin( yRot );  float cy = Math::cos( yRot );
      float sz = Math::sin( zRot );  float cz = Math::cos( zRot );

      
      switch (order)
      {
      case XYZ::ID:
         
         result( 0, 0 ) = cy*cz;             result( 0, 1 ) = -cy*sz;            result( 0, 2 ) = sy;
         result( 1, 0 ) = sx*sy*cz + cx*sz;  result( 1, 1 ) = -sx*sy*sz + cx*cz; result( 1, 2 ) = -sx*cy;
         result( 2, 0 ) = -cx*sy*cz + sx*sz; result( 2, 1 ) = cx*sy*sz + sx*cz;  result( 2, 2 ) = cx*cy;
         break;
      case ZYX::ID:
         
         result( 0, 0 ) = cy*cz; result( 0, 1 ) = -cx*sz + sx*sy*cz; result( 0, 2 ) = sx*sz + cx*sy*cz;
         result( 1, 0 ) = cy*sz; result( 1, 1 ) = cx*cz + sx*sy*sz;  result( 1, 2 ) = -sx*cz + cx*sy*sz;
         result( 2, 0 ) = -sy;   result( 2, 1 ) = sx*cy;             result( 2, 2 ) = cx*cy;
         break;
      case ZXY::ID:
         
         result( 0, 0 ) = cy*cz - sx*sy*sz; result( 0, 1 ) = -cx*sz; result( 0, 2 ) = sy*cz + sx*cy*sz;
         result( 1, 0 ) = cy*sz + sx*sy*cz; result( 1, 1 ) = cx*cz;  result( 1, 2 ) = sy*sz - sx*cy*cz;
         result( 2, 0 ) = -cx*sy;           result( 2, 1 ) = sx;     result( 2, 2 ) = cx*cy;
         break;
      default:
         (void)( (!!((false && "unknown rotation order passed to setRot"))) || (_wassert(L"(false && \"unknown rotation order passed to setRot\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 850), 0) );
         break;
      }

      return result;
   }

   


   template< typename DATA_TYPE, unsigned ROWS, unsigned COLS, typename ROT_ORDER >
   inline Matrix<DATA_TYPE, ROWS, COLS>& set( Matrix<DATA_TYPE, ROWS, COLS>& result, const EulerAngle<DATA_TYPE, ROT_ORDER>& euler )
   {
      gmtl::identity( result );
      return setRot( result, euler );
   }

   



   template< typename DATA_TYPE, unsigned ROWS, unsigned COLS >
   inline float makeYRot( const Matrix<DATA_TYPE, ROWS, COLS>& mat )
   {
      const gmtl::Vec3f forward_point(0.0f, 0.0f, -1.0f);   
      const gmtl::Vec3f origin_point(0.0f, 0.0f, 0.0f);
      gmtl::Vec3f end_point, start_point;

      gmtl::xform(end_point, mat, forward_point);
      gmtl::xform(start_point, mat, origin_point);
      gmtl::Vec3f direction_vector = end_point - start_point;

      
      direction_vector[1] = 0.0f;                  
      gmtl::normalize(direction_vector);
      float y_rot = gmtl::Math::aCos(gmtl::dot(direction_vector,
                                               forward_point));

      gmtl::Vec3f which_side; gmtl::cross(which_side,forward_point, direction_vector);

      
      if ( which_side[1] < 0.0f )
      {
         y_rot = -y_rot;
      }

      return y_rot;
   }

   



   template< typename DATA_TYPE, unsigned ROWS, unsigned COLS >
   inline float makeXRot( const Matrix<DATA_TYPE, ROWS, COLS>& mat )
   {
      const gmtl::Vec3f forward_point(0.0f, 0.0f, -1.0f);   
      const gmtl::Vec3f origin_point(0.0f, 0.0f, 0.0f);
      gmtl::Vec3f end_point, start_point;

      gmtl::xform(end_point, mat, forward_point);
      gmtl::xform(start_point, mat, origin_point);
      gmtl::Vec3f direction_vector = end_point - start_point;

      
      direction_vector[0] = 0.0f;                  
      gmtl::normalize(direction_vector);
      float x_rot = gmtl::Math::aCos(gmtl::dot(direction_vector,
                                               forward_point));

      gmtl::Vec3f which_side; gmtl::cross(which_side,forward_point, direction_vector);

      
      if ( which_side[0] < 0.0f )
      {
         x_rot = -x_rot;
      }

      return x_rot;
   }

   



   template< typename DATA_TYPE, unsigned ROWS, unsigned COLS >
   inline float makeZRot( const Matrix<DATA_TYPE, ROWS, COLS>& mat )
   {
      const gmtl::Vec3f forward_point(0.0f, 0.0f, -1.0f);   
      const gmtl::Vec3f origin_point(0.0f, 0.0f, 0.0f);
      gmtl::Vec3f end_point, start_point;

      gmtl::xform(end_point, mat, forward_point);
      gmtl::xform(start_point, mat, origin_point);
      gmtl::Vec3f direction_vector = end_point - start_point;

      
      direction_vector[2] = 0.0f;                  
      gmtl::normalize(direction_vector);
      float z_rot = gmtl::Math::aCos(gmtl::dot(direction_vector,
                                               forward_point));

      gmtl::Vec3f which_side; gmtl::cross(which_side,forward_point, direction_vector);

      
      if ( which_side[2] < 0.0f )
      {
         z_rot = -z_rot;
      }

      return z_rot;
   }

   









   template< typename DATA_TYPE, unsigned ROWS, unsigned COLS >
   inline Matrix<DATA_TYPE, ROWS, COLS>& setDirCos( Matrix<DATA_TYPE, ROWS, COLS>& result,
                                                     const Vec<DATA_TYPE, 3>& xDestAxis,
                                                     const Vec<DATA_TYPE, 3>& yDestAxis, const Vec<DATA_TYPE, 3>& zDestAxis,
                                                     const Vec<DATA_TYPE, 3>& xSrcAxis = Vec<DATA_TYPE, 3>(1,0,0),
                                                     const Vec<DATA_TYPE, 3>& ySrcAxis = Vec<DATA_TYPE, 3>(0,1,0),
                                                     const Vec<DATA_TYPE, 3>& zSrcAxis = Vec<DATA_TYPE, 3>(0,0,1) )
   {
      
      (void)( (!!((ROWS >= 3 && COLS >= 3 && ROWS <= 4 && COLS <= 4 && "this is undefined for Matrix smaller than 3x3 or bigger than 4x4"))) || (_wassert(L"(ROWS >= 3 && COLS >= 3 && ROWS <= 4 && COLS <= 4 && \"this is undefined for Matrix smaller than 3x3 or bigger than 4x4\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 982), 0) );

      DATA_TYPE Xa, Xb, Xc;    
      DATA_TYPE Ya, Yb, Yc;    
      DATA_TYPE Za, Zb, Zc;    

      Xa = dot(xDestAxis, xSrcAxis);  Xb = dot(xDestAxis, ySrcAxis);  Xc = dot(xDestAxis, zSrcAxis);
      Ya = dot(yDestAxis, xSrcAxis);  Yb = dot(yDestAxis, ySrcAxis);  Yc = dot(yDestAxis, zSrcAxis);
      Za = dot(zDestAxis, xSrcAxis);  Zb = dot(zDestAxis, ySrcAxis);  Zc = dot(zDestAxis, zSrcAxis);

      
      result( 0, 0 ) = Xa; result( 0, 1 ) = Ya; result( 0, 2 ) = Za;
      result( 1, 0 ) = Xb; result( 1, 1 ) = Yb; result( 1, 2 ) = Zb;
      result( 2, 0 ) = Xc; result( 2, 1 ) = Yc; result( 2, 2 ) = Zc;

      return result;
   }

   



   template< typename DATA_TYPE, unsigned ROWS, unsigned COLS >
   inline Matrix<DATA_TYPE, ROWS, COLS>& setAxes( Matrix<DATA_TYPE, ROWS, COLS>& result,
                                                  const Vec<DATA_TYPE, 3>& xAxis,
                                                  const Vec<DATA_TYPE, 3>& yAxis,
                                                  const Vec<DATA_TYPE, 3>& zAxis )
   {
      
      (void)( (!!((ROWS >= 3 && COLS >= 3 && ROWS <= 4 && COLS <= 4 && "this is undefined for Matrix smaller than 3x3 or bigger than 4x4"))) || (_wassert(L"(ROWS >= 3 && COLS >= 3 && ROWS <= 4 && COLS <= 4 && \"this is undefined for Matrix smaller than 3x3 or bigger than 4x4\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 1011), 0) );

      result( 0, 0 ) = xAxis[0];
      result( 1, 0 ) = xAxis[1];
      result( 2, 0 ) = xAxis[2];

      result( 0, 1 ) = yAxis[0];
      result( 1, 1 ) = yAxis[1];
      result( 2, 1 ) = yAxis[2];

      result( 0, 2 ) = zAxis[0];
      result( 1, 2 ) = zAxis[1];
      result( 2, 2 ) = zAxis[2];

      return result;
   }

   



   template< typename ROTATION_TYPE >
   inline ROTATION_TYPE makeAxes( const Vec<typename ROTATION_TYPE::DataType, 3>& xAxis,
                                  const Vec<typename ROTATION_TYPE::DataType, 3>& yAxis,
                                  const Vec<typename ROTATION_TYPE::DataType, 3>& zAxis,
                                  Type2Type< ROTATION_TYPE > t = Type2Type< ROTATION_TYPE >() )
   {
      gmtl::ignore_unused_variable_warning(t);
      ROTATION_TYPE temporary;
      return setAxes( temporary, xAxis, yAxis, zAxis );
   }

   



   template < typename DATA_TYPE, unsigned ROWS, unsigned COLS >
   inline Matrix<DATA_TYPE, ROWS, COLS> makeTranspose( const Matrix<DATA_TYPE, ROWS, COLS>& m )
   {
      Matrix<DATA_TYPE, ROWS, COLS> temporary( m );
      return transpose( temporary );
   }

   






   template< typename DATA_TYPE, unsigned ROWS, unsigned COLS >
   inline Matrix<DATA_TYPE, ROWS, COLS> makeInverse( const Matrix<DATA_TYPE, ROWS, COLS> src,
        Type2Type< Matrix<DATA_TYPE, ROWS, COLS> > t = Type2Type< Matrix< DATA_TYPE, ROWS, COLS > >() )
   {
      Matrix<DATA_TYPE, ROWS, COLS> result;
      return invert( result, src );
   }

   



   template <typename DATATYPE, typename POS_TYPE, typename ROT_TYPE, unsigned MATCOLS, unsigned MATROWS >
   inline Matrix<DATATYPE, MATROWS, MATCOLS>& set( Matrix<DATATYPE, MATROWS, MATCOLS>& mat,
                                                   const Coord<POS_TYPE, ROT_TYPE>& coord )
   {
      
      gmtl::identity( mat );

      
      
      if (MATCOLS == 4)
      {
         setTrans( mat, coord.getPos() );
      }
      setRot( mat, coord.getRot() ); 
      return mat;
   }

   


   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   Matrix<DATA_TYPE, ROWS, COLS>& setRot( Matrix<DATA_TYPE, ROWS, COLS>& mat, const Quat<DATA_TYPE>& q )
   {
      (void)( (!!((((ROWS == 3 && COLS == 3) || (ROWS == 3 && COLS == 4) || (ROWS == 4 && COLS == 3) || (ROWS == 4 && COLS == 4)) && "pre conditions not met on set( mat, quat ) which only sets a quaternion to the rotation part of a 3x3, 3x4, 4x3, or 4x4 matrix."))) || (_wassert(L"(((ROWS == 3 && COLS == 3) || (ROWS == 3 && COLS == 4) || (ROWS == 4 && COLS == 3) || (ROWS == 4 && COLS == 4)) && \"pre conditions not met on set( mat, quat ) which only sets a quaternion to the rotation part of a 3x3, 3x4, 4x3, or 4x4 matrix.\")", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h", 1100), 0) );
#line 1101 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"

      
      DATA_TYPE wx, wy, wz, xx, yy, yz, xy, xz, zz, xs, ys, zs;

      xs = q[Xelt] + q[Xelt]; ys = q[Yelt] + q[Yelt]; zs = q[Zelt] + q[Zelt];
      xx = q[Xelt] * xs;      xy = q[Xelt] * ys;      xz = q[Xelt] * zs;
      yy = q[Yelt] * ys;      yz = q[Yelt] * zs;      zz = q[Zelt] * zs;
      wx = q[Welt] * xs;      wy = q[Welt] * ys;      wz = q[Welt] * zs;

      mat( 0, 0 ) = DATA_TYPE(1.0) - (yy + zz);
      mat( 1, 0 ) = xy + wz;
      mat( 2, 0 ) = xz - wy;

      mat( 0, 1 ) = xy - wz;
      mat( 1, 1 ) = DATA_TYPE(1.0) - (xx + zz);
      mat( 2, 1 ) = yz + wx;

      mat( 0, 2 ) = xz + wy;
      mat( 1, 2 ) = yz - wx;
      mat( 2, 2 ) = DATA_TYPE(1.0) - (xx + yy);

      return mat;
   }

   




   template <typename DATA_TYPE, unsigned ROWS, unsigned COLS>
   Matrix<DATA_TYPE, ROWS, COLS>& set( Matrix<DATA_TYPE, ROWS, COLS>& mat, const Quat<DATA_TYPE>& q )
   {
      setRot( mat, q );

      if (ROWS == 4)
      {
         mat( 3, 0 ) = DATA_TYPE(0.0);
         mat( 3, 1 ) = DATA_TYPE(0.0);
         mat( 3, 2 ) = DATA_TYPE(0.0);
      }

      if (COLS == 4)
      {
         mat( 0, 3 ) = DATA_TYPE(0.0);
         mat( 1, 3 ) = DATA_TYPE(0.0);
         mat( 2, 3 ) = DATA_TYPE(0.0);
      }

      if (ROWS == 4 && COLS == 4)
         mat( 3, 3 ) = DATA_TYPE(1.0);

      return mat;
   }

   

   




   
   template <typename DATATYPE, typename POS_TYPE, typename ROT_TYPE, unsigned MATCOLS, unsigned MATROWS >
   inline Coord<POS_TYPE, ROT_TYPE>& set( Coord<POS_TYPE, ROT_TYPE>& eulercoord, const Matrix<DATATYPE, MATROWS, MATCOLS>& mat )
   {
      gmtl::setTrans( eulercoord.pos(), mat );
      gmtl::set( eulercoord.rot(), mat );
      return eulercoord;
   }

   


   template <typename DATATYPE, typename POS_TYPE, typename ROT_TYPE, unsigned MATCOLS, unsigned MATROWS >
   inline Coord<POS_TYPE, ROT_TYPE>& setRot( Coord<POS_TYPE, ROT_TYPE>& result, const Matrix<DATATYPE, MATROWS, MATCOLS>& mat )
   {
      return gmtl::set( result, mat );
   }

   

} 

#line 1185 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Generate.h"

#line 26 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Intersection.h"






































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AABox.h"








































































































































































#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Intersection.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Point.h"






































































































































#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Intersection.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Sphere.h"












































































































































#line 42 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Intersection.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h"






































































































































#line 43 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Intersection.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Plane.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h"






































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Plane.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Point.h"






































































































































#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Plane.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecOps.h"
























































































































































































































































































































































































































































































































































#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Plane.h"

namespace gmtl
{




















template< class DATA_TYPE>
class Plane
{
public:
   



   Plane()
      : mOffset( 0 )
   {}

   






   Plane( const Point<DATA_TYPE, 3>& pt1, const Point<DATA_TYPE, 3>& pt2,
          const Point<DATA_TYPE, 3>& pt3)
   {
      Vec<DATA_TYPE, 3> vec12( pt2-pt1 );
      Vec<DATA_TYPE, 3> vec13( pt3-pt1 );

      mNorm = cross( vec12, vec13 );
      normalize( mNorm );

      mOffset = dot( static_cast< Vec<DATA_TYPE, 3> >(pt1), mNorm );  
   }

   





   Plane( const Vec<DATA_TYPE, 3>& norm, const Point<DATA_TYPE, 3>& pt )
      : mNorm( norm )
   {
      mOffset = dot( static_cast< Vec<DATA_TYPE, 3> >(pt), norm );
   }

   





   Plane( const Vec<DATA_TYPE, 3>& norm, const DATA_TYPE& dPlaneConst )
      : mNorm( norm ), mOffset( dPlaneConst )
   {}

   




   Plane( const Plane<DATA_TYPE>& plane )
      : mNorm( plane.mNorm ), mOffset( plane.mOffset )
   {}

   




   const Vec<DATA_TYPE, 3>& getNormal() const
   {
      return mNorm;
   }

   






   void setNormal( const Vec<DATA_TYPE, 3>& norm )
   {
      mNorm = norm;
   }

   





   const DATA_TYPE& getOffset() const
   {
      return mOffset;
   }

   




   void setOffset( const DATA_TYPE& offset )
   {
      mOffset = offset;
   }

public:
   
   



   Vec<DATA_TYPE, 3> mNorm;

   




   DATA_TYPE mOffset;
};

typedef Plane<float> Planef;
typedef Plane<double> Planed;



































































} 
#line 256 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Plane.h"
#line 44 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Intersection.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecOps.h"
























































































































































































































































































































































































































































































































































#line 45 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Intersection.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"






















































































































































































































































































































































































































































































































































































#line 46 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Intersection.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Ray.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Point.h"






































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Ray.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h"






































































































































#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Ray.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecOps.h"
























































































































































































































































































































































































































































































































































#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Ray.h"

namespace gmtl {











template< class DATA_TYPE >
class Ray
{
public:
   


   Ray()
   {}

   






   Ray( const Point<DATA_TYPE, 3>& origin, const Vec<DATA_TYPE, 3>& dir )
      : mOrigin( origin ), mDir( dir )
   {}

   

   




   Ray( const Ray& lineseg )
   {
      mOrigin = lineseg.mOrigin;
      mDir = lineseg.mDir;
   }

   




   const Point<DATA_TYPE, 3>& getOrigin() const
   {
      return mOrigin;
   }

   




   void setOrigin( const Point<DATA_TYPE, 3>& origin )
   {
      mOrigin = origin;
   }

   




   const Vec<DATA_TYPE, 3>& getDir() const
   {
      return mDir;
   }

   




   void setDir( const Vec<DATA_TYPE, 3>& dir )
   {
      mDir = dir;
   }

public:
   


   Point<DATA_TYPE, 3> mOrigin;

   


   Vec<DATA_TYPE, 3> mDir;
};



typedef Ray<float>  Rayf;
typedef Ray<double> Rayd;
}

#line 147 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Ray.h"
#line 47 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Intersection.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_LineSeg.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Point.h"






































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_LineSeg.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h"






































































































































#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_LineSeg.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecOps.h"
























































































































































































































































































































































































































































































































































#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_LineSeg.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Ray.h"


















































































































































#line 42 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_LineSeg.h"

namespace gmtl {












template <typename DATA_TYPE>
class LineSeg : public Ray<DATA_TYPE>
{
public:
   


   LineSeg()
   {}

   






   LineSeg( const Point<DATA_TYPE, 3>& origin, const Vec<DATA_TYPE, 3>& dir )
      : Ray<DATA_TYPE>( origin, dir )
   {}

   




   LineSeg( const LineSeg& ray ) : Ray<DATA_TYPE>( ray )
   {
   }

   





   LineSeg( const Point<DATA_TYPE, 3>& beg, const Point<DATA_TYPE, 3>& end )
      : Ray<DATA_TYPE>()
   {
      this->mOrigin = beg;
      this->mDir = end - beg;
   }

   



   DATA_TYPE getLength() const
   {
      return length(this->mDir);
   }
};



typedef LineSeg<float>  LineSegf;
typedef LineSeg<double> LineSegd;
}

#line 116 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_LineSeg.h"
#line 48 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Intersection.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Tri.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Point.h"






































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Tri.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h"






































































































































#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Tri.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecOps.h"
























































































































































































































































































































































































































































































































































#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Tri.h"
 
namespace gmtl
{







template< class DATA_TYPE >
class  Tri
{
public:
   


   Tri() {}

   









   Tri( const Point<DATA_TYPE, 3>& p1, const Point<DATA_TYPE, 3>& p2,
        const Point<DATA_TYPE, 3>& p3)
   {
      mVerts[0] = p1;
      mVerts[1] = p2;
      mVerts[2] = p3;
   }

   




   Tri( const Tri<DATA_TYPE>& tri )
   {
      mVerts[0] = tri[0];
      mVerts[1] = tri[1];
      mVerts[2] = tri[2];
   }

   







   
   Point<DATA_TYPE, 3>& operator[]( int idx )
   {
      (void)( (!!(((0 <= idx) && (idx <= 2)))) || (_wassert(L"((0 <= idx) && (idx <= 2))", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Tri.h", 101), 0) );
      return mVerts[idx];
   }
   const Point<DATA_TYPE, 3>& operator[]( int idx ) const
   {
      (void)( (!!(((0 <= idx) && (idx <= 2)))) || (_wassert(L"((0 <= idx) && (idx <= 2))", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Tri.h", 106), 0) );
      return mVerts[idx];
   }
   

   









   Vec<DATA_TYPE, 3> edge( int idx ) const
   {
      (void)( (!!(((0 <= idx) && (idx <= 2)))) || (_wassert(L"((0 <= idx) && (idx <= 2))", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Tri.h", 123), 0) );
      int idx2 = ( idx == 2 ) ? 0 : idx + 1;
      return (mVerts[idx2] - mVerts[idx]);
   }

   









   void set( const Point<DATA_TYPE, 3>& p1, const Point<DATA_TYPE, 3>& p2,
           const Point<DATA_TYPE, 3>& p3 )
   {
      mVerts[0] = p1;
      mVerts[1] = p2;
      mVerts[2] = p3;
   }

private:
   


   Point<DATA_TYPE, 3> mVerts[3];
};


typedef Tri<float> Trif;
typedef Tri<double> Trid;
typedef Tri<int> Trii;
}




































































































#line 259 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Tri.h"

#line 49 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Intersection.h"

namespace gmtl
{
   








   template<class DATA_TYPE>
   bool intersect(const AABox<DATA_TYPE>& box1, const AABox<DATA_TYPE>& box2)
   {
      
      if (box1.getMin()[0] > box2.getMax()[0])  return false;
      if (box1.getMin()[1] > box2.getMax()[1])  return false;
      if (box1.getMin()[2] > box2.getMax()[2])  return false;

      if (box2.getMin()[0] > box1.getMax()[0])  return false;
      if (box2.getMin()[1] > box1.getMax()[1])  return false;
      if (box2.getMin()[2] > box1.getMax()[2])  return false;

      
      return true;
   }
   
   








   template<class DATA_TYPE>
   bool intersect( const AABox<DATA_TYPE>& box, const Point<DATA_TYPE, 3>& point )
   {
      
      if (box.getMin()[0] > point[0])  return false;
      if (box.getMin()[1] > point[1])  return false;
      if (box.getMin()[2] > point[2])  return false;

      if (point[0] > box.getMax()[0])  return false;
      if (point[1] > box.getMax()[1])  return false;
      if (point[2] > box.getMax()[2])  return false;

      
      return true;
   }

   













   template<class DATA_TYPE>
   bool intersect( const AABox<DATA_TYPE>& box1, const Vec<DATA_TYPE, 3>& path1,
                   const AABox<DATA_TYPE>& box2, const Vec<DATA_TYPE, 3>& path2,
                   DATA_TYPE& firstContact, DATA_TYPE& secondContact )
   {
      
      
      
      

      
      Vec<DATA_TYPE, 3> path = path2 - path1;

      
      Vec<DATA_TYPE, 3> overlap1(DATA_TYPE(0), DATA_TYPE(0), DATA_TYPE(0));

      
      Vec<DATA_TYPE, 3> overlap2(DATA_TYPE(1), DATA_TYPE(1), DATA_TYPE(1));

      
      if (intersect(box1, box2))
      {
         firstContact = secondContact = DATA_TYPE(0);
         return true;
      }

      
      for (int i=0; i<3; ++i)
      {
         if ((box1.getMax()[i] < box2.getMin()[i]) && (path[i] < DATA_TYPE(0)))
         {
            overlap1[i] = (box1.getMax()[i] - box2.getMin()[i]) / path[i];
         }
         else if ((box2.getMax()[i] < box1.getMin()[i]) && (path[i] > DATA_TYPE(0)))
         {
            overlap1[i] = (box1.getMin()[i] - box2.getMax()[i]) / path[i];
         }

         if ((box2.getMax()[i] > box1.getMin()[i]) && (path[i] < DATA_TYPE(0)))
         {
            overlap2[i] = (box1.getMin()[i] - box2.getMax()[i]) / path[i];
         }
         else if ((box1.getMax()[i] > box2.getMin()[i]) && (path[i] > DATA_TYPE(0)))
         {
            overlap2[i] = (box1.getMax()[i] - box2.getMin()[i]) / path[i];
         }
      }

      
      firstContact = Math::Max(overlap1[0], overlap1[1], overlap1[2]);

      
      secondContact = Math::Min(overlap2[0], overlap2[1], overlap2[2]);

      
      
      return firstContact <= secondContact;
   }

   













   template<class DATA_TYPE>
   bool intersect(const Sphere<DATA_TYPE>& sph1, const Vec<DATA_TYPE, 3>& path1,
                  const Sphere<DATA_TYPE>& sph2, const Vec<DATA_TYPE, 3>& path2,
                  DATA_TYPE& firstContact, DATA_TYPE& secondContact)
   {
      
      
      
      

      
      const Vec<DATA_TYPE, 3> path = path2 - path1;

      
      const Vec<DATA_TYPE, 3> start_offset = sph2.getCenter() - sph1.getCenter();

      
      const DATA_TYPE radius_sum = sph1.getRadius() + sph2.getRadius();

      
      const DATA_TYPE a = dot(path, path);

      
      const DATA_TYPE b = DATA_TYPE(2) * dot(path, start_offset);

      
      const DATA_TYPE c = dot(start_offset, start_offset) - radius_sum * radius_sum;

      
      if (dot(start_offset, start_offset) <= radius_sum * radius_sum)
      {
         firstContact = secondContact = DATA_TYPE(0);
         return true;
      }

      
      if (Math::quadraticFormula(firstContact, secondContact, a, b, c))
      {
         
         if (firstContact > secondContact)
         {
            std::swap(firstContact, secondContact);
            return true;
         }
      }

      return false;
   }

   








   template<class DATA_TYPE>
   bool intersect(const AABox<DATA_TYPE>& box, const Sphere<DATA_TYPE>& sph)
   {
      DATA_TYPE dist_sqr = DATA_TYPE(0);

      
      for (int i=0; i<3; ++i)
      {
         if (sph.getCenter()[i] < box.getMin()[i])
         {
            DATA_TYPE s = sph.getCenter()[i] - box.getMin()[i];
            dist_sqr += s*s;
         }
         else if (sph.getCenter()[i] > box.getMax()[i])
         {
            DATA_TYPE s = sph.getCenter()[i] - box.getMax()[i];
            dist_sqr += s*s;
         }
      }

      return dist_sqr <= (sph.getRadius()*sph.getRadius());
   }

   








   template<class DATA_TYPE>
   bool intersect(const Sphere<DATA_TYPE>& sph, const AABox<DATA_TYPE>& box)
   {
      return intersect(box, sph);
   }

   









   template<class DATA_TYPE>
   bool intersect( const Plane<DATA_TYPE>& plane, const Ray<DATA_TYPE>& ray, DATA_TYPE& t )
   {
      Vec<DATA_TYPE, 3> N( plane.getNormal() );
      t = dot( N, N * plane.getOffset() - ray.getOrigin() ) / dot( N, ray.getDir() );
      return (DATA_TYPE)0 <= t && t <= (DATA_TYPE)1.0; 
   }

   











   template<class DATA_TYPE>
   bool intersect( const Tri<DATA_TYPE>& tri, const Ray<DATA_TYPE>& ray, 
   						   float& u, float& v, float& t )
   {
	   const float EPSILON = (DATA_TYPE)0.00001;
	   Vec<DATA_TYPE, 3> edge1, edge2, tvec, pvec, qvec;
      float det,inv_det;

      
      edge1 = tri[1] - tri[0];
      edge2 = tri[2] - tri[0];

      
      gmtl::cross( pvec, ray.getDir(), edge2 );

      
      det = gmtl::dot( edge1, pvec );

      if (det < EPSILON)
         return false;

      
      tvec = ray.getOrigin() - tri[0];

      
      u = gmtl::dot( tvec, pvec );
      if (u < 0.0 || u > det)
         return false;

      
      gmtl::cross( qvec, tvec, edge1 );

      
      v = gmtl::dot( ray.getDir(), qvec );
      if (v < 0.0 || u + v > det)
         return false;

      
      t = gmtl::dot( edge2, qvec );
      inv_det = ((DATA_TYPE)1.0) / det;
      t *= inv_det;
      u *= inv_det;
      v *= inv_det;
      
      
      return t >= (DATA_TYPE)0;
   }

   











   template<class DATA_TYPE>
   bool intersect( const Tri<DATA_TYPE>& tri, const LineSeg<DATA_TYPE>& lineseg, 
   						   float& u, float& v, float& t )
   {
      const DATA_TYPE eps = (DATA_TYPE)0.0001010101;
      DATA_TYPE l = length( lineseg.getDir() );
      if (eps < l)
      {
         Ray<DATA_TYPE> temp( lineseg.getOrigin(), lineseg.getDir() / l );
         bool result = intersect( tri, temp, u, v, t );
         t /= lineseg.getLength(); 
         return result && t <= (DATA_TYPE)1.0;
      }
      else 
         return false;
   }
}

   

#line 396 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Intersection.h"
#line 27 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_LineSeg.h"



















































































































#line 28 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_LineSegOps.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_LineSeg.h"



















































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_LineSegOps.h"

namespace gmtl {









template< class DATA_TYPE >
Point<DATA_TYPE, 3> findNearestPt( const LineSeg<DATA_TYPE>& lineseg,
                                   const Point<DATA_TYPE, 3>& pt )
{
   
   return ( lineseg.mOrigin + lineseg.mDir *
            dot(pt - lineseg.mOrigin, lineseg.mDir) );
}









template< class DATA_TYPE >
inline DATA_TYPE distance( const LineSeg<DATA_TYPE>& lineseg,
                           const Point<DATA_TYPE, 3>& pt )
{
   return gmtl::length( pt - findNearestPt( lineseg, pt ) );
}










template< class DATA_TYPE >
inline bool operator==( const LineSeg<DATA_TYPE>& ls1, const LineSeg<DATA_TYPE>& ls2 )
{
   return ( (ls1.mOrigin == ls2.mOrigin) && (ls1.mDir == ls2.mDir) );
}









template< class DATA_TYPE >
inline bool operator!=( const LineSeg<DATA_TYPE>& ls1,
                        const LineSeg<DATA_TYPE>& ls2 )
{
   return ( ! (ls1 == ls2) );
}













template< class DATA_TYPE >
inline bool isEqual( const LineSeg<DATA_TYPE>& ls1,
                     const LineSeg<DATA_TYPE>& ls2,
                     const DATA_TYPE& eps )
{
   (void)( (!!((eps >= 0))) || (_wassert(L"(eps >= 0)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_LineSegOps.h", 121), 0) );
   return ( (isEqual(ls1.mOrigin, ls2.mOrigin, eps)) &&
            (isEqual(ls1.mDir, ls2.mDir, eps)) );
}

} 
#line 128 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_LineSegOps.h"
#line 29 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"






















































































































































































































































































































































































































































































































































































#line 30 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h"






























































































































































































































































































































































































































#line 31 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_MatrixOps.h"




















































































































































































































































































































































































































































































































#line 32 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Output.h"






































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\Util/gmtl_Assert.h"













#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Output.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h"





























































































































































































































#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Output.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Matrix.h"






























































































































































































































































































































































































































#line 42 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Output.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Quat.h"





























































































































































































#line 43 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Output.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Tri.h"



































































































































































































































































#line 44 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Output.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Plane.h"































































































































































































































































#line 45 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Output.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Sphere.h"












































































































































#line 46 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Output.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_EulerAngle.h"





























































































































































#line 47 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Output.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_AABox.h"








































































































































































#line 48 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Output.h"

namespace gmtl
{
   


   

   









   template< class DATA_TYPE, unsigned SIZE >
   std::ostream& operator<<( std::ostream& out,
                             const VecBase<DATA_TYPE, SIZE>& v )
   {
      out << "(";
      for ( unsigned i=0; i<SIZE; ++i )
      {
         if ( i != 0 )
         {
            out << ", ";
         }
         out << v[i];
      }
      out << ")";
      return out;
   }

   








   template< class DATA_TYPE, typename ROTATION_ORDER>
   std::ostream& operator<<( std::ostream& out,
                             const EulerAngle<DATA_TYPE, ROTATION_ORDER>& e )
   {
      const DATA_TYPE* angle_data(e.getData());
      out << "{" << angle_data[0] << ", " << angle_data[1] << ", " << angle_data[2] << "}";
      return out;
   }


   













   template< class DATA_TYPE, unsigned ROWS, unsigned COLS >
   std::ostream& operator<<( std::ostream& out,
                             const Matrix<DATA_TYPE, ROWS, COLS>& m )
   {
      for ( unsigned row=0; row<ROWS; ++row )
      {
         out << "|";
         for ( unsigned col=0; col<COLS; ++col )
         {
            out << " " << m(row, col);
         }
         out << " |" << std::endl;
      }
      return out;
   }

   









   template< typename DATA_TYPE >
   std::ostream& operator<<( std::ostream& out, const Quat<DATA_TYPE>& q )
   {
      out << q.mData;
      return out;
   }

   














   template< typename DATA_TYPE >
   std::ostream& operator<<( std::ostream& out, const Tri<DATA_TYPE> &t )
   {
      out << t[0] << ", " << t[1] << ", " << t[2];
      return out;
   }

   













   template< typename DATA_TYPE >
   std::ostream& operator<<( std::ostream& out, const Plane<DATA_TYPE> &p )
   {
      out << p.mNorm << ", " << p.mOffset;
      return out;
   }

   













   template< typename DATA_TYPE >
   std::ostream& operator<<( std::ostream& out, const Sphere<DATA_TYPE> &s )
   {
      out << s.mCenter << ", " << s.mRadius;
      return out;
   }

   













   template< typename DATA_TYPE >
   std::ostream& operator<<( std::ostream& out, const AABox<DATA_TYPE>& b)
   {
      out << b.mMin << " " << b.mMax << " ";
      out << (b.mEmpty ? "true" : "false");
      return out;
   }
   

} 

#line 239 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Output.h"
#line 33 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Plane.h"































































































































































































































































#line 34 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_PlaneOps.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Defines.h"



































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_PlaneOps.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Plane.h"































































































































































































































































#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_PlaneOps.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"






















































































































































































































































































































































































































































































































































































#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_PlaneOps.h"

namespace gmtl
{





       








template< class DATA_TYPE >
DATA_TYPE distance( const Plane<DATA_TYPE>& plane, const Point<DATA_TYPE, 3>& pt )
{
   return ( dot(plane.mNorm, static_cast< Vec<DATA_TYPE, 3> >(pt)) - plane.mOffset );
}











template< class DATA_TYPE >
PlaneSide whichSide( const Plane<DATA_TYPE>& plane,
                     const Point<DATA_TYPE, 3>& pt )
{
   DATA_TYPE dist = distance( plane, pt );

   if ( dist < DATA_TYPE(0) )
      return NEG_SIDE;
   else if ( dist > DATA_TYPE(0) )
      return POS_SIDE;
   else
      return ON_PLANE;
}












template< class DATA_TYPE >
PlaneSide whichSide( const Plane<DATA_TYPE>& plane,
                     const Point<DATA_TYPE, 3>& pt,
                     const DATA_TYPE& eps )
{
   DATA_TYPE dist = distance( plane, pt );

   if ( dist < eps )
      return NEG_SIDE;
   else if ( dist > eps )
      return POS_SIDE;
   else
      return ON_PLANE;
}











template< class DATA_TYPE >
DATA_TYPE findNearestPt( const Plane<DATA_TYPE>& plane,
                         const Point<DATA_TYPE, 3>& pt,
                         Point<DATA_TYPE, 3>& result )
{
   
   
   (void)( (!!((isNormalized(plane.mNorm)))) || (_wassert(L"(isNormalized(plane.mNorm))", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_PlaneOps.h", 131), 0) );   
   DATA_TYPE dist_to_plane(0);
   dist_to_plane = plane.mOffset + dot( plane.mNorm, static_cast< Vec<DATA_TYPE, 3> >(pt) );
   result = pt - (plane.mNorm * dist_to_plane);
   return dist_to_plane;
}
















template< class DATA_TYPE >
inline bool operator==( const Plane<DATA_TYPE>& p1, const Plane<DATA_TYPE>& p2 )
{
   return ( (p1.mNorm == p2.mNorm) && (p1.mOffset == p2.mOffset) );
}










template< class DATA_TYPE >
inline bool operator!=( const Plane<DATA_TYPE>& p1, const Plane<DATA_TYPE>& p2 )
{
   return (! (p1 == p2));
}












template< class DATA_TYPE >
inline bool isEqual( const Plane<DATA_TYPE>& p1, const Plane<DATA_TYPE>& p2,
                     const DATA_TYPE& eps )
{
   (void)( (!!((eps >= 0))) || (_wassert(L"(eps >= 0)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_PlaneOps.h", 189), 0) );
   return ( (isEqual(p1.mNorm, p2.mNorm, eps)) &&
            (Math::isEqual(p1.mOffset, p2.mOffset, eps)) );
}



} 

#line 199 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_PlaneOps.h"

#line 35 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Point.h"






































































































































#line 36 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_PointOps.h"



#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\j_MathFunc.h"


	
	#pragma warning (disable : 4305)
	#pragma warning (disable : 4244)

	
	#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"
















#pragma once
#line 19 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"




#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 24 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtwrn.h"











#pragma once




#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtdefs.h"














 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 18 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtwrn.h"


















































#line 69 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\crtwrn.h"
#line 25 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"








#line 34 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"

#line 36 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"
#line 37 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"
#line 38 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"


extern "C" {
#line 42 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"











































 __declspec(dllimport) unsigned int __cdecl _clearfp(void);
#pragma warning(push)
#pragma warning(disable: 4141)
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) unsigned int __cdecl _controlfp(     unsigned int _NewValue,     unsigned int _Mask);
#pragma warning(pop)
 __declspec(dllimport) void __cdecl _set_controlfp(     unsigned int _NewValue,      unsigned int _Mask);
 __declspec(dllimport) errno_t __cdecl _controlfp_s(       unsigned int *_CurrentState,      unsigned int _NewValue,      unsigned int _Mask);
 __declspec(dllimport) unsigned int __cdecl _statusfp(void);
 __declspec(dllimport) void __cdecl _fpreset(void);


 __declspec(dllimport) void __cdecl _statusfp2(       unsigned int *_X86_status,        unsigned int *_SSE2_status);
#line 98 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"










































































#line 173 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"

 __declspec(dllimport) unsigned int __cdecl _control87(     unsigned int _NewValue,     unsigned int _Mask);

 __declspec(dllimport) int __cdecl __control87_2(     unsigned int _NewValue,      unsigned int _Mask,
                                         unsigned int* _X86_cw,        unsigned int* _Sse2_cw);
#line 179 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"




__declspec(dllimport) extern  int * __cdecl __fpecode(void);



#line 188 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"
































__declspec(dllimport)  double __cdecl _scalb(     double _X,      long _Y);
__declspec(dllimport)  double __cdecl _logb(     double _X);
__declspec(dllimport)  double __cdecl _nextafter(     double _X,      double _Y);
__declspec(dllimport)  int    __cdecl _finite(     double _X);
__declspec(dllimport)  int    __cdecl _isnan(     double _X);
__declspec(dllimport)  int    __cdecl _fpclass(     double _X);

























 __declspec(dllimport) void __cdecl fpreset(void);





























































#line 314 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"


}
#line 318 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"

#line 320 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\float.h"
#line 9 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\j_MathFunc.h"
	#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"


























































































































































































































































































































































































































































































































































































































































#line 636 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"

#line 10 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\j_MathFunc.h"
	

	
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\j_MathTypes.h"


	
	
	
	static const float	PI				=	3.14159265358979323846f;	
	static const float  HALFPI		=	1.57079632679489661923f;	
	static const float  TWOPI			=	6.28318530717958647692f;	
	static const float  INVPI			=	0.31830988618379067154f;	
	static const float	EPSILON		= 0.00000000000000000001f;

	static const float  RADTODEG	=	57.2957795130823208768f;	
	static const float  DEGTORAD	=	0.01745329251994329577f;	

	static const float  EXP				=	2.71828182845904523536f;	
	static const float  ILOG2			=	3.32192809488736234787f;	
	static const float  INV255		=	0.00392156862745098039f;	

	
	struct UByte4 
	{ 
		
		unsigned char rgba[4]; 
		UByte4() { rgba[0]=rgba[1]=rgba[2]=rgba[3]=255; }

		
		UByte4 operator = (const UByte4 &v) 
		{ 
			rgba[0]=v.rgba[0];	rgba[1]=v.rgba[1];
			rgba[2]=v.rgba[2];	rgba[3]=v.rgba[3];
			return *this;
		}
			
		
		bool operator == (const UByte4 &v) 
		{ 
			if((rgba[0]==v.rgba[0])&&(rgba[1]==v.rgba[1])&&
				(rgba[2]==v.rgba[2])&&(rgba[3]==v.rgba[3]))
			{ return true; }
			else 
			{ return false; }
		}
	};

	
#line 47 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\j_MathTypes.h"
#line 14 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\j_MathFunc.h"

	
	
	
	inline int IAbs		(int iValue);
	inline int ICeil	(float fValue);
	inline int IFloor (float fValue);
	inline int ISign	(int iValue);

	
	
	
	inline float Abs	(float fValue);
	inline float ACos (float fValue);
	inline float ASin (float fValue);
	inline float ATan (float fValue);
	inline float ATan2(float fY, float fX);
	inline float Ceil (float fValue);
	inline float Cos	(float fValue);
	inline float Exp	(float fValue);
	inline float Floor(float fValue);
	inline float Log	(float fValue);
	inline float Pow	(float kBase, float kExponent);
	inline float Sign (float fValue);
	inline float Sin	(float fValue);
	inline float Sqr	(float fValue);
	inline float Sqrt (float fValue);
	inline float Min	(float a,float b);
	inline float Max	(float a,float b);
	inline float UnitRandom ();			 
	inline float SymmetricRandom (); 

	
	
	
	inline int IAbs(int iValue)
	{ return(iValue >= 0 ? iValue : -iValue); }

	
	
	
	inline int ICeil(float fValue)
	{ return int(ceil(fValue)); }

	
	
	
	inline int IFloor(float fValue)
	{ return int(floor(fValue));}

	
	
	
	inline int ISign(int iValue)
	{ return(iValue > 0 ? +1 : (iValue<0 ? -1:0)); }

	
	
	
	inline float Abs(float fValue)
	{ return float(fabs(fValue)); }

	
	
	
	inline float ACos(float fValue)
	{
			if(-1.0 < fValue)
			{
				if(fValue < 1.0)
					return float(acos(fValue));
				else
					return 0.0;
			}
			else
			{ return PI; }
	}

	
	
	
	inline float ASin(float fValue)
	{
		if(-1.0 < fValue)
		{
			if(fValue < 1.0)
				return float(asin(fValue));
			else
				return -HALFPI;
		}
		else
		{ return HALFPI; }
	}

	
	
	
	inline float ATan(float fValue)
	{ return float(atan(fValue)); }

	
	
	
	inline float ATan2(float fY, float fX)
	{ return float(atan2(fY,fX)); }

	
	
	
	inline float Ceil(float fValue)
	{ return float(ceil(fValue)); }

	
	
	
	inline float Cos(float fValue)
	{ return float(cos(fValue)); }

	
	
	
	inline float Exp(float fValue)
	{ return float(exp(fValue)); }

	
	
	
	inline float Floor(float fValue)
	{ return float(floor(fValue)); }

	
	
	
	inline float Log(float fValue)
	{ return float(log(fValue)); }

	
	
	
	inline float Pow(float fBase, float fExponent)
	{ return float(pow(fBase,fExponent)); }

	
	
	
	inline float Sign(float fValue)
	{
		if(fValue > 0.0)	return 1.0;
		if(fValue < 0.0)	return -1.0;
		return 0.0;
	}

	
	
	
	inline float Sin(float fValue)
	{ return float(sin(fValue)); }

	
	
	
	inline float Sqr(float fValue)
	{ return fValue*fValue; }

	
	
	
	inline float Sqrt(float fValue)
	{ return float(sqrt(fValue)); }

	
	
	
	inline float Min(float a, float b)
	{	return (a<b) ? a:b; }

	
	
	
	inline float Max(float a, float b)
	{	return (a>b) ? a:b; }

	
	
	
	inline float UnitRandom()
	{ return float(rand())/float(0x7fff); }

	
	
	
	inline float SymmetricRandom()
	{ return 2.0*float(rand())/float(0x7fff) - 1.0; }

	
#line 210 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\j_MathFunc.h"
#line 5 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_PointOps.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\j_MathFast.h"


	
	#pragma warning (disable : 4305)
	#pragma warning (disable : 4244)

	
	
	#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"


























































































































































































































































































































































































































































































































































































































































#line 636 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"

#line 10 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\j_MathFast.h"

	
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\j_MathTypes.h"














































#line 13 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\j_MathFast.h"

	
	
	
	inline float fSin0(float fT)
	{
			
			
			

			float fTSqr = fT*fT;
			float fResult = 7.61e-03f;
			fResult *= fTSqr;
			fResult -= 1.6605e-01f;
			fResult *= fTSqr;
			fResult += 1.0f;
			fResult *= fT;
			return fResult;
	}

	
	
	
	inline float fSin1(float fT)
	{
			
			
			

			float fTSqr = fT*fT;
			float fResult = -2.39e-08f;
			fResult *= fTSqr;
			fResult += 2.7526e-06f;
			fResult *= fTSqr;
			fResult -= 1.98409e-04f;
			fResult *= fTSqr;
			fResult += 8.3333315e-03f;
			fResult *= fTSqr;
			fResult -= 1.666666664e-01f;
			fResult *= fTSqr;
			fResult += 1.0f;
			fResult *= fT;
			return fResult;
	}

	
	
	
	inline float fCos0(float fT)
	{
			
			
			

			float fTSqr = fT*fT;
			float fResult = 3.705e-02f;
			fResult *= fTSqr;
			fResult -= 4.967e-01f;
			fResult *= fTSqr;
			fResult += 1.0f;
			return fResult;
	}

	
	
	
	inline float fCos1(float fT)
	{
			
			
			

			float fTSqr = fT*fT;
			float fResult = -2.605e-07f;
			fResult *= fTSqr;
			fResult += 2.47609e-05f;
			fResult *= fTSqr;
			fResult -= 1.3888397e-03f;
			fResult *= fTSqr;
			fResult += 4.16666418e-02f;
			fResult *= fTSqr;
			fResult -= 4.999999963e-01f;
			fResult *= fTSqr;
			fResult += 1.0f;
			return fResult;
	}

	
	
	
	inline float fTan0(float fT)
	{
			
			
			

			float fTSqr = fT*fT;
			float fResult = 2.033e-01f;
			fResult *= fTSqr;
			fResult += 3.1755e-01f;
			fResult *= fTSqr;
			fResult += 1.0f;
			fResult *= fT;
			return fResult;
	}

	
	
	
	inline float fTan1(float fT)
	{
			
			
			

			float fTSqr = fT*fT;
			float fResult = 9.5168091e-03f;
			fResult *= fTSqr;
			fResult += 2.900525e-03f;
			fResult *= fTSqr;
			fResult += 2.45650893e-02f;
			fResult *= fTSqr;
			fResult += 5.33740603e-02f;
			fResult *= fTSqr;
			fResult += 1.333923995e-01f;
			fResult *= fTSqr;
			fResult += 3.333314036e-01f;
			fResult *= fTSqr;
			fResult += 1.0f;
			fResult *= fT;
			return fResult;
	}

	
	
	
	inline float fInvTan0(float fT)
	{
			
			
			

			float fTSqr = fT*fT;
			return fT/(1.0f + 0.28f*fTSqr);
	}

	
	
	
	inline float fInvTan1(float fT)
	{
			
			
			

			float fTSqr = fT*fT;
			float fResult = 0.0208351f;
			fResult *= fTSqr;
			fResult -= 0.085133f;
			fResult *= fTSqr;
			fResult += 0.180141f;
			fResult *= fTSqr;
			fResult -= 0.3302995f;
			fResult *= fTSqr;
			fResult += 0.999866f;
			fResult *= fT;
			return fResult;
	}

	
	
	
	inline float fInvTan2(float fT)
	{
			
			
			

			float fTSqr = fT*fT;
			float fResult = 0.0028662257f;
			fResult *= fTSqr;
			fResult -= 0.0161657367f;
			fResult *= fTSqr;
			fResult += 0.0429096138f;
			fResult *= fTSqr;
			fResult -= 0.0752896400f;
			fResult *= fTSqr;
			fResult += 0.1065626393f;
			fResult *= fTSqr;
			fResult -= 0.1420889944f;
			fResult *= fTSqr;
			fResult += 0.1999355085f;
			fResult *= fTSqr;
			fResult -= 0.3333314528f;
			fResult *= fTSqr;
			fResult += 1.0f;
			fResult *= fT;
			return fResult;
	}

	
	
	
	inline float fInvSin0(float fT)
	{
			
			
			
			float fRoot = sqrtf(1.0f-fT);

			float fResult = -0.0187293f;
			fResult *= fT;
			fResult += 0.0742610f;
			fResult *= fT;
			fResult -= 0.2121144f;
			fResult *= fT;
			fResult += 1.5707288f;
			fResult = HALFPI - fRoot*fResult;
			return fResult;
	}

	
	
	
	inline float fInvCos0(float fT)
	{
			
			
			
			float fRoot = sqrtf(1.0f-fT);

			float fResult = -0.0187293f;
			fResult *= fT;
			fResult += 0.0742610f;
			fResult *= fT;
			fResult -= 0.2121144f;
			fResult *= fT;
			fResult += 1.5707288f;
			fResult *= fRoot;
			return fResult;
	}

	
	
	
	inline float fRSqrt(float number)
	{
		long i;
		float x2, y;
		const float threehalfs = 1.5f;

		x2 = number * 0.5f;
		y  = number;
		i  = * (long *) &y;											
		i  = 0x5f3759df - (i >> 1);             
		y  = * (float *) &i;
		y  = y * (threehalfs - (x2 * y * y));   

		return y;
	}
	
	
	
	inline float fSqrt(float num)
	{
		_asm
		{
			MOVSS xmm2,num
			SQRTSS xmm1,xmm2
			MOVSS num,xmm1
		}
		return num;
	}

	
	
	
	inline int fNextPowerOfTwo(int N)
	{
		if (N<=0L				) return 0;
		if (N<=1L				) return 1;
		if (N<=2L				) return 2;
		if (N<=4L				) return 4;
		if (N<=8L				) return 8;
		if (N<=16L	    ) return 16;
		if (N<=32L	    ) return 32;
		if (N<=64L 	    ) return 64;
		if (N<=128L     ) return 128;
		if (N<=256L     ) return 256;
		if (N<=512L     ) return 512;
		if (N<=1024L    ) return 1024;
		if (N<=2048L    ) return 2048;
		if (N<=4096L    ) return 4096;
		if (N<=8192L    ) return 8192;
		if (N<=16384L   ) return 16384;
		if (N<=32768L   ) return 32768;
		if (N<=65536L		) return 65536;
		else			  return 0;
	}

	

#line 316 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\j_MathFast.h"
#line 6 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_PointOps.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Defines.h"



































































































#line 7 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_PointOps.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"






















































































































































































































































































































































































































































































































































































#line 8 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_PointOps.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Point.h"






































































































































#line 9 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_PointOps.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"


























































































































































































































































































































































































































































































































































































































































#line 636 "C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\math.h"

#line 10 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_PointOps.h"



namespace gmtl
{
	
	template<class DATA_TYPE, unsigned SIZE>
	Point<DATA_TYPE, SIZE>& operator +=(Point<DATA_TYPE, SIZE>& p1,
																				const Point<DATA_TYPE, SIZE>& p2)
	{
		for(unsigned i=0;i<SIZE;++i) {	p1[i] += p2[i];	}
		return p1;
	}

	
	template<class DATA_TYPE, unsigned SIZE>
	Point<DATA_TYPE, SIZE> operator +(const Point<DATA_TYPE, SIZE>& p1,
																			const Point<DATA_TYPE, SIZE>& p2)
	{
		VecBase<DATA_TYPE, SIZE> ret_val(p1);
		ret_val += p2; return ret_val;
	}

	
	template<class DATA_TYPE, unsigned SIZE>
	Point<DATA_TYPE, SIZE>& operator -=(Point<DATA_TYPE, SIZE>& p1,
																				const Point<DATA_TYPE, SIZE>& p2)
	{
		for(unsigned i=0;i<SIZE;++i) {	p1[i] -= p2[i]; }
		return p1;
	}

	
	template<class DATA_TYPE, unsigned SIZE>
	inline bool operator==(const Point<DATA_TYPE, SIZE>& p1,
												 const Point<DATA_TYPE, SIZE>& p2)
	{
		for(unsigned i=0;i<SIZE;++i)
		{	if(p1[i] != p2[i]){	return false;	}	}
		return true;
	}

	
	template<class DATA_TYPE, unsigned SIZE>
	inline bool operator!=(const Point<DATA_TYPE, SIZE>& p1,
												 const Point<DATA_TYPE, SIZE>& p2)
	{	return(! (p1 == p2));	}

	
	template < class DATA_TYPE, unsigned SIZE>
	Point<DATA_TYPE, SIZE> operator -(const Point<DATA_TYPE, SIZE>& p1,
																		const Point<DATA_TYPE, SIZE>& p2)
	{
		Point<DATA_TYPE, SIZE> ret_val(p1);
		ret_val -= p2; return ret_val;
	}

	
	template<class DATA_TYPE, unsigned SIZE, class SCALAR_TYPE>
	Point<DATA_TYPE, SIZE>& operator *=(Point<DATA_TYPE, SIZE>& p1,
																			const SCALAR_TYPE& scalar)
	{
		for(unsigned i=0;i<SIZE;++i) {	p1[i] *= (DATA_TYPE)scalar;	}
		return p1;
	}

	
	template<class DATA_TYPE, unsigned SIZE, class SCALAR_TYPE>
	Point<DATA_TYPE, SIZE> operator *(const Point<DATA_TYPE, SIZE>& p1,
																		const SCALAR_TYPE& scalar)
	{
		Point<DATA_TYPE, SIZE> ret_val(p1);
		ret_val *= scalar;	return ret_val;
	}

	
	template<class DATA_TYPE, unsigned SIZE, class SCALAR_TYPE>
	Point<DATA_TYPE, SIZE> operator *(const SCALAR_TYPE& scalar,
																		const Point<DATA_TYPE, SIZE>& p1)
	{
		Point<DATA_TYPE, SIZE> ret_val(p1);
		ret_val *= scalar;	return ret_val;
	}

	
	template<class DATA_TYPE, unsigned SIZE, class SCALAR_TYPE>
	Point<DATA_TYPE, SIZE>& operator /=(Point<DATA_TYPE, SIZE>& p1,
																			const SCALAR_TYPE& scalar)
	{
		for(unsigned i=0;i<SIZE;++i) {	p1[i] /= scalar; }
		return p1;
	}

	
	template<class DATA_TYPE, unsigned SIZE, class SCALAR_TYPE>
	Point<DATA_TYPE, SIZE> operator /(const Point<DATA_TYPE, SIZE>& p1,
																		const SCALAR_TYPE& scalar)
	{
		Point<DATA_TYPE, SIZE> ret_val(p1);
		ret_val /= scalar;	return ret_val;
	}

	
	template<class DATA_TYPE, unsigned SIZE>
	DATA_TYPE dot(const Point<DATA_TYPE, SIZE>& p1, const Point<DATA_TYPE, SIZE>& p2)
	{
		DATA_TYPE ret_val(0);
		for(unsigned i=0;i<SIZE;++i) {	ret_val += (p1[i] * p2[i]);	}
		return ret_val;
	}

	
	
	
	inline Point3f UnitRandomPoint3(void)
	{ return Point3f(UnitRandom(),UnitRandom(),UnitRandom());	}

	
	
	
	inline Point3f SymRandomPoint3(void)
	{ return Point3f(SymmetricRandom(),SymmetricRandom(),SymmetricRandom());	}

	
	
	
	inline Point3f Lerp(const Point3f& a,const Point3f& b,const float t)
	{	
		return Point3f(a[0] + t * (b[0] - a[0]),
									 a[1] + t * (b[1] - a[1]),
									 a[2] + t * (b[2] - a[2]));	
	}

	
	
	
	
	inline Point3f Herp(const Point3f& p0,const Point3f& p1,
										  const Point3f& p2,const Point3f& p3,const float t)
	{
		Point3f ret;
		const float t2 = t * t;
		const float t3 = t2 * t;
		const float kp0 = (2.0f * t2 - t3 - t) * 0.5f;
		const float kp1 = (3.0f * t3 - 5.0f * t2 + 2.0f) * 0.5f;
		const float kp2 = (4.0f * t2 - 3.0f * t3 + t) * 0.5f;
		const float kp3 = (t3 - t2) * 0.5f;
		ret[0] = p0[0] * kp0 + p1[0] * kp1 + p2[0] * kp2 + p3[0] * kp3;
		ret[1] = p0[1] * kp0 + p1[1] * kp1 + p2[1] * kp2 + p3[1] * kp3;
		ret[2] = p0[2] * kp0 + p1[2] * kp1 + p2[2] * kp2 + p3[2] * kp3;
		return ret;
	}

	
	
	
	inline void Swap(Point3f &a, Point3f &b) 
	{ Point3f tmp(a); a = b; b = tmp; }

	
	
	
	inline float Distance(Point3f &a, Point3f &b)
	{ 
		return fSqrt(((b[0] - a[0])*(b[0] - a[0]))+ 
								 ((b[1] - a[1])*(b[1] - a[1]))+
								 ((b[2] - a[2])*(b[2] - a[2])));
	}

	
	
	
	inline Point3f PMin(Point3f& a,Point3f& b) 
	{ return Point3f(Min(a[0],b[0]),
									 Min(a[1],b[1]),
									 Min(a[2],b[2])); }

	
	inline Point3f PMax(Point3f& a,Point3f& b) 
	{ 
		return Point3f(Max(a[0],b[0]),
									 Max(a[1],b[1]),
									 Max(a[2],b[2])); }

	

} 

#line 199 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_PointOps.h"
#line 37 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Quat.h"





























































































































































































#line 38 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_QuatOps.h"




















































































































































































































































































































































































































































































































































































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Ray.h"


















































































































































#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Sphere.h"












































































































































#line 41 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_SphereOps.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Sphere.h"












































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_SphereOps.h"
#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Math.h"






















































































































































































































































































































































































































































































































































































#line 40 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_SphereOps.h"

namespace gmtl
{














template< class DATA_TYPE >
inline bool operator==( const Sphere<DATA_TYPE>& s1, const Sphere<DATA_TYPE>& s2 )
{
   return ( (s1.mCenter == s2.mCenter) && (s1.mRadius == s2.mRadius) );
}









template< class DATA_TYPE >
inline bool operator!=( const Sphere<DATA_TYPE>& s1, const Sphere<DATA_TYPE>& s2 )
{
   return (! (s1 == s2));
}












template< class DATA_TYPE >
inline bool isEqual( const Sphere<DATA_TYPE>& s1, const Sphere<DATA_TYPE>& s2, const DATA_TYPE& eps )
{
   (void)( (!!((eps >= 0))) || (_wassert(L"(eps >= 0)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_SphereOps.h", 91), 0) );
   return ( (isEqual(s1.mCenter, s2.mCenter, eps)) &&
            (Math::isEqual(s1.mRadius, s2.mRadius, eps)) );
}


} 

#line 100 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_SphereOps.h"

#line 42 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Tri.h"



































































































































































































































































#line 43 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_TriOps.h"





































#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Tri.h"



































































































































































































































































#line 39 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_TriOps.h"

namespace gmtl
{












template< class DATA_TYPE >
Point<DATA_TYPE, 3> center( const Tri<DATA_TYPE>& tri )
{
   const float one_third = (1.0f/3.0f);
   return (tri[0] + tri[1] + tri[2]) * one_third;
}








template< class DATA_TYPE >
Vec<DATA_TYPE, 3> normal( const Tri<DATA_TYPE>& tri )
{
   Vec<DATA_TYPE, 3> normal = cross( tri[1] - tri[0], tri[2] - tri[0] );
   normalize( normal );
   return normal;
}















template< class DATA_TYPE >
bool operator==( const Tri<DATA_TYPE>& tri1, const Tri<DATA_TYPE>& tri2 )
{
   return ( (tri1[0] == tri2[0]) &&
            (tri1[1] == tri2[1]) &&
            (tri1[2] == tri2[2]) );
}









template< class DATA_TYPE >
bool operator!=( const Tri<DATA_TYPE>& tri1, const Tri<DATA_TYPE>& tri2 )
{
   return (! (tri1 == tri2));
}












template< class DATA_TYPE >
bool isEqual( const Tri<DATA_TYPE>& tri1, const Tri<DATA_TYPE>& tri2,
              const DATA_TYPE& eps )
{
   (void)( (!!((eps >= 0))) || (_wassert(L"(eps >= 0)", L"c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_TriOps.h", 127), 0) );
   return ( isEqual(tri1[0], tri2[0], eps) &&
            isEqual(tri1[1], tri2[1], eps) &&
            isEqual(tri1[2], tri2[2], eps) );
}


} 

#line 137 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_TriOps.h"

#line 44 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecBase.h"





























































































































































































































#line 45 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Vec.h"






































































































































#line 46 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_VecOps.h"
























































































































































































































































































































































































































































































































































#line 47 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Version.h"


























































































#line 92 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Version.h"









#line 102 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Version.h"









#line 112 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Version.h"


























namespace gmtl
{
   inline const char* getVersion()
   {
      return "0.2.1";
   }
} 




























#line 174 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Version.h"
#line 48 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\gmtl_Xforms.h"






















































































































































































































































































































































































































































#line 49 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"

	
	using namespace gmtl;

	
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\j_MathTypes.h"














































#line 55 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\j_MathFunc.h"

















































































































































































































#line 56 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
	#line 1 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\math\\j_MathFast.h"



























































































































































































































































































































#line 57 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"

	

#line 61 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\Math/bbb_Math.h"
#line 9 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\bbb_GLWidget.h"







enum BrickState {INACTIVE = 0, ACTIVE};







class Brick
{
	public:
		gmtl::Point3f corners[8];
		gmtl::Vec3f	  normals[6];
		
		BrickState    state;
		bool cantilevered;
		bool corner;
	
	public:
		bool isCantilevered() { return cantilevered; }
		void setCantilever() { cantilevered = true; }
		void clearCantilever() { cantilevered = false; }
		bool isCorner() { return corner; }
		void setCorner() { corner = true; }
		void clearCorner() { corner = false; }
		bool isSolid() { return (state == ACTIVE); }
		bool isHollow() { return (state == INACTIVE); }
};


struct WallSegment
{	std::vector<gmtl::Point3f> knots; };






struct WallPath
{ 
	std::vector<WallSegment> segments;
	char                     filename[256];
};







class BBB_Form;
class BBB_GLWidget : public QGLWidget
{
   public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:
	
  BBB_GLWidget( QWidget* parent, const char* name );
  ~BBB_GLWidget();

	
	
	
	
	void bindForm(BBB_Form* ref_form);
			
public :
	
	
	
	void rebuildBricks(void);

	
	
	
	
	void  resizeWall(void);

	
	
	
	
	
	void  resizeColumns(void);

	
	
	
	void resizePadding(void);

	
	
	
	
	

	
	
	
	void cantileverPattern();

	
	
	
	void cantileverPattern(int col);

	
	
	
	
	void activateBricks(void);

	
	
	
	void clearActiveBricks(void);

	
	
	
	void  randomActiveBricks(void);
	
	
	
	
	void generatePattern(void);

	
	
	
	
	
	void clearPattern(void);

	
	
	
	void clearRules(void);
	
	
	
	
	void generateBeams(void);

	
	
	
	void clearBeams(void);

	
	
	
	void clearColumn(int index);

	
	
	
	
	void  toggleGrid(void)	  { m_drawGrid = !m_drawGrid; }
	void  toggleBorders(void) { m_drawBorder = !m_drawBorder; }
	void  showInactive(void)  { m_showInactive = !m_showInactive; }
	
	
	
	
	void toggleOffset(void);

	
	
	
	
	void  invertActive(void);	

	
	
	
	
	void  zoomExtents(void);

	
	
	
	void  resetAll(void);

	
	
	
	
	void  takeScreenshot(void);

	
	
	
	bool importPath(char* filename=0);

	
	bool savePattern(void);
	bool loadPattern(void);

	
	bool exportToObj(void);
	bool exportToRLE(void);
	bool exportToMP3(void);

protected:
	
	
	
    void initializeGL();

	
	
	
    void paintGL();

	
	
	
	
	
    void resizeGL( int w, int h );

	
	
	
	
    bool event(QEvent* e);

private:
	
	
	
	void drawGrid(float size, float step);

	
	void drawBricks(void);
	
	
	void drawBorders(void);

	
	
	
	
	
	
	void clearBricks(int row=0);

	
	void toggleInitialCondition(int index);
	void setInitialCondition(int index, BrickState bs);
	void setCornerColumn(int index);
	void clearCornerColumn(int index);

	
	
	
	
	void evaluateNeighborhood(int index,int n1,int n2,int n3,int n4,int n5);
	void evaluateRule(int index);

	
	
	
	
	
	bool cantileverCheck(int index);
	void setCantileverColumn(int index);
	void clearCantileverColumn(int index);

	
	void printBrickCount(FILE * fOut, unsigned int s, unsigned int h, unsigned int c, unsigned int r);

	bool text2wav(QString filepath, QString txt);
	WCHAR * QStringToWCHAR(QString orig);

private:
	BBB_Form* m_form;

	
	float				m_zoom;
    float				m_xpos,m_ypos;
    float				m_xrot,m_yrot;
	int					m_lastMouseX, m_lastMouseY;	

	
	bool				m_mouseDown;
	bool				m_pickingBricks;
	bool				m_hasStartCondition;
	bool				m_generatingPattern;
	bool				m_drawBorder;
	bool				m_drawGrid;
	bool				m_showInactive;
	bool				m_uniformStack;

	
	gmtl::Point3f       m_minimum;
	gmtl::Point3f		m_maximum;

	
	WallPath*           m_path;
	std::vector<Brick>  m_newBricks;

	
	int                 m_numBricksPerRow;
	int					m_selectedBrick;
	int					m_cornerWidth; 
	int					m_paddingRows; 
	int					m_cantileveredHeight;  
	int					m_selectedStartBrick;  
	int					m_selectedEndBrick;  
	std::vector<bool>	m_cantileverableBricks;   
	int					m_screenshotIndex;
};

#line 332 "c:\\documents and settings\\chipp\\desktop\\projects\\automason\\automasonqt3\\bbb_GLWidget.h"
#line 12 ".\\moc_bbb_GLWidget.cpp"
#line 1 "C:\\qt-3.3.8\\include\\qmetaobject.h"









































#line 1 "c:\\qt-3.3.8\\include\\qconnection.h"









































#line 1 "c:\\qt-3.3.8\\include\\qobject.h"



































































































































































































































































#line 43 "c:\\qt-3.3.8\\include\\qconnection.h"
#line 44 "c:\\qt-3.3.8\\include\\qconnection.h"

class __declspec(dllimport) QConnection
{
public:
    QConnection( const QObject *, int, const char *memberName, int memberType );
   ~QConnection() {}

    bool     isConnected() const { return obj != 0; }

    QObject *object() const  { return obj; }	
    int  member() const  { return mbr; }
    const char *memberName() const { return mbr_name; }
    int  memberType() const  { return mbr_type; }
    int	     numArgs() const { return nargs; }

private:
    QObject *obj;				
    int  mbr;				
    const char *mbr_name;
    int mbr_type;
    int	     nargs;

private:	



#line 71 "c:\\qt-3.3.8\\include\\qconnection.h"
};


#line 1 "c:\\qt-3.3.8\\include\\qwinexport.h"










































#line 44 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 49 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 54 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 59 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 65 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 70 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 75 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 81 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 87 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 94 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 101 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 106 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 112 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 118 "c:\\qt-3.3.8\\include\\qwinexport.h"



extern template class __declspec(dllimport) QPtrListIterator<QConnection>;
extern template class __declspec(dllimport) QPtrList<QConnection>;
#line 124 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 130 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 136 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 141 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 146 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 151 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 156 "c:\\qt-3.3.8\\include\\qwinexport.h"







#line 164 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 170 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 176 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 182 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 187 "c:\\qt-3.3.8\\include\\qwinexport.h"








#line 196 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 202 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 207 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 211 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 218 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 222 "c:\\qt-3.3.8\\include\\qwinexport.h"
#line 75 "c:\\qt-3.3.8\\include\\qconnection.h"
#line 76 "c:\\qt-3.3.8\\include\\qconnection.h"
#line 43 "C:\\qt-3.3.8\\include\\qmetaobject.h"
#line 1 "c:\\qt-3.3.8\\include\\qstrlist.h"










































































































#line 44 "C:\\qt-3.3.8\\include\\qmetaobject.h"
#line 45 "C:\\qt-3.3.8\\include\\qmetaobject.h"



#line 49 "C:\\qt-3.3.8\\include\\qmetaobject.h"

class QObject;
struct QUMethod;
class QMetaObjectPrivate;

struct QMetaData				
{						
    const char *name;				
    const QUMethod* method;			
    enum Access { Private, Protected, Public };
    Access access;				
};


struct QMetaEnum				
{						
    const char *name;				
    uint count;					
    struct Item					
    {
	const char *key;
	int value;
    };
    const Item *items;				
    bool set;					
};
#line 76 "C:\\qt-3.3.8\\include\\qmetaobject.h"



class __declspec(dllimport) QMetaProperty			
{
public:
    const char*	type() const { return t; }	
    const char*	name() const { return n; }	

    bool writable() const;
    bool isValid() const;

    bool isSetType() const;
    bool isEnumType() const;
    QStrList enumKeys() const;			

    int keyToValue( const char* key ) const;	
    const char* valueToKey( int value ) const;
    int keysToValue( const QStrList& keys ) const;
    QStrList valueToKeys( int value ) const;

    bool designable( QObject* = 0 ) const;
    bool scriptable( QObject* = 0 ) const;
    bool stored( QObject* = 0 ) const;

    bool reset( QObject* ) const;

    const char* t;			
    const char* n;			

    enum Flags  {
	Invalid		= 0x00000000,
	Readable	= 0x00000001,
	Writable	= 0x00000002,
	EnumOrSet	= 0x00000004,
	UnresolvedEnum	= 0x00000008,
	StdSet		= 0x00000100,
	Override	= 0x00000200
    };

    uint flags; 
    bool testFlags( uint f ) const;	
    bool stdSet() const; 		
    int id() const; 			

    QMetaObject** meta; 		

    const QMetaEnum* enumData;		
    int _id; 				
    void clear(); 			
};

inline bool QMetaProperty::testFlags( uint f ) const
{ return (flags & (uint)f) != (uint)0; }

#line 132 "C:\\qt-3.3.8\\include\\qmetaobject.h"

struct QClassInfo				
{
    const char* name;				
    const char* value;				
};

class __declspec(dllimport) QMetaObject			
{
public:
    QMetaObject( const char * const class_name, QMetaObject *superclass,
		 const QMetaData * const slot_data, int n_slots,
		 const QMetaData * const signal_data, int n_signals,

		 const QMetaProperty *const prop_data, int n_props,
		 const QMetaEnum *const enum_data, int n_enums,
#line 149 "C:\\qt-3.3.8\\include\\qmetaobject.h"
		 const QClassInfo *const class_info, int n_info );


    QMetaObject( const char * const class_name, QMetaObject *superclass,
		 const QMetaData * const slot_data, int n_slots,
		 const QMetaData * const signal_data, int n_signals,
		 const QMetaProperty *const prop_data, int n_props,
		 const QMetaEnum *const enum_data, int n_enums,
		 bool (*qt_static_property)(QObject*, int, int, QVariant*),
		 const QClassInfo *const class_info, int n_info );
#line 160 "C:\\qt-3.3.8\\include\\qmetaobject.h"


    virtual ~QMetaObject();

    const char	*className()		const { return classname; }
    const char	*superClassName()	const { return superclassname; }

    QMetaObject *superClass()		const { return superclass; }

    bool	inherits( const char* clname ) const;

    int	numSlots( bool super = 0 ) const;
    int		numSignals( bool super = 0 ) const;

    int		findSlot( const char *, bool super = 0 ) const;
    int		findSignal( const char *, bool super = 0 ) const;

    const QMetaData 	*slot( int index, bool super = 0 ) const;
    const QMetaData 	*signal( int index, bool super = 0 ) const;

    QStrList	slotNames( bool super = 0 ) const;
    QStrList	signalNames( bool super = 0 ) const;

    int		slotOffset() const;
    int		signalOffset() const;
    int		propertyOffset() const;

    int		numClassInfo( bool super = 0 ) const;
    const QClassInfo	*classInfo( int index, bool super = 0 ) const;
    const char	*classInfo( const char* name, bool super = 0 ) const;


    const QMetaProperty	*property( int index, bool super = 0 ) const;
    int findProperty( const char *name, bool super = 0 ) const;
    int indexOfProperty( const QMetaProperty*, bool super = 0 ) const;
    const QMetaProperty* resolveProperty( const QMetaProperty* ) const;
    int resolveProperty( int ) const;
    QStrList		propertyNames( bool super = 0 ) const;
    int		numProperties( bool super = 0 ) const;
#line 200 "C:\\qt-3.3.8\\include\\qmetaobject.h"

    
    
    
    static QMetaObject	*new_metaobject( const char *, QMetaObject *,
					const QMetaData *const, int,
					const QMetaData *const, int,

					const QMetaProperty *const prop_data, int n_props,
					const QMetaEnum *const enum_data, int n_enums,
#line 211 "C:\\qt-3.3.8\\include\\qmetaobject.h"
					const QClassInfo *const  class_info, int n_info );

    static QMetaObject	*new_metaobject( const char *, QMetaObject *,
					const QMetaData *const, int,
					const QMetaData *const, int,
					const QMetaProperty *const prop_data, int n_props,
					const QMetaEnum *const enum_data, int n_enums,
					 bool (*qt_static_property)(QObject*, int, int, QVariant*),
					const QClassInfo *const  class_info, int n_info );
    QStrList		enumeratorNames( bool super = 0 ) const;
    int numEnumerators( bool super = 0 ) const;
    const QMetaEnum		*enumerator( const char* name, bool super = 0 ) const;
#line 224 "C:\\qt-3.3.8\\include\\qmetaobject.h"

    static QMetaObject *metaObject( const char *class_name );
    static bool hasMetaObject( const char *class_name );

private:
    QMemberDict		*init( const QMetaData *, int );

    const char		*classname;		
    const char		*superclassname;	
    QMetaObject	*superclass;			
    QMetaObjectPrivate	*d;			
    void	*reserved;			
    const QMetaData		*slotData;	
    QMemberDict	*slotDict;			
    const QMetaData		*signalData;	
    QMemberDict	*signalDict;			
    int signaloffset;
    int slotoffset;

    int propertyoffset;
public:
    bool qt_static_property( QObject* o, int id, int f, QVariant* v);
private:
    friend class QMetaProperty;
#line 249 "C:\\qt-3.3.8\\include\\qmetaobject.h"

private:	



#line 255 "C:\\qt-3.3.8\\include\\qmetaobject.h"
};

inline int QMetaObject::slotOffset() const
{ return slotoffset; }

inline int QMetaObject::signalOffset() const
{ return signaloffset; }


inline int QMetaObject::propertyOffset() const
{ return propertyoffset; }
#line 267 "C:\\qt-3.3.8\\include\\qmetaobject.h"

typedef QMetaObject *(*QtStaticMetaObjectFunction)();

class __declspec(dllimport) QMetaObjectCleanUp
{
public:
    QMetaObjectCleanUp( const char *mo_name, QtStaticMetaObjectFunction );
    QMetaObjectCleanUp();
    ~QMetaObjectCleanUp();

    void setMetaObject( QMetaObject *&mo );

private:
    QMetaObject **metaObject;
};

#line 284 "C:\\qt-3.3.8\\include\\qmetaobject.h"
#line 13 ".\\moc_bbb_GLWidget.cpp"
#line 1 "C:\\qt-3.3.8\\include\\qapplication.h"









































#line 1 "c:\\qt-3.3.8\\include\\qdesktopwidget.h"







































#line 1 "c:\\qt-3.3.8\\include\\qwidget.h"
































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 41 "c:\\qt-3.3.8\\include\\qdesktopwidget.h"
#line 42 "c:\\qt-3.3.8\\include\\qdesktopwidget.h"

class QApplication;
class QDesktopWidgetPrivate; 

class __declspec(dllimport) QDesktopWidget : public QWidget
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QDesktopWidget();
    ~QDesktopWidget();

    bool isVirtualDesktop() const;

    int numScreens() const;
    int primaryScreen() const;

    int screenNumber( QWidget *widget = 0 ) const; 
    int screenNumber( const QPoint & ) const;

    QWidget *screen( int screen = -1 );

    const QRect& screenGeometry( int screen = -1 ) const;
    const QRect& screenGeometry( QWidget *widget ) const
    { return screenGeometry( screenNumber( widget ) ); }
    const QRect& screenGeometry( const QPoint &point ) const
    { return screenGeometry( screenNumber( point ) ); }

    const QRect& availableGeometry( int screen = -1 ) const;
    const QRect& availableGeometry( QWidget *widget ) const
    { return availableGeometry( screenNumber( widget ) ); }
    const QRect& availableGeometry( const QPoint &point ) const
    { return availableGeometry( screenNumber( point ) ); }

    void insertChild( QObject * );

protected:
    void resized( int );
    void workAreaResized( int );

protected:
    void resizeEvent( QResizeEvent *e );

private:
    QDesktopWidgetPrivate *d;




#line 91 "c:\\qt-3.3.8\\include\\qdesktopwidget.h"

    friend class QApplication;



};

#line 99 "c:\\qt-3.3.8\\include\\qdesktopwidget.h"
#line 43 "C:\\qt-3.3.8\\include\\qapplication.h"
#line 1 "c:\\qt-3.3.8\\include\\qasciidict.h"









































#line 1 "c:\\qt-3.3.8\\include\\qgdict.h"









































#line 1 "c:\\qt-3.3.8\\include\\qptrcollection.h"












































































#line 43 "c:\\qt-3.3.8\\include\\qgdict.h"
#line 1 "c:\\qt-3.3.8\\include\\qstring.h"

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 44 "c:\\qt-3.3.8\\include\\qgdict.h"
#line 45 "c:\\qt-3.3.8\\include\\qgdict.h"

class QGDictIterator;
class QGDItList;


class QBaseBucket				
{
public:
    QPtrCollection::Item	 getData()			{ return data; }
    QPtrCollection::Item	 setData( QPtrCollection::Item d ) { return data = d; }
    QBaseBucket		*getNext()			{ return next; }
    void		 setNext( QBaseBucket *n)	{ next = n; }
protected:
    QBaseBucket( QPtrCollection::Item d, QBaseBucket *n ) : data(d), next(n) {}
    QPtrCollection::Item	 data;
    QBaseBucket		*next;
};

class QStringBucket : public QBaseBucket
{
public:
    QStringBucket( const QString &k, QPtrCollection::Item d, QBaseBucket *n )
	: QBaseBucket(d,n), key(k)		{}
    const QString  &getKey() const		{ return key; }
private:
    QString	    key;
};

class QAsciiBucket : public QBaseBucket
{
public:
    QAsciiBucket( const char *k, QPtrCollection::Item d, QBaseBucket *n )
	: QBaseBucket(d,n), key(k) {}
    const char *getKey() const { return key; }
private:
    const char *key;
};

class QIntBucket : public QBaseBucket
{
public:
    QIntBucket( long k, QPtrCollection::Item d, QBaseBucket *n )
	: QBaseBucket(d,n), key(k) {}
    long  getKey() const { return key; }
private:
    long  key;
};

class QPtrBucket : public QBaseBucket
{
public:
    QPtrBucket( void *k, QPtrCollection::Item d, QBaseBucket *n )
	: QBaseBucket(d,n), key(k) {}
    void *getKey() const { return key; }
private:
    void *key;
};


class __declspec(dllimport) QGDict : public QPtrCollection	
{
public:
    uint	count() const	{ return numItems; }
    uint	size()	const	{ return vlen; }
    QPtrCollection::Item look_string( const QString& key, QPtrCollection::Item,
				   int );
    QPtrCollection::Item look_ascii( const char *key, QPtrCollection::Item, int );
    QPtrCollection::Item look_int( long key, QPtrCollection::Item, int );
    QPtrCollection::Item look_ptr( void *key, QPtrCollection::Item, int );

    QDataStream &read( QDataStream & );
    QDataStream &write( QDataStream & ) const;
#line 118 "c:\\qt-3.3.8\\include\\qgdict.h"
protected:
    enum KeyType { StringKey, AsciiKey, IntKey, PtrKey };

    QGDict( uint len, KeyType kt, bool cs, bool ck );
    QGDict( const QGDict & );
   ~QGDict();

    QGDict     &operator=( const QGDict & );

    bool	remove_string( const QString &key, QPtrCollection::Item item=0 );
    bool	remove_ascii( const char *key, QPtrCollection::Item item=0 );
    bool	remove_int( long key, QPtrCollection::Item item=0 );
    bool	remove_ptr( void *key, QPtrCollection::Item item=0 );
    QPtrCollection::Item take_string( const QString &key );
    QPtrCollection::Item take_ascii( const char *key );
    QPtrCollection::Item take_int( long key );
    QPtrCollection::Item take_ptr( void *key );

    void	clear();
    void	resize( uint );

    int		hashKeyString( const QString & );
    int		hashKeyAscii( const char * );

    void	statistics() const;


    virtual QDataStream &read( QDataStream &, QPtrCollection::Item & );
    virtual QDataStream &write( QDataStream &, QPtrCollection::Item ) const;
#line 148 "c:\\qt-3.3.8\\include\\qgdict.h"
private:
    QBaseBucket **vec;
    uint	vlen;
    uint	numItems;
    uint	keytype	: 2;
    uint	cases	: 1;
    uint	copyk	: 1;
    QGDItList  *iterators;
    void	   unlink_common( int, QBaseBucket *, QBaseBucket * );
    QStringBucket *unlink_string( const QString &,
				  QPtrCollection::Item item = 0 );
    QAsciiBucket  *unlink_ascii( const char *, QPtrCollection::Item item = 0 );
    QIntBucket    *unlink_int( long, QPtrCollection::Item item = 0 );
    QPtrBucket    *unlink_ptr( void *, QPtrCollection::Item item = 0 );
    void	init( uint, KeyType, bool, bool );
    friend class QGDictIterator;
};


class __declspec(dllimport) QGDictIterator			
{
friend class QGDict;
public:
    QGDictIterator( const QGDict & );
    QGDictIterator( const QGDictIterator & );
    QGDictIterator &operator=( const QGDictIterator & );
   ~QGDictIterator();

    QPtrCollection::Item toFirst();

    QPtrCollection::Item get()	     const;
    QString	      getKeyString() const;
    const char	     *getKeyAscii()  const;
    long	      getKeyInt()    const;
    void	     *getKeyPtr()    const;

    QPtrCollection::Item operator()();
    QPtrCollection::Item operator++();
    QPtrCollection::Item operator+=(uint);

protected:
    QGDict	     *dict;

private:
    QBaseBucket      *curNode;
    uint	      curIndex;
};

inline QPtrCollection::Item QGDictIterator::get() const
{
    return curNode ? curNode->getData() : 0;
}

inline QString QGDictIterator::getKeyString() const
{
    return curNode ? ((QStringBucket*)curNode)->getKey() : QString::null;
}

inline const char *QGDictIterator::getKeyAscii() const
{
    return curNode ? ((QAsciiBucket*)curNode)->getKey() : 0;
}

inline long QGDictIterator::getKeyInt() const
{
    return curNode ? ((QIntBucket*)curNode)->getKey() : 0;
}

inline void *QGDictIterator::getKeyPtr() const
{
    return curNode ? ((QPtrBucket*)curNode)->getKey() : 0;
}


#line 223 "c:\\qt-3.3.8\\include\\qgdict.h"
#line 43 "c:\\qt-3.3.8\\include\\qasciidict.h"
#line 44 "c:\\qt-3.3.8\\include\\qasciidict.h"

template<class type>
class QAsciiDict



	: public QGDict
#line 52 "c:\\qt-3.3.8\\include\\qasciidict.h"
{
public:
    QAsciiDict(int size=17, bool caseSensitive=1, bool copyKeys=1 )
	: QGDict(size,AsciiKey,caseSensitive,copyKeys) {}
    QAsciiDict( const QAsciiDict<type> &d ) : QGDict(d) {}
   ~QAsciiDict()			{ clear(); }
    QAsciiDict<type> &operator=(const QAsciiDict<type> &d)
			{ return (QAsciiDict<type>&)QGDict::operator=(d); }
    uint  count()   const		{ return QGDict::count(); }
    uint  size()    const		{ return QGDict::size(); }
    bool  isEmpty() const		{ return QGDict::count() == 0; }

    void  insert( const char *k, const type *d )
					{ QGDict::look_ascii(k,(Item)d,1); }
    void  replace( const char *k, const type *d )
					{ QGDict::look_ascii(k,(Item)d,2); }
    bool  remove( const char *k )	{ return QGDict::remove_ascii(k); }
    type *take( const char *k )		{ return (type *)QGDict::take_ascii(k); }
    type *find( const char *k ) const
		{ return (type *)((QGDict*)this)->QGDict::look_ascii(k,0,0); }
    type *operator[]( const char *k ) const
		{ return (type *)((QGDict*)this)->QGDict::look_ascii(k,0,0); }

    void  clear()			{ QGDict::clear(); }
    void  resize( uint n )		{ QGDict::resize(n); }
    void  statistics() const		{ QGDict::statistics(); }







private:
    void  deleteItem( Item d );
};


template<> inline void QAsciiDict<void>::deleteItem( QPtrCollection::Item )
{
}
#line 94 "c:\\qt-3.3.8\\include\\qasciidict.h"

template<class type> inline void QAsciiDict<type>::deleteItem( QPtrCollection::Item d )
{
    if ( del_item ) delete (type *)d;
}

template<class type>
class QAsciiDictIterator : public QGDictIterator
{
public:
    QAsciiDictIterator(const QAsciiDict<type> &d)
	: QGDictIterator((QGDict &)d) {}
   ~QAsciiDictIterator()      {}
    uint  count()   const     { return dict->count(); }
    bool  isEmpty() const     { return dict->count() == 0; }
    type *toFirst()	      { return (type *)QGDictIterator::toFirst(); }
    operator type *() const   { return (type *)QGDictIterator::get(); }
    type   *current() const   { return (type *)QGDictIterator::get(); }
    const char *currentKey() const { return QGDictIterator::getKeyAscii(); }
    type *operator()()	      { return (type *)QGDictIterator::operator()(); }
    type *operator++()	      { return (type *)QGDictIterator::operator++(); }
    type *operator+=(uint j)  { return (type *)QGDictIterator::operator+=(j);}
};


#line 1 "c:\\qt-3.3.8\\include\\qwinexport.h"










































#line 44 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 49 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 54 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 59 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 65 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 70 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 75 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 81 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 87 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 94 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 101 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 106 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 112 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 118 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 124 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 130 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 136 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 141 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 146 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 151 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 156 "c:\\qt-3.3.8\\include\\qwinexport.h"







#line 164 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 170 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 176 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 182 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 187 "c:\\qt-3.3.8\\include\\qwinexport.h"








#line 196 "c:\\qt-3.3.8\\include\\qwinexport.h"





#line 202 "c:\\qt-3.3.8\\include\\qwinexport.h"




#line 207 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 211 "c:\\qt-3.3.8\\include\\qwinexport.h"






#line 218 "c:\\qt-3.3.8\\include\\qwinexport.h"



#line 222 "c:\\qt-3.3.8\\include\\qwinexport.h"
#line 120 "c:\\qt-3.3.8\\include\\qasciidict.h"
#line 121 "c:\\qt-3.3.8\\include\\qasciidict.h"
#line 44 "C:\\qt-3.3.8\\include\\qapplication.h"
#line 1 "c:\\qt-3.3.8\\include\\qpalette.h"


























































































































































































#line 45 "C:\\qt-3.3.8\\include\\qapplication.h"
#line 1 "c:\\qt-3.3.8\\include\\qtranslator.h"










































#line 1 "c:\\qt-3.3.8\\include\\qobject.h"



































































































































































































































































#line 44 "c:\\qt-3.3.8\\include\\qtranslator.h"
#line 1 "c:\\qt-3.3.8\\include\\qvaluelist.h"


























































































































































































































































































































































































































































































































































































































































































#line 45 "c:\\qt-3.3.8\\include\\qtranslator.h"
#line 46 "c:\\qt-3.3.8\\include\\qtranslator.h"



class QTranslatorPrivate;

class __declspec(dllimport) QTranslatorMessage
{
public:
    QTranslatorMessage();
    QTranslatorMessage( const char * context,
			const char * sourceText,
			const char * comment,
			const QString& translation = QString::null );
    QTranslatorMessage( QDataStream & );
    QTranslatorMessage( const QTranslatorMessage & m );

    QTranslatorMessage & operator=( const QTranslatorMessage & m );

    uint hash() const { return h; }
    const char *context() const { return cx; }
    const char *sourceText() const { return st; }
    const char *comment() const { return cm; }

    void setTranslation( const QString & translation ) { tn = translation; }
    QString translation() const { return tn; }

    enum Prefix { NoPrefix, Hash, HashContext, HashContextSourceText,
		  HashContextSourceTextComment };
    void write( QDataStream & s, bool strip = 0,
		Prefix prefix = HashContextSourceTextComment ) const;
    Prefix commonPrefix( const QTranslatorMessage& ) const;

    bool operator==( const QTranslatorMessage& m ) const;
    bool operator!=( const QTranslatorMessage& m ) const
    { return !operator==( m ); }
    bool operator<( const QTranslatorMessage& m ) const;
    bool operator<=( const QTranslatorMessage& m ) const
    { return !m.operator<( *this ); }
    bool operator>( const QTranslatorMessage& m ) const
    { return m.operator<( *this ); }
    bool operator>=( const QTranslatorMessage& m ) const
    { return !operator<( m ); }

private:
    uint h;
    QCString cx;
    QCString st;
    QCString cm;
    QString tn;

    enum Tag { Tag_End = 1, Tag_SourceText16, Tag_Translation, Tag_Context16,
	       Tag_Hash, Tag_SourceText, Tag_Context, Tag_Comment,
	       Tag_Obsolete1 };
};


class __declspec(dllimport) QTranslator: public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QTranslator( QObject * parent = 0, const char * name = 0 );
    ~QTranslator();


    QString find( const char *context, const char *sourceText, const char * comment = 0 ) const {
	return findMessage( context, sourceText, comment ).translation();
    }
#line 114 "c:\\qt-3.3.8\\include\\qtranslator.h"
    virtual QTranslatorMessage findMessage( const char *, const char *,
					    const char * = 0 ) const;

    bool load( const QString & filename,
	       const QString & directory = QString::null,
	       const QString & search_delimiters = QString::null,
	       const QString & suffix = QString::null );
    bool load( const uchar *data, int len ) {
	clear();
	return do_load( data, len );
    }

    void clear();


    enum SaveMode { Everything, Stripped };

    bool save( const QString & filename, SaveMode mode = Everything );

    void insert( const QTranslatorMessage& );
    void insert( const char *context, const char *sourceText, const QString &translation ) {
	insert( QTranslatorMessage(context, sourceText, "", translation) );
    }
    void remove( const QTranslatorMessage& );
    void remove( const char *context, const char *sourceText ) {
	remove( QTranslatorMessage(context, sourceText, "") );
    }
    bool contains( const char *, const char *, const char * comment = 0 ) const;

    void squeeze( SaveMode = Everything );
    void unsqueeze();

    QValueList<QTranslatorMessage> messages() const;
#line 148 "c:\\qt-3.3.8\\include\\qtranslator.h"

    bool isEmpty() const;

private:



#line 156 "c:\\qt-3.3.8\\include\\qtranslator.h"

    bool do_load( const uchar *data, int len );

    QTranslatorPrivate * d;
};

#line 163 "c:\\qt-3.3.8\\include\\qtranslator.h"

#line 165 "c:\\qt-3.3.8\\include\\qtranslator.h"
#line 46 "C:\\qt-3.3.8\\include\\qapplication.h"
#line 1 "c:\\qt-3.3.8\\include\\qstrlist.h"










































































































#line 47 "C:\\qt-3.3.8\\include\\qapplication.h"
#line 1 "c:\\qt-3.3.8\\include\\qstringlist.h"







































































































#line 48 "C:\\qt-3.3.8\\include\\qapplication.h"
#line 49 "C:\\qt-3.3.8\\include\\qapplication.h"

class QSessionManager;
class QStyle;
class QTranslator;
class QEventLoop;


#line 57 "C:\\qt-3.3.8\\include\\qapplication.h"


class QMutex;
#line 61 "C:\\qt-3.3.8\\include\\qapplication.h"


class QApplication;
extern __declspec(dllimport) QApplication *qApp;		


class __declspec(dllimport) QApplication : public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QApplication( int &argc, char **argv );
    QApplication( int &argc, char **argv, bool GUIenabled );
    enum Type { Tty, GuiClient, GuiServer };
    QApplication( int &argc, char **argv, Type );




#line 80 "C:\\qt-3.3.8\\include\\qapplication.h"
    virtual ~QApplication();

    int		    argc()	const;
    char	  **argv()	const;

    Type type() const;


    static QStyle  &style();
    static void	    setStyle( QStyle* );
    static QStyle*  setStyle( const QString& );
#line 92 "C:\\qt-3.3.8\\include\\qapplication.h"

    enum ColorMode { NormalColors, CustomColors };
    static ColorMode colorMode();
    static void      setColorMode( QApplication::ColorMode );
#line 97 "C:\\qt-3.3.8\\include\\qapplication.h"

    enum ColorSpec { NormalColor=0, CustomColor=1, ManyColor=2 };
    static int	     colorSpec();
    static void      setColorSpec( int );

    static QCursor  *overrideCursor();
    static void	     setOverrideCursor( const QCursor &, bool replace=0 );
    static void	     restoreOverrideCursor();
#line 106 "C:\\qt-3.3.8\\include\\qapplication.h"
    static bool	     hasGlobalMouseTracking();
    static void	     setGlobalMouseTracking( bool enable );

    static QPalette  palette( const QWidget* = 0 );
    static void	     setPalette( const QPalette &, bool informWidgets=0,
				 const char* className = 0 );
#line 113 "C:\\qt-3.3.8\\include\\qapplication.h"
    static QFont     font( const QWidget* = 0 );
    static void	     setFont( const QFont &, bool informWidgets=0,
			      const char* className = 0 );
    static QFontMetrics fontMetrics();

    QWidget	    *mainWidget()  const;
    virtual void     setMainWidget( QWidget * );
    virtual void     polish( QWidget * );

    static QWidgetList *allWidgets();
    static QWidgetList *topLevelWidgets();

    static QDesktopWidget   *desktop();

    static QWidget     *activePopupWidget();
    static QWidget     *activeModalWidget();

    static QClipboard  *clipboard();
#line 132 "C:\\qt-3.3.8\\include\\qapplication.h"
    QWidget	       *focusWidget() const;
    QWidget	       *activeWindow() const;

    static QWidget  *widgetAt( int x, int y, bool child=0 );
    static QWidget  *widgetAt( const QPoint &, bool child=0 );

    static QEventLoop *eventLoop();

    int		     exec();
    void	     processEvents();
    void	     processEvents( int maxtime );
    void	     processOneEvent();
    bool	     hasPendingEvents();
    int		     enter_loop();
    void	     exit_loop();
    int		     loopLevel() const;
    static void	     exit( int retcode=0 );

    static bool	     sendEvent( QObject *receiver, QEvent *event );
    static void	     postEvent( QObject *receiver, QEvent *event );
    static void	     sendPostedEvents( QObject *receiver, int event_type );
    static void	     sendPostedEvents();

    static void      removePostedEvents( QObject *receiver );

    virtual bool     notify( QObject *, QEvent * );

    static bool	     startingUp();
    static bool	     closingDown();

    static void	     flushX();
    static void flush();
    static void	     syncX();

    static void	     beep();



    void	     setDefaultCodec( QTextCodec * );
    QTextCodec*	     defaultCodec() const;
#line 173 "C:\\qt-3.3.8\\include\\qapplication.h"
    void	     installTranslator( QTranslator * );
    void	     removeTranslator( QTranslator * );
#line 176 "C:\\qt-3.3.8\\include\\qapplication.h"
    enum Encoding { DefaultCodec, UnicodeUTF8 };
    QString	     translate( const char * context,
				const char * key,
				const char * comment = 0,
				Encoding encoding = DefaultCodec ) const;

    QString   applicationDirPath();
    QString   applicationFilePath();
#line 185 "C:\\qt-3.3.8\\include\\qapplication.h"

    
    static void      setWinStyleHighlightColor( const QColor &c ) {
	QPalette p( palette() );
	p.setColor( QColorGroup::Highlight, c );
	setPalette( p, 1);
    }
    static const QColor &winStyleHighlightColor() {
	return palette().active().highlight();
    }
#line 196 "C:\\qt-3.3.8\\include\\qapplication.h"
    static void      setDesktopSettingsAware( bool );
    static bool      desktopSettingsAware();

    static void      setCursorFlashTime( int );
    static int       cursorFlashTime();

    static void      setDoubleClickInterval( int );
    static int       doubleClickInterval();

    static void      setWheelScrollLines( int );
    static int       wheelScrollLines();
#line 208 "C:\\qt-3.3.8\\include\\qapplication.h"
    static void	     setGlobalStrut( const QSize & );



    static QSize     globalStrut();
#line 214 "C:\\qt-3.3.8\\include\\qapplication.h"


    static void      setLibraryPaths( const QStringList & );
    static QStringList libraryPaths();
    static void      addLibraryPath( const QString & );
    static void      removeLibraryPath( const QString & );
#line 221 "C:\\qt-3.3.8\\include\\qapplication.h"
    static void setStartDragTime( int ms );
    static int startDragTime();
    static void setStartDragDistance( int l );
    static int startDragDistance();

    static void setReverseLayout( bool b );
    static bool reverseLayout();

    static int horizontalAlignment( int align );

    static bool	    isEffectEnabled( Qt::UIEffect );
    static void	    setEffectEnabled( Qt::UIEffect, bool enable = 1 );



#line 237 "C:\\qt-3.3.8\\include\\qapplication.h"

    virtual bool     winEventFilter( MSG * );
#line 240 "C:\\qt-3.3.8\\include\\qapplication.h"




#line 245 "C:\\qt-3.3.8\\include\\qapplication.h"













#line 259 "C:\\qt-3.3.8\\include\\qapplication.h"


    static WindowsVersion winVersion();


#line 265 "C:\\qt-3.3.8\\include\\qapplication.h"

    void	     winFocus( QWidget *, bool );
    static void	     winMouseButtonUp();
#line 269 "C:\\qt-3.3.8\\include\\qapplication.h"


    
    bool	     isSessionRestored() const;
    QString 	sessionId() const;
    QString 	sessionKey() const;
    virtual void     commitData( QSessionManager& sm );
    virtual void     saveState( QSessionManager& sm );
#line 278 "C:\\qt-3.3.8\\include\\qapplication.h"




#line 283 "C:\\qt-3.3.8\\include\\qapplication.h"
    void	     wakeUpGuiThread();

    void	     lock();
    void	     unlock(bool wakeUpGui = 1);
    bool	     locked();
    bool             tryLock();
#line 290 "C:\\qt-3.3.8\\include\\qapplication.h"

protected:
    void	     lastWindowClosed();
    void	     aboutToQuit();
    void	     guiThreadAwake();

public :
    void	     quit();
    void	     closeAllWindows();
    void	     aboutQt();




#line 305 "C:\\qt-3.3.8\\include\\qapplication.h"

protected:
    bool event(QEvent *);

private:
    void construct( int &argc, char **argv, Type );
    void initialize( int, char ** );
    void init_precmdline();
    void process_cmdline( int* argcptr, char ** argv );
    bool internalNotify( QObject *, QEvent * );



#line 319 "C:\\qt-3.3.8\\include\\qapplication.h"














#line 334 "C:\\qt-3.3.8\\include\\qapplication.h"


    static QMutex   *qt_mutex;
#line 338 "C:\\qt-3.3.8\\include\\qapplication.h"

    int		     app_argc;
    char	   **app_argv;
    bool	     quit_now;
    int		     quit_code;
    static QStyle   *app_style;
    static int	     app_cspec;

    static QPalette *app_pal;
#line 348 "C:\\qt-3.3.8\\include\\qapplication.h"
    static QFont    *app_font;

    static QCursor  *app_cursor;
#line 352 "C:\\qt-3.3.8\\include\\qapplication.h"
    static QEventLoop* eventloop;
    static int	     app_tracking;
    static bool	     is_app_running;
    static bool	     is_app_closing;
    static bool	     app_exit_loop;
    static int	     loop_level;
    static QWidget  *main_widget;
    static QWidget  *focus_widget;
    static QWidget  *active_window;
    static bool	     obey_desktop_settings;
    static int	     cursor_flash_time;
    static int	     mouse_double_click_time;
    static int	     wheel_scroll_lines;
    static int	     composedUnicode; 

    static bool	     animate_ui;
    static bool	     animate_menu;
    static bool	     animate_tooltip;
    static bool	     animate_combo;
    static bool	     fade_menu;
    static bool	     fade_tooltip;
    static bool	     animate_toolbox;
    static bool	     widgetCount; 
    static bool	     metaComposeUnicode;

    QValueList<QTranslator*> *translators;

    QSessionManager *session_manager;
    QString	     session_id;
    static QString* session_key;
    bool	     is_session_restored;
#line 384 "C:\\qt-3.3.8\\include\\qapplication.h"


#line 387 "C:\\qt-3.3.8\\include\\qapplication.h"

    static QSize     app_strut;

    static QStringList *app_libpaths;
#line 392 "C:\\qt-3.3.8\\include\\qapplication.h"
    static QAsciiDict<QPalette> *app_palettes;
    static QAsciiDict<QFont>    *app_fonts;

    static QWidgetList *popupWidgets;
    bool	     inPopupMode() const;
    void	     closePopup( QWidget *popup );
    void	     openPopup( QWidget *popup );
    void	     setActiveWindow( QWidget* act );

    static bool      sendSpontaneousEvent( QObject *receiver, QEvent *event );
    static void      removePostedEvent( QEvent * );

    friend class QWidget;
    friend class QETWidget;
    friend class QDialog;
    friend class QAccelManager;
    friend class QEvent;
    friend class QTranslator;
    friend class QEventLoop;
    friend __declspec(dllimport) void qt_ucm_initialize( QApplication * );

    friend bool qt_sendSpontaneousEvent( QObject*, QEvent* );
#line 415 "C:\\qt-3.3.8\\include\\qapplication.h"


#line 418 "C:\\qt-3.3.8\\include\\qapplication.h"
private: 



#line 423 "C:\\qt-3.3.8\\include\\qapplication.h"
};

inline int QApplication::argc() const
{
    return app_argc;
}

inline char **QApplication::argv() const
{
    return app_argv;
}







#line 442 "C:\\qt-3.3.8\\include\\qapplication.h"


inline QCursor *QApplication::overrideCursor()
{
    return app_cursor;
}
#line 449 "C:\\qt-3.3.8\\include\\qapplication.h"
inline bool QApplication::hasGlobalMouseTracking()
{
    return app_tracking > 0;
}

inline QWidget *QApplication::mainWidget() const
{
    return main_widget;
}

inline QWidget *QApplication::focusWidget() const
{
    return focus_widget;
}

inline QWidget *QApplication::activeWindow() const
{
    return active_window;
}

inline QWidget *QApplication::widgetAt( const QPoint &p, bool child )
{
    return widgetAt( p.x(), p.y(), child );
}

inline bool QApplication::inPopupMode() const
{
    return popupWidgets != 0;
}

inline bool QApplication::isSessionRestored() const
{
    return is_session_restored;
}

inline QString QApplication::sessionId() const
{
    return session_id;
}

inline QString QApplication::sessionKey() const
{
    return session_key ? *session_key : QString::null;
}
#line 494 "C:\\qt-3.3.8\\include\\qapplication.h"

inline QSize QApplication::globalStrut()
{
    return app_strut;
}
#line 500 "C:\\qt-3.3.8\\include\\qapplication.h"

inline bool QApplication::sendEvent( QObject *receiver, QEvent *event )
{  if ( event ) event->spont = 0; return qApp ? qApp->notify( receiver, event ) : 0; }

inline bool QApplication::sendSpontaneousEvent( QObject *receiver, QEvent *event )
{ if ( event ) event->spont = 1; return qApp ? qApp->notify( receiver, event ) : 0; }















inline int QApplication::horizontalAlignment( int align )
{
    align &= AlignHorizontal_Mask;
    if ( align == AlignAuto ) {
	if ( reverseLayout() )
	    align = AlignRight;
	else
	    align = AlignLeft;
    }
    return align;
}

#line 534 "C:\\qt-3.3.8\\include\\qapplication.h"

#line 14 ".\\moc_bbb_GLWidget.cpp"

#line 1 "C:\\qt-3.3.8\\include\\private/qucomextra_p.h"





















































#line 1 "C:\\qt-3.3.8\\include\\private/qucom_p.h"





















































#line 1 "C:\\qt-3.3.8\\include\\qstring.h"

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 55 "C:\\qt-3.3.8\\include\\private/qucom_p.h"
#line 1 "C:\\qt-3.3.8\\include\\quuid.h"









































#line 1 "c:\\qt-3.3.8\\include\\qstring.h"

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 43 "C:\\qt-3.3.8\\include\\quuid.h"
#line 44 "C:\\qt-3.3.8\\include\\quuid.h"














#line 59 "C:\\qt-3.3.8\\include\\quuid.h"


struct __declspec(dllimport) QUuid
{
    enum Variant {
	VarUnknown	=-1,
	NCS		= 0, 
	DCE		= 2, 
	Microsoft	= 6, 
	Reserved	= 7  
    };

    enum Version {
	VerUnknown	=-1,
	Time		= 1, 
	EmbeddedPOSIX	= 2, 
	Name		= 3, 
	Random		= 4  
    };

    QUuid()
    {
	memset( this, 0, sizeof(QUuid) );
    }
    QUuid( uint l, ushort w1, ushort w2, uchar b1, uchar b2, uchar b3, uchar b4, uchar b5, uchar b6, uchar b7, uchar b8 )
    {
	data1 = l;
	data2 = w1;
	data3 = w2;
	data4[0] = b1;
	data4[1] = b2;
	data4[2] = b3;
	data4[3] = b4;
	data4[4] = b5;
	data4[5] = b6;
	data4[6] = b7;
	data4[7] = b8;
    }
    QUuid( const QUuid &uuid )
    {
	memcpy( this, &uuid, sizeof(QUuid) );
    }

    QUuid( const QString & );
    QUuid( const char * );
    QString toString() const;
    operator QString() const { return toString(); }
#line 107 "C:\\qt-3.3.8\\include\\quuid.h"
    bool isNull() const;

    QUuid &operator=(const QUuid &orig )
    {
	memcpy( this, &orig, sizeof(QUuid) );
	return *this;
    }

    bool operator==(const QUuid &orig ) const
    {
	uint i;
	if ( data1 != orig.data1 || data2 != orig.data2 || 
	     data3 != orig.data3 )
	    return 0;

	for( i = 0; i < 8; i++ )
	    if ( data4[i] != orig.data4[i] )
		return 0;
	
	return 1;
    }

    bool operator!=(const QUuid &orig ) const
    {
	return !( *this == orig );
    }

    bool operator<(const QUuid &other ) const;
    bool operator>(const QUuid &other ) const;


    
    
    QUuid( const GUID &guid )
    {
	memcpy( this, &guid, sizeof(GUID) );
    }

    QUuid &operator=(const GUID &orig )
    {
	memcpy( this, &orig, sizeof(QUuid) );
	return *this;
    }

    operator GUID() const
    {
	GUID guid = { data1, data2, data3, { data4[0], data4[1], data4[2], data4[3], data4[4], data4[5], data4[6], data4[7] } };
	return guid;
    }

    bool operator==( const GUID &guid ) const
    {
	uint i;
	if ( data1 != guid.Data1 || data2 != guid.Data2 || 
	     data3 != guid.Data3 )
	    return 0;

	for( i = 0; i < 8; i++ )
	    if ( data4[i] != guid.Data4[i] )
		return 0;
	
	return 1;
    }

    bool operator!=( const GUID &guid ) const
    {
	return !( *this == guid );
    }
#line 176 "C:\\qt-3.3.8\\include\\quuid.h"
    static QUuid createUuid();
    QUuid::Variant variant() const;
    QUuid::Version version() const;

    uint    data1;
    ushort  data2;
    ushort  data3;
    uchar   data4[ 8 ];
};


__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QUuid & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QUuid & );
#line 190 "C:\\qt-3.3.8\\include\\quuid.h"

#line 192 "C:\\qt-3.3.8\\include\\quuid.h"
#line 56 "C:\\qt-3.3.8\\include\\private/qucom_p.h"
#line 57 "C:\\qt-3.3.8\\include\\private/qucom_p.h"







#line 65 "C:\\qt-3.3.8\\include\\private/qucom_p.h"

struct QUObject;
struct QUInterfaceDescription;
struct QUnknownInterface;
struct QDispatchInterface;


struct __declspec(dllimport) QUBuffer
{
    virtual long read( char *data, ulong maxlen ) = 0;
    virtual long write( const char *data, ulong len ) = 0;
};



struct __declspec(dllimport) QUType
{
    virtual const QUuid *uuid() const = 0;
    virtual const char *desc() const = 0;


    virtual bool canConvertFrom( QUObject *, QUType * ) = 0;
    
    virtual bool canConvertTo( QUObject *, QUType * ) = 0;


    virtual bool convertFrom( QUObject *, QUType * ) = 0;
    
    virtual bool convertTo( QUObject *, QUType * ) = 0;

    virtual void clear( QUObject * ) = 0;

    virtual int serializeTo( QUObject *, QUBuffer * ) = 0;
    virtual int serializeFrom( QUObject *, QUBuffer * ) = 0;

    static bool isEqual( const QUType *t1, const QUType *t2 );
    static bool check( QUObject* o, QUType* t );
};



extern __declspec(dllimport) const QUuid TID_QUType_Null;
struct __declspec(dllimport) QUType_Null : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * );
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern __declspec(dllimport) QUType_Null static_QUType_Null;



struct __declspec(dllimport) QUObject
{
public: 
    QUObject() : type( &static_QUType_Null ) {}
    ~QUObject() { type->clear( this ); }

    QUType *type;

    
    union
    {
	bool b;

	char c;
	short s;
	int i;
	long l;

	unsigned char uc;
	unsigned short us;
	unsigned int ui;
	unsigned long ul;

	float f;
	double d;

	char byte[16];

	struct {
	   char* data;
	   unsigned long size;
	} bytearray;

	void* ptr;

	struct {
	    void *ptr;
	    bool owner;
	} voidstar;

	struct {
	    char *ptr;
	    bool owner;
	} charstar;

	struct {
	    char *ptr;
	    bool owner;
	} utf8;

	struct {
	    char *ptr;
	    bool owner;
	} local8bit;

	QUnknownInterface* iface;
	QDispatchInterface* idisp;

    } payload;

};





struct __declspec(dllimport) QUParameter
{
    const char* name;
    QUType *type;
    const void* typeExtra; 
    enum { In = 1, Out = 2, InOut = In | Out };
    int inOut;
};



struct __declspec(dllimport) QUMethod
{
    const char* name;
    int count;
    const QUParameter* parameters;
};


struct __declspec(dllimport) QUProperty
{
    const char* name;
    QUType* type;
    const void* typeExtra; 

    int set; 
    int get; 

    int designable; 
    int stored; 
};



struct __declspec(dllimport) QUInterfaceDescription
{
    int methodCount;
    const QUMethod* methods;
    int propertyCount;
    const QUProperty* properties;
};





struct __declspec(dllimport) QUComponentDescription
{
    const char* name;
    const char* vendor;
    const char* release;
    const char* info;
    QUuid cid;
    int count;
    const QUuid* interfaces;
};





struct __declspec(dllimport) QUComponentServerDescription
{
    const char* name;
    const char* vendor;
    const char* release;
    const char* info;
    int count;
    const QUComponentDescription* components;
};



struct __declspec(dllimport) QUEnumItem 				
{
    const char *key;
    int value;
};

struct __declspec(dllimport) QUEnum
{
    const char *name;			
    unsigned int count;			
    const QUEnumItem *items;		
    bool set;				
};

inline bool QUType::isEqual( const QUType *t1, const QUType *t2 ) {
    return t1 == t2 || t1->uuid() == t2->uuid() ||
	*(t1->uuid()) == *(t2->uuid());
}

inline bool QUType::check( QUObject* o, QUType* t ) {
    return isEqual( o->type, t ) || t->convertFrom( o, o->type );
}




extern __declspec(dllimport) const QUuid TID_QUType_enum;
struct __declspec(dllimport) QUType_enum : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, int );
    int &get( QUObject * o ) { return o->payload.i; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern __declspec(dllimport) QUType_enum static_QUType_enum;



extern __declspec(dllimport) const QUuid TID_QUType_ptr;
struct __declspec(dllimport) QUType_ptr : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, const void* );
    void* &get( QUObject * o ) { return o->payload.ptr; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern __declspec(dllimport) QUType_ptr static_QUType_ptr;


extern __declspec(dllimport) const QUuid TID_QUType_iface;
struct __declspec(dllimport) QUType_iface : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, QUnknownInterface* );
    QUnknownInterface* &get( QUObject *o ){ return o->payload.iface; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern __declspec(dllimport) QUType_iface static_QUType_iface;


extern __declspec(dllimport) const QUuid TID_QUType_idisp;
struct __declspec(dllimport) QUType_idisp : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, QDispatchInterface* );
    QDispatchInterface* &get( QUObject *o ){ return o->payload.idisp; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern __declspec(dllimport) QUType_idisp static_QUType_idisp;


extern __declspec(dllimport) const QUuid TID_QUType_bool;
struct __declspec(dllimport) QUType_bool : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, bool );
    bool &get( QUObject *o ) { return o->payload.b; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern __declspec(dllimport) QUType_bool static_QUType_bool;


extern __declspec(dllimport) const QUuid TID_QUType_int;
struct __declspec(dllimport) QUType_int : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, int );
    int &get( QUObject *o ) { return o->payload.i; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern __declspec(dllimport) QUType_int static_QUType_int;



extern __declspec(dllimport) const QUuid TID_QUType_double;
struct __declspec(dllimport) QUType_double : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, double );
    double &get( QUObject *o ) { return o->payload.d; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern __declspec(dllimport) QUType_double static_QUType_double;



extern __declspec(dllimport) const QUuid TID_QUType_charstar;
struct __declspec(dllimport) QUType_charstar : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, const char*, bool take = 0 );
    char* get( QUObject *o ){ return o->payload.charstar.ptr; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * );
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );

};
extern __declspec(dllimport) QUType_charstar static_QUType_charstar;


extern const QUuid TID_QUType_QString;

struct __declspec(dllimport) QUType_QString : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, const QString & );
    QString &get( QUObject * o ) { return *(QString*)o->payload.ptr; }

    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * );
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );

};
extern __declspec(dllimport) QUType_QString static_QUType_QString;


#line 468 "C:\\qt-3.3.8\\include\\private/qucom_p.h"
#line 55 "C:\\qt-3.3.8\\include\\private/qucomextra_p.h"
#line 56 "C:\\qt-3.3.8\\include\\private/qucomextra_p.h"



#line 60 "C:\\qt-3.3.8\\include\\private/qucomextra_p.h"

class QVariant;



extern const QUuid TID_QUType_QVariant;

struct __declspec(dllimport) QUType_QVariant : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, const QVariant & );
    QVariant &get( QUObject * o );

    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * );
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern __declspec(dllimport) QUType_QVariant static_QUType_QVariant;
#line 85 "C:\\qt-3.3.8\\include\\private/qucomextra_p.h"



extern __declspec(dllimport) const QUuid TID_QUType_varptr;
struct __declspec(dllimport) QUType_varptr : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, const void* );
    void* &get( QUObject * o ) { return o->payload.ptr; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern __declspec(dllimport) QUType_varptr static_QUType_varptr;


#line 108 "C:\\qt-3.3.8\\include\\private/qucomextra_p.h"

#line 16 ".\\moc_bbb_GLWidget.cpp"




#line 21 ".\\moc_bbb_GLWidget.cpp"

const char *BBB_GLWidget::className() const
{
    return "BBB_GLWidget";
}

QMetaObject *BBB_GLWidget::metaObj = 0;
static QMetaObjectCleanUp cleanUp_BBB_GLWidget( "BBB_GLWidget", &BBB_GLWidget::staticMetaObject );


QString BBB_GLWidget::tr( const char *s, const char *c )
{
    if ( qApp )
	return qApp->translate( "BBB_GLWidget", s, c, QApplication::DefaultCodec );
    else
	return QString::fromLatin1( s );
}

QString BBB_GLWidget::trUtf8( const char *s, const char *c )
{
    if ( qApp )
	return qApp->translate( "BBB_GLWidget", s, c, QApplication::UnicodeUTF8 );
    else
	return QString::fromUtf8( s );
}
#line 47 ".\\moc_bbb_GLWidget.cpp"

#line 49 ".\\moc_bbb_GLWidget.cpp"

QMetaObject* BBB_GLWidget::staticMetaObject()
{
    if ( metaObj )
	return metaObj;
    QMetaObject* parentObject = QGLWidget::staticMetaObject();
    static const QUMethod slot_0 = {"rebuildBricks", 0, 0 };
    static const QUMethod slot_1 = {"resizeWall", 0, 0 };
    static const QUMethod slot_2 = {"resizeColumns", 0, 0 };
    static const QUMethod slot_3 = {"resizePadding", 0, 0 };
    static const QUMethod slot_4 = {"cantileverPattern", 0, 0 };
    static const QUParameter param_slot_5[] = {
	{ "col", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod slot_5 = {"cantileverPattern", 1, param_slot_5 };
    static const QUMethod slot_6 = {"activateBricks", 0, 0 };
    static const QUMethod slot_7 = {"clearActiveBricks", 0, 0 };
    static const QUMethod slot_8 = {"randomActiveBricks", 0, 0 };
    static const QUMethod slot_9 = {"generatePattern", 0, 0 };
    static const QUMethod slot_10 = {"clearPattern", 0, 0 };
    static const QUMethod slot_11 = {"clearRules", 0, 0 };
    static const QUMethod slot_12 = {"generateBeams", 0, 0 };
    static const QUMethod slot_13 = {"clearBeams", 0, 0 };
    static const QUParameter param_slot_14[] = {
	{ "index", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod slot_14 = {"clearColumn", 1, param_slot_14 };
    static const QUMethod slot_15 = {"toggleGrid", 0, 0 };
    static const QUMethod slot_16 = {"toggleBorders", 0, 0 };
    static const QUMethod slot_17 = {"showInactive", 0, 0 };
    static const QUMethod slot_18 = {"toggleOffset", 0, 0 };
    static const QUMethod slot_19 = {"invertActive", 0, 0 };
    static const QUMethod slot_20 = {"zoomExtents", 0, 0 };
    static const QUMethod slot_21 = {"resetAll", 0, 0 };
    static const QUMethod slot_22 = {"takeScreenshot", 0, 0 };
    static const QUParameter param_slot_23[] = {
	{ 0, &static_QUType_bool, 0, QUParameter::Out }
    };
    static const QUMethod slot_23 = {"importPath", 1, param_slot_23 };
    static const QUParameter param_slot_24[] = {
	{ 0, &static_QUType_bool, 0, QUParameter::Out },
	{ "filename", &static_QUType_charstar, 0, QUParameter::In }
    };
    static const QUMethod slot_24 = {"importPath", 2, param_slot_24 };
    static const QUParameter param_slot_25[] = {
	{ 0, &static_QUType_bool, 0, QUParameter::Out }
    };
    static const QUMethod slot_25 = {"savePattern", 1, param_slot_25 };
    static const QUParameter param_slot_26[] = {
	{ 0, &static_QUType_bool, 0, QUParameter::Out }
    };
    static const QUMethod slot_26 = {"loadPattern", 1, param_slot_26 };
    static const QUParameter param_slot_27[] = {
	{ 0, &static_QUType_bool, 0, QUParameter::Out }
    };
    static const QUMethod slot_27 = {"exportToObj", 1, param_slot_27 };
    static const QUParameter param_slot_28[] = {
	{ 0, &static_QUType_bool, 0, QUParameter::Out }
    };
    static const QUMethod slot_28 = {"exportToRLE", 1, param_slot_28 };
    static const QUParameter param_slot_29[] = {
	{ 0, &static_QUType_bool, 0, QUParameter::Out }
    };
    static const QUMethod slot_29 = {"exportToMP3", 1, param_slot_29 };
    static const QMetaData slot_tbl[] = {
	{ "rebuildBricks()", &slot_0, QMetaData::Public },
	{ "resizeWall()", &slot_1, QMetaData::Public },
	{ "resizeColumns()", &slot_2, QMetaData::Public },
	{ "resizePadding()", &slot_3, QMetaData::Public },
	{ "cantileverPattern()", &slot_4, QMetaData::Public },
	{ "cantileverPattern(int)", &slot_5, QMetaData::Public },
	{ "activateBricks()", &slot_6, QMetaData::Public },
	{ "clearActiveBricks()", &slot_7, QMetaData::Public },
	{ "randomActiveBricks()", &slot_8, QMetaData::Public },
	{ "generatePattern()", &slot_9, QMetaData::Public },
	{ "clearPattern()", &slot_10, QMetaData::Public },
	{ "clearRules()", &slot_11, QMetaData::Public },
	{ "generateBeams()", &slot_12, QMetaData::Public },
	{ "clearBeams()", &slot_13, QMetaData::Public },
	{ "clearColumn(int)", &slot_14, QMetaData::Public },
	{ "toggleGrid()", &slot_15, QMetaData::Public },
	{ "toggleBorders()", &slot_16, QMetaData::Public },
	{ "showInactive()", &slot_17, QMetaData::Public },
	{ "toggleOffset()", &slot_18, QMetaData::Public },
	{ "invertActive()", &slot_19, QMetaData::Public },
	{ "zoomExtents()", &slot_20, QMetaData::Public },
	{ "resetAll()", &slot_21, QMetaData::Public },
	{ "takeScreenshot()", &slot_22, QMetaData::Public },
	{ "importPath()", &slot_23, QMetaData::Public },
	{ "importPath(char*)", &slot_24, QMetaData::Public },
	{ "savePattern()", &slot_25, QMetaData::Public },
	{ "loadPattern()", &slot_26, QMetaData::Public },
	{ "exportToObj()", &slot_27, QMetaData::Public },
	{ "exportToRLE()", &slot_28, QMetaData::Public },
	{ "exportToMP3()", &slot_29, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
	"BBB_GLWidget", parentObject,
	slot_tbl, 30,
	0, 0,

	0, 0,
	0, 0,
#line 153 ".\\moc_bbb_GLWidget.cpp"
	0, 0 );
    cleanUp_BBB_GLWidget.setMetaObject( metaObj );
    return metaObj;
}

void* BBB_GLWidget::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "BBB_GLWidget" ) )
	return this;
    return QGLWidget::qt_cast( clname );
}

bool BBB_GLWidget::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: rebuildBricks(); break;
    case 1: resizeWall(); break;
    case 2: resizeColumns(); break;
    case 3: resizePadding(); break;
    case 4: cantileverPattern(); break;
    case 5: cantileverPattern((int)static_QUType_int.get(_o+1)); break;
    case 6: activateBricks(); break;
    case 7: clearActiveBricks(); break;
    case 8: randomActiveBricks(); break;
    case 9: generatePattern(); break;
    case 10: clearPattern(); break;
    case 11: clearRules(); break;
    case 12: generateBeams(); break;
    case 13: clearBeams(); break;
    case 14: clearColumn((int)static_QUType_int.get(_o+1)); break;
    case 15: toggleGrid(); break;
    case 16: toggleBorders(); break;
    case 17: showInactive(); break;
    case 18: toggleOffset(); break;
    case 19: invertActive(); break;
    case 20: zoomExtents(); break;
    case 21: resetAll(); break;
    case 22: takeScreenshot(); break;
    case 23: static_QUType_bool.set(_o,importPath()); break;
    case 24: static_QUType_bool.set(_o,importPath((char*)static_QUType_charstar.get(_o+1))); break;
    case 25: static_QUType_bool.set(_o,savePattern()); break;
    case 26: static_QUType_bool.set(_o,loadPattern()); break;
    case 27: static_QUType_bool.set(_o,exportToObj()); break;
    case 28: static_QUType_bool.set(_o,exportToRLE()); break;
    case 29: static_QUType_bool.set(_o,exportToMP3()); break;
    default:
	return QGLWidget::qt_invoke( _id, _o );
    }
    return 1;
}

bool BBB_GLWidget::qt_emit( int _id, QUObject* _o )
{
    return QGLWidget::qt_emit(_id,_o);
}


bool BBB_GLWidget::qt_property( int id, int f, QVariant* v)
{
    return QGLWidget::qt_property( id, f, v);
}

bool BBB_GLWidget::qt_static_property( QObject* , int , int , QVariant* ){ return 0; }
#line 217 ".\\moc_bbb_GLWidget.cpp"
